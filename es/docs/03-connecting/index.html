<!doctype html><html lang=es dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Conexión # ¿Por qué WebRTC necesita un subsistema dedicado para conectarse? # La mayoría de las aplicaciones implementadas hoy en día establecen conexiones cliente/servidor. Una conexión cliente/servidor requiere que el servidor tenga una dirección de transporte estable y bien conocida. Un cliente contacta a un servidor, y el servidor responde.
WebRTC no usa un modelo cliente/servidor, establece conexiones peer-to-peer (P2P). En una conexión P2P, la tarea de crear una conexión se distribuye equitativamente entre ambos pares."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/es/docs/03-connecting/"><meta property="og:site_name" content="WebRTC para los curiosos"><meta property="og:title" content="Conexión"><meta property="og:description" content="Conexión # ¿Por qué WebRTC necesita un subsistema dedicado para conectarse? # La mayoría de las aplicaciones implementadas hoy en día establecen conexiones cliente/servidor. Una conexión cliente/servidor requiere que el servidor tenga una dirección de transporte estable y bien conocida. Un cliente contacta a un servidor, y el servidor responde.
WebRTC no usa un modelo cliente/servidor, establece conexiones peer-to-peer (P2P). En una conexión P2P, la tarea de crear una conexión se distribuye equitativamente entre ambos pares."><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-10-31T11:17:17-04:00"><title>Conexión | WebRTC para los curiosos</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/es/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Подключение><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/es.search.min.9b1bcd2b6b542753f44e44010ec9bb845a245c0565d705379397ad936fb4332a.js integrity="sha256-mxvNK2tUJ1P0TkQBDsm7hFokXAVl1wU3k5etk2+0Myo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/es/><span>WebRTC para los curiosos</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Buscar aria-label=Buscar maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Español</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/es/docs/01-what-why-and-how/>¿Qué, Por qué y Cómo?</a></li><li><a href=/es/docs/02-signaling/>Señalización</a></li><li><a href=/es/docs/03-connecting/ class=active>Conexión</a></li><li><a href=/es/docs/04-securing/>Seguridad</a></li><li><a href=/es/docs/05-real-time-networking/>Redes en Tiempo Real</a></li><li><a href=/es/docs/06-media-communication/>Comunicación de Medios</a></li><li><a href=/es/docs/07-data-communication/>Comunicación de Datos</a></li><li><a href=/es/docs/08-applied-webrtc/>WebRTC Aplicado</a></li><li><a href=/es/docs/09-debugging/>Depuración</a></li><li><a href=/es/docs/10-history-of-webrtc/>Historia</a></li><li><a href=/es/docs/11-faq/>FAQ</a></li><li><a href=/es/docs/12-glossary/>Glosario</a></li><li><a href=/es/docs/13-reference/>Referencia</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Conexión</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#por-qué-webrtc-necesita-un-subsistema-dedicado-para-conectarse>¿Por qué WebRTC necesita un subsistema dedicado para conectarse?</a><ul><li><a href=#costos-de-ancho-de-banda-reducidos>Costos de Ancho de Banda Reducidos</a></li><li><a href=#menor-latencia>Menor Latencia</a></li><li><a href=#comunicación-e2e-segura>Comunicación E2E Segura</a></li></ul></li><li><a href=#cómo-funciona>¿Cómo funciona?</a></li><li><a href=#restricciones-de-redes-del-mundo-real>Restricciones de redes del mundo real</a><ul><li><a href=#no-en-la-misma-red>No en la misma red</a></li><li><a href=#restricciones-de-protocolo>Restricciones de Protocolo</a></li><li><a href=#reglas-de-firewallids>Reglas de Firewall/IDS</a></li></ul></li><li><a href=#mapeo-nat>Mapeo NAT</a><ul><li><a href=#crear-un-mapeo>Crear un mapeo</a></li><li><a href=#comportamientos-de-creación-de-mapeos>Comportamientos de Creación de Mapeos</a></li><li><a href=#comportamientos-de-filtrado-de-mapeos>Comportamientos de Filtrado de Mapeos</a></li><li><a href=#actualización-de-mapeos>Actualización de Mapeos</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#estructura-del-protocolo>Estructura del Protocolo</a></li><li><a href=#crear-un-mapeo-nat>Crear un Mapeo NAT</a></li><li><a href=#determinar-el-tipo-de-nat>Determinar el Tipo de NAT</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#ciclo-de-vida-de-turn>Ciclo de Vida de TURN</a></li><li><a href=#uso-de-turn>Uso de TURN</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#crear-un-agente-ice>Crear un Agente ICE</a></li><li><a href=#recopilación-de-candidatos>Recopilación de Candidatos</a></li><li><a href=#verificaciones-de-conectividad>Verificaciones de Conectividad</a></li><li><a href=#selección-de-candidatos>Selección de Candidatos</a></li><li><a href=#reinicios>Reinicios</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=conexión>Conexión
<a class=anchor href=#conexi%c3%b3n>#</a></h1><h2 id=por-qué-webrtc-necesita-un-subsistema-dedicado-para-conectarse>¿Por qué WebRTC necesita un subsistema dedicado para conectarse?
<a class=anchor href=#por-qu%c3%a9-webrtc-necesita-un-subsistema-dedicado-para-conectarse>#</a></h2><p>La mayoría de las aplicaciones implementadas hoy en día establecen conexiones cliente/servidor. Una conexión cliente/servidor requiere que el servidor tenga una dirección de transporte estable y bien conocida. Un cliente contacta a un servidor, y el servidor responde.</p><p>WebRTC no usa un modelo cliente/servidor, establece conexiones peer-to-peer (P2P). En una conexión P2P, la tarea de crear una conexión se distribuye equitativamente entre ambos pares. Esto se debe a que una dirección de transporte (IP y puerto) en WebRTC no se puede asumir, e incluso puede cambiar durante la sesión. WebRTC recopilará toda la información que pueda e irá a grandes esfuerzos para lograr comunicación bidireccional entre dos Agentes WebRTC.</p><p>Sin embargo, establecer conectividad peer-to-peer puede ser difícil. Estos agentes podrían estar en diferentes redes sin conectividad directa. En situaciones donde existe conectividad directa, aún puedes tener otros problemas. En algunos casos, tus clientes no hablan los mismos protocolos de red (UDP &lt;-> TCP) o tal vez usan diferentes versiones de IP (IPv4 &lt;-> IPv6).</p><p>A pesar de estas dificultades para establecer una conexión P2P, obtienes ventajas sobre la tecnología cliente/servidor tradicional debido a los siguientes atributos que WebRTC ofrece.</p><h3 id=costos-de-ancho-de-banda-reducidos>Costos de Ancho de Banda Reducidos
<a class=anchor href=#costos-de-ancho-de-banda-reducidos>#</a></h3><p>Dado que la comunicación de medios ocurre directamente entre pares, no tienes que pagar por, u hospedar un servidor separado para transmitir medios.</p><h3 id=menor-latencia>Menor Latencia
<a class=anchor href=#menor-latencia>#</a></h3><p>La comunicación es más rápida cuando es directa. Cuando un usuario tiene que ejecutar todo a través de tu servidor, hace que las transmisiones sean más lentas.</p><h3 id=comunicación-e2e-segura>Comunicación E2E Segura
<a class=anchor href=#comunicaci%c3%b3n-e2e-segura>#</a></h3><p>La comunicación directa es más segura. Dado que los usuarios no están enrutando datos a través de tu servidor, ni siquiera necesitan confiar en que no los descifrarás.</p><h2 id=cómo-funciona>¿Cómo funciona?
<a class=anchor href=#c%c3%b3mo-funciona>#</a></h2><p>El proceso descrito anteriormente se llama Establecimiento de Conectividad Interactiva (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>). Otro protocolo que es anterior a WebRTC.</p><p>ICE es un protocolo que intenta encontrar la mejor manera de comunicarse entre dos Agentes ICE. Cada Agente ICE publica las formas en que es accesible, estas se conocen como candidatos. Un candidato es esencialmente una dirección de transporte del agente que cree que el otro par puede alcanzar. ICE entonces determina el mejor emparejamiento de candidatos.</p><p>El proceso ICE real se describe con mayor detalle más adelante en este capítulo. Para entender por qué existe ICE, es útil entender qué comportamientos de red estamos superando.</p><h2 id=restricciones-de-redes-del-mundo-real>Restricciones de redes del mundo real
<a class=anchor href=#restricciones-de-redes-del-mundo-real>#</a></h2><p>ICE se trata de superar las restricciones de las redes del mundo real. Antes de explorar la solución, hablemos de los problemas reales.</p><h3 id=no-en-la-misma-red>No en la misma red
<a class=anchor href=#no-en-la-misma-red>#</a></h3><p>La mayor parte del tiempo el otro Agente WebRTC ni siquiera estará en la misma red. Una llamada típica suele ser entre dos Agentes WebRTC en diferentes redes sin conectividad directa.</p><p>A continuación se muestra un gráfico de dos redes distintas, conectadas a través de Internet público. En cada red tienes dos hosts.</p><p><img src=../../images/03-two-networks.png alt="Dos redes" title="Dos redes"></p><p>Para los hosts en la misma red es muy fácil conectarse. ¡La comunicación entre <code>192.168.0.1 -> 192.168.0.2</code> es fácil de hacer! Estos dos hosts pueden conectarse entre sí sin ninguna ayuda externa.</p><p>Sin embargo, un host usando <code>Router B</code> no tiene forma de acceder directamente a nada detrás de <code>Router A</code>. ¿Cómo distinguirías entre <code>192.168.0.1</code> detrás de <code>Router A</code> y la misma IP detrás de <code>Router B</code>? ¡Son IPs privadas! Un host usando <code>Router B</code> podría enviar tráfico directamente a <code>Router A</code>, pero la solicitud terminaría ahí. ¿Cómo sabe <code>Router A</code> a qué host debe reenviar el mensaje?</p><h3 id=restricciones-de-protocolo>Restricciones de Protocolo
<a class=anchor href=#restricciones-de-protocolo>#</a></h3><p>Algunas redes no permiten tráfico UDP en absoluto, o tal vez no permiten TCP. Algunas redes pueden tener un MTU (Unidad Máxima de Transmisión) muy bajo. Hay muchas variables que los administradores de red pueden cambiar que pueden dificultar la comunicación.</p><h3 id=reglas-de-firewallids>Reglas de Firewall/IDS
<a class=anchor href=#reglas-de-firewallids>#</a></h3><p>Otra es la &ldquo;Inspección Profunda de Paquetes&rdquo; y otro filtrado inteligente. Algunos administradores de red ejecutarán software que intenta procesar cada paquete. Muchas veces este software no entiende WebRTC, por lo que lo bloquea porque no sabe qué hacer, por ejemplo, tratando los paquetes WebRTC como paquetes UDP sospechosos en un puerto arbitrario que no está en la lista blanca.</p><h2 id=mapeo-nat>Mapeo NAT
<a class=anchor href=#mapeo-nat>#</a></h2><p>El mapeo NAT (Traducción de Direcciones de Red) es la magia que hace posible la conectividad de WebRTC. Así es como WebRTC permite que dos pares en subredes completamente diferentes se comuniquen, abordando el problema de &ldquo;no en la misma red&rdquo; anterior. Si bien crea nuevos desafíos, expliquemos cómo funciona el mapeo NAT en primer lugar.</p><p>No utiliza un relé, proxy o servidor. Nuevamente tenemos <code>Agente 1</code> y <code>Agente 2</code> y están en diferentes redes. Sin embargo, el tráfico fluye completamente. Visualizado se ve así:</p><p><img src=../../images/03-nat-mapping.png alt="Mapeo NAT" title="Mapeo NAT"></p><p>Para que esta comunicación suceda, estableces un mapeo NAT. El Agente 1 usa el puerto 7000 para establecer una conexión WebRTC con el Agente 2. Esto crea un enlace de <code>192.168.0.1:7000</code> a <code>5.0.0.1:7000</code>. Esto permite que el Agente 2 alcance al Agente 1 enviando paquetes a <code>5.0.0.1:7000</code>. Crear un mapeo NAT como en este ejemplo es como una versión automatizada de hacer reenvío de puertos en tu enrutador.</p><p>La desventaja del mapeo NAT es que no hay una sola forma de mapeo (por ejemplo, reenvío de puertos estático), y el comportamiento es inconsistente entre redes. Los ISP y fabricantes de hardware pueden hacerlo de diferentes maneras. En algunos casos, los administradores de red pueden incluso deshabilitarlo.</p><p>La buena noticia es que se entiende y observa el rango completo de comportamientos, por lo que un Agente ICE puede confirmar que creó un mapeo NAT y los atributos del mapeo.</p><p>El documento que describe estos comportamientos es <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>.</p><h3 id=crear-un-mapeo>Crear un mapeo
<a class=anchor href=#crear-un-mapeo>#</a></h3><p>Crear un mapeo es la parte más fácil. ¡Cuando envías un paquete a una dirección fuera de tu red, se crea un mapeo! Un mapeo NAT es solo una IP pública temporal y un puerto que es asignado por tu NAT. El mensaje saliente se reescribirá para tener su dirección de origen dada por la dirección de mapeo recién creada. Si se envía un mensaje al mapeo, se enrutará automáticamente de vuelta al host dentro del NAT que lo creó. Los detalles sobre los mapeos es donde se vuelve complicado.</p><h3 id=comportamientos-de-creación-de-mapeos>Comportamientos de Creación de Mapeos
<a class=anchor href=#comportamientos-de-creaci%c3%b3n-de-mapeos>#</a></h3><p>La creación de mapeos se divide en tres categorías diferentes:</p><h4 id=mapeo-independiente-del-punto-final>Mapeo Independiente del Punto Final
<a class=anchor href=#mapeo-independiente-del-punto-final>#</a></h4><p>Se crea un mapeo para cada remitente dentro del NAT. Si envías dos paquetes a dos direcciones remotas diferentes, el mapeo NAT se reutilizará. Ambos hosts remotos verían la misma IP y puerto de origen. Si los hosts remotos responden, se enviaría de vuelta al mismo oyente local.</p><p>Este es el mejor escenario posible. Para que una llamada funcione, al menos un lado DEBE ser de este tipo.</p><h4 id=mapeo-dependiente-de-la-dirección>Mapeo Dependiente de la Dirección
<a class=anchor href=#mapeo-dependiente-de-la-direcci%c3%b3n>#</a></h4><p>Se crea un nuevo mapeo cada vez que envías un paquete a una nueva dirección. Si envías dos paquetes a diferentes hosts, se crearán dos mapeos. Si envías dos paquetes al mismo host remoto pero diferentes puertos de destino, NO se creará un nuevo mapeo.</p><h4 id=mapeo-dependiente-de-dirección-y-puerto>Mapeo Dependiente de Dirección y Puerto
<a class=anchor href=#mapeo-dependiente-de-direcci%c3%b3n-y-puerto>#</a></h4><p>Se crea un nuevo mapeo si la IP o el puerto remoto es diferente. Si envías dos paquetes al mismo host remoto, pero diferentes puertos de destino, se creará un nuevo mapeo.</p><h3 id=comportamientos-de-filtrado-de-mapeos>Comportamientos de Filtrado de Mapeos
<a class=anchor href=#comportamientos-de-filtrado-de-mapeos>#</a></h3><p>El filtrado de mapeos son las reglas sobre quién puede usar el mapeo. Se dividen en tres clasificaciones similares:</p><h4 id=filtrado-independiente-del-punto-final>Filtrado Independiente del Punto Final
<a class=anchor href=#filtrado-independiente-del-punto-final>#</a></h4><p>Cualquiera puede usar el mapeo. Puedes compartir el mapeo con múltiples otros pares, y todos podrían enviar tráfico a él.</p><h4 id=filtrado-dependiente-de-la-dirección>Filtrado Dependiente de la Dirección
<a class=anchor href=#filtrado-dependiente-de-la-direcci%c3%b3n>#</a></h4><p>Solo el host para el que se creó el mapeo puede usar el mapeo. Si envías un paquete al host <code>A</code> solo puedes obtener una respuesta de ese mismo host. Si el host <code>B</code> intenta enviar un paquete a ese mapeo, será ignorado.</p><h4 id=filtrado-dependiente-de-dirección-y-puerto>Filtrado Dependiente de Dirección y Puerto
<a class=anchor href=#filtrado-dependiente-de-direcci%c3%b3n-y-puerto>#</a></h4><p>Solo el host y puerto para el que se creó el mapeo pueden usar ese mapeo. Si envías un paquete a <code>A:5000</code> solo puedes obtener una respuesta de ese mismo host y puerto. Si <code>A:5001</code> intenta enviar un paquete a ese mapeo, será ignorado.</p><h3 id=actualización-de-mapeos>Actualización de Mapeos
<a class=anchor href=#actualizaci%c3%b3n-de-mapeos>#</a></h3><p>Se recomienda que si un mapeo no se usa durante 5 minutos, debe ser destruido. Esto depende completamente del ISP o fabricante de hardware.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (Utilidades de Traversal de Sesión para NAT) es un protocolo que fue creado solo para trabajar con NATs. Esta es otra tecnología que es anterior a WebRTC (¡y a ICE!). Está definido por <a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>, que también define la estructura del paquete STUN. El protocolo STUN también es utilizado por ICE/TURN.</p><p>STUN es útil porque permite la creación programática de Mapeos NAT. Antes de STUN, podíamos crear un mapeo NAT, ¡pero no teníamos idea de cuál era la IP y el puerto! STUN no solo te da la capacidad de crear un mapeo, sino que también te da los detalles para que puedas compartirlos con otros, para que puedan enviarte tráfico de vuelta a través del mapeo que acabas de crear.</p><p>Comencemos con una descripción básica de STUN. Más tarde, ampliaremos el uso de TURN e ICE. Por ahora, solo vamos a describir el flujo de Solicitud/Respuesta para crear un mapeo. Luego hablaremos sobre cómo obtener los detalles para compartir con otros. Este es el proceso que ocurre cuando tienes un servidor <code>stun:</code> en tus URLs ICE para una PeerConnection de WebRTC. En pocas palabras, STUN ayuda a un punto final detrás de un NAT a descubrir qué mapeo fue creado al pedirle a un servidor STUN fuera del NAT que informe lo que observa.</p><h3 id=estructura-del-protocolo>Estructura del Protocolo
<a class=anchor href=#estructura-del-protocolo>#</a></h3><p>Cada paquete STUN tiene la siguiente estructura:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=tipo-de-mensaje-stun>Tipo de Mensaje STUN
<a class=anchor href=#tipo-de-mensaje-stun>#</a></h4><p>Cada paquete STUN tiene un tipo. Por ahora, solo nos importan los siguientes:</p><ul><li>Solicitud de Enlace (Binding Request) - <code>0x0001</code></li><li>Respuesta de Enlace (Binding Response) - <code>0x0101</code></li></ul><p>Para crear un mapeo NAT hacemos una <code>Solicitud de Enlace</code>. Luego el servidor responde con una <code>Respuesta de Enlace</code>.</p><h4 id=longitud-del-mensaje>Longitud del Mensaje
<a class=anchor href=#longitud-del-mensaje>#</a></h4><p>Esto es cuán larga es la sección <code>Data</code>. Esta sección contiene datos arbitrarios que son definidos por el <code>Tipo de Mensaje</code>.</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>El valor fijo <code>0x2112A442</code> en orden de bytes de red, ayuda a distinguir el tráfico STUN de otros protocolos.</p><h4 id=id-de-transacción>ID de Transacción
<a class=anchor href=#id-de-transacci%c3%b3n>#</a></h4><p>Un identificador de 96 bits que identifica únicamente una solicitud/respuesta. Esto te ayuda a emparejar tus solicitudes y respuestas.</p><h4 id=data>Data
<a class=anchor href=#data>#</a></h4><p>Data contendrá una lista de atributos STUN. Un Atributo STUN tiene la siguiente estructura:</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>La <code>Solicitud de Enlace STUN</code> no usa atributos. Esto significa que una <code>Solicitud de Enlace STUN</code> contiene solo el encabezado.</p><p>La <code>Respuesta de Enlace STUN</code> usa un <code>XOR-MAPPED-ADDRESS (0x0020)</code>. Este atributo contiene una IP y puerto. ¡Esta es la IP y el puerto del mapeo NAT que se crea!</p><h3 id=crear-un-mapeo-nat>Crear un Mapeo NAT
<a class=anchor href=#crear-un-mapeo-nat>#</a></h3><p>¡Crear un mapeo NAT usando STUN solo requiere enviar una solicitud! Envías una <code>Solicitud de Enlace STUN</code> al Servidor STUN. El Servidor STUN entonces responde con una <code>Respuesta de Enlace STUN</code>.
Esta <code>Respuesta de Enlace STUN</code> contendrá la <code>Dirección Mapeada</code>. La <code>Dirección Mapeada</code> es cómo el Servidor STUN te ve y es tu <code>mapeo NAT</code>.
La <code>Dirección Mapeada</code> es lo que compartirías si quisieras que alguien te envíe paquetes.</p><p>La gente también llamará a la <code>Dirección Mapeada</code> tu <code>IP Pública</code> o <code>Candidato Reflexivo del Servidor</code>.</p><h3 id=determinar-el-tipo-de-nat>Determinar el Tipo de NAT
<a class=anchor href=#determinar-el-tipo-de-nat>#</a></h3><p>Desafortunadamente, la <code>Dirección Mapeada</code> puede no ser útil en todos los casos. Si es <code>Dependiente de la Dirección</code>, solo el servidor STUN puede enviarte tráfico de vuelta. Si la compartes y otro par intenta enviar mensajes, serán descartados. Esto lo hace inútil para comunicarse con otros. Puedes encontrar que el caso <code>Dependiente de la Dirección</code> es de hecho solucionable, ¡si el host que ejecuta el servidor STUN también puede reenviar paquetes para ti al par! Esto nos lleva a la solución usando TURN a continuación.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a> define un método para ejecutar una prueba para determinar tu Tipo de NAT. Esto es útil porque sabrías de antemano si la conectividad directa es posible.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (Traversal Usando Relés alrededor de NAT) está definido en <a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a> y es la solución cuando la conectividad directa no es posible. Puede ser porque tienes dos Tipos de NAT que son incompatibles, ¡o tal vez no pueden hablar el mismo protocolo! TURN también se puede usar para propósitos de privacidad. Al ejecutar toda tu comunicación a través de TURN, ocultas la dirección real del cliente.</p><p>TURN usa un servidor dedicado. Este servidor actúa como un proxy para un cliente. El cliente se conecta a un Servidor TURN y crea una <code>Asignación</code>. Al crear una asignación, un cliente obtiene un IP/Puerto/Protocolo temporal que se puede usar para enviar tráfico de vuelta al cliente. Este nuevo oyente se conoce como la <code>Dirección de Transporte Retransmitida</code>. ¡Piensa en ella como una dirección de reenvío, la das para que otros puedan enviarte tráfico a través de TURN! Para cada par al que le das la <code>Dirección de Transporte de Relé</code>, debes crear un nuevo <code>Permiso</code> para permitir la comunicación contigo.</p><p>Cuando envías tráfico saliente a través de TURN, se envía a través de la <code>Dirección de Transporte Retransmitida</code>. Cuando un par remoto recibe tráfico, lo ve venir del Servidor TURN.</p><h3 id=ciclo-de-vida-de-turn>Ciclo de Vida de TURN
<a class=anchor href=#ciclo-de-vida-de-turn>#</a></h3><p>Lo siguiente es todo lo que un cliente que desea crear una asignación TURN tiene que hacer. Comunicarse con alguien que está usando TURN no requiere cambios. El otro par obtiene una IP y puerto, y se comunica con ella como cualquier otro host.</p><h4 id=asignaciones>Asignaciones
<a class=anchor href=#asignaciones>#</a></h4><p>Las asignaciones están en el núcleo de TURN. Una <code>asignación</code> es básicamente una &ldquo;Sesión TURN&rdquo;. Para crear una asignación TURN, te comunicas con la <code>Dirección de Transporte del Servidor</code> TURN (generalmente puerto <code>3478</code>).</p><p>Al crear una asignación, necesitas proporcionar lo siguiente:</p><ul><li>Nombre de Usuario/Contraseña - Crear asignaciones TURN requiere autenticación.</li><li>Transporte de Asignación - El protocolo de transporte entre el servidor (<code>Dirección de Transporte Retransmitida</code>) y los pares, puede ser UDP o TCP.</li><li>Even-Port - Puedes solicitar puertos secuenciales para múltiples asignaciones, no relevante para WebRTC.</li></ul><p>Si la solicitud tuvo éxito, obtienes una respuesta del Servidor TURN con los siguientes Atributos STUN en la sección Data:</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>Dirección Mapeada</code> del <code>Cliente TURN</code>. Cuando alguien envía datos a la <code>Dirección de Transporte Retransmitida</code>, aquí es donde se reenvía.</li><li><code>RELAYED-ADDRESS</code> - Esta es la dirección que das a otros clientes. Si alguien envía un paquete a esta dirección, se retransmite al cliente TURN.</li><li><code>LIFETIME</code> - Cuánto tiempo hasta que esta Asignación TURN sea destruida. Puedes extender el tiempo de vida enviando una solicitud <code>Refresh</code>.</li></ul><h4 id=permisos>Permisos
<a class=anchor href=#permisos>#</a></h4><p>Un host remoto no puede enviar a tu <code>Dirección de Transporte Retransmitida</code> hasta que crees un permiso para ellos. Cuando creas un permiso, le estás diciendo al servidor TURN que esta IP y puerto pueden enviar tráfico entrante.</p><p>El host remoto necesita darte la IP y el puerto tal como aparece en el servidor TURN. Esto significa que debe enviar una <code>Solicitud de Enlace STUN</code> al Servidor TURN. Un caso de error común es que un host remoto enviará una <code>Solicitud de Enlace STUN</code> a un servidor diferente. Luego te pedirán que crees un permiso para esta IP.</p><p>Digamos que quieres crear un permiso para un host detrás de un <code>Mapeo Dependiente de la Dirección</code>. Si generas la <code>Dirección Mapeada</code> desde un servidor TURN diferente, todo el tráfico entrante será descartado. Cada vez que se comunican con un host diferente, genera un nuevo mapeo. Los permisos expiran después de 5 minutos si no se actualizan.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>Estos dos mensajes son para que el Cliente TURN envíe mensajes a un par remoto.</p><p>SendIndication es un mensaje autocontenido. Dentro está los datos que deseas enviar, y a quién deseas enviarlo. Esto es derrochador si estás enviando muchos mensajes a un par remoto. Si envías 1,000 mensajes repetirás su Dirección IP 1,000 veces.</p><p>ChannelData te permite enviar datos, pero sin repetir una Dirección IP. Creas un Canal con una IP y puerto. Luego envías con el ChannelId, y la IP y puerto se completarán del lado del servidor. Esta es la mejor opción si estás enviando muchos mensajes.</p><h4 id=actualización>Actualización
<a class=anchor href=#actualizaci%c3%b3n>#</a></h4><p>Las asignaciones se destruirán automáticamente. El Cliente TURN debe actualizarlas antes del <code>LIFETIME</code> dado al crear la asignación.</p><h3 id=uso-de-turn>Uso de TURN
<a class=anchor href=#uso-de-turn>#</a></h3><p>El uso de TURN existe en dos formas. Usualmente, tienes un par actuando como un &ldquo;Cliente TURN&rdquo; y el otro lado comunicándose directamente. En algunos casos, puedes tener uso de TURN en ambos lados, por ejemplo, porque ambos clientes están en redes que bloquean UDP y, por lo tanto, la conexión a los respectivos servidores TURN ocurre a través de TCP.</p><p>Estos diagramas ayudan a ilustrar cómo se vería eso.</p><h4 id=una-asignación-turn-para-comunicación>Una Asignación TURN para Comunicación
<a class=anchor href=#una-asignaci%c3%b3n-turn-para-comunicaci%c3%b3n>#</a></h4><p><img src=../../images/03-one-turn-allocation.png alt="Una asignación TURN" title="Una asignación TURN"></p><h4 id=dos-asignaciones-turn-para-comunicación>Dos Asignaciones TURN para Comunicación
<a class=anchor href=#dos-asignaciones-turn-para-comunicaci%c3%b3n>#</a></h4><p><img src=../../images/03-two-turn-allocations.png alt="Dos asignaciones TURN" title="Dos asignaciones TURN"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Establecimiento de Conectividad Interactiva) es cómo WebRTC conecta dos Agentes. Definido en <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>, ¡esta es otra tecnología que es anterior a WebRTC! ICE es un protocolo para establecer conectividad. Determina todas las rutas posibles entre los dos pares y luego asegura que te mantengas conectado.</p><p>Estas rutas se conocen como <code>Pares de Candidatos</code>, que es un emparejamiento de una dirección de transporte local y remota. Aquí es donde STUN y TURN entran en juego con ICE. Estas direcciones pueden ser tu Dirección IP local más un puerto, <code>mapeo NAT</code>, o <code>Dirección de Transporte Retransmitida</code>. Cada lado recopila todas las direcciones que quieren usar, las intercambian, ¡y luego intentan conectarse!</p><p>Dos Agentes ICE se comunican usando paquetes de ping ICE (o formalmente llamados verificaciones de conectividad) para establecer conectividad. Después de que se establece la conectividad, pueden enviar los datos que quieran. Será como usar un socket normal. Estas verificaciones usan el protocolo STUN.</p><h3 id=crear-un-agente-ice>Crear un Agente ICE
<a class=anchor href=#crear-un-agente-ice>#</a></h3><p>Un Agente ICE es <code>Controlador</code> o <code>Controlado</code>. El Agente <code>Controlador</code> es el que decide el <code>Par de Candidatos</code> seleccionado. Generalmente, el par que envía la oferta es el lado controlador.</p><p>Cada lado debe tener un <code>fragmento de usuario</code> y una <code>contraseña</code>. Estos dos valores deben intercambiarse antes de que puedan comenzar las verificaciones de conectividad. El <code>fragmento de usuario</code> se envía en texto plano y es útil para demultiplexar múltiples Sesiones ICE.
La <code>contraseña</code> se usa para generar un atributo <code>MESSAGE-INTEGRITY</code>. Al final de cada paquete STUN, hay un atributo que es un hash de todo el paquete usando la <code>contraseña</code> como clave. Esto se usa para autenticar el paquete y asegurar que no haya sido manipulado.</p><p>Para WebRTC, todos estos valores se distribuyen a través de la <code>Descripción de Sesión</code> como se describe en el capítulo anterior.</p><h3 id=recopilación-de-candidatos>Recopilación de Candidatos
<a class=anchor href=#recopilaci%c3%b3n-de-candidatos>#</a></h3><p>Ahora necesitamos recopilar todas las direcciones posibles en las que somos accesibles. Estas direcciones se conocen como candidatos.</p><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><p>Un candidato Host está escuchando directamente en una interfaz local. Esto puede ser UDP o TCP.</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>Un candidato mDNS es similar a un candidato host, pero la dirección IP está oculta. En lugar de informar al otro lado sobre tu dirección IP, le das un UUID como nombre de host. Luego configuras un oyente de multidifusión y respondes si alguien solicita el UUID que publicaste.</p><p>Si estás en la misma red que el agente, pueden encontrarse entre sí a través de Multidifusión. Si no estás en la misma red, no podrás conectarte (a menos que el administrador de red configuró explícitamente la red para permitir que los paquetes de Multidifusión atraviesen).</p><p>Esto es útil para propósitos de privacidad. Un usuario podría descubrir tu dirección IP local a través de WebRTC con un candidato Host (sin siquiera intentar conectarse a ti), pero con un candidato mDNS, ahora solo obtienen un UUID aleatorio.</p><h4 id=reflexivo-del-servidor>Reflexivo del Servidor
<a class=anchor href=#reflexivo-del-servidor>#</a></h4><p>Un candidato Reflexivo del Servidor se genera haciendo una <code>Solicitud de Enlace STUN</code> a un Servidor STUN.</p><p>Cuando obtienes la <code>Respuesta de Enlace STUN</code>, el <code>XOR-MAPPED-ADDRESS</code> es tu Candidato Reflexivo del Servidor.</p><h4 id=reflexivo-del-par>Reflexivo del Par
<a class=anchor href=#reflexivo-del-par>#</a></h4><p>Un candidato Reflexivo del Par se crea cuando el par remoto recibe tu solicitud desde una dirección previamente desconocida para el par. Al recibir, el par informa (refleja) dicha dirección de vuelta a ti. El par sabe que la solicitud fue enviada por ti y no por alguien más porque ICE es un protocolo autenticado.</p><p>Esto comúnmente ocurre cuando un <code>Candidato Host</code> se comunica con un <code>Candidato Reflexivo del Servidor</code> que está en una subred diferente, lo que resulta en la creación de un nuevo <code>mapeo NAT</code>. Recuerda que dijimos que las verificaciones de conectividad son de hecho paquetes STUN. El formato de la respuesta STUN naturalmente permite que un par informe de vuelta la dirección reflexiva del par.</p><h4 id=relé>Relé
<a class=anchor href=#rel%c3%a9>#</a></h4><p>Un Candidato de Relé se genera usando un Servidor TURN.</p><p>Después del handshake inicial con el Servidor TURN, se te da una <code>RELAYED-ADDRESS</code>, este es tu Candidato de Relé.</p><h3 id=verificaciones-de-conectividad>Verificaciones de Conectividad
<a class=anchor href=#verificaciones-de-conectividad>#</a></h3><p>¡Ahora conocemos el <code>fragmento de usuario</code>, <code>contraseña</code> y candidatos del agente remoto. Ahora podemos intentar conectar! Cada candidato se empareja entre sí. Así que si tienes 3 candidatos en cada lado, ahora tienes 9 pares de candidatos.</p><p>Visualmente se ve así:</p><p><img src=../../images/03-connectivity-checks.png alt="Verificaciones de conectividad" title="Verificaciones de conectividad"></p><h3 id=selección-de-candidatos>Selección de Candidatos
<a class=anchor href=#selecci%c3%b3n-de-candidatos>#</a></h3><p>El Agente Controlador y Controlado comienzan a enviar tráfico en cada par. Esto es necesario si un Agente está detrás de un <code>Mapeo Dependiente de la Dirección</code>, esto causará que se cree un <code>Candidato Reflexivo del Par</code>.</p><p>Cada <code>Par de Candidatos</code> que vio tráfico de red es entonces promovido a un par <code>Candidato Válido</code>. El Agente Controlador luego toma un par <code>Candidato Válido</code> y lo nomina. Este se convierte en el <code>Par Nominado</code>. El Agente Controlador y Controlado luego intentan una ronda más de comunicación bidireccional. Si eso tiene éxito, ¡el <code>Par Nominado</code> se convierte en el <code>Par de Candidatos Seleccionado</code>! Este par se usa luego para el resto de la sesión.</p><h3 id=reinicios>Reinicios
<a class=anchor href=#reinicios>#</a></h3><p>Si el <code>Par de Candidatos Seleccionado</code> deja de funcionar por cualquier razón (el mapeo NAT expira, el Servidor TURN falla), el Agente ICE pasará al estado <code>Failed</code>. Ambos agentes pueden reiniciarse y harán todo el proceso de nuevo.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/5deb9d27fb754365c8bd0c350c4d35faf1b6a8d8 title='Última modificación por Claes Mogren | octubre 31, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>octubre 31, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Editar esta página</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#por-qué-webrtc-necesita-un-subsistema-dedicado-para-conectarse>¿Por qué WebRTC necesita un subsistema dedicado para conectarse?</a><ul><li><a href=#costos-de-ancho-de-banda-reducidos>Costos de Ancho de Banda Reducidos</a></li><li><a href=#menor-latencia>Menor Latencia</a></li><li><a href=#comunicación-e2e-segura>Comunicación E2E Segura</a></li></ul></li><li><a href=#cómo-funciona>¿Cómo funciona?</a></li><li><a href=#restricciones-de-redes-del-mundo-real>Restricciones de redes del mundo real</a><ul><li><a href=#no-en-la-misma-red>No en la misma red</a></li><li><a href=#restricciones-de-protocolo>Restricciones de Protocolo</a></li><li><a href=#reglas-de-firewallids>Reglas de Firewall/IDS</a></li></ul></li><li><a href=#mapeo-nat>Mapeo NAT</a><ul><li><a href=#crear-un-mapeo>Crear un mapeo</a></li><li><a href=#comportamientos-de-creación-de-mapeos>Comportamientos de Creación de Mapeos</a></li><li><a href=#comportamientos-de-filtrado-de-mapeos>Comportamientos de Filtrado de Mapeos</a></li><li><a href=#actualización-de-mapeos>Actualización de Mapeos</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#estructura-del-protocolo>Estructura del Protocolo</a></li><li><a href=#crear-un-mapeo-nat>Crear un Mapeo NAT</a></li><li><a href=#determinar-el-tipo-de-nat>Determinar el Tipo de NAT</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#ciclo-de-vida-de-turn>Ciclo de Vida de TURN</a></li><li><a href=#uso-de-turn>Uso de TURN</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#crear-un-agente-ice>Crear un Agente ICE</a></li><li><a href=#recopilación-de-candidatos>Recopilación de Candidatos</a></li><li><a href=#verificaciones-de-conectividad>Verificaciones de Conectividad</a></li><li><a href=#selección-de-candidatos>Selección de Candidatos</a></li><li><a href=#reinicios>Reinicios</a></li></ul></li></ul></nav></div></aside></main></body></html>