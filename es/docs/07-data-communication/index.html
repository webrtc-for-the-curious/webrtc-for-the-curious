<!doctype html><html lang=es dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Comunicación de Datos # ¿Qué obtengo de la comunicación de datos de WebRTC? # WebRTC proporciona canales de datos para la comunicación de datos. Entre dos pares puedes abrir 65,534 canales de datos. Un canal de datos está basado en datagramas, y cada uno tiene su propia configuración de durabilidad. Por defecto, cada canal de datos tiene entrega ordenada garantizada.
Si te acercas a WebRTC desde un trasfondo de medios, los canales de datos pueden parecer derro chadores."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/es/docs/07-data-communication/"><meta property="og:site_name" content="WebRTC para los curiosos"><meta property="og:title" content="Comunicación de Datos"><meta property="og:description" content="Comunicación de Datos # ¿Qué obtengo de la comunicación de datos de WebRTC? # WebRTC proporciona canales de datos para la comunicación de datos. Entre dos pares puedes abrir 65,534 canales de datos. Un canal de datos está basado en datagramas, y cada uno tiene su propia configuración de durabilidad. Por defecto, cada canal de datos tiene entrega ordenada garantizada.
Si te acercas a WebRTC desde un trasfondo de medios, los canales de datos pueden parecer derro chadores."><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-10-31T11:17:17-04:00"><title>Comunicación de Datos | WebRTC para los curiosos</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/es/docs/07-data-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/07-data-communication/ title=Datakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/07-data-communication/ title="Коммуникация данных"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/07-data-communication/ title=数据通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/07-data-communication/ title=データ・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/07-data-communication/ title="ارتباط داده ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/07-data-communication/ title="Communication de données"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/07-data-communication/ title="Veri İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/07-data-communication/ title="데이터 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/es.search.min.9b1bcd2b6b542753f44e44010ec9bb845a245c0565d705379397ad936fb4332a.js integrity="sha256-mxvNK2tUJ1P0TkQBDsm7hFokXAVl1wU3k5etk2+0Myo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/es/><span>WebRTC para los curiosos</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Buscar aria-label=Buscar maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Español</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/07-data-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/07-data-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/07-data-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/07-data-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/07-data-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/07-data-communication/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/07-data-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/es/docs/01-what-why-and-how/>¿Qué, Por qué y Cómo?</a></li><li><a href=/es/docs/02-signaling/>Señalización</a></li><li><a href=/es/docs/03-connecting/>Conexión</a></li><li><a href=/es/docs/04-securing/>Seguridad</a></li><li><a href=/es/docs/05-real-time-networking/>Redes en Tiempo Real</a></li><li><a href=/es/docs/06-media-communication/>Comunicación de Medios</a></li><li><a href=/es/docs/07-data-communication/ class=active>Comunicación de Datos</a></li><li><a href=/es/docs/08-applied-webrtc/>WebRTC Aplicado</a></li><li><a href=/es/docs/09-debugging/>Depuración</a></li><li><a href=/es/docs/10-history-of-webrtc/>Historia</a></li><li><a href=/es/docs/11-faq/>FAQ</a></li><li><a href=/es/docs/12-glossary/>Glosario</a></li><li><a href=/es/docs/13-reference/>Referencia</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Comunicación de Datos</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#qué-obtengo-de-la-comunicación-de-datos-de-webrtc>¿Qué obtengo de la comunicación de datos de WebRTC?</a></li><li><a href=#cómo-funciona>¿Cómo funciona?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#protocolo-de-transmisión-de-control-de-flujo>Protocolo de Transmisión de Control de Flujo</a></li><li><a href=#conceptos>Conceptos</a><ul><li><a href=#asociación>Asociación</a></li><li><a href=#flujos>Flujos</a></li><li><a href=#basado-en-datagramas>Basado en Datagramas</a></li><li><a href=#fragmentos>Fragmentos</a></li><li><a href=#número-de-secuencia-de-transmisión>Número de Secuencia de Transmisión</a></li><li><a href=#identificador-de-flujo>Identificador de Flujo</a></li><li><a href=#identificador-de-protocolo-de-carga-útil>Identificador de Protocolo de Carga Útil</a></li></ul></li><li><a href=#protocolo-1>Protocolo</a><ul><li><a href=#fragmento-data>Fragmento DATA</a></li><li><a href=#fragmento-init>Fragmento INIT</a></li><li><a href=#fragmento-sack>Fragmento SACK</a></li><li><a href=#fragmento-heartbeat>Fragmento HEARTBEAT</a></li><li><a href=#fragmento-abort>Fragmento ABORT</a></li><li><a href=#fragmento-shutdown>Fragmento SHUTDOWN</a></li><li><a href=#fragmento-error>Fragmento ERROR</a></li><li><a href=#fragmento-forward-tsn>Fragmento FORWARD TSN</a></li></ul></li><li><a href=#máquina-de-estados>Máquina de Estados</a><ul><li><a href=#flujo-de-establecimiento-de-conexión>Flujo de Establecimiento de Conexión</a></li><li><a href=#flujo-de-desconexión>Flujo de Desconexión</a></li><li><a href=#mecanismo-de-keep-alive>Mecanismo de Keep-Alive</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=comunicación-de-datos>Comunicación de Datos
<a class=anchor href=#comunicaci%c3%b3n-de-datos>#</a></h1><h2 id=qué-obtengo-de-la-comunicación-de-datos-de-webrtc>¿Qué obtengo de la comunicación de datos de WebRTC?
<a class=anchor href=#qu%c3%a9-obtengo-de-la-comunicaci%c3%b3n-de-datos-de-webrtc>#</a></h2><p>WebRTC proporciona canales de datos para la comunicación de datos. Entre dos pares puedes abrir 65,534 canales de datos.
Un canal de datos está basado en datagramas, y cada uno tiene su propia configuración de durabilidad. Por defecto, cada canal de datos tiene entrega ordenada garantizada.</p><p>Si te acercas a WebRTC desde un trasfondo de medios, los canales de datos pueden parecer derro chadores. ¿Por qué necesito todo este subsistema cuando podría simplemente usar HTTP o WebSockets?</p><p>El verdadero poder de los canales de datos es que puedes configurarlos para que se comporten como UDP con entrega desordenada/con pérdida.
Esto es necesario para situaciones de baja latencia y alto rendimiento. Puedes medir la contrapresión y asegurarte de que solo estás enviando tanto como tu red soporta.</p><h2 id=cómo-funciona>¿Cómo funciona?
<a class=anchor href=#c%c3%b3mo-funciona>#</a></h2><p>WebRTC usa el Protocolo de Transmisión de Control de Flujo (SCTP), definido en <a href=https://tools.ietf.org/html/rfc4960>RFC 4960</a>. SCTP es un
protocolo de capa de transporte que fue concebido como una alternativa a TCP o UDP. Para WebRTC lo usamos como un protocolo de capa de aplicación que se ejecuta sobre nuestra conexión DTLS.</p><p>SCTP te da flujos y cada flujo puede ser configurado independientemente. Los canales de datos de WebRTC son solo abstracciones delgadas sobre ellos. Las configuraciones
sobre durabilidad y ordenamiento se pasan directamente al Agente SCTP.</p><p>Los canales de datos tienen algunas características que SCTP no puede expresar, como etiquetas de canal. Para resolver eso, WebRTC usa el Protocolo de Establecimiento de Canal de Datos (DCEP)
que está definido en <a href=https://tools.ietf.org/html/rfc8832>RFC 8832</a>. DCEP define un mensaje para comunicar la etiqueta del canal y el protocolo.</p><h2 id=dcep>DCEP
<a class=anchor href=#dcep>#</a></h2><p>DCEP solo tiene dos mensajes <code>DATA_CHANNEL_OPEN</code> y <code>DATA_CHANNEL_ACK</code>. Para cada canal de datos que se abre, el remoto debe responder con un acuse de recibo.</p><h3 id=data_channel_open>DATA_CHANNEL_OPEN
<a class=anchor href=#data_channel_open>#</a></h3><p>Este mensaje es enviado por el Agente WebRTC que desea abrir un canal.</p><h4 id=formato-de-paquete>Formato de Paquete
<a class=anchor href=#formato-de-paquete>#</a></h4><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Message Type | Channel Type | Priority |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Reliability Parameter |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Label Length | Protocol Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\<br>/ Label /
\<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\<br>/ Protocol /
\<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><h4 id=tipo-de-mensaje>Tipo de Mensaje
<a class=anchor href=#tipo-de-mensaje>#</a></h4><p>El Tipo de Mensaje es un valor estático de `0x03`.</p><h4 id=tipo-de-canal>Tipo de Canal
<a class=anchor href=#tipo-de-canal>#</a></h4><p>El Tipo de Canal controla los atributos de durabilidad/ordenamiento del canal. Puede tener los siguientes valores:</p><ul><li>`DATA_CHANNEL_RELIABLE` (`0x00`) - No se pierden mensajes y llegarán en orden</li><li>`DATA_CHANNEL_RELIABLE_UNORDERED` (`0x80`) - No se pierden mensajes, pero pueden llegar fuera de orden.</li><li>`DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT` (`0x01`) - Los mensajes pueden perderse después de intentar la cantidad de veces solicitada, pero llegarán en orden.</li><li>`DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED` (`0x81`) - Los mensajes pueden perderse después de intentar la cantidad de veces solicitada y pueden llegar fuera de orden.</li><li>`DATA_CHANNEL_PARTIAL_RELIABLE_TIMED` (`0x02`) - Los mensajes pueden perderse si no llegan en la cantidad de tiempo solicitada, pero llegarán en orden.</li><li>`DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED` (`0x82`) - Los mensajes pueden perderse si no llegan en la cantidad de tiempo solicitada y pueden llegar fuera de orden.</li></ul><h4 id=prioridad>Prioridad
<a class=anchor href=#prioridad>#</a></h4><p>La prioridad del canal de datos. Los canales de datos con mayor prioridad se programarán primero. Los mensajes de usuario de prioridad más baja y de gran tamaño no retrasarán el envío de mensajes de usuario de mayor prioridad.</p><h4 id=parámetro-de-confiabilidad>Parámetro de Confiabilidad
<a class=anchor href=#par%c3%a1metro-de-confiabilidad>#</a></h4><p>Si el tipo de canal de datos es `DATA_CHANNEL_PARTIAL_RELIABLE`, los sufijos configuran el comportamiento:</p><ul><li>`REXMIT` - Define cuántas veces el remitente reintentará enviar el mensaje antes de rendirse.</li><li>`TIMED` - Define durante cuánto tiempo (en ms) el remitente reintentará enviar el mensaje antes de rendirse.</li></ul><h4 id=etiqueta>Etiqueta
<a class=anchor href=#etiqueta>#</a></h4><p>Una cadena codificada en UTF-8 que contiene el nombre del canal de datos. Esta cadena puede estar vacía.</p><h4 id=protocolo>Protocolo
<a class=anchor href=#protocolo>#</a></h4><p>Si es una cadena vacía, el protocolo no está especificado. Si es una cadena no vacía, debe especificar un protocolo registrado en el &ldquo;WebSocket Subprotocol Name Registry&rdquo;, definido en <a href=https://tools.ietf.org/html/rfc6455#page-61>RFC 6455</a>.</p><h3 id=data_channel_ack>DATA_CHANNEL_ACK
<a class=anchor href=#data_channel_ack>#</a></h3><p>Este mensaje es enviado por el Agente WebRTC para reconocer que este canal de datos ha sido abierto.</p><h4 id=formato-de-paquete-1>Formato de Paquete
<a class=anchor href=#formato-de-paquete-1>#</a></h4><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Message Type |
+-+-+-+-+-+-+-+-+
```</p><h2 id=protocolo-de-transmisión-de-control-de-flujo>Protocolo de Transmisión de Control de Flujo
<a class=anchor href=#protocolo-de-transmisi%c3%b3n-de-control-de-flujo>#</a></h2><p>SCTP es el verdadero poder detrás de los canales de datos de WebRTC. Proporciona todas estas características del canal de datos:</p><ul><li>Multiplexación</li><li>Entrega confiable usando un mecanismo de retransmisión similar a TCP</li><li>Opciones de confiabilidad parcial</li><li>Evitación de Congestión</li><li>Control de Flujo</li></ul><p>Para entender SCTP lo exploraremos en tres partes. El objetivo es que sepas lo suficiente para depurar y aprender los detalles profundos de SCTP por tu cuenta después de este capítulo.</p><h2 id=conceptos>Conceptos
<a class=anchor href=#conceptos>#</a></h2><p>SCTP es un protocolo rico en características. Esta sección solo va a cubrir las partes de SCTP que son usadas por WebRTC.
Las características en SCTP que no son usadas por WebRTC incluyen multi-homing y selección de ruta.</p><p>Con más de veinte años de desarrollo, SCTP puede ser difícil de comprender completamente.</p><h3 id=asociación>Asociación
<a class=anchor href=#asociaci%c3%b3n>#</a></h3><p>Asociación es el término usado para una Sesión SCTP. Es el estado que se comparte
entre dos Agentes SCTP mientras se comunican.</p><h3 id=flujos>Flujos
<a class=anchor href=#flujos>#</a></h3><p>Un flujo es una secuencia bidireccional de datos de usuario. Cuando creas un canal de datos en realidad solo estás creando un flujo SCTP. Cada Asociación SCTP contiene una lista de flujos. Cada flujo puede ser configurado con diferentes tipos de confiabilidad.</p><p>WebRTC solo te permite configurar en la creación del flujo, pero SCTP en realidad permite cambiar la configuración en cualquier momento.</p><h3 id=basado-en-datagramas>Basado en Datagramas
<a class=anchor href=#basado-en-datagramas>#</a></h3><p>SCTP enmarca datos como datagramas y no como un flujo de bytes. Enviar y recibir datos se siente como usar UDP en lugar de TCP.
No necesitas agregar ningún código extra para transferir múltiples archivos sobre un flujo.</p><p>Los mensajes SCTP no tienen límites de tamaño como UDP. Un solo mensaje SCTP puede ser de múltiples gigabytes de tamaño.</p><h3 id=fragmentos>Fragmentos
<a class=anchor href=#fragmentos>#</a></h3><p>El protocolo SCTP está compuesto de fragmentos. Hay muchos tipos diferentes de fragmentos. Estos fragmentos se usan para toda la comunicación.
Datos de usuario, inicialización de conexión, control de congestión y más se hacen a través de fragmentos.</p><p>Cada paquete SCTP contiene una lista de fragmentos. Así que en un paquete UDP puedes tener múltiples fragmentos transportando mensajes de diferentes flujos.</p><h3 id=número-de-secuencia-de-transmisión>Número de Secuencia de Transmisión
<a class=anchor href=#n%c3%bamero-de-secuencia-de-transmisi%c3%b3n>#</a></h3><p>El Número de Secuencia de Transmisión (TSN) es un identificador único global para fragmentos DATA. Un fragmento DATA es lo que transporta todos los mensajes que un usuario desea enviar. El TSN es importante porque ayuda a un receptor a determinar si los paquetes se perdieron o están fuera de orden.</p><p>Si el receptor nota un TSN faltante, no entrega los datos al usuario hasta que se cumpla.</p><h3 id=identificador-de-flujo>Identificador de Flujo
<a class=anchor href=#identificador-de-flujo>#</a></h3><p>Cada flujo tiene un identificador único. Cuando creas un canal de datos con un ID explícito, en realidad solo se pasa directamente a SCTP como el identificador de flujo. Si no pasas un ID, el identificador de flujo se elige por ti.</p><h3 id=identificador-de-protocolo-de-carga-útil>Identificador de Protocolo de Carga Útil
<a class=anchor href=#identificador-de-protocolo-de-carga-%c3%batil>#</a></h3><p>Cada fragmento DATA también tiene un Identificador de Protocolo de Carga Útil (PPID). Esto se usa para identificar de manera única qué tipo de datos se está intercambiando.
SCTP tiene muchos PPIDs, pero WebRTC solo está usando los siguientes cinco:</p><ul><li>`WebRTC DCEP` (`50`) - Mensajes DCEP.</li><li>`WebRTC String` (`51`) - Mensajes de cadena de DataChannel.</li><li>`WebRTC Binary` (`53`) - Mensajes binarios de DataChannel.</li><li>`WebRTC String Empty` (`56`) - Mensajes de cadena de DataChannel con longitud 0.</li><li>`WebRTC Binary Empty` (`57`) - Mensajes binarios de DataChannel con longitud 0.</li></ul><h2 id=protocolo-1>Protocolo
<a class=anchor href=#protocolo-1>#</a></h2><p>Los siguientes son algunos de los fragmentos utilizados por el protocolo SCTP. Esta no es
una demostración exhaustiva. Esto proporciona suficientes estructuras para que la
máquina de estados tenga sentido.</p><p>Cada Fragmento comienza con un campo `tipo`. Antes de una lista de fragmentos, también
tendrás un encabezado.</p><h3 id=fragmento-data>Fragmento DATA
<a class=anchor href=#fragmento-data>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 0 | Reserved|U|B|E| Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| TSN |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Stream Identifier | Stream Sequence Number |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Payload Protocol Identifier |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\<br>/ User Data /
\<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
El fragmento DATA es cómo se intercambian todos los datos de usuario. Cuando envías
cualquier cosa sobre el canal de datos, así es como se intercambia.</p><p>El bit `U` se establece si este es un paquete desordenado. Podemos ignorar el
Número de Secuencia de Flujo.</p><p>`B` y `E` son los bits de inicio y fin. Si quieres enviar un
mensaje que es demasiado grande para un fragmento DATA, necesita fragmentarse en múltiples fragmentos DATA enviados en paquetes separados.
Con el bit `B` y `E` y Números de Secuencia, SCTP es capaz de expresar
esto.</p><ul><li>`B=1`, `E=0` - Primera pieza de un mensaje de usuario fragmentado.</li><li>`B=0`, `E=0` - Pieza intermedia de un mensaje de usuario fragmentado.</li><li>`B=0`, `E=1` - Última pieza de un mensaje de usuario fragmentado.</li><li>`B=1`, `E=1` - Mensaje sin fragmentar.</li></ul><p>`TSN` es el Número de Secuencia de Transmisión. Es el identificador
único global para este fragmento DATA. Después de 4,294,967,295 fragmentos esto se reiniciará a 0.
El TSN se incrementa para cada fragmento en un mensaje de usuario fragmentado para que el receptor sepa cómo ordenar los fragmentos recibidos para reconstruir el mensaje original.</p><p>`Identificador de Flujo` es el identificador único para el flujo al que pertenecen estos datos.</p><p>`Número de Secuencia de Flujo` es un número de 16 bits incrementado cada mensaje de usuario e incluido en el encabezado del fragmento del mensaje DATA. Después de 65535 mensajes esto se reiniciará a 0. Este número se usa para decidir el orden de entrega de mensajes al receptor si `U` está establecido en 0. Similar al TSN, excepto que el Número de Secuencia de Flujo solo se incrementa para cada mensaje en su conjunto y no para cada fragmento DATA individual.</p><p>`Identificador de Protocolo de Carga Útil` es el tipo de datos que fluye a través
de este flujo. Para WebRTC, será DCEP, String o Binary.</p><p>`Datos de Usuario` es lo que estás enviando. Todos los datos que envías a través de un canal de datos de WebRTC
se transmiten a través de un fragmento DATA.</p><h3 id=fragmento-init>Fragmento INIT
<a class=anchor href=#fragmento-init>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 1 | Chunk Flags | Chunk Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Initiate Tag |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Advertised Receiver Window Credit (a_rwnd) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Number of Outbound Streams | Number of Inbound Streams |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Initial TSN |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\<br>/ Optional/Variable-Length Parameters /
\<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>El fragmento INIT inicia el proceso de creación de una asociación.</p><p>`Etiqueta de Inicio` se usa para la generación de cookies. Las cookies se usan para la protección contra
Man-In-The-Middle y Denegación de Servicio. Se describen con mayor detalle en la sección de
máquina de estados.</p><p>`Crédito de Ventana de Receptor Anunciado` se usa para el Control de Congestión de SCTP. Esto
comunica qué tan grande es el búfer que el receptor ha asignado para esta asociación.</p><p>`Número de Flujos de Salida/Entrada` notifica al remoto cuántos flujos este
agente soporta.</p><p>`TSN Inicial` es un `uint32` aleatorio para comenzar el TSN local.</p><p>`Parámetros Opcionales` permite a SCTP introducir nuevas características al protocolo.</p><h3 id=fragmento-sack>Fragmento SACK
<a class=anchor href=#fragmento-sack>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 3 |Chunk Flags | Chunk Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Cumulative TSN Ack |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Advertised Receiver Window Credit (a_rwnd) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Number of Gap Ack Blocks = N | Number of Duplicate TSNs = X |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Gap Ack Block #1 Start | Gap Ack Block #1 End |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/ /
\ &mldr;<br>/ /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Gap Ack Block #N Start | Gap Ack Block #N End |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Duplicate TSN 1 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/ /
\ &mldr;<br>/ /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Duplicate TSN X |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>El fragmento SACK (Acuse de Recibo Selectivo) es cómo un receptor notifica
a un remitente que ha recibido un paquete. Hasta que un remitente obtiene un SACK para un TSN
reenviará el fragmento DATA en cuestión. Sin embargo, un SACK hace más que
actualizar el TSN.</p><p>`TSN ACK Acumulativo` el TSN más alto que se ha recibido.</p><p>`Crédito de Ventana de Receptor Anunciado` tamaño del búfer del receptor. El receptor
puede cambiar esto durante la sesión si hay más memoria disponible.</p><p>`Bloques Ack` TSNs que han sido recibidos después del `TSN ACK Acumulativo`.
Esto se usa si hay una brecha en los paquetes entregados. Digamos que los fragmentos DATA con TSNs
`100`, `102`, `103` y `104` son entregados. El `TSN ACK Acumulativo` sería `100`, pero
`Bloques Ack` podrían usarse para decirle al remitente que no necesita reenviar `102`, `103` o `104`.</p><p>`TSN Duplicado` informa al remitente que ha recibido los siguientes fragmentos DATA más de una vez.</p><h3 id=fragmento-heartbeat>Fragmento HEARTBEAT
<a class=anchor href=#fragmento-heartbeat>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 4 | Chunk Flags | Heartbeat Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\<br>/ Heartbeat Information TLV (Variable-Length) /
\<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>El fragmento HEARTBEAT se usa para afirmar que el remoto todavía está respondiendo.
Útil si no estás enviando fragmentos DATA y necesitas mantener un
mapeo NAT abierto.</p><h3 id=fragmento-abort>Fragmento ABORT
<a class=anchor href=#fragmento-abort>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 6 |Reserved |T| Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/ /
\ Zero or more Error Causes<br>/ /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>Un fragmento ABORT cierra abruptamente la asociación. Usado cuando
un lado entra en un estado de error. Finalizar la conexión de manera elegante usa
el fragmento SHUTDOWN.</p><h3 id=fragmento-shutdown>Fragmento SHUTDOWN
<a class=anchor href=#fragmento-shutdown>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 7 | Chunk Flags | Length = 8 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Cumulative TSN Ack |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>El fragmento SHUTDOWN inicia un cierre elegante de la asociación SCTP.
Cada agente informa al remoto del último TSN que envió. Esto asegura
que no se pierdan paquetes. WebRTC no hace un cierre elegante de
la asociación SCTP. Necesitas cerrar cada canal de datos tú mismo
para manejarlo de manera elegante.</p><p>`TSN ACK Acumulativo` es el último TSN que fue enviado. Cada lado sabe
que no debe terminar hasta que haya recibido el fragmento DATA con este TSN.</p><h3 id=fragmento-error>Fragmento ERROR
<a class=anchor href=#fragmento-error>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 9 | Chunk Flags | Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\<br>/ One or more Error Causes /
\<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>Un fragmento ERROR se usa para notificar al Agente SCTP remoto que ha ocurrido un
error no fatal.</p><h3 id=fragmento-forward-tsn>Fragmento FORWARD TSN
<a class=anchor href=#fragmento-forward-tsn>#</a></h3><p>```
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type = 192 | Flags = 0x00 | Length = Variable |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| New Cumulative TSN |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Stream-1 | Stream Sequence-1 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\ /
/<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Stream-N | Stream Sequence-N |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```</p><p>El fragmento `FORWARD TSN` mueve el TSN global hacia adelante. SCTP hace esto
para que puedas saltar algunos paquetes que ya no te importan. Digamos
que envías `10 11 12 13 14 15` y estos paquetes solo son válidos si
todos llegan. Estos datos también son sensibles al tiempo real, así que si llegan
tarde no son útiles.</p><p>Si pierdes `12` y `13` ¡no hay razón para enviar `14` y `15`!
SCTP usa el fragmento `FORWARD TSN` para lograr eso. Le dice al receptor
que `14` y `15` ya no se entregarán.</p><p>`Nuevo TSN Acumulativo` este es el nuevo TSN de la conexión. Cualquier paquete
antes de este TSN no se retendrá.</p><p>`Flujo` y `Secuencia de Flujo` se usan para saltar el `Número de Secuencia de Flujo`
adelante. Consulta de nuevo el Fragmento DATA para la importancia de este campo.</p><h2 id=máquina-de-estados>Máquina de Estados
<a class=anchor href=#m%c3%a1quina-de-estados>#</a></h2><p>Estas son algunas partes interesantes de la máquina de estados SCTP. WebRTC no usa todas
las características de la máquina de estados SCTP, por lo que hemos excluido esas partes. También hemos simplificado algunos componentes para hacerlos comprensibles por sí mismos.</p><h3 id=flujo-de-establecimiento-de-conexión>Flujo de Establecimiento de Conexión
<a class=anchor href=#flujo-de-establecimiento-de-conexi%c3%b3n>#</a></h3><p>Los fragmentos `INIT` e `INIT ACK` se usan para intercambiar las capacidades y configuraciones
de cada par. SCTP usa una cookie durante el handshake para validar el par con el que se está comunicando.
Esto es para asegurar que el handshake no sea interceptado y para prevenir ataques DoS.</p><p>El fragmento `INIT ACK` contiene la cookie. La cookie luego se devuelve a su creador
usando el `COOKIE ECHO`. Si la verificación de la cookie es exitosa, se
envía el `COOKIE ACK` y los fragmentos DATA están listos para ser intercambiados.</p><p><img src=../../images/07-connection-establishment.png alt="Establecimiento de conexión" title="Establecimiento de conexión"></p><h3 id=flujo-de-desconexión>Flujo de Desconexión
<a class=anchor href=#flujo-de-desconexi%c3%b3n>#</a></h3><p>SCTP usa el fragmento `SHUTDOWN`. Cuando un agente recibe un fragmento `SHUTDOWN`, esperará hasta que
reciba el `TSN ACK Acumulativo` solicitado. Esto permite a un usuario asegurar que todos los datos
se entreguen incluso si la conexión tiene pérdidas.</p><h3 id=mecanismo-de-keep-alive>Mecanismo de Keep-Alive
<a class=anchor href=#mecanismo-de-keep-alive>#</a></h3><p>SCTP usa los fragmentos `HEARTBEAT REQUEST` y `HEARTBEAT ACK` para mantener la conexión viva. Estos se envían
en un intervalo configurable. SCTP también realiza un backoff exponencial si el paquete no ha llegado.</p><p>El fragmento `HEARTBEAT` también contiene un valor de tiempo. Esto permite que dos asociaciones calculen el tiempo de viaje entre dos agentes.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/5deb9d27fb754365c8bd0c350c4d35faf1b6a8d8 title='Última modificación por Claes Mogren | octubre 31, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>octubre 31, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/07-data-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Editar esta página</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#qué-obtengo-de-la-comunicación-de-datos-de-webrtc>¿Qué obtengo de la comunicación de datos de WebRTC?</a></li><li><a href=#cómo-funciona>¿Cómo funciona?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#protocolo-de-transmisión-de-control-de-flujo>Protocolo de Transmisión de Control de Flujo</a></li><li><a href=#conceptos>Conceptos</a><ul><li><a href=#asociación>Asociación</a></li><li><a href=#flujos>Flujos</a></li><li><a href=#basado-en-datagramas>Basado en Datagramas</a></li><li><a href=#fragmentos>Fragmentos</a></li><li><a href=#número-de-secuencia-de-transmisión>Número de Secuencia de Transmisión</a></li><li><a href=#identificador-de-flujo>Identificador de Flujo</a></li><li><a href=#identificador-de-protocolo-de-carga-útil>Identificador de Protocolo de Carga Útil</a></li></ul></li><li><a href=#protocolo-1>Protocolo</a><ul><li><a href=#fragmento-data>Fragmento DATA</a></li><li><a href=#fragmento-init>Fragmento INIT</a></li><li><a href=#fragmento-sack>Fragmento SACK</a></li><li><a href=#fragmento-heartbeat>Fragmento HEARTBEAT</a></li><li><a href=#fragmento-abort>Fragmento ABORT</a></li><li><a href=#fragmento-shutdown>Fragmento SHUTDOWN</a></li><li><a href=#fragmento-error>Fragmento ERROR</a></li><li><a href=#fragmento-forward-tsn>Fragmento FORWARD TSN</a></li></ul></li><li><a href=#máquina-de-estados>Máquina de Estados</a><ul><li><a href=#flujo-de-establecimiento-de-conexión>Flujo de Establecimiento de Conexión</a></li><li><a href=#flujo-de-desconexión>Flujo de Desconexión</a></li><li><a href=#mecanismo-de-keep-alive>Mecanismo de Keep-Alive</a></li></ul></li></ul></nav></div></aside></main></body></html>