<!doctype html><html lang=es dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Seguridad # ¿Qué seguridad tiene WebRTC? # Cada conexión WebRTC está autenticada y cifrada. Puedes estar seguro de que un tercero no puede ver lo que estás enviando ni insertar mensajes falsos. También puedes estar seguro de que el Agente WebRTC que generó la Descripción de Sesión es con quien te estás comunicando.
Es muy importante que nadie manipule esos mensajes. Está bien si un tercero lee la Descripción de Sesión en tránsito."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/es/docs/04-securing/"><meta property="og:site_name" content="WebRTC para los curiosos"><meta property="og:title" content="Seguridad"><meta property="og:description" content="Seguridad # ¿Qué seguridad tiene WebRTC? # Cada conexión WebRTC está autenticada y cifrada. Puedes estar seguro de que un tercero no puede ver lo que estás enviando ni insertar mensajes falsos. También puedes estar seguro de que el Agente WebRTC que generó la Descripción de Sesión es con quien te estás comunicando.
Es muy importante que nadie manipule esos mensajes. Está bien si un tercero lee la Descripción de Sesión en tránsito."><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-10-31T11:17:17-04:00"><title>Seguridad | WebRTC para los curiosos</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/es/docs/04-securing/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/04-securing/ title=Защита><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/04-securing/ title=安全性><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/04-securing/ title=امنیت><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/04-securing/ title=Securing><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/04-securing/ title=Securing><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/04-securing/ title=Güvenlik><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/04-securing/ title=보안><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/es.search.min.9b1bcd2b6b542753f44e44010ec9bb845a245c0565d705379397ad936fb4332a.js integrity="sha256-mxvNK2tUJ1P0TkQBDsm7hFokXAVl1wU3k5etk2+0Myo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/es/><span>WebRTC para los curiosos</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Buscar aria-label=Buscar maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Español</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/04-securing/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/04-securing/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/04-securing/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/04-securing/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/04-securing/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/04-securing/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/04-securing/>한국어</a></li></ul></li></ul><ul><li><a href=/es/docs/01-what-why-and-how/>¿Qué, Por qué y Cómo?</a></li><li><a href=/es/docs/02-signaling/>Señalización</a></li><li><a href=/es/docs/03-connecting/>Conexión</a></li><li><a href=/es/docs/04-securing/ class=active>Seguridad</a></li><li><a href=/es/docs/05-real-time-networking/>Redes en Tiempo Real</a></li><li><a href=/es/docs/06-media-communication/>Comunicación de Medios</a></li><li><a href=/es/docs/07-data-communication/>Comunicación de Datos</a></li><li><a href=/es/docs/08-applied-webrtc/>WebRTC Aplicado</a></li><li><a href=/es/docs/09-debugging/>Depuración</a></li><li><a href=/es/docs/10-history-of-webrtc/>Historia</a></li><li><a href=/es/docs/11-faq/>FAQ</a></li><li><a href=/es/docs/12-glossary/>Glosario</a></li><li><a href=/es/docs/13-reference/>Referencia</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Seguridad</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#qué-seguridad-tiene-webrtc>¿Qué seguridad tiene WebRTC?</a></li><li><a href=#cómo-funciona>¿Cómo funciona?</a></li><li><a href=#seguridad-101>Seguridad 101</a><ul><li><a href=#texto-plano-y-texto-cifrado>Texto Plano y Texto Cifrado</a></li><li><a href=#cifrador>Cifrador</a></li><li><a href=#funciones-hash>Funciones Hash</a></li><li><a href=#criptografía-de-clave-públicaprivada>Criptografía de Clave Pública/Privada</a></li><li><a href=#intercambio-diffiehellman>Intercambio Diffie–Hellman</a></li><li><a href=#función-pseudoaleatoria>Función Pseudoaleatoria</a></li><li><a href=#función-de-derivación-de-clave>Función de Derivación de Clave</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#código-de-autenticación-de-mensajes>Código de Autenticación de Mensajes</a></li><li><a href=#rotación-de-claves>Rotación de Claves</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#formato-de-paquete>Formato de Paquete</a></li><li><a href=#máquina-de-estados-del-handshake>Máquina de Estados del Handshake</a></li><li><a href=#generación-de-claves>Generación de Claves</a></li><li><a href=#intercambio-de-applicationdata>Intercambio de ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#creación-de-sesión>Creación de Sesión</a></li><li><a href=#intercambio-de-medios>Intercambio de Medios</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=seguridad>Seguridad
<a class=anchor href=#seguridad>#</a></h1><h2 id=qué-seguridad-tiene-webrtc>¿Qué seguridad tiene WebRTC?
<a class=anchor href=#qu%c3%a9-seguridad-tiene-webrtc>#</a></h2><p>Cada conexión WebRTC está autenticada y cifrada. Puedes estar seguro de que un tercero no puede ver lo que estás enviando ni insertar mensajes falsos. También puedes estar seguro de que el Agente WebRTC que generó la Descripción de Sesión es con quien te estás comunicando.</p><p>Es muy importante que nadie manipule esos mensajes. Está bien si un tercero lee la Descripción de Sesión en tránsito. Sin embargo, WebRTC no tiene protección contra su modificación. Un atacante podría realizar un ataque de intermediario (man-in-the-middle) cambiando los Candidatos ICE y actualizando la Huella Digital del Certificado.</p><h2 id=cómo-funciona>¿Cómo funciona?
<a class=anchor href=#c%c3%b3mo-funciona>#</a></h2><p>WebRTC usa dos protocolos preexistentes, Seguridad de la Capa de Transporte de Datagramas (<a href=https://tools.ietf.org/html/rfc6347>DTLS</a>) y el Protocolo de Transporte en Tiempo Real Seguro (<a href=https://tools.ietf.org/html/rfc3711>SRTP</a>).</p><p>DTLS te permite negociar una sesión y luego intercambiar datos de forma segura entre dos pares. Es un hermano de TLS, la misma tecnología que impulsa HTTPS, pero DTLS usa UDP en lugar de TCP como capa de transporte. Eso significa que el protocolo tiene que manejar entregas no confiables. SRTP está específicamente diseñado para intercambiar medios de forma segura. Hay algunas optimizaciones que podemos hacer al usarlo en lugar de DTLS.</p><p>DTLS se usa primero. Hace un handshake sobre la conexión proporcionada por ICE. DTLS es un protocolo cliente/servidor, por lo que un lado necesita iniciar el handshake. Los roles de Cliente/Servidor se eligen durante la señalización. Durante el handshake DTLS, ambos lados ofrecen un certificado.
Después de que se completa el handshake, este certificado se compara con el hash del certificado en la Descripción de Sesión. Esto es para asegurar que el handshake ocurrió con el Agente WebRTC que esperabas. La conexión DTLS está entonces disponible para ser utilizada para la comunicación DataChannel.</p><p>Para crear una sesión SRTP la inicializamos usando las claves generadas por DTLS. SRTP no tiene un mecanismo de handshake, por lo que tiene que ser iniciado con claves externas. Una vez que esto se hace, ¡los medios pueden ser intercambiados cifrados usando SRTP!</p><h2 id=seguridad-101>Seguridad 101
<a class=anchor href=#seguridad-101>#</a></h2><p>Para entender la tecnología presentada en este capítulo necesitarás entender estos términos primero. La criptografía es un tema complicado, ¡así que valdría la pena consultar otras fuentes también!</p><h3 id=texto-plano-y-texto-cifrado>Texto Plano y Texto Cifrado
<a class=anchor href=#texto-plano-y-texto-cifrado>#</a></h3><p>El texto plano es la entrada a un cifrador. El texto cifrado es la salida de un cifrador.</p><h3 id=cifrador>Cifrador
<a class=anchor href=#cifrador>#</a></h3><p>Un cifrador es una serie de pasos que lleva el texto plano a texto cifrado. El cifrador puede ser revertido, para que puedas llevar tu texto cifrado de vuelta a texto plano. Un cifrador generalmente tiene una clave para cambiar su comportamiento. Otro término para esto es cifrar y descifrar.</p><p>Un cifrador simple es ROT13. Cada letra se mueve 13 caracteres hacia adelante. Para deshacer el cifrador mueves 13 caracteres hacia atrás. El texto plano <code>HELLO</code> se convertiría en el texto cifrado <code>URYYB</code>. En este caso, el Cifrador es ROT, y la clave es 13.</p><h3 id=funciones-hash>Funciones Hash
<a class=anchor href=#funciones-hash>#</a></h3><p>Una función hash criptográfica es un proceso unidireccional que genera un resumen. Dado una entrada, genera la misma salida cada vez. Es importante que la salida <em>no</em> sea reversible. Si tienes una salida, no deberías poder determinar su entrada. El hash es útil cuando quieres confirmar que un mensaje no ha sido manipulado.</p><p>Una función hash simple (aunque ciertamente no adecuada para criptografía real) sería tomar solo cada dos letras. <code>HELLO</code> se convertiría en <code>HLO</code>. No puedes asumir que <code>HELLO</code> fue la entrada, pero puedes confirmar que <code>HELLO</code> coincidiría con el resumen hash.</p><h3 id=criptografía-de-clave-públicaprivada>Criptografía de Clave Pública/Privada
<a class=anchor href=#criptograf%c3%ada-de-clave-p%c3%bablicaprivada>#</a></h3><p>La Criptografía de Clave Pública/Privada describe el tipo de cifradores que DTLS y SRTP usan. En este sistema, tienes dos claves, una clave pública y una privada. La clave pública es para cifrar mensajes y es seguro compartirla.
La clave privada es para descifrar, y nunca debe ser compartida. Es la única clave que puede descifrar los mensajes cifrados con la clave pública.</p><h3 id=intercambio-diffiehellman>Intercambio Diffie–Hellman
<a class=anchor href=#intercambio-diffiehellman>#</a></h3><p>El intercambio Diffie–Hellman permite que dos usuarios que nunca se han conocido antes creen un secreto compartido de forma segura a través de Internet. El Usuario <code>A</code> puede enviar un secreto al Usuario <code>B</code> sin preocuparse por escuchas indiscretas. Esto depende de la dificultad de romper el problema del logaritmo discreto.
No necesitas entender completamente cómo funciona esto, pero ayuda saber que esto es lo que hace posible el handshake DTLS.</p><p>Wikipedia tiene un ejemplo de esto en acción <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>aquí</a>.</p><h3 id=función-pseudoaleatoria>Función Pseudoaleatoria
<a class=anchor href=#funci%c3%b3n-pseudoaleatoria>#</a></h3><p>Una Función Pseudoaleatoria (PRF) es una función predefinida para generar un valor que aparece aleatorio. Puede tomar múltiples entradas y generar una única salida.</p><h3 id=función-de-derivación-de-clave>Función de Derivación de Clave
<a class=anchor href=#funci%c3%b3n-de-derivaci%c3%b3n-de-clave>#</a></h3><p>La Derivación de Clave es un tipo de Función Pseudoaleatoria. La Derivación de Clave es una función que se usa para hacer una clave más fuerte. Un patrón común es el estiramiento de claves.</p><p>Digamos que te dan una clave de 8 bytes. Podrías usar una KDF para hacerla más fuerte.</p><h3 id=nonce>Nonce
<a class=anchor href=#nonce>#</a></h3><p>Un nonce es una entrada adicional a un cifrador. Esto se usa para que puedas obtener una salida diferente del cifrador, incluso si estás cifrando el mismo mensaje varias veces.</p><p>Si cifras el mismo mensaje 10 veces, el cifrador te dará el mismo texto cifrado 10 veces. Al usar un nonce puedes obtener una salida diferente, mientras sigues usando la misma clave. ¡Es importante que uses un nonce diferente para cada mensaje! De lo contrario, niega gran parte del valor.</p><h3 id=código-de-autenticación-de-mensajes>Código de Autenticación de Mensajes
<a class=anchor href=#c%c3%b3digo-de-autenticaci%c3%b3n-de-mensajes>#</a></h3><p>Un Código de Autenticación de Mensajes es un hash que se coloca al final de un mensaje. Un MAC prueba que el mensaje proviene del usuario que esperabas.</p><p>Si no usas un MAC, un atacante podría insertar mensajes inválidos. Después de descifrar solo tendrías basura porque no conocen la clave.</p><h3 id=rotación-de-claves>Rotación de Claves
<a class=anchor href=#rotaci%c3%b3n-de-claves>#</a></h3><p>La Rotación de Claves es la práctica de cambiar tu clave en un intervalo. Esto hace que una clave robada tenga menos impacto. Si una clave es robada o filtrada, se pueden descifrar menos datos.</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS (Seguridad de la Capa de Transporte de Datagramas) permite que dos pares establezcan comunicación segura sin configuración preexistente. Incluso si alguien está escuchando la conversación, no podrán descifrar los mensajes.</p><p>Para que un Cliente DTLS y un Servidor se comuniquen, necesitan acordar un cifrador y la clave. Determinan estos valores haciendo un handshake DTLS. Durante el handshake, los mensajes están en texto plano.
Cuando un Cliente/Servidor DTLS ha intercambiado suficientes detalles para comenzar a cifrar, envía un <code>Change Cipher Spec</code>. ¡Después de este mensaje, cada mensaje subsiguiente será cifrado!</p><h3 id=formato-de-paquete>Formato de Paquete
<a class=anchor href=#formato-de-paquete>#</a></h3><p>Cada paquete DTLS comienza con un encabezado.</p><h4 id=tipo-de-contenido>Tipo de Contenido
<a class=anchor href=#tipo-de-contenido>#</a></h4><p>Puedes esperar los siguientes tipos:</p><ul><li><code>20</code> - Change Cipher Spec</li><li><code>22</code> - Handshake</li><li><code>23</code> - Application Data</li></ul><p><code>Handshake</code> se usa para intercambiar los detalles para iniciar la sesión. <code>Change Cipher Spec</code> se usa para notificar al otro lado que todo será cifrado. <code>Application Data</code> son los mensajes cifrados.</p><h4 id=versión>Versión
<a class=anchor href=#versi%c3%b3n>#</a></h4><p>La versión puede ser <code>0x0000feff</code> (DTLS v1.0) o <code>0x0000fefd</code> (DTLS v1.2), no hay v1.1.</p><h4 id=época>Época
<a class=anchor href=#%c3%a9poca>#</a></h4><p>La época comienza en <code>0</code>, pero se convierte en <code>1</code> después de un <code>Change Cipher Spec</code>. Cualquier mensaje con una época distinta de cero está cifrado.</p><h4 id=número-de-secuencia>Número de Secuencia
<a class=anchor href=#n%c3%bamero-de-secuencia>#</a></h4><p>El Número de Secuencia se usa para mantener los mensajes en orden. Cada mensaje incrementa el Número de Secuencia. Cuando la época se incrementa, el Número de Secuencia comienza de nuevo.</p><h4 id=longitud-y-carga-útil>Longitud y Carga Útil
<a class=anchor href=#longitud-y-carga-%c3%batil>#</a></h4><p>La Carga Útil es específica del <code>Tipo de Contenido</code>. Para un <code>Application Data</code> la <code>Carga Útil</code> son los datos cifrados. Para <code>Handshake</code> será diferente dependiendo del mensaje. La longitud es para qué tan grande es la <code>Carga Útil</code>.</p><h3 id=máquina-de-estados-del-handshake>Máquina de Estados del Handshake
<a class=anchor href=#m%c3%a1quina-de-estados-del-handshake>#</a></h3><p>Durante el handshake, el Cliente/Servidor intercambian una serie de mensajes. Estos mensajes se agrupan en vuelos. Cada vuelo puede tener múltiples mensajes (o solo uno).
Un Vuelo no está completo hasta que se han recibido todos los mensajes en el vuelo. Describiremos el propósito de cada mensaje con mayor detalle a continuación.</p><p><img src=../../images/04-handshake.png alt=Handshake title=Handshake></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello es el mensaje inicial enviado por el cliente. Contiene una lista de atributos. Estos atributos le dicen al servidor los cifradores y características que el cliente soporta. Para WebRTC así es como elegimos el Cifrador SRTP también. También contiene datos aleatorios que se usarán para generar las claves para la sesión.</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>HelloVerifyRequest es enviado por el servidor al cliente. Es para asegurarse de que el cliente tenía la intención de enviar la solicitud. El Cliente luego reenvía el ClientHello, pero con un token proporcionado en el HelloVerifyRequest.</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello es la respuesta del servidor para la configuración de esta sesión. Contiene qué cifrador se usará cuando esta sesión termine. También contiene los datos aleatorios del servidor.</p><h4 id=certificate>Certificate
<a class=anchor href=#certificate>#</a></h4><p>Certificate contiene el certificado para el Cliente o Servidor. Esto se usa para identificar únicamente con quién nos estábamos comunicando. Después de que termine el handshake nos aseguraremos de que este certificado cuando se hashea coincida con la huella digital en la <code>SessionDescription</code>.</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>Estos mensajes se usan para transmitir la clave pública. Al inicio, el cliente y el servidor generan un par de claves. Después del handshake estos valores se usarán para generar el <code>Pre-Master Secret</code>.</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>Un CertificateRequest es enviado por el servidor notificando al cliente que quiere un certificado. El servidor puede Solicitar o Requerir un certificado.</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone notifica al cliente que el servidor ha terminado con el handshake.</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>CertificateVerify es cómo el remitente prueba que tiene la clave privada enviada en el mensaje Certificate.</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec informa al receptor que todo lo enviado después de este mensaje será cifrado.</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished está cifrado y contiene un hash de todos los mensajes. Esto es para afirmar que el handshake no fue manipulado.</p><h3 id=generación-de-claves>Generación de Claves
<a class=anchor href=#generaci%c3%b3n-de-claves>#</a></h3><p>Después de que el Handshake está completo, puedes comenzar a enviar datos cifrados. El Cifrador fue elegido por el servidor y está en el ServerHello. ¿Cómo se eligió la clave entonces?</p><p>Primero generamos el <code>Pre-Master Secret</code>. Para obtener este valor se usa Diffie–Hellman en las claves intercambiadas por el <code>ServerKeyExchange</code> y <code>ClientKeyExchange</code>. Los detalles difieren dependiendo del Cifrador elegido.</p><p>A continuación se genera el <code>Master Secret</code>. Cada versión de DTLS tiene una <code>Función Pseudoaleatoria</code> definida. Para DTLS 1.2 la función toma el <code>Pre-Master Secret</code> y valores aleatorios en el <code>ClientHello</code> y <code>ServerHello</code>.
La salida de ejecutar la <code>Función Pseudoaleatoria</code> es el <code>Master Secret</code>. El <code>Master Secret</code> es el valor que se usa para el Cifrador.</p><h3 id=intercambio-de-applicationdata>Intercambio de ApplicationData
<a class=anchor href=#intercambio-de-applicationdata>#</a></h3><p>El caballo de batalla de DTLS es <code>ApplicationData</code>. Ahora que tenemos un cifrador inicializado, podemos comenzar a cifrar y enviar valores.</p><p>Los mensajes <code>ApplicationData</code> usan un encabezado DTLS como se describió anteriormente. La <code>Carga Útil</code> se rellena con texto cifrado. Ahora tienes una Sesión DTLS funcionando y puedes comunicarte de forma segura.</p><p>DTLS tiene muchas más características interesantes como la renegociación. No son usadas por WebRTC, por lo que no se cubrirán aquí.</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP es un protocolo diseñado específicamente para cifrar paquetes RTP. Para iniciar una sesión SRTP especificas tus claves y cifrador. A diferencia de DTLS no tiene mecanismo de handshake. Toda la configuración y claves fueron generadas durante el handshake DTLS.</p><p>DTLS proporciona una API dedicada para exportar las claves para ser utilizadas por otro proceso. Esto está definido en <a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>.</p><h3 id=creación-de-sesión>Creación de Sesión
<a class=anchor href=#creaci%c3%b3n-de-sesi%c3%b3n>#</a></h3><p>SRTP define una Función de Derivación de Clave que se usa en las entradas. Al crear una Sesión SRTP, las entradas se ejecutan a través de esto para generar nuestras claves para nuestro Cifrador SRTP. Después de esto puedes pasar al procesamiento de medios.</p><h3 id=intercambio-de-medios>Intercambio de Medios
<a class=anchor href=#intercambio-de-medios>#</a></h3><p>Cada paquete RTP tiene un SequenceNumber de 16 bits. Estos Números de Secuencia se usan para mantener los paquetes en orden, como una Clave Primaria. Durante una llamada estos se reiniciarán. SRTP rastrea esto y lo llama el contador de reinicio (rollover counter).</p><p>Al cifrar un paquete, SRTP usa el contador de reinicio y el número de secuencia como un nonce. Esto es para asegurar que incluso si envías los mismos datos dos veces, el texto cifrado será diferente. Esto es importante para evitar que un atacante identifique patrones o intente un ataque de repetición.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/5deb9d27fb754365c8bd0c350c4d35faf1b6a8d8 title='Última modificación por Claes Mogren | octubre 31, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>octubre 31, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Editar esta página</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#qué-seguridad-tiene-webrtc>¿Qué seguridad tiene WebRTC?</a></li><li><a href=#cómo-funciona>¿Cómo funciona?</a></li><li><a href=#seguridad-101>Seguridad 101</a><ul><li><a href=#texto-plano-y-texto-cifrado>Texto Plano y Texto Cifrado</a></li><li><a href=#cifrador>Cifrador</a></li><li><a href=#funciones-hash>Funciones Hash</a></li><li><a href=#criptografía-de-clave-públicaprivada>Criptografía de Clave Pública/Privada</a></li><li><a href=#intercambio-diffiehellman>Intercambio Diffie–Hellman</a></li><li><a href=#función-pseudoaleatoria>Función Pseudoaleatoria</a></li><li><a href=#función-de-derivación-de-clave>Función de Derivación de Clave</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#código-de-autenticación-de-mensajes>Código de Autenticación de Mensajes</a></li><li><a href=#rotación-de-claves>Rotación de Claves</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#formato-de-paquete>Formato de Paquete</a></li><li><a href=#máquina-de-estados-del-handshake>Máquina de Estados del Handshake</a></li><li><a href=#generación-de-claves>Generación de Claves</a></li><li><a href=#intercambio-de-applicationdata>Intercambio de ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#creación-de-sesión>Creación de Sesión</a></li><li><a href=#intercambio-de-medios>Intercambio de Medios</a></li></ul></li></ul></nav></div></aside></main></body></html>