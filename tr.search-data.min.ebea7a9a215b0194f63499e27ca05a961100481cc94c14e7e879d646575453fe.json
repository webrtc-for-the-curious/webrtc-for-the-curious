[{"id":0,"href":"/tr/docs/01-what-why-and-how/","title":"Ne, Neden ve Nasıl","section":"Docs","content":" Ne, Neden ve Nasıl # WebRTC Nedir? # WebRTC, Web Real-Time Communication\u0026rsquo;ın kısaltması olarak hem bir API hem de bir Protokoldür. WebRTC protokolü, iki WebRTC aracısının çift yönlü güvenli gerçek zamanlı iletişim müzakere etmesi için bir dizi kuraldan oluşur. WebRTC API\u0026rsquo;si ise geliştiricilerin WebRTC protokolünü kullanmasına olanak tanır. WebRTC API\u0026rsquo;si yalnızca JavaScript için belirtilmiştir.\nBenzer bir ilişki HTTP ve Fetch API arasındaki ilişki olacaktır. WebRTC protokolü HTTP olurken, WebRTC API\u0026rsquo;si Fetch API olur.\nWebRTC protokolü JavaScript dışında diğer API\u0026rsquo;ler ve dillerde de mevcuttur. WebRTC için sunucular ve domain-spesifik araçlar da bulabilirsiniz. Tüm bu uygulamalar WebRTC protokolünü kullanır böylece birbirleriyle etkileşim kurabilirler.\nWebRTC protokolü IETF\u0026rsquo;de rtcweb çalışma grubunda sürdürülmektedir. WebRTC API\u0026rsquo;si ise W3C\u0026rsquo;de webrtc olarak belgelendirilmiştir.\nNeden WebRTC öğrenmeliyim? # WebRTC\u0026rsquo;nin size vereceği şeyler şunlardır:\nAçık standart Çoklu uygulamalar Tarayıcılarda mevcut Zorunlu şifreleme NAT Geçişi Mevcut teknolojinin yeniden kullanımı Tıkanıklık kontrolü Saniyenin altında gecikme Bu liste kapsamlı değil, yolculuğunuz sırasında takdir edebileceğiniz şeylerin sadece bir örneği. Henüz tüm bu terimleri bilmiyorsanız endişelenmeyin, bu kitap bunları yol boyunca size öğretecek.\nWebRTC Protokolü diğer teknolojilerin bir koleksiyonudur # WebRTC Protokolü, açıklamak için tam bir kitap gerektirecek muazzam bir konudur. Ancak başlangıç olarak onu dört adıma ayırıyoruz.\nSinyalleme Bağlanma Güvenlik İletişim Bu adımlar sıralıdır, yani önceki adımın sonraki adımın başlaması için %100 başarılı olması gerekir.\nWebRTC hakkındaki garip bir gerçek, her adımın aslında birçok başka protokolden oluşmasıdır! WebRTC yapmak için birçok mevcut teknolojiyi bir araya getiriyoruz. Bu anlamda WebRTC\u0026rsquo;yi, kendi başına yepyeni bir süreç olmaktan ziyade 2000\u0026rsquo;li yılların başlarına dayanan iyi anlaşılmış teknolojilerin bir kombinasyonu ve konfigürasyonu olarak düşünebilirsiniz.\nBu adımların her birinin özel bölümleri vardır, ancak önce bunları yüksek düzeyde anlamak yararlıdır. Birbirlerine bağımlı oldukları için, bu adımların her birinin amacını daha fazla açıklarken yardımcı olacaktır.\nSinyalleme: WebRTC\u0026rsquo;de eşler birbirlerini nasıl bulur # Bir WebRTC Aracısı başladığında, kimle iletişim kuracağı veya ne hakkında iletişim kuracağı hakkında hiçbir fikri yoktur. Sinyalleme adımı bu sorunu çözer! Sinyalleme, çağrıyı başlatmak için kullanılır ve iki bağımsız WebRTC aracısının iletişim kurmaya başlamasına olanak tanır.\nSinyalleme, SDP (Session Description Protocol) adı verilen mevcut, düz metin bir protokol kullanır. Her SDP mesajı anahtar/değer çiftlerinden oluşur ve \u0026ldquo;medya bölümleri\u0026rdquo; listesi içerir. İki WebRTC aracısının değiş tokuş ettiği SDP şu gibi detayları içerir:\nAracının ulaşılabilir olduğu IP\u0026rsquo;ler ve Portlar (adaylar). Aracının göndermek istediği ses ve video parça sayısı. Her aracının desteklediği ses ve video codec\u0026rsquo;leri. Bağlanırken kullanılan değerler (uFrag/uPwd). Güvenlik sağlanırken kullanılan değerler (sertifika parmak izi). Sinyallemenin tipik olarak \u0026ldquo;bant dışı\u0026rdquo; gerçekleştiğini not etmek çok önemlidir, bu da uygulamaların genellikle sinyalleme mesajlarını değiş tokuş etmek için WebRTC\u0026rsquo;nin kendisini kullanmadığı anlamına gelir. İki taraf arasında bir WebRTC bağlantısı başlatmadan önce başka bir iletişim kanalına ihtiyaç vardır. Kullanılan kanal türü WebRTC\u0026rsquo;nin endişesi değildir. Mesaj göndermek için uygun herhangi bir mimari, bağlanan eşler arasında SDP\u0026rsquo;leri aktarabilir ve birçok uygulama, uygun istemciler arasında SDP\u0026rsquo;lerin değiş tokuşunu kolaylaştırmak için mevcut altyapılarını (örneğin REST uç noktaları, WebSocket bağlantıları veya kimlik doğrulama proxy\u0026rsquo;leri) basitçe kullanacaktır.\nSTUN/TURN ile Bağlanma ve NAT Geçişi # İki WebRTC aracısı SDP\u0026rsquo;leri değiş tokuş ettikten sonra, birbirlerine bağlanmaya çalışmak için yeterli bilgiye sahip olurlar. Bu bağlantıyı gerçekleştirmek için WebRTC, ICE (Interactive Connectivity Establishment) adı verilen başka bir yerleşik teknolojiyi kullanır.\nICE, WebRTC\u0026rsquo;den önce var olan ve merkezi bir sunucu olmadan iki aracı arasında doğrudan bağlantı kurulmasına olanak tanıyan bir protokoldür. Bu iki aracı aynı ağda veya dünyanın diğer ucunda olabilir.\nICE doğrudan bağlantı sağlar, ancak bağlanma sürecinin gerçek büyüsü \u0026lsquo;NAT Geçişi\u0026rsquo; kavramını ve STUN/TURN Sunucularının kullanımını içerir. Daha sonra derinlemesine keşfedeceğimiz bu iki kavram, başka bir alt ağdaki ICE Aracısı ile iletişim kurmak için ihtiyacınız olan her şeydir.\nİki aracı başarıyla bir ICE bağlantısı kurduğunda, WebRTC bir sonraki adıma geçer; aralarında ses, video ve veri paylaşımı için şifrelenmiş bir aktarım katmanı kurmak.\nDTLS ve SRTP ile aktarım katmanını güvenlik altına alma # Artık çift yönlü iletişimimiz (ICE aracılığıyla) olduğuna göre, iletişimimizi güvenli hale getirmemiz gerekiyor! Bu, yine WebRTC\u0026rsquo;den önce var olan iki protokol daha aracılığıyla yapılır; DTLS (Datagram Transport Layer Security) ve SRTP (Secure Real-Time Transport Protocol). İlk protokol olan DTLS, basitçe UDP üzerinden TLS\u0026rsquo;dir (TLS, HTTPS üzerinden iletişimi güvenli hale getirmek için kullanılan kriptografik protokoldür). İkinci protokol olan SRTP, RTP (Real-time Transport Protocol) veri paketlerinin şifrelenmesini sağlamak için kullanılır.\nİlk olarak, WebRTC, ICE tarafından kurulan bağlantı üzerinden bir DTLS el sıkışması yaparak bağlanır. HTTPS\u0026rsquo;den farklı olarak, WebRTC sertifikalar için merkezi bir otorite kullanmaz. Sadece DTLS aracılığıyla değiş tokuş edilen sertifikanın, sinyalleme yoluyla paylaşılan parmak iziyle eşleştiğini doğrular. Bu DTLS bağlantısı daha sonra DataChannel mesajları için kullanılır.\nArdından, WebRTC ses/video iletimi için SRTP kullanarak güvenli hale getirilmiş RTP protokolünü kullanır. SRTP oturumumuzu, müzakere edilen DTLS oturumundan anahtarları çıkararak başlatırız.\nMedya ve veri iletiminin neden kendi protokollerine sahip olduğunu daha sonraki bir bölümde tartışacağız, ancak şimdilik bunların ayrı ayrı ele alındığını bilmek yeterlidir.\nŞimdi bittik! Başarılı bir şekilde çift yönlü ve güvenli iletişim kurduk. WebRTC aracılarınız arasında kararlı bir bağlantınız varsa, ihtiyacınız olan tüm karmaşıklık budur. Bir sonraki bölümde, WebRTC\u0026rsquo;nin talihsiz gerçek dünya problemleri olan paket kaybı ve bant genişliği sınırları ile nasıl başa çıktığını tartışacağız.\nRTP ve SCTP aracılığıyla eşlerle iletişim # Artık iki WebRTC aracımız bağlandı ve güvenli, çift yönlü iletişim kuruldu, hadi iletişim kurmaya başlayalım! Yine, WebRTC iki önceden var olan protokol kullanacak: RTP (Real-time Transport Protocol) ve SCTP (Stream Control Transmission Protocol). SRTP ile şifrelenmiş medyayı değiş tokuş etmek için RTP kullanır ve DTLS ile şifrelenmiş DataChannel mesajlarını göndermek ve almak için SCTP kullanırız.\nRTP oldukça minimal bir protokoldür, ancak gerçek zamanlı akış uygulamak için gerekli araçları sağlar. RTP hakkında en önemli şey, geliştiriciye esneklik sağlamasıdır ve gecikme, paket kaybı ve tıkanıklığı istedikleri gibi ele almalarına olanak tanır. Bunu medya bölümünde daha ayrıntılı tartışacağız.\nYığındaki son protokol SCTP\u0026rsquo;dir. SCTP hakkında önemli olan şey, güvenilir ve sıralı mesaj teslimini (birçok farklı seçenek arasında) kapatabilmenizdir. Bu, geliştiricilerin gerçek zamanlı sistemler için gerekli gecikmeyi sağlamalarına olanak tanır.\nWebRTC, protokollerin bir koleksiyonu # WebRTC bir sürü problemi çözer. İlk bakışta teknoloji aşırı mühendislik edilmiş görünebilir, ancak WebRTC\u0026rsquo;nin dehası onun alçakgönüllülüğündedir. Her şeyi daha iyi çözebileceği varsayımı altında yaratılmamıştır. Bunun yerine, birçok mevcut tek amaçlı teknolojiyi kucaklamış ve bunları akıcı, yaygın olarak uygulanabilir bir pakete getirmiştir.\nBu, her parçayı bunalmadan ayrı ayrı incelememize ve öğrenmemize olanak tanır. Bunu görselleştirmenin iyi bir yolu, bir \u0026lsquo;WebRTC Aracısı\u0026rsquo;nın gerçekten birçok farklı protokolün sadece bir orkestratörü olduğudur.\nWebRTC API\u0026rsquo;si nasıl çalışır? # Bu bölüm, WebRTC JavaScript API\u0026rsquo;sinin yukarıda açıklanan WebRTC protokolüne nasıl eşlendiğini özetler. WebRTC API\u0026rsquo;sinin kapsamlı bir demosu olması amaçlanmamıştır, daha çok her şeyin nasıl bir araya geldiğini gösteren zihinsel bir model oluşturmak içindir. Protokol veya API\u0026rsquo;ye aşina değilseniz endişelenmeyin. Bu, daha fazla öğrendikçe geri dönmek için eğlenceli bir bölüm olabilir!\nnew RTCPeerConnection # RTCPeerConnection, üst düzey \u0026ldquo;WebRTC Oturumu\u0026quot;dur. Yukarıda bahsedilen tüm protokolleri içerir. Alt sistemlerin hepsi tahsis edilir ancak henüz hiçbir şey olmaz.\naddTrack # addTrack yeni bir RTP akışı oluşturur. Bu akış için rastgele bir Synchronization Source (SSRC) oluşturulacaktır. Bu akış daha sonra createOffer tarafından oluşturulan Session Description içinde bir medya bölümü içinde yer alacaktır. Her addTrack çağrısı yeni bir SSRC ve medya bölümü oluşturacaktır.\nBir SRTP Oturumu kurulur kurulmaz, bu medya paketleri SRTP kullanılarak şifrelenmeye başlar ve ICE aracılığıyla gönderilir.\ncreateDataChannel # createDataChannel, SCTP ilişkisi yoksa yeni bir SCTP akışı oluşturur. SCTP varsayılan olarak etkin değildir. Yalnızca bir taraf veri kanalı talep ettiğinde başlatılır.\nBir DTLS Oturumu kurulur kurulmaz, SCTP ilişkisi DTLS ile şifrelenmiş paketleri ICE aracılığıyla göndermeye başlayacaktır.\ncreateOffer # createOffer, uzak eşle paylaşılacak yerel durumun bir Session Description\u0026rsquo;ını oluşturur.\ncreateOffer çağrısı yerel eş için hiçbir şeyi değiştirmez.\nsetLocalDescription # setLocalDescription, talep edilen değişiklikleri onaylar. addTrack, createDataChannel ve benzer çağrılar bu çağrıya kadar geçicidir. setLocalDescription, createOffer tarafından oluşturulan değerle çağrılır.\nGenellikle bu çağrıdan sonra, teklifi uzak eşe göndereceksiniz, o da bunu setRemoteDescription çağırmak için kullanacaktır.\nsetRemoteDescription # setRemoteDescription, yerel aracıyı uzak adayların durumu hakkında nasıl bilgilendirdiğimizdir. \u0026lsquo;Sinyalleme\u0026rsquo; eylemi JavaScript API\u0026rsquo;si ile bu şekilde yapılır.\nHer iki tarafta da setRemoteDescription çağrıldığında, WebRTC aracıları artık Eşten-Eşe (P2P) iletişim kurmaya başlamak için yeterli bilgiye sahiptir!\naddIceCandidate # addIceCandidate, bir WebRTC aracısının herhangi bir zamanda daha fazla uzak ICE Adayı eklemesine olanak tanır. Bu API, ICE Adayını doğrudan ICE alt sistemine gönderir ve daha büyük WebRTC bağlantısı üzerinde başka bir etkisi yoktur.\nontrack # ontrack, uzak eşten bir RTP paketi alındığında tetiklenen bir callback\u0026rsquo;tir. Gelen paketler, setRemoteDescription\u0026lsquo;a geçirilen Session Description\u0026rsquo;da beyan edilmiş olacaktır.\nWebRTC, SSRC\u0026rsquo;yi kullanır ve ilişkili MediaStream ve MediaStreamTrack\u0026lsquo;i arar ve bu detaylarla doldurulmuş bu callback\u0026rsquo;i tetikler.\noniceconnectionstatechange # oniceconnectionstatechange, ICE aracısının durumundaki değişikliği yansıtan bir callback\u0026rsquo;tir. Ağ bağlantısında bir değişiklik olduğunda bu şekilde bilgilendirilirsiniz.\nonconnectionstatechange # onconnectionstatechange, ICE aracısı ve DTLS aracısı durumunun bir kombinasyonudur. ICE ve DTLS\u0026rsquo;nin her ikisi de başarıyla tamamlandığında bilgilendirilmek için bunu izleyebilirsiniz.\n"},{"id":1,"href":"/tr/docs/02-signaling/","title":"Sinyalleşme","section":"Docs","content":" Sinyalleşme # WebRTC Sinyalleşme Nedir? # Bir WebRTC ajanı oluşturduğunuzda, diğer eş hakkında hiçbir şey bilmez. Kiminle bağlantı kuracağını veya ne göndereceklerini bilmez! Sinyalleşme, bir çağrıyı mümkün kılan ilk önyüklemedir. Bu değerler değiş tokuş edildikten sonra, WebRTC ajanları doğrudan birbirleriyle iletişim kurabilir.\nSinyalleşme mesajları sadece metindir. WebRTC ajanları bunların nasıl taşındığını umursamaz. Genellikle Websocket\u0026rsquo;ler aracılığıyla paylaşılırlar, ancak bu bir gereklilik değildir.\nWebRTC sinyalleşme nasıl çalışır? # WebRTC, Oturum Tanımlama Protokolü adlı mevcut bir protokol kullanır. Bu protokol aracılığıyla, iki WebRTC Ajanı bir bağlantı kurmak için gerekli tüm durumu paylaşacaktır. Protokolün kendisi okumak ve anlamak için basittir. Karmaşıklık, WebRTC\u0026rsquo;nin onunla doldurduğu tüm değerleri anlamaktan gelir.\nBu protokol WebRTC\u0026rsquo;ye özgü değildir. İlk olarak WebRTC hakkında konuşmadan Oturum Tanımlama Protokolünü öğreneceğiz. WebRTC gerçekten protokolün sadece bir alt kümesinden yararlanır, bu yüzden sadece ihtiyacımız olanı kapsayacağız. Protokolü anladıktan sonra, WebRTC\u0026rsquo;deki uygulamalı kullanımına geçeceğiz.\nOturum Tanımlama Protokolü (SDP) Nedir? # Oturum Tanımlama Protokolü RFC 8866\u0026lsquo;da tanımlanmıştır. Her değerden sonra yeni satır olan bir anahtar/değer protokolüdür. Bir INI dosyasına benzer hissettirecektir. Bir Oturum Tanımı sıfır veya daha fazla Medya Tanımı içerir. Zihinsel olarak bunu, bir Medya Tanımları dizisi içeren bir Oturum Tanımı olarak modelleyebilirsiniz.\nBir Medya Tanımı genellikle tek bir medya akışıyla eşlenir. Yani üç video akışı ve iki ses parçası olan bir çağrıyı tanımlamak istiyorsanız, beş Medya Tanımınız olurdu.\nSDP nasıl okunur # Bir Oturum Tanımındaki her satır tek bir karakterle başlayacaktır, bu sizin anahtarınızdır. Ardından eşittir işareti gelecektir. Bu eşittir işaretinden sonra gelen her şey değerdir. Değer tamamlandıktan sonra, yeni bir satırınız olacaktır.\nOturum Tanımlama Protokolü geçerli olan tüm anahtarları tanımlar. Protokolde tanımlandığı gibi anahtarlar için sadece harfleri kullanabilirsiniz. Bu anahtarların hepsi önemli anlamlara sahiptir ve daha sonra açıklanacaktır.\nBu Oturum Tanımı alıntısını ele alalım:\na=my-sdp-value a=second-value İki satırınız var. Her biri a anahtarıyla. İlk satırın değeri my-sdp-value, ikinci satırın değeri second-value.\nWebRTC sadece bazı SDP anahtarlarını kullanır # Oturum Tanımlama Protokolü tarafından tanımlanan tüm anahtar değerleri WebRTC tarafından kullanılmaz. Sadece RFC 8829\u0026lsquo;da tanımlanan JavaScript Oturum Kurma Protokolü (JSEP)\u0026rsquo;nde kullanılan anahtarlar önemlidir. Aşağıdaki yedi anahtar şu anda anlamanız gereken tek anahtarlardır:\nv - Sürüm, 0\u0026lsquo;a eşit olmalıdır. o - Kaynak, yeniden müzakereler için yararlı benzersiz bir ID içerir. s - Oturum Adı, -\u0026lsquo;ye eşit olmalıdır. t - Zamanlama, 0 0\u0026lsquo;a eşit olmalıdır. m - Medya Tanımı (m=\u0026lt;media\u0026gt; \u0026lt;port\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;fmt\u0026gt; ...), aşağıda ayrıntılı olarak açıklanmıştır. a - Öznitelik, serbest metin alanı. Bu WebRTC\u0026rsquo;de en yaygın satırdır. c - Bağlantı Verisi, IN IP4 0.0.0.0\u0026lsquo;a eşit olmalıdır. Oturum Tanımında Medya Tanımları # Bir Oturum Tanımı sınırsız sayıda Medya Tanımı içerebilir.\nBir Medya Tanımı tanımı, format listesi içerir. Bu formatlar RTP Yük Türleriyle eşlenir. Gerçek codec daha sonra Medya Tanımında rtpmap değerine sahip bir Öznitelik tarafından tanımlanır. RTP ve RTP Yük Türlerinin önemi daha sonra Medya bölümünde tartışılır. Her Medya Tanımı sınırsız sayıda öznitelik içerebilir.\nBu Oturum Tanımı alıntısını örnek olarak ele alalım:\nv=0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4000 RTP/AVP 96 a=rtpmap:96 VP8/90000 a=my-sdp-value İki Medya Tanımınız var, biri fmt 111 olan ses türünde ve biri format 96 olan video türünde. İlk Medya Tanımının sadece bir özniteliği var. Bu öznitelik Yük Türü 111\u0026lsquo;i Opus\u0026rsquo;a eşler. İkinci Medya Tanımının iki özniteliği var. İlk öznitelik Yük Türü 96\u0026lsquo;yı VP8 olarak eşler ve ikinci öznitelik sadece my-sdp-value.\nTam Örnek # Aşağıdaki, bahsettiğimiz tüm kavramları bir araya getirir. Bunlar WebRTC\u0026rsquo;nin kullandığı Oturum Tanımlama Protokolünün tüm özellikleridir. Bunu okuyabiliyorsanız, herhangi bir WebRTC Oturum Tanımını okuyabilirsiniz!\nv=0 o=- 0 0 IN IP4 127.0.0.1 s=- c=IN IP4 127.0.0.1 t=0 0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4002 RTP/AVP 96 a=rtpmap:96 VP8/90000 v, o, s, c, t tanımlandı, ancak WebRTC oturumunu etkilemezler. İki Medya Tanımınız var. Biri audio türünde ve biri video türünde. Her birinin bir özniteliği var. Bu öznitelik, \u0026ldquo;Medya İletişimi\u0026rdquo; bölümünde tartışılan RTP pipeline\u0026rsquo;ının detaylarını yapılandırır. Oturum Tanımlama Protokolü ve WebRTC nasıl birlikte çalışır # Bulmacının bir sonraki parçası WebRTC\u0026rsquo;nin Oturum Tanımlama Protokolünü nasıl kullandığını anlamaktır.\nTeklifler ve Cevaplar Nedir? # WebRTC bir teklif/cevap modeli kullanır. Bunun anlamı, bir WebRTC Ajanının bir çağrı başlatmak için \u0026ldquo;Teklif\u0026rdquo; yapması ve diğer WebRTC Ajanlarının sunulanı kabul etmeye istekliyse \u0026ldquo;Cevap\u0026rdquo; vermesidir.\nBu, cevaplayıcıya Medya Tanımlarında desteklenmeyen codec\u0026rsquo;leri reddetme şansı verir. İki eşin hangi formatları değiş tokuş etmeye istekli olduklarını anlayabilmesinin yolu budur.\nTransceiverlar gönderme ve alma içindir # Transceiverlar API\u0026rsquo;de göreceğiniz WebRTC\u0026rsquo;ye özgü bir kavramdır. Yaptığı şey \u0026ldquo;Medya Tanımını\u0026rdquo; JavaScript API\u0026rsquo;sine açmaktır. Her Medya Tanımı bir Transceiver olur. Her Transceiver oluşturduğunuzda yerel Oturum Tanımına yeni bir Medya Tanımı eklenir.\nWebRTC\u0026rsquo;deki her Medya Tanımının bir yön özniteliği olacaktır. Bu, bir WebRTC Ajanının \u0026ldquo;Size bu codec\u0026rsquo;i göndereceğim, ama geri hiçbir şey kabul etmeye istekli değilim\u0026rdquo; demesine izin verir. Dört geçerli değer vardır:\nsend recv sendrecv inactive WebRTC tarafından kullanılan SDP Değerleri # Bu, bir WebRTC Ajanından gelen Oturum Tanımında göreceğiniz bazı yaygın özniteliklerin listesidir. Bu değerlerin çoğu henüz tartışmadığımız alt sistemleri kontrol eder.\ngroup:BUNDLE # Bundling, birden fazla trafik türünü tek bir bağlantı üzerinden çalıştırma eylemidir. Bazı WebRTC uygulamaları medya akışı başına özel bağlantı kullanır. Bundling tercih edilmelidir.\nfingerprint:sha-256 # Bu, bir eşin DTLS için kullandığı sertifikanın hash\u0026rsquo;idir. DTLS el sıkışması tamamlandıktan sonra, beklediğiniz kişiyle iletişim kurduğunuzu onaylamak için bunu gerçek sertifikayla karşılaştırırsınız.\nsetup: # Bu, DTLS Ajanı davranışını kontrol eder. ICE bağlandıktan sonra istemci veya sunucu olarak çalışıp çalışmayacağını belirler. Olası değerler:\nsetup:active - DTLS İstemcisi olarak çalış. setup:passive - DTLS Sunucusu olarak çalış. setup:actpass - Diğer WebRTC Ajanından seçmesini iste. mid # \u0026ldquo;mid\u0026rdquo; özniteliği, oturum tanımı içindeki medya akışlarını tanımlamak için kullanılır.\nice-ufrag # Bu, ICE Ajanı için kullanıcı parçası değeridir. ICE Trafiğinin kimlik doğrulaması için kullanılır.\nice-pwd # Bu, ICE Ajanı için paroladır. ICE Trafiğinin kimlik doğrulaması için kullanılır.\nrtpmap # Bu değer, belirli bir codec\u0026rsquo;i RTP Yük Türüne eşlemek için kullanılır. Yük türleri statik değildir, bu yüzden her çağrı için teklif veren her codec için yük türlerini belirler.\nfmtp # Bir Yük Türü için ek değerleri tanımlar. Bu, belirli bir video profili veya kodlayıcı ayarını iletmek için yararlıdır.\ncandidate # Bu, ICE Ajanından gelen bir ICE Adayıdır. Bu, WebRTC Ajanının mevcut olduğu olası bir adrestir. Bunlar bir sonraki bölümde tam olarak açıklanmıştır.\nssrc # Bir Senkronizasyon Kaynağı (SSRC) tek bir medya akışı parçasını tanımlar.\nlabel bu bireysel akış için ID\u0026rsquo;dir. mslabel içinde birden fazla akış olabilen bir konteyner için ID\u0026rsquo;dir.\nWebRTC Oturum Tanımı Örneği # Aşağıdaki, bir WebRTC İstemcisi tarafından oluşturulan tam bir Oturum Tanımıdır:\nv=0 o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0 s=- t=0 0 a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E a=group:BUNDLE 0 1 m=audio 9 UDP/TLS/RTP/SAVPF 111 c=IN IP4 0.0.0.0 a=setup:active a=mid:0 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:111 opus/48000/2 a=fmtp:111 minptime=10;useinbandfec=1 a=ssrc:350842737 cname:yvKPspsHcYcwGFTw a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw a=ssrc:350842737 label:DfQnKjQQuwceLFdV a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates m=video 9 UDP/TLS/RTP/SAVPF 96 c=IN IP4 0.0.0.0 a=setup:active a=mid:1 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:96 VP8/90000 a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=sendrecv Bu mesajdan bildiklerimiz:\nİki medya bölümümüz var, biri ses ve biri video. Her ikisi de sendrecv transceiverları. İki akış alıyoruz ve ikisini geri gönderebiliriz. ICE Adayları ve Kimlik Doğrulama detaylarımız var, böylece bağlanmaya çalışabiliriz. Sertifika parmak izimiz var, böylece güvenli bir çağrı yapabiliriz. İleri Konular # Bu kitabın sonraki sürümlerinde, aşağıdaki konular da ele alınacaktır:\nYeniden müzakere Simulcast "},{"id":2,"href":"/tr/docs/03-connecting/","title":"Bağlanma","section":"Docs","content":" Bağlanma # WebRTC neden bağlanma için özel bir alt sisteme ihtiyaç duyar? # Bugün dağıtılan çoğu uygulama istemci/sunucu bağlantıları kurar. Bir istemci/sunucu bağlantısı, sunucunun kararlı, iyi bilinen bir aktarım adresine sahip olmasını gerektirir. Bir istemci sunucuyla iletişime geçer ve sunucu yanıt verir.\nWebRTC bir istemci/sunucu modeli kullanmaz, eşten-eşe (P2P) bağlantılar kurar. P2P bağlantısında, bağlantı oluşturma görevi her iki eşe eşit olarak dağıtılır. Bunun nedeni, WebRTC\u0026rsquo;de bir aktarım adresinin (IP ve port) varsayılamayacak olması ve hatta oturum sırasında değişebilmesidir. WebRTC tüm toplayabileceği bilgileri toplayacak ve iki WebRTC Ajanı arasında çift yönlü iletişim sağlamak için büyük çaba gösterecektir.\nAncak eşten-eşe bağlantı kurmak zor olabilir. Bu ajanlar doğrudan bağlantısı olmayan farklı ağlarda olabilir. Doğrudan bağlantının mevcut olduğu durumlarda bile başka sorunlarınız olabilir. Bazı durumlarda, istemcileriniz aynı ağ protokollerini konuşmaz (UDP \u0026lt;-\u0026gt; TCP) veya belki farklı IP Sürümleri (IPv4 \u0026lt;-\u0026gt; IPv6) kullanır.\nP2P bağlantı kurmada bu zorluklara rağmen, WebRTC\u0026rsquo;nin sunduğu aşağıdaki özellikler nedeniyle geleneksel İstemci/Sunucu teknolojisine göre avantajlar elde edersiniz.\nAzaltılmış Bant Genişliği Maliyetleri # Medya iletişimi doğrudan eşler arasında gerçekleştiği için medyayı aktarmak için ayrı bir sunucu için ödeme yapmanız veya barındırmanız gerekmez.\nDaha Düşük Gecikme # İletişim doğrudan olduğunda daha hızlıdır! Bir kullanıcı her şeyi sunucunuzdan geçirmek zorunda kaldığında, aktarımları yavaşlatır.\nGüvenli Uçtan Uca İletişim # Doğrudan İletişim daha güvenlidir. Kullanıcılar verileri sunucunuzdan yönlendirmediği için, şifresini çözmeyeceğinize güvenmeleri bile gerekmez.\nNasıl çalışır? # Yukarıda açıklanan işleme Etkileşimli Bağlantı Kurma (ICE) denir. WebRTC\u0026rsquo;den önce var olan başka bir protokol.\nICE, iki ICE Ajanı arasında iletişim kurmanın en iyi yolunu bulmaya çalışan bir protokoldür. Her ICE Ajanı ulaşılabilir olduğu yolları yayınlar, bunlar adaylar olarak bilinir. Bir aday, esasen ajanın diğer eşin ulaşabileceğine inandığı aktarım adresidir. ICE daha sonra adayların en iyi eşleşmesini belirler.\nGerçek ICE süreci bu bölümün ilerleyen kısımlarında daha ayrıntılı olarak açıklanmıştır. ICE\u0026rsquo;nin neden var olduğunu anlamak için, hangi ağ davranışlarını aştığımızı anlamak yararlıdır.\nGerçek dünya ağ kısıtlamaları # ICE tamamen gerçek dünya ağlarının kısıtlamalarını aşmakla ilgilidir. Çözümü keşfetmeden önce, gerçek problemleri konuşalım.\nAynı ağda değil # Çoğu zaman diğer WebRTC Ajanı aynı ağda bile olmayacaktır. Tipik bir çağrı genellikle doğrudan bağlantısı olmayan farklı ağlardaki iki WebRTC Ajanı arasındadır.\nAşağıda genel internet üzerinden bağlanan iki farklı ağın grafiği bulunmaktadır. Her ağda iki host bulunmaktadır.\nAynı ağdaki hostlar için bağlantı kurmak çok kolaydır. 192.168.0.1 -\u0026gt; 192.168.0.2 arasındaki iletişim kolay yapılabilir! Bu iki host herhangi bir dış yardım olmadan birbirine bağlanabilir.\nAncak, Router B kullanan bir host\u0026rsquo;un Router A\u0026lsquo;nın arkasındaki hiçbir şeye doğrudan erişim yolu yoktur. Router A\u0026lsquo;nın arkasındaki 192.168.0.1 ile Router B\u0026lsquo;nin arkasındaki aynı IP arasındaki farkı nasıl anlarsınız? Bunlar özel IP\u0026rsquo;lerdir! Router B kullanan bir host doğrudan Router A\u0026lsquo;ya trafik gönderebilir, ancak istek orada sonlanır. Router A mesajı hangi host\u0026rsquo;a yönlendirmesi gerektiğini nasıl bilir?\nProtokol Kısıtlamaları # Bazı ağlar UDP trafiğine hiç izin vermez, belki de TCP\u0026rsquo;ye izin vermezler. Bazı ağlarda çok düşük MTU (Maksimum İletim Birimi) olabilir. Ağ yöneticilerinin değiştirebileceği ve iletişimi zorlaştırabilecek birçok değişken vardır.\nFirewall/IDS Kuralları # Bir diğeri \u0026ldquo;Derin Paket İncelemesi\u0026rdquo; ve diğer akıllı filtrelemelerdir. Bazı ağ yöneticileri her paketi işlemeye çalışan yazılım çalıştırır. Çoğu zaman bu yazılım WebRTC\u0026rsquo;yi anlamaz, bu yüzden ne yapacağını bilmediği için onu bloklar, örneğin WebRTC paketlerini beyaz listede olmayan rastgele bir port üzerindeki şüpheli UDP paketleri olarak değerlendirir.\nNAT Mapping # NAT (Ağ Adresi Çevirisi) eşlemesi WebRTC\u0026rsquo;nin bağlantısını mümkün kılan sihirdir. WebRTC\u0026rsquo;nin tamamen farklı alt ağlardaki iki eşin iletişim kurmasına nasıl izin verdiği, yukarıdaki \u0026ldquo;aynı ağda değil\u0026rdquo; problemini ele aldığı budur. Yeni zorluklar yaratsa da, NAT eşlemesinin ilk etapta nasıl çalıştığını açıklayalım.\nRelay, proxy veya sunucu kullanmaz. Yine Ajan 1 ve Ajan 2\u0026lsquo;miz var ve farklı ağlardalar. Ancak, trafik tamamen akıyor. Görselleştirildiğinde şöyle görünür:\nBu iletişimi gerçekleştirmek için bir NAT eşlemesi kurarsınız. Ajan 1, Ajan 2 ile WebRTC bağlantısı kurmak için port 7000\u0026rsquo;i kullanır. Bu, 192.168.0.1:7000\u0026lsquo;i 5.0.0.1:7000\u0026lsquo;e bağlama oluşturur. Bu daha sonra Ajan 2\u0026rsquo;nin 5.0.0.1:7000\u0026lsquo;e paketler göndererek Ajan 1\u0026rsquo;e ulaşmasına izin verir. Bu örnekteki gibi NAT eşlemesi oluşturmak, router\u0026rsquo;ınızda port yönlendirme yapmanın otomatik versiyonu gibidir.\nNAT eşlemesinin dezavantajı, tek bir eşleme formu olmaması (örneğin statik port yönlendirme) ve davranışın ağlar arasında tutarsız olmasıdır. ISP\u0026rsquo;ler ve donanım üreticileri bunu farklı şekillerde yapabilir. Bazı durumlarda, ağ yöneticileri bunu devre dışı bile bırakabilir.\nİyi haber, davranış aralığının tam olarak anlaşılması ve gözlemlenebilir olmasıdır, bu yüzden bir ICE Ajanı bir NAT eşlemesi oluşturduğunu ve eşlemenin özelliklerini doğrulayabilir.\nBu davranışları açıklayan belge RFC 4787\u0026lsquo;dir.\nEşleme Oluşturma # Eşleme oluşturmak en kolay kısımdır. Ağınızın dışındaki bir adrese paket gönderdiğinizde, bir eşleme oluşturulur! NAT eşlemesi, NAT\u0026rsquo;ınız tarafından tahsis edilen sadece geçici bir genel IP ve port\u0026rsquo;tur. Giden mesaj, kaynak adresinin yeni eşleme adresi tarafından verilmesi için yeniden yazılacaktır. Eşlemeye bir mesaj gönderilirse, onu oluşturan NAT içindeki host\u0026rsquo;a otomatik olarak geri yönlendirilecektir. Eşlemeler etrafındaki ayrıntılar karmaşık hale geldiği yerdir.\nEşleme Oluşturma Davranışları # Eşleme oluşturma üç farklı kategoriye ayrılır:\nEndpoint-Independent Mapping # NAT içindeki her gönderen için bir eşleme oluşturulur. İki farklı uzak adrese iki paket gönderirseniz, NAT eşlemesi yeniden kullanılacaktır. Her iki uzak host da aynı kaynak IP ve port\u0026rsquo;u görecektir. Uzak hostlar yanıt verirlerse, aynı yerel dinleyiciye geri gönderilecektir.\nBu en iyi durum senaryosudur. Bir çağrının çalışması için en az bir tarafın bu türde olması GEREKİR.\nAddress Dependent Mapping # Yeni bir adrese paket gönderdiğiniz her seferde yeni bir eşleme oluşturulur. İki farklı host\u0026rsquo;a iki paket gönderirseniz, iki eşleme oluşturulacaktır. Aynı uzak host\u0026rsquo;a ancak farklı hedef portlara iki paket gönderirseniz, yeni bir eşleme oluşturulmayacaktır.\nAddress and Port Dependent Mapping # Uzak IP veya port farklıysa yeni bir eşleme oluşturulur. Aynı uzak host\u0026rsquo;a ancak farklı hedef portlara iki paket gönderirseniz, yeni bir eşleme oluşturulacaktır.\nEşleme Filtreleme Davranışları # Eşleme filtreleme, eşlemeyi kimlerin kullanmasına izin verildiği etrafındaki kurallardır. Benzer üç sınıflandırmaya ayrılırlar:\nEndpoint-Independent Filtering # Herkes eşlemeyi kullanabilir. Eşlemeyi birden fazla diğer eşle paylaşabilirsiniz ve hepsi ona trafik gönderebilir.\nAddress Dependent Filtering # Sadece eşlemenin oluşturulduğu host eşlemeyi kullanabilir. A host\u0026rsquo;una bir paket gönderirseniz sadece aynı host\u0026rsquo;tan yanıt alabilirsiniz. B host\u0026rsquo;u o eşlemeye paket göndermeye çalışırsa, görmezden gelinecektir.\nAddress and Port Dependent Filtering # Sadece eşlemenin oluşturulduğu host ve port o eşlemeyi kullanabilir. A:5000\u0026lsquo;e bir paket gönderirseniz sadece aynı host ve port\u0026rsquo;tan yanıt alabilirsiniz. A:5001 o eşlemeye paket göndermeye çalışırsa, görmezden gelinecektir.\nEşleme Yenileme # Bir eşleme 5 dakika kullanılmazsa yok edilmesi önerilir. Bu tamamen ISP veya donanım üreticisine bağlıdır.\nSTUN # STUN (NAT için Oturum Geçiş Yardımcı Programları) sadece NAT\u0026rsquo;larla çalışmak için oluşturulmuş bir protokoldür. Bu, WebRTC\u0026rsquo;den (ve ICE\u0026rsquo;den!) önce var olan başka bir teknolojidir. RFC 8489 tarafından tanımlanır, bu aynı zamanda STUN paket yapısını da tanımlar. STUN protokolü ayrıca ICE/TURN tarafından da kullanılır.\nSTUN, NAT Eşlemelerinin programatik olarak oluşturulmasına izin verdiği için yararlıdır. STUN\u0026rsquo;dan önce, bir NAT eşlemesi oluşturabiliyorduk, ancak bunun IP ve port\u0026rsquo;unun ne olduğu hakkında hiçbir fikrimiz yoktu! STUN size sadece eşleme oluşturma yeteneği vermekle kalmaz, aynı zamanda başkalarıyla paylaşabilmeniz için ayrıntıları da verir, böylece az önce oluşturduğunuz eşleme aracılığıyla size trafik geri gönderebilirler.\nSTUN\u0026rsquo;un temel bir açıklamasıyla başlayalım. Daha sonra, TURN ve ICE kullanımını genişleteceğiz. Şimdilik, sadece eşleme oluşturmak için İstek/Yanıt akışını açıklayacağız. Sonra başkalarıyla paylaşmak için ayrıntılarını nasıl alacağımızı konuşacağız. Bu, WebRTC PeerConnection için ICE URL\u0026rsquo;lerinizde bir stun: sunucunuz olduğunda gerçekleşen işlemdir. Özetle, STUN bir NAT arkasındaki endpoint\u0026rsquo;in NAT dışındaki bir STUN sunucusundan gözlemlediğini rapor etmesini isteyerek hangi eşlemenin oluşturulduğunu anlamasına yardımcı olur.\nProtokol Yapısı # Her STUN paketi aşağıdaki yapıya sahiptir:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN Message Type # Her STUN paketinin bir türü vardır. Şimdilik, sadece aşağıdakilerle ilgileniyoruz:\nBinding Request - 0x0001 Binding Response - 0x0101 NAT eşlemesi oluşturmak için bir Binding Request yaparız. Sonra sunucu Binding Response ile yanıt verir.\nMessage Length # Bu, Data bölümünün ne kadar uzun olduğudur. Bu bölüm Message Type tarafından tanımlanan rastgele veriler içerir.\nMagic Cookie # Ağ byte sırasında sabit değer 0x2112A442, STUN trafiğini diğer protokollerden ayırt etmeye yardımcı olur.\nTransaction ID # Bir istek/yanıtı benzersiz şekilde tanımlayan 96-bit tanımlayıcı. Bu, isteklerinizi ve yanıtlarınızı eşleştirmenize yardımcı olur.\nData # Data bir STUN öznitelikleri listesi içerecektir. Bir STUN Özniteliği aşağıdaki yapıya sahiptir:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Value (variable) .... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN Binding Request hiçbir öznitelik kullanmaz. Bu, STUN Binding Request\u0026lsquo;in sadece başlığı içerdiği anlamına gelir.\nSTUN Binding Response bir XOR-MAPPED-ADDRESS (0x0020) kullanır. Bu öznitelik bir IP ve port içerir. Bu, oluşturulan NAT eşlemesinin IP ve port\u0026rsquo;udur!\nNAT Eşlemesi Oluşturma # STUN kullanarak NAT eşlemesi oluşturmak sadece bir istek göndermeyi gerektirir! STUN Sunucusuna bir STUN Binding Request gönderirsiniz. STUN Sunucusu daha sonra STUN Binding Response ile yanıt verir. Bu STUN Binding Response Mapped Address içerecektir. Mapped Address, STUN Sunucusunun sizi nasıl gördüğüdür ve sizin NAT eşlemenizdir. Mapped Address, birinin size paketler göndermesini istiyorsanız paylaşacağınız şeydir.\nİnsanlar Mapped Address\u0026lsquo;i aynı zamanda sizin Public IP\u0026lsquo;niz veya Server Reflexive Candidate\u0026lsquo;ınız olarak da adlandırırlar.\nNAT Türünü Belirleme # Ne yazık ki, Mapped Address tüm durumlarda yararlı olmayabilir. Address Dependent ise, sadece STUN sunucusu size geri trafik gönderebilir. Bunu paylaştıysanız ve başka bir eş mesaj göndermeye çalıştıysa, düşürüleceklerdir. Bu, başkalarıyla iletişim kurmak için işe yaramaz hale getirir. Address Dependent durumunun aslında çözülebilir olduğunu görebilirsiniz, eğer STUN sunucusunu çalıştıran host aynı zamanda sizin için paketleri eşe yönlendirebiliyorsa! Bu bizi aşağıda TURN kullanarak çözüme götürür.\nRFC 5780 NAT Türünüzü belirlemek için bir test çalıştırma yöntemi tanımlar. Bu yararlıdır çünkü doğrudan bağlantının mümkün olup olmadığını önceden bilirsiniz.\nTURN # TURN (NAT etrafında Relay\u0026rsquo;ler Kullanarak Geçiş) RFC 8656\u0026lsquo;da tanımlanır ve doğrudan bağlantının mümkün olmadığı durumlarda çözümdür. Bu, uyumsuz iki NAT Türünüz olması veya belki aynı protokolü konuşamıyor olmanız nedeniyle olabilir! TURN ayrıca gizlilik amaçları için de kullanılabilir. Tüm iletişiminizi TURN üzerinden çalıştırarak istemcinin gerçek adresini gizlersiniz.\nTURN özel bir sunucu kullanır. Bu sunucu bir istemci için proxy görevi görür. İstemci bir TURN Sunucusuna bağlanır ve bir Allocation oluşturur. Allocation oluşturarak, istemci istemciye geri trafik göndermek için kullanılabilecek geçici bir IP/Port/Protokol alır. Bu yeni dinleyici Relayed Transport Address olarak bilinir. Bunu yönlendirme adresi olarak düşünün, başkalarının TURN üzerinden size trafik gönderebilmesi için bunu dağıtırsınız! Relay Transport Address\u0026lsquo;i verdiğiniz her eş için, sizinle iletişime izin vermek için yeni bir Permission oluşturmalısınız.\nTURN üzerinden giden trafiği gönderdiğinizde, Relayed Transport Address üzerinden gönderilir. Uzak bir eş trafik aldığında, TURN Sunucusundan geldiğini görür.\nTURN Yaşam Döngüsü # Aşağıda TURN allocation oluşturmak isteyen bir istemcinin yapması gereken her şey bulunmaktadır. TURN kullanan biriyle iletişim kurmak hiçbir değişiklik gerektirmez. Diğer eş bir IP ve port alır ve herhangi bir diğer host gibi onunla iletişim kurar.\nAllocations # Allocation\u0026rsquo;lar TURN\u0026rsquo;ün kalbindedir. Bir allocation temel olarak bir \u0026ldquo;TURN Oturumu\u0026quot;dur. TURN allocation oluşturmak için TURN Server Transport Address (genellikle port 3478) ile iletişim kurarsınız.\nAllocation oluştururken, aşağıdakileri sağlamanız gerekir:\nKullanıcı Adı/Şifre - TURN allocation\u0026rsquo;ları oluşturmak kimlik doğrulaması gerektirir. Allocation Transport - Sunucu (Relayed Transport Address) ve eşler arasındaki aktarım protokolü, UDP veya TCP olabilir. Even-Port - Birden fazla allocation için ardışık portlar isteyebilirsiniz, WebRTC için ilgili değil. İstek başarılı olursa, Data bölümünde aşağıdaki STUN Öznitelikleri ile TURN Sunucusundan bir yanıt alırsınız:\nXOR-MAPPED-ADDRESS - TURN Client\u0026lsquo;ın Mapped Address\u0026lsquo;i. Birisi Relayed Transport Address\u0026lsquo;e veri gönderdiğinde, buraya yönlendirilir. RELAYED-ADDRESS - Bu, diğer istemcilere verdiğiniz adrestir. Birisi bu adrese bir paket gönderirse, TURN istemcisine aktarılır. LIFETIME - Bu TURN Allocation\u0026rsquo;ın ne kadar süre sonra yok edildiği. Refresh isteği göndererek yaşam süresini uzatabilirsiniz. Permissions # Uzak bir host, onlar için bir permission oluşturana kadar Relayed Transport Address\u0026lsquo;inize gönderemez. Permission oluşturduğunuzda, TURN sunucusuna bu IP ve port\u0026rsquo;un gelen trafiği göndermeye izinli olduğunu söylüyorsunuz.\nUzak host\u0026rsquo;un size TURN sunucusuna göründüğü şekliyle IP ve port\u0026rsquo;u vermesi gerekir. Bu, TURN Sunucusuna bir STUN Binding Request göndermesi gerektiği anlamına gelir. Yaygın bir hata durumu, uzak host\u0026rsquo;un farklı bir sunucuya STUN Binding Request göndermesidir. Daha sonra sizden bu IP için permission oluşturmanızı isteyeceklerdir.\nDiyelim ki Address Dependent Mapping arkasındaki bir host için permission oluşturmak istiyorsunuz. Farklı bir TURN sunucusundan Mapped Address üretirseniz, tüm gelen trafik düşürülecektir. Farklı bir host ile her iletişim kurduklarında yeni bir eşleme oluşturur. Permission\u0026rsquo;lar yenilenmezlerse 5 dakika sonra sona erer.\nSendIndication/ChannelData # Bu iki mesaj TURN Client\u0026rsquo;ın uzak bir eşe mesaj göndermesi içindir.\nSendIndication bağımsız bir mesajdır. İçinde göndermek istediğiniz veri ve kime göndermek istediğiniz vardır. Uzak bir eşe çok sayıda mesaj gönderiyorsanız bu savurgan olur. 1.000 mesaj gönderirseniz IP Adreslerini 1.000 kez tekrar edeceksiniz!\nChannelData veri göndermenize izin verir, ancak IP Adresini tekrar etmez. Bir IP ve port ile Channel oluşturursunuz. Daha sonra ChannelId ile gönderirsiniz ve IP ve port sunucu tarafında doldurulacaktır. Çok sayıda mesaj gönderiyorsanız bu daha iyi seçimdir.\nRefreshing # Allocation\u0026rsquo;lar kendilerini otomatik olarak yok ederler. TURN Client bunları allocation oluştururken verilen LIFETIME\u0026lsquo;dan daha önce yenilemelidir.\nTURN Kullanımı # TURN Kullanımı iki formda var olur. Genellikle, bir eşiniz \u0026ldquo;TURN Client\u0026rdquo; görevi görür ve diğer taraf doğrudan iletişim kurar. Bazı durumlarda her iki tarafta da TURN kullanımınız olabilir, örneğin her iki istemci de UDP\u0026rsquo;yi bloke eden ağlarda olduğu ve bu nedenle ilgili TURN sunucularına bağlantı TCP üzerinden gerçekleştiği için.\nBu diyagramlar bunun nasıl görüneceğini açıklamaya yardımcı olur.\nİletişim için Bir TURN Allocation # İletişim için İki TURN Allocation # ICE # ICE (Etkileşimli Bağlantı Kurma) WebRTC\u0026rsquo;nin iki Ajanı nasıl bağladığıdır. RFC 8445\u0026rsquo;te tanımlanır, bu WebRTC\u0026rsquo;den önce var olan başka bir teknolojidir! ICE bağlantı kurmak için bir protokoldür. İki eş arasındaki tüm olası yolları belirler ve sonra bağlı kaldığınızı garanti eder.\nBu yollar Candidate Pairs olarak bilinir, bu yerel ve uzak aktarım adresinin eşleştirilmesidir. STUN ve TURN\u0026rsquo;ün ICE ile devreye girdiği yer burasıdır. Bu adresler yerel IP Adresiniz artı port, NAT mapping veya Relayed Transport Address olabilir. Her taraf kullanmak istedikleri tüm adresleri toplar, bunları değiş tokuş eder ve sonra bağlanmaya çalışır!\nİki ICE Ajanı bağlantı kurmak için ICE ping paketleri (veya resmi olarak connectivity checks adı verilen) kullanarak iletişim kurar. Bağlantı kurulduktan sonra, istedikleri herhangi bir veriyi gönderebilirler. Normal socket kullanmak gibi olacaktır. Bu kontroller STUN protokolünü kullanır.\nICE Ajanı Oluşturma # Bir ICE Ajanı ya Controlling ya da Controlled\u0026lsquo;dır. Controlling Ajanı seçilen Candidate Pair\u0026lsquo;i belirleyen ajandır. Genellikle, teklifi gönderen eş controlling taraftır.\nHer tarafın bir user fragment ve password\u0026lsquo;ü olmalıdır. Bu iki değer connectivity check\u0026rsquo;ler başlamadan önce değiş tokuş edilmelidir. user fragment düz metin olarak gönderilir ve birden fazla ICE Oturumunu demux etmek için yararlıdır. password bir MESSAGE-INTEGRITY özniteliği oluşturmak için kullanılır. Her STUN paketinin sonunda, password\u0026lsquo;ü anahtar olarak kullanan tüm paketin hash\u0026rsquo;i olan bir öznitelik vardır. Bu paketi doğrulamak ve kurcalanmadığından emin olmak için kullanılır.\nWebRTC için, tüm bu değerler önceki bölümde açıklandığı gibi Session Description aracılığıyla dağıtılır.\nCandidate Gathering # Şimdi ulaşılabilir olduğumuz tüm olası adresleri toplamamız gerekiyor. Bu adresler candidate olarak bilinir.\nHost # Host candidate doğrudan yerel arayüzde dinler. Bu UDP veya TCP olabilir.\nmDNS # mDNS candidate host candidate\u0026rsquo;e benzer, ancak IP adresi gizlenir. Diğer tarafa IP adresinizi bildirmek yerine, hostname olarak onlara bir UUID verirsiniz. Daha sonra multicast dinleyici kurarsınız ve yayınladığınız UUID\u0026rsquo;yi isteyen olursa yanıt verirsiniz.\nAjan ile aynı ağdaysanız, Multicast aracılığıyla birbirinizi bulabilirsiniz. Aynı ağda değilseniz, bağlanamayacaksınız (ağ yöneticisi ağı Multicast paketlerinin geçişine izin verecek şekilde açıkça yapılandırmadıkça).\nBu gizlilik amacıyla yararlıdır. Bir kullanıcı Host candidate ile WebRTC aracılığıyla yerel IP adresinizi öğrenebilir (size bağlanmaya çalışmadan bile), ancak mDNS candidate ile şimdi sadece rastgele bir UUID alırlar.\nServer Reflexive # Server Reflexive candidate, STUN Sunucusuna STUN Binding Request yaparak oluşturulur.\nSTUN Binding Response aldığınızda, XOR-MAPPED-ADDRESS sizin Server Reflexive Candidate\u0026rsquo;ınızdır.\nPeer Reflexive # Peer Reflexive candidate, uzak eş isteğinizi daha önce eşe bilinmeyen bir adresten aldığında oluşturulur. Alındığında, eş söz konusu adresi size geri bildirir (yansıtır). Eş isteğin sizin tarafınızdan gönderildiğini ve başka biri tarafından gönderilmediğini bilir çünkü ICE kimlik doğrulamalı bir protokoldür.\nBu yaygın olarak bir Host Candidate\u0026lsquo;in farklı alt ağda olan Server Reflexive Candidate ile iletişim kurması durumunda gerçekleşir ve bu yeni bir NAT mapping oluşturulmasına neden olur. Connectivity check\u0026rsquo;lerin aslında STUN paketleri olduğunu söylediğimizi hatırlayın? STUN yanıtının formatı doğal olarak eşin peer-reflexive adresi geri bildirmesine izin verir.\nRelay # Relay Candidate, TURN Sunucusu kullanarak oluşturulur.\nTURN Sunucusu ile ilk handshake\u0026rsquo;den sonra size bir RELAYED-ADDRESS verilir, bu sizin Relay Candidate\u0026rsquo;ınızdır.\nConnectivity Checks # Şimdi uzak ajanın user fragment, password ve candidate\u0026rsquo;larını biliyoruz. Artık bağlanmaya çalışabiliriz! Her candidate birbiriyle eşleştirilir. Her tarafta 3 candidate\u0026rsquo;ınız varsa, şimdi 9 candidate çiftiniz vardır.\nGörsel olarak şöyle görünür:\nCandidate Selection # Controlling ve Controlled Agent\u0026rsquo;lar her çift üzerinde trafik göndermeye başlar. Bu, bir Ajanın Address Dependent Mapping arkasında olması durumunda gereklidir, bu Peer Reflexive Candidate oluşturulmasına neden olacaktır.\nAğ trafiği gören her Candidate Pair daha sonra Valid Candidate çiftine terfi edilir. Controlling Agent daha sonra bir Valid Candidate çiftini alır ve onu aday gösterir. Bu Nominated Pair olur. Controlling ve Controlled Agent daha sonra bir tur daha çift yönlü iletişim denemeye çalışır. Bu başarılı olursa, Nominated Pair Selected Candidate Pair olur! Bu çift daha sonra oturumun geri kalanı için kullanılır.\nRestarts # Selected Candidate Pair herhangi bir nedenle çalışmayı durdurursa (NAT mapping süresi dolar, TURN Sunucusu çöker) ICE Ajanı Failed durumuna geçer. Her iki ajan da yeniden başlatılabilir ve tüm süreci baştan yapacaktır.\n"},{"id":3,"href":"/tr/docs/04-securing/","title":"Güvenlik","section":"Docs","content":" Güvenlik # WebRTC hangi güvenlik özelliklerine sahip? # Her WebRTC bağlantısı kimlik doğrulamalı ve şifrelidir. Üçüncü bir tarafın gönderdiğiniz şeyleri göremeyeceğinden veya sahte mesajlar ekleyemeyeceğinden emin olabilirsiniz. Ayrıca Oturum Tanımını oluşturan WebRTC Ajanının iletişim kurduğunuz kişi olduğundan da emin olabilirsiniz.\nBu mesajlarla kimsenin oynamaması çok önemlidir. Üçüncü bir tarafın geçiş sırasında Oturum Tanımını okuması sorun değil. Ancak, WebRTC\u0026rsquo;nin değiştirilmesine karşı koruması yoktur. Bir saldırgan, ICE Adaylarını değiştirip Sertifika Parmak İzini güncelleyerek size ortadaki adam saldırısı gerçekleştirebilir.\nNasıl çalışır? # WebRTC, önceden var olan iki protokol kullanır: Datagram Aktarım Katmanı Güvenliği (DTLS) ve Güvenli Gerçek zamanlı Aktarım Protokolü (SRTP).\nDTLS, bir oturum müzakere etmenizi ve ardından iki eş arasında güvenli bir şekilde veri alışverişi yapmanızı sağlar. HTTPS\u0026rsquo;yi destekleyen aynı teknoloji olan TLS\u0026rsquo;nin bir kardeşidir, ancak DTLS aktarım katmanı olarak TCP yerine UDP kullanır. Bu, protokolün güvenilmez teslimatı ele alması gerektiği anlamına gelir. SRTP özellikle medyayı güvenli bir şekilde değiş tokuş etmek için tasarlanmıştır. DTLS yerine bunu kullanarak yapabileceğimiz bazı optimizasyonlar vardır.\nDTLS önce kullanılır. ICE tarafından sağlanan bağlantı üzerinden el sıkışma yapar. DTLS bir istemci/sunucu protokolüdür, bu yüzden bir tarafın el sıkışmayı başlatması gerekir. İstemci/Sunucu rolleri sinyalleşme sırasında seçilir. DTLS el sıkışması sırasında her iki taraf da bir sertifika sunar. El sıkışma tamamlandıktan sonra, bu sertifika Oturum Tanımındaki sertifika hash\u0026rsquo;i ile karşılaştırılır. Bu, el sıkışmanın beklediğiniz WebRTC Ajanı ile gerçekleştiğinden emin olmak içindir. DTLS bağlantısı daha sonra DataChannel iletişimi için kullanılabilir hale gelir.\nSRTP oturumu oluşturmak için onu DTLS tarafından oluşturulan anahtarları kullanarak başlatırız. SRTP\u0026rsquo;nin el sıkışma mekanizması yoktur, bu yüzden dış anahtarlarla önyüklenmesi gerekir. Bu yapıldıktan sonra, SRTP kullanılarak şifrelenmiş medya değiş tokuş edilebilir!\nGüvenlik 101 # Bu bölümde sunulan teknolojiyi anlamak için önce bu terimleri anlamanız gerekecek. Kriptografi zor bir konudur, bu yüzden diğer kaynaklara da danışmaya değer!\nDüz Metin ve Şifreli Metin # Düz metin bir şifrenin girdisidir. Şifreli metin bir şifrenin çıktısıdır.\nŞifre # Şifre, düz metni şifreli metne götüren bir dizi adımdır. Şifre daha sonra tersine çevrilebilir, böylece şifreli metninizi tekrar düz metne dönüştürebilirsiniz. Bir şifre genellikle davranışını değiştirmek için bir anahtara sahiptir. Bunun için başka bir terim şifreleme ve şifre çözmedir.\nBasit bir şifre ROT13\u0026rsquo;tür. Her harf 13 karakter ileri taşınır. Şifreyi geri almak için 13 karakter geri taşırsınız. HELLO düz metni URYYB şifreli metnine dönüşür. Bu durumda, Şifre ROT\u0026rsquo;dur ve anahtar 13\u0026rsquo;tür.\nHash Fonksiyonları # Kriptografik hash fonksiyonu, bir özet üreten tek yönlü bir işlemdir. Bir girdi verildiğinde, her seferinde aynı çıktıyı üretir. Çıktının tersine çevrilemez olması önemlidir. Bir çıktınız varsa, girdisini belirleyememelisiniz. Hash, bir mesajın kurcalanmadığını doğrulamak istediğinizde yararlıdır.\nBasit (kesinlikle gerçek kriptografi için uygun olmasa da) bir hash fonksiyonu sadece her iki harften birini almak olacaktır. HELLO HLO olacaktır. HELLO\u0026lsquo;nun girdi olduğunu varsayamazsınız, ancak HELLO\u0026lsquo;nun hash özetine eşleşme olacağını doğrulayabilirsiniz.\nAçık/Özel Anahtar Kriptografisi # Açık/Özel Anahtar Kriptografisi, DTLS ve SRTP\u0026rsquo;nin kullandığı şifre türünü açıklar. Bu sistemde, açık ve özel anahtar olmak üzere iki anahtarınız vardır. Açık anahtar mesajları şifrelemek içindir ve paylaşılması güvenlidir. Özel anahtar şifre çözmek içindir ve asla paylaşılmamalıdır. Açık anahtarla şifrelenmiş mesajları çözebilen tek anahtardır.\nDiffie–Hellman Değişimi # Diffie–Hellman değişimi, daha önce hiç tanışmamış iki kullanıcının internet üzerinden güvenli bir şekilde paylaşılan bir sır oluşturmasına izin verir. Kullanıcı A, gizlice dinleme konusunda endişelenmeden Kullanıcı B\u0026lsquo;ye bir sır gönderebilir. Bu, ayrık logaritma problemini çözmenin zorluğuna bağlıdır. Bunun nasıl çalıştığını tam olarak anlamanıza gerek yok, ancak DTLS el sıkışmasını mümkün kılan şeyin bu olduğunu bilmek yararlıdır.\nWikipedia\u0026rsquo;da bunun eylemde örneği burada mevcut.\nPseudorandom Fonksiyon # Pseudorandom Fonksiyon (PRF), rastgele görünen bir değer üretmek için önceden tanımlanmış bir fonksiyondur. Birden fazla girdi alabilir ve tek bir çıktı üretebilir.\nAnahtar Türetme Fonksiyonu # Anahtar Türetme, Pseudorandom Fonksiyonun bir türüdür. Anahtar Türetme, bir anahtarı daha güçlü hale getirmek için kullanılan bir fonksiyondur. Yaygın bir desen anahtar uzatmadır.\nDiyelim ki size 8 byte\u0026rsquo;lık bir anahtar verildi. Onu daha güçlü hale getirmek için KDF kullanabilirsiniz.\nNonce # Nonce, bir şifreye ek girdidiri. Bu, aynı mesajı birden fazla kez şifreliyor olsanız bile şifreden farklı çıktı alabilmeniz için kullanılır.\nAynı mesajı 10 kez şifrelerseniz, şifre size 10 kez aynı şifreli metni verecektir. Nonce kullanarak, aynı anahtarı kullanırken farklı çıktı alabilirsiniz. Her mesaj için farklı bir nonce kullanmanız önemlidir! Aksi takdirde, değerin çoğunu yok eder.\nMesaj Kimlik Doğrulama Kodu # Mesaj Kimlik Doğrulama Kodu, mesajın sonuna yerleştirilen bir hash\u0026rsquo;tir. MAC, mesajın beklediğiniz kullanıcıdan geldiğini kanıtlar.\nMAC kullanmazsanız, bir saldırgan geçersiz mesajlar ekleyebilir. Şifreyi çözdükten sonra, anahtarı bilmedikleri için sadece saçmalıklarınız olacaktır.\nAnahtar Rotasyonu # Anahtar Rotasyonu, anahtarınızı belirli aralıklarla değiştirme uygulamasıdır. Bu, çalınan bir anahtarın etkisini daha az hale getirir. Bir anahtar çalınır veya sızarsa, daha az veri şifresi çözülebilir.\nDTLS # DTLS (Datagram Aktarım Katmanı Güvenliği), iki eşin önceden var olan hiçbir yapılandırma olmadan güvenli iletişim kurmasına izin verir. Birisi konuşmayı gizlice dinliyor olsa bile, mesajları şifreyi çözemeyecektir.\nDTLS İstemcisi ve Sunucusunun iletişim kurması için bir şifre ve anahtar üzerinde anlaşmaları gerekir. Bu değerleri DTLS el sıkışması yaparak belirlerler. El sıkışması sırasında mesajlar düz metindedir. DTLS İstemcisi/Sunucusu şifrelemeye başlamak için yeterli detayı değiş tokuş ettiğinde bir Change Cipher Spec gönderir. Bu mesajdan sonra, sonraki her mesaj şifrelenecektir!\nPaket Formatı # Her DTLS paketi bir başlık ile başlar.\nİçerik Türü # Aşağıdaki türleri bekleyebilirsiniz:\n20 - Change Cipher Spec 22 - Handshake 23 - Application Data Handshake oturumu başlatmak için detayları değiş tokuş etmek için kullanılır. Change Cipher Spec diğer tarafa her şeyin şifreleneceğini bildirmek için kullanılır. Application Data şifrelenmiş mesajlardır.\nSürüm # Sürüm 0x0000feff (DTLS v1.0) veya 0x0000fefd (DTLS v1.2) olabilir, v1.1 yoktur.\nEpoch # Epoch 0\u0026lsquo;da başlar, ancak Change Cipher Spec\u0026lsquo;ten sonra 1 olur. Sıfır olmayan epoch\u0026rsquo;a sahip herhangi bir mesaj şifrelidir.\nSıra Numarası # Sıra Numarası mesajları sırayla tutmak için kullanılır. Her mesaj Sıra Numarasını artırır. Epoch artırıldığında, Sıra Numarası baştan başlar.\nUzunluk ve Yük # Yük İçerik Türü\u0026lsquo;ne özgüdür. Application Data için Yük şifrelenmiş veridir. Handshake için mesaja bağlı olarak farklı olacaktır. Uzunluk, Yük\u0026lsquo;ün ne kadar büyük olduğudur.\nEl Sıkışma Durum Makinesi # El sıkışması sırasında, İstemci/Sunucu bir dizi mesaj değiş tokuş eder. Bu mesajlar uçuşlara gruplandırılır. Her uçuşta birden fazla mesaj olabilir (veya sadece bir). Uçuştaki tüm mesajlar alınana kadar Uçuş tamamlanmaz. Her mesajın amacını aşağıda daha ayrıntılı olarak açıklayacağız.\nClientHello # ClientHello, istemci tarafından gönderilen ilk mesajdır. Nitelik listesi içerir. Bu nitelikler sunucuya istemcinin desteklediği şifreleri ve özellikleri söyler. WebRTC için SRTP Şifresini de bu şekilde seçeriz. Ayrıca oturum için anahtarları oluşturmak için kullanılacak rastgele veri içerir.\nHelloVerifyRequest # HelloVerifyRequest sunucu tarafından istemciye gönderilir. İstemcinin isteği göndermeyi amaçladığından emin olmak içindir. İstemci daha sonra ClientHello\u0026rsquo;yu yeniden gönderir, ancak HelloVerifyRequest\u0026rsquo;te sağlanan token ile.\nServerHello # ServerHello, bu oturumun yapılandırması için sunucunun yanıtıdır. Bu oturum bittiğinde hangi şifrenin kullanılacağını içerir. Ayrıca sunucu rastgele verisini de içerir.\nCertificate # Certificate, İstemci veya Sunucu için sertifika içerir. Bu, kiminle iletişim kurduğumuzu benzersiz şekilde tanımlamak için kullanılır. El sıkışma bittikten sonra bu sertifikanın hash\u0026rsquo;lendiğinde SessionDescription\u0026lsquo;daki parmak izine uyduğundan emin olacağız.\nServerKeyExchange/ClientKeyExchange # Bu mesajlar açık anahtarı iletmek için kullanılır. Başlangıçta, istemci ve sunucu ikisi de bir anahtar çifti oluşturur. El sıkışmadan sonra bu değerler Pre-Master Secret oluşturmak için kullanılacaktır.\nCertificateRequest # CertificateRequest, sunucu tarafından istemciye sertifika istediğini bildirmek için gönderilir. Sunucu sertifika İsteyebilir veya Gerektirebilir.\nServerHelloDone # ServerHelloDone, istemciye sunucunun el sıkışmayla işinin bittiğini bildirir.\nCertificateVerify # CertificateVerify, gönderenin Certificate mesajında gönderilen özel anahtara sahip olduğunu kanıtlama yöntemidir.\nChangeCipherSpec # ChangeCipherSpec, alıcıya bu mesajdan sonra gönderilen her şeyin şifreleneceğini bildirir.\nFinished # Finished şifrelidir ve tüm mesajların hash\u0026rsquo;ini içerir. Bu, el sıkışmanın kurcalanmadığını iddia etmek içindir.\nAnahtar Üretimi # El Sıkışma tamamlandıktan sonra, şifrelenmiş veri göndermeye başlayabilirsiniz. Şifre sunucu tarafından seçildi ve ServerHello\u0026rsquo;da. Peki anahtar nasıl seçildi?\nÖnce Pre-Master Secret\u0026lsquo;i oluşturuyoruz. Bu değeri elde etmek için ServerKeyExchange ve ClientKeyExchange tarafından değiş tokuş edilen anahtarlarda Diffie–Hellman kullanılır. Detaylar seçilen Şifreye bağlı olarak farklıdır.\nSonra Master Secret oluşturulur. DTLS\u0026rsquo;nin her sürümünün tanımlanmış Pseudorandom fonksiyonu vardır. DTLS 1.2 için fonksiyon Pre-Master Secret\u0026lsquo;i ve ClientHello ve ServerHello\u0026lsquo;daki rastgele değerleri alır. Pseudorandom Fonksiyonu çalıştırmanın çıktısı Master Secret\u0026lsquo;tir. Master Secret, Şifre için kullanılan değerdir.\nApplicationData Değiş Tokuşu # DTLS\u0026rsquo;nin iş atı ApplicationData\u0026lsquo;dır. Artık başlatılmış bir şifremiz olduğuna göre, değerleri şifrelemeye ve göndermeye başlayabiliriz.\nApplicationData mesajları daha önce açıklandığı gibi DTLS başlığı kullanır. Yük şifreli metin ile doldurulur. Artık çalışan bir DTLS Oturumunuz var ve güvenli bir şekilde iletişim kurabilirsiniz.\nDTLS\u0026rsquo;nin yeniden müzakere gibi daha birçok ilginç özelliği vardır. WebRTC tarafından kullanılmadıkları için burada ele alınmayacaktır.\nSRTP # SRTP, özellikle RTP paketlerini şifrelemek için tasarlanmış bir protokoldür. SRTP oturumu başlatmak için anahtarlarınızı ve şifrenizi belirtirsiniz. DTLS\u0026rsquo;nin aksine el sıkışma mekanizması yoktur. Tüm yapılandırma ve anahtarlar DTLS el sıkışması sırasında oluşturuldu.\nDTLS, anahtarları başka bir işlem tarafından kullanılmak üzere dışa aktarmak için özel bir API sağlar. Bu RFC 5705\u0026rsquo;te tanımlanmıştır.\nOturum Oluşturma # SRTP, girdiler üzerinde kullanılan bir Anahtar Türetme Fonksiyonu tanımlar. SRTP Oturumu oluştururken girdiler SRTP Şifremiz için anahtarlarımızı oluşturmak için bundan geçirilir. Bundan sonra medya işlemeye geçebilirsiniz.\nMedya Değiş Tokuşu # Her RTP paketinin 16 bit SıraNumarası vardır. Bu Sıra Numaraları paketleri sırayla tutmak için kullanılır, Birincil Anahtar gibi. Bir çağrı sırasında bunlar döner. SRTP bunu takip eder ve buna rollover sayacı denir.\nBir paketi şifrelerken SRTP rollover sayacını ve sıra numarasını nonce olarak kullanır. Bu, aynı veriyi iki kez gönderseniz bile şifreli metnin farklı olacağından emin olmak içindir. Bu, bir saldırganın kalıpları tanımlamasını veya tekrar saldırısı denemesini önlemek için önemlidir.\n"},{"id":4,"href":"/tr/docs/05-real-time-networking/","title":"Gerçek Zamanlı Ağ İletişimi","section":"Docs","content":" Gerçek Zamanlı Ağ İletişimi # Gerçek zamanlı iletişimde ağ iletişimi neden bu kadar önemli? # Ağlar gerçek zamanlı iletişimde sınırlayıcı faktördür. İdeal bir dünyada sınırsız bant genişliğine sahip olurduk ve paketler anında ulaşırdı. Ancak durum böyle değil. Ağlar sınırlıdır ve koşullar her an değişebilir. Ağ koşullarını ölçmek ve gözlemlemek de zor bir problemdir. Donanım, yazılım ve bunların konfigürasyonuna bağlı olarak farklı davranışlar alabilirsiniz.\nGerçek zamanlı iletişim ayrıca diğer çoğu alanda bulunmayan bir problem yaratır. Bir web geliştirici için web sitenizin bazı ağlarda daha yavaş olması ölümcül değildir. Tüm veriler ulaştığı sürece kullanıcılar mutludur. WebRTC ile verileriniz geç gelirse işe yaramaz. Kimse 5 saniye önce bir konferans görüşmesinde söylenenleri umursamaz. Dolayısıyla gerçek zamanlı iletişim sistemi geliştirirken bir ödünleşim yapmanız gerekir. Zaman sınırım nedir ve ne kadar veri gönderebilirim?\nBu bölüm hem veri hem de medya iletişimi için geçerli olan kavramları kapsar. Sonraki bölümlerde teorinin ötesine geçip WebRTC\u0026rsquo;nin medya ve veri alt sistemlerinin bu problemleri nasıl çözdüğünü tartışıyoruz.\nAğın zorlaştıran öznitelikleri nelerdir? # Tüm ağlarda etkili çalışan kod karmaşıktır. Birçok farklı faktörünüz var ve hepsi birbirini incelikle etkileyebilir. Geliştiricilerin karşılaşacağı en yaygın sorunlar bunlardır.\nBant Genişliği # Bant genişliği, belirli bir yol boyunca aktarılabilecek maksimum veri hızıdır. Bunun da statik bir sayı olmadığını hatırlamak önemlidir. Daha fazla (veya daha az) kişi kullandıkça rota boyunca bant genişliği değişecektir.\nİletim Süresi ve Gidiş-Geliş Süresi # İletim Süresi, bir paketin hedefine ulaşması için geçen süredir. Bant Genişliği gibi bu da sabit değildir. İletim Süresi her an dalgalanabilir.\ntransmission_time = receive_time - send_time\nİletim süresini hesaplamak için gönderen ve alıcıda milisaniye hassasiyetinde senkronize saatlere ihtiyacınız vardır. Küçük bir sapma bile güvenilmez iletim süresi ölçümü üretir. WebRTC son derece heterojen ortamlarda çalıştığından, hostlar arasında mükemmel zaman senkronizasyonuna güvenmek neredeyse imkansızdır.\nGidiş-geliş süresi ölçümü, kusurlu saat senkronizasyonu için bir geçici çözümdür.\nDağıtılmış saatler üzerinde çalışmak yerine bir WebRTC eşi kendi zaman damgası sendertime1 ile özel bir paket gönderir. İşbirlikçi bir eş paketi alır ve zaman damgasını gönderene geri yansıtır. Orijinal gönderen yansıtılan zamanı aldığında sendertime1 zaman damgasını mevcut zaman sendertime2\u0026lsquo;den çıkarır. Bu zaman deltası \u0026ldquo;gidiş-geliş yayılım gecikmesi\u0026rdquo; veya daha yaygın olarak gidiş-geliş süresi olarak adlandırılır.\nrtt = sendertime2 - sendertime1\nGidiş-geliş süresinin yarısı, iletim süresinin yeterince iyi bir yaklaşımı olarak kabul edilir.\nBu geçici çözümün dezavantajları yok değildir. Paket gönderme ve almanın eşit miktarda zaman aldığı varsayımını yapar. Ancak hücresel ağlarda gönderme ve alma işlemleri zaman-simetrik olmayabilir. Telefonunuzdaki yükleme hızlarının neredeyse her zaman indirme hızlarından düşük olduğunu fark etmiş olabilirsiniz.\ntransmission_time = rtt/2\nGidiş-geliş süresi ölçümünün teknik detayları RTCP Gönderen ve Alıcı Raporları bölümünde daha ayrıntılı olarak açıklanmıştır.\nJitter # Jitter, her paket için İletim Süresinin değişebileceği gerçeğidir. Paketleriniz gecikebilir, ancak daha sonra patlamalar halinde gelebilir.\nPaket Kaybı # Paket Kaybı, iletim sırasında mesajların kaybolmasıdır. Kayıp sabit olabilir veya ani artışlar halinde gelebilir. Bu, uydu veya Wi-Fi gibi ağ tipinden kaynaklanabilir. Veya yol boyunca yazılım tarafından tanıtılabilir.\nMaksimum İletim Birimi # Maksimum İletim Birimi, tek bir paketin ne kadar büyük olabileceğinin sınırıdır. Ağlar bir dev mesaj göndermenize izin vermez. Protokol seviyesinde, mesajların birden fazla küçük pakete bölünmesi gerekebilir.\nMTU ayrıca hangi ağ yolunu aldığınıza bağlı olarak da farklılık gösterecektir. Gönderebileceğiniz en büyük paket boyutunu anlamak için Path MTU Discovery gibi bir protokol kullanabilirsiniz.\nTıkanıklık # Tıkanıklık, ağın sınırlarına ulaşıldığında ortaya çıkar. Bu genellikle mevcut rotanın kaldırabileceği en yüksek bant genişliğine ulaştığınız içindir. Veya ISP\u0026rsquo;nizin yapılandırdığı saatlik sınırlar gibi operatör dayatmalı olabilir.\nTıkanıklık kendini birçok farklı şekilde gösterir. Standartlaştırılmış davranış yoktur. Çoğu durumda tıkanıklığa ulaşıldığında ağ fazla paketleri düşürür. Diğer durumlarda ağ tamponlayacaktır. Bu paketlerinizin İletim Süresinin artmasına neden olur. Ağınız tıkandıkça daha fazla jitter de görebilirsiniz. Bu hızla değişen bir alan ve tıkanıklık tespiti için yeni algoritmalar hala yazılmaktadır.\nDinamik # Ağlar inanılmaz derecede dinamiktir ve koşullar hızla değişebilir. Bir çağrı sırasında yüz binlerce paket gönderip alabilirsiniz. Bu paketler birden fazla atlama üzerinden seyahat edecektir. Bu atlamalar milyonlarca başka kullanıcı tarafından paylaşılacaktır. Yerel ağınızda bile HD filmler indiriliyor olabilir veya belki bir cihaz yazılım güncellemesi indirmeye karar verir.\nİyi bir çağrı yapmak başlangıçta ağınızı ölçmek kadar basit değildir. Sürekli değerlendirmeniz gerekir. Ayrıca çok sayıda ağ donanımı ve yazılımından gelen tüm farklı davranışları ele almanız gerekir.\nPaket Kaybını Çözme # Paket kaybını ele almak çözülecek ilk problemdir. Bunu çözmenin birden fazla yolu vardır, her birinin kendi faydaları vardır. Neyi gönderdiğinize ve gecikme toleransınızın ne olduğuna bağlıdır. Ayrıca tüm paket kaybının ölümcül olmadığını belirtmek önemlidir. Bazı video kaybetmek problem olmayabilir, insan gözü bunu algılayamayabilir bile. Kullanıcının metin mesajlarını kaybetmek ölümcüldür.\nDiyelim ki 10 paket gönderiyorsunuz ve 5. ve 6. paketler kayboldu. Bunu çözmenin yolları şunlardır.\nOnaylar # Onaylar, alıcının gönderene aldığı her paketi bildirmesidir. Gönderen, son olmayan bir paket için iki kez onay aldığında paket kaybının farkına varır. Gönderen paket 4 için iki kez ACK aldığında, paket 5\u0026rsquo;in henüz görülmediğini bilir.\nSeçici Onaylar # Seçici Onaylar, Onayların gelişmiş halidir. Bir alıcı birden fazla paketi onaylayan ve gönderene boşlukları bildiren bir SACK gönderebilir. Şimdi gönderen paket 4 ve 7 için bir SACK alabilir. Daha sonra paket 5 ve 6\u0026rsquo;yı yeniden göndermesi gerektiğini bilir.\nNegatif Onaylar # Negatif Onaylar problemi ters şekilde çözer. Gönderene neyi aldığını bildirmek yerine, alıcı gönderene neyin kaybolduğunu bildirir. Bizim durumumuzda paket 5 ve 6 için bir NACK gönderilecektir. Gönderen sadece alıcının yeniden gönderilmesini istediği paketleri bilir.\nİleri Hata Düzeltme # İleri Hata Düzeltme paket kaybını önceden düzeltir. Gönderen gereksiz veri gönderir, yani kayıp bir paket son akışı etkilemez. Bunun için popüler bir algoritma Reed–Solomon hata düzeltmesidir.\nBasit bir örnekte, gönderen 3 paket gönderir ancak aynı mesaj 3 kez tekrarlanır. Alıcı bu 3 paketten herhangi ikisini alabildikçe mesajı yeniden yapılandırabilir.\nJitterBuffer # JitterBuffer akış halindeki gecikmeyi çözer. Geç gelen paketlerin titreşime neden olmaması avantajdır. Çağrı sırasında şu paket varış zamanlarını gördüğünüzü hayal edin:\n* time=1.46 ms * time=1.93 ms * time=1.57 ms * time=1.55 ms * time=1.54 ms * time=1.72 ms * time=1.45 ms * time=1.73 ms * time=1.80 ms Bu durumda, yaklaşık 1.8 ms iyi bir seçim olacaktır. Geç gelen paketler gecikme penceremizi kullanacak. Erken gelen paketler biraz geciktirilecek ve geç gelen paketlerin boşalttığı pencereyi dolduracak. Bu artık takılma olmadığı ve istemci için düzgün bir teslimat oranı sağladığı anlamına gelir.\nJitterBuffer işleyişi # Her paket alınır alınmaz jitter buffer\u0026rsquo;a eklenir. Çerçeveyi yeniden yapılandırmak için yeterli paket olduğunda, çerçeveyi oluşturan paketler buffer\u0026rsquo;dan serbest bırakılır ve decode için gönderilir. Decoder, video çerçevesini decode eder ve kullanıcının ekranında çizer. Jitter buffer sınırlı kapasiteye sahip olduğundan, buffer\u0026rsquo;da çok uzun süre kalan paketler atılacaktır.\nVideo çerçevelerinin RTP paketlerine nasıl dönüştürüldüğü ve yeniden yapılandırmanın neden gerekli olduğu hakkında daha fazla bilgi için medya iletişimi bölümünü okuyun.\njitterBufferDelay ağ performansınız ve oynatma düzgünlüğü üzerindeki etkisini anlama konusunda harika bir içgörü sağlar. Bu, alıcının gelen akışıyla ilgili WebRTC istatistik API\u0026rsquo;sinin bir parçasıdır. Gecikme, video çerçevelerinin decode için gönderilmeden önce jitter buffer\u0026rsquo;da harcadığı zamanı tanımlar. Uzun jitter buffer gecikmesi ağınızın yoğun olduğu anlamına gelir.\nTıkanıklığı Tespit Etme # Tıkanıklığı çözmeden önce onu tespit etmemiz gerekir. Bunu tespit etmek için tıkanıklık kontrolcüsü kullanırız. Bu karmaşık bir konudur ve hala hızla değişmektedir. Yeni algoritmalar hala yayınlanmakta ve test edilmektedir. Üst düzeyde hepsi aynı şekilde çalışır. Tıkanıklık kontrolcüsü, bazı girdiler verilen bant genişliği tahminleri sağlar. Bunlar olası girdilerden bazıları:\nPaket Kaybı - Ağ tıkandıkça paketler düşürülür. Jitter - Ağ ekipmanı daha fazla yüklenirken paket sıralama zamanların düzensiz olmasına neden olur. Gidiş-Geliş Süresi - Tıkanıklık olduğunda paketlerin gelmesi daha uzun sürer. Jitter\u0026rsquo;ın aksine, Gidiş-Geliş Süresi artmaya devam eder. Açık Tıkanıklık Bildirimi - Yeni ağlar tıkanıklığı azaltmak için düşürülme riski taşıyan paketleri etiketleyebilir. Bu değerlerin çağrı sırasında sürekli olarak ölçülmesi gerekir. Ağın kullanımı artabilir veya azalabilir, bu nedenle mevcut bant genişliği sürekli değişebilir.\nTıkanıklığı Çözme # Artık tahmini bir bant genişliğimiz olduğuna göre gönderdiğimizi ayarlamamız gerekiyor. Nasıl ayarladığımız ne tür veri göndermek istediğimize bağlıdır.\nDaha Yavaş Gönderme # Veri gönderme hızınızı sınırlamak tıkanıklığı önlemenin ilk çözümüdür. Tıkanıklık Kontrolcüsü size bir tahmin verir ve hız sınırlamak gönderenin sorumluluğundadır.\nBu çoğu veri iletişimi için kullanılan yöntemdir. TCP gibi protokollerle bu işletim sistemi tarafından yapılır ve hem kullanıcılar hem de geliştiriciler için tamamen şeffaftır.\nDaha Az Gönderme # Bazı durumlarda sınırlarımızı karşılamak için daha az bilgi gönderebiliriz. Ayrıca verilerimizin gelişi için katı son teslim tarihlerimiz var, bu yüzden daha yavaş gönderemeyiz. Bunlar Gerçek zamanlı medyanın altında kaldığı kısıtlamalardır.\nYeterli bant genişliğimiz yoksa, gönderdiğimiz video kalitesini düşürebiliriz. Bu video kodlayıcınız ve tıkanıklık kontrolcüsü arasında sıkı bir geri bildirim döngüsü gerektirir.\nBu, Onayları gönderme ve ele almanın gecikme/karmaşıklığını azaltır. İçinde bulunduğunuz ağın sıfır kaybı varsa İleri Hata Düzeltme bant genişliği israfıdır.\nJitter\u0026rsquo;ı Çözme # Jitter çoğu ağda mevcuttur. Bir LAN içinde bile dalgalanan hızlarda veri gönderen birçok cihazınız vardır. ping komutuyla başka bir cihaza ping atarak ve gidiş-geliş gecikmesindeki dalgalanmaları fark ederek jitter\u0026rsquo;ı kolayca gözlemleyebilirsiniz.\nJitter\u0026rsquo;ı çözmek için istemciler JitterBuffer kullanır. JitterBuffer paketlerin sabit teslimat süresini sağlar. Dezavantajı JitterBuffer\u0026rsquo;ın erken gelen paketlere biraz gecikme eklemesidir. Avantajı ise geç paketlerin jitter\u0026rsquo;a neden olmamasıdır. Bir çağrı sırasında aşağıdaki paket varış sürelerini gördüğünüzü hayal edin:\n* time=1.46 ms * time=1.93 ms * time=1.57 ms * time=1.55 ms * time=1.54 ms * time=1.72 ms * time=1.45 ms * time=1.73 ms * time=1.80 ms Bu durumda, yaklaşık 1.8 ms iyi bir seçim olurdu. Geç gelen paketler gecikme penceremizi kullanacaktır. Erken gelen paketler biraz geciktirilecek ve geç paketlerin tükettiği pencereyi doldurabilecektir. Bu, artık takılma olmadığı ve istemci için pürüzsüz teslimat hızı sağladığımız anlamına gelir.\nJitterBuffer işlemi # Her paket alınır alınmaz jitter buffer\u0026rsquo;a eklenir. Çerçeveyi yeniden oluşturmak için yeterli paket olduğunda, çerçeveyi oluşturan paketler buffer\u0026rsquo;dan serbest bırakılır ve dekodlama için gönderilir. Dekoder, sırayla dekod eder ve video çerçevesini kullanıcının ekranında çizer. Jitter buffer\u0026rsquo;ın sınırlı kapasitesi olduğundan, buffer\u0026rsquo;da çok uzun kalan paketler atılacaktır.\nVideo çerçevelerinin RTP paketlerine nasıl dönüştürüldüğü ve yeniden oluşturmanın neden gerekli olduğu hakkında daha fazla bilgi medya iletişimi bölümünde okuyun.\njitterBufferDelay ağ performansınız ve oynatma pürüzsüzlüğü üzerindeki etkisi hakkında harika bir bakış açısı sağlar. Alıcının gelen akışıyla ilgili WebRTC istatistik API\u0026rsquo;sinin bir parçasıdır. Gecikme, video çerçevelerinin dekodlama için gönderilmeden önce jitter buffer\u0026rsquo;da geçirdikleri süreyi tanımlar. Uzun jitter buffer gecikmesi ağınızın yoğun şekilde tıkandığı anlamına gelir.\nTıkanıklığı Tespit Etme # Tıkanıklığı çözmeden önce onu tespit etmemiz gerekir. Bunu tespit etmek için bir tıkanıklık kontrolörü kullanırız. Bu karmaşık bir konudur ve hala hızla değişmektedir. Yeni algoritmalar hala yayınlanıyor ve test ediliyor. Yüksek seviyede hepsi aynı şekilde çalışır. Bir tıkanıklık kontrolörü bazı girdiler verildiğinde bant genişliği tahminleri sağlar. Bunlar bazı olası girdilerdir:\nPaket Kaybı - Ağ tıkandıkça paketler düşürülür. Jitter - Ağ ekipmanı daha fazla yüklendiğinde paket kuyruğu zamanların düzensiz olmasına neden olur. Gidiş-Geliş Süresi - Tıkandığında paketlerin gelmesi daha uzun sürer. Jitter\u0026rsquo;dan farklı olarak, Gidiş-Geliş Süresi artmaya devam eder. Açık Tıkanıklık Bildirimi - Yeni ağlar tıkanıklığı hafifletmek için düşürülme riski altındaki paketleri etiketleyebilir. Bu değerlerin çağrı sırasında sürekli ölçülmesi gerekir. Ağın kullanımı artabilir veya azalabilir, dolayısıyla mevcut bant genişliği sürekli değişiyor olabilir.\nTıkanıklığı Çözme # Artık tahmini bir bant genişliğimiz olduğuna göre gönderdiğimizi ayarlamamız gerekiyor. Nasıl ayarladığımız hangi tür veri göndermek istediğimize bağlıdır.\nDaha Yavaş Gönderme # Veri gönderme hızınızı sınırlamak tıkanıklığı önlemenin ilk çözümüdür. Tıkanıklık Kontrolörü size bir tahmin verir ve gönderenin hızı sınırlaması sorumluluğundadır.\nBu çoğu veri iletişimi için kullanılan yöntemdir. TCP gibi protokollerde bu işletim sistemi tarafından yapılır ve hem kullanıcılar hem de geliştiriciler için tamamen şeffaftır.\nDaha Az Gönderme # Bazı durumlarda sınırlarımızı karşılamak için daha az bilgi gönderebiliriz. Ayrıca verilerimizin varışı için sert son teslim tarihlerimiz var, bu yüzden daha yavaş gönderemeyiz. Bunlar Gerçek zamanlı medyanın altında kaldığı kısıtlamalardır.\nYeterli bant genişliğimiz yoksa, gönderdiğimiz video kalitesini düşürebiliriz. Bu, video kodlayıcınız ve tıkanıklık kontrolörünüz arasında sıkı bir geri bildirim döngüsü gerektirir.\n"},{"id":5,"href":"/tr/docs/06-media-communication/","title":"Medya İletişimi","section":"Docs","content":" Medya İletişimi # WebRTC\u0026rsquo;nin medya iletişiminden ne elde ederim? # WebRTC size sınırsız miktarda ses ve video akışı gönderip almanıza izin verir. Bu akışları bir çağrı sırasında istediğiniz zaman ekleyip çıkarabilirsiniz. Bu akışların hepsi bağımsız olabilir veya birlikte paketlenmiş olabilir! Masaüstünüzün video beslemesini gönderebilir ve ardından web kameranızdan ses ve video ekleyebilirsiniz.\nWebRTC protokolü codec agnostiktir. Alttaki aktarım her şeyi destekler, henüz var olmayan şeyleri bile! Ancak, iletişim kurduğunuz WebRTC Ajanı bunu kabul etmek için gerekli araçlara sahip olmayabilir.\nWebRTC ayrıca dinamik ağ koşullarını ele almak için tasarlanmıştır. Bir çağrı sırasında bant genişliğiniz artabilir veya azalabilir. Belki aniden çok fazla paket kaybı yaşarsınız. Protokol tüm bunları ele almak için tasarlanmıştır. WebRTC ağ koşullarına yanıt verir ve mevcut kaynaklarla size mümkün olan en iyi deneyimi sunmaya çalışır.\nNasıl çalışır? # WebRTC önceden var olan iki protokol kullanır: RTP ve RTCP, her ikisi de RFC 1889\u0026lsquo;da tanımlanmıştır.\nRTP (Gerçek zamanlı Aktarım Protokolü), medyayı taşıyan protokoldür. Videonun gerçek zamanlı teslimatına izin verecek şekilde tasarlanmıştır. Gecikme veya güvenilirlik etrafında herhangi bir kural koymazken, bunları uygulamak için araçları verir. RTP size akışlar verir, böylece tek bir bağlantı üzerinden birden fazla medya beslemesi çalıştırabilirsiniz. Ayrıca bir medya pipeline\u0026rsquo;ını beslemek için ihtiyacınız olan zamanlama ve sıralama bilgilerini de verir.\nRTCP (RTP Kontrol Protokolü), çağrı hakkındaki meta verileri ileten protokoldür. Format çok esnektir ve istediğiniz meta verileri eklemenize izin verir. Bu, çağrı hakkındaki istatistikleri iletmek için kullanılır. Ayrıca paket kaybını ele almak ve tıkanıklık kontrolü uygulamak için de kullanılır. Değişen ağ koşullarına yanıt vermek için gerekli çift yönlü iletişimi sağlar.\nGecikme vs Kalite # Gerçek zamanlı medya, gecikme ve kalite arasında ödünleşimler yapmakla ilgilidir. Tolere etmeye istekli olduğunuz gecikme ne kadar fazlaysa, o kadar yüksek kaliteli video bekleyebilirsiniz.\nGerçek Dünya Sınırlamaları # Bu kısıtlamaların hepsi gerçek dünyanın sınırlamaları nedeniyle oluşur. Bunların hepsi üstesinden gelmeniz gereken ağınızın özellikleridir.\nVideo Karmaşıktır # Video taşımak kolay değildir. 30 dakikalık sıkıştırılmamış 720 8-bit video depolamak için yaklaşık 110 GB\u0026rsquo;a ihtiyacınız var. Bu rakamlarla 4 kişilik konferans görüşmesi gerçekleşmeyecektir. Daha küçük hale getirmenin bir yoluna ihtiyacımız var ve cevap video sıkıştırmadır. Yine de bunun dezavantajları yok değildir.\nVideo 101 # Video sıkıştırmayı derinlemesine ele almayacağız, ancak RTP\u0026rsquo;nin neden bu şekilde tasarlandığını anlamak için yeterli kadarını ele alacağız. Video sıkıştırma, videoyu aynı videoyu temsil etmek için daha az bit gerektiren yeni bir formata kodlar.\nKayıplı ve Kayıpsız sıkıştırma # Videoyu kayıpsız (hiçbir bilgi kaybolmaz) veya kayıplı (bilgi kaybolabilir) olacak şekilde kodlayabilirsiniz. Kayıpsız kodlama bir eşe daha fazla veri gönderilmesini gerektirdiği için, daha yüksek gecikmeli akış ve daha fazla düşürülen paket oluşturduğu için, video kalitesi o kadar iyi olmasa da RTP tipik olarak kayıplı sıkıştırma kullanır.\nÇerçeve içi ve çerçeveler arası sıkıştırma # Video sıkıştırma iki türde gelir. İlki çerçeve içidir. Çerçeve içi sıkıştırma, tek bir video çerçevesini tanımlamak için kullanılan bitleri azaltır. Aynı teknikler JPEG sıkıştırma yöntemi gibi durağan resimleri sıkıştırmak için kullanılır.\nİkinci tür çerçeveler arası sıkıştırmadır. Video birçok resimden oluştuğu için aynı bilgiyi iki kez göndermemenin yollarını ararız.\nÇerçeve arası türler # Üç çerçeve türü vardır:\nI-Frame - Tam bir resim, başka bir şey olmadan decode edilebilir. P-Frame - Kısmi bir resim, sadece önceki resimden değişiklikleri içerir. B-Frame - Kısmi bir resim, önceki ve gelecek resimlerin bir modifikasyonudur. Aşağıda üç çerçeve türünün görselleştirmesi verilmiştir.\nVideo hassastır # Video sıkıştırma inanılmaz derecede durumludur, bu da internet üzerinden aktarımını zorlaştırır. Bir I-Frame\u0026rsquo;in bir parçasını kaybederseniz ne olur? P-Frame neyi değiştireceğini nasıl biliyor? Video sıkıştırma daha karmaşık hale geldikçe, bu daha da büyük bir sorun haline geliyor. Neyse ki RTP ve RTCP\u0026rsquo;nin çözümü var.\nRTP # Paket Formatı # Her RTP paketi aşağıdaki yapıya sahiptir:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Synchronization Source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | Contributing Source (CSRC) identifiers | | .... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Version (V) # Version her zaman 2\u0026lsquo;dir.\nPadding (P) # Padding, payload\u0026rsquo;ın padding\u0026rsquo;i olup olmadığını kontrol eden bir boolean\u0026rsquo;dır.\nPayload\u0026rsquo;ın son byte\u0026rsquo;ı kaç padding byte\u0026rsquo;ının eklendiğini içerir.\nExtension (X) # Ayarlanırsa, RTP başlığının uzantıları olacaktır. Bu aşağıda daha ayrıntılı olarak açıklanmaktadır.\nCSRC count (CC) # SSRC\u0026lsquo;den sonra ve payload\u0026rsquo;dan önce gelen CSRC tanımlayıcılarının miktarı.\nMarker (M) # İşaretleyici bit önceden belirlenmiş bir anlama sahip değildir ve kullanıcının istediği şekilde kullanılabilir.\nBazı durumlarda kullanıcı konuşurken ayarlanır. Ayrıca yaygın olarak bir anahtar çerçeveyi işaretlemek için kullanılır.\nPayload Type (PT) # Payload Type, bu paket tarafından taşınan codec\u0026rsquo;in benzersiz tanımlayıcısıdır.\nWebRTC için Payload Type dinamiktir. Bir çağrıdaki VP8 diğerinden farklı olabilir. Çağrıdaki teklif veren, Session Description\u0026lsquo;da Payload Types\u0026lsquo;ın codec\u0026rsquo;lere eşlemesini belirler.\nSequence Number # Sequence Number, bir akıştaki paketleri sıralamak için kullanılır. Her paket gönderildiğinde Sequence Number bir artırılır.\nRTP, kayıplı ağlar üzerinde yararlı olacak şekilde tasarlanmıştır. Bu, alıcıya paketlerin ne zaman kaybolduğunu tespit etme yolu verir.\nTimestamp # Bu paket için örnekleme anı. Bu küresel bir saat değildir, medya akışında ne kadar zaman geçtiğidir. Birkaç RTP paketi, örneğin hepsi aynı video çerçevesinin parçasıysa aynı zaman damgasına sahip olabilir.\nSynchronization Source (SSRC) # SSRC, bu akış için benzersiz tanımlayıcıdır. Bu, tek bir RTP akışı üzerinden birden fazla medya akışı çalıştırmanıza olanak tanır.\nContributing Source (CSRC) # Bu pakete hangi SSRC\u0026lsquo;lerin katkıda bulunduğunu ileten bir liste.\nBu yaygın olarak konuşma göstergeleri için kullanılır. Diyelim ki sunucu tarafında birden fazla ses beslemesini tek bir RTP akışında birleştirdiniz. Daha sonra bu alanı \u0026ldquo;Bu anda Giriş akışı A ve C konuşuyordu\u0026rdquo; demek için kullanabilirsiniz.\nPayload # Gerçek payload verisi. Padding bayrağı ayarlanmışsa, kaç padding byte\u0026rsquo;ının eklendiğinin sayısıyla sonlanabilir.\nUzantılar # RTCP # Paket Formatı # Her RTCP paketi aşağıdaki yapıya sahiptir:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| RC | PT | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Version (V) # Version her zaman 2\u0026lsquo;dir.\nPadding (P) # Padding, payload\u0026rsquo;ın padding\u0026rsquo;i olup olmadığını kontrol eden bir boolean\u0026rsquo;dır.\nPayload\u0026rsquo;ın son byte\u0026rsquo;ı kaç padding byte\u0026rsquo;ının eklendiğini içerir.\nReception Report Count (RC) # Bu paketteki raporların sayısı. Tek bir RTCP paketi birden fazla olay içerebilir.\nPacket Type (PT) # Bu RTCP Paketinin ne tür olduğunun benzersiz tanımlayıcısı. Bir WebRTC Ajanının tüm bu türleri desteklemesi gerekmez ve Ajanlar arasındaki destek farklı olabilir. Yaygın olarak görebilecekleriniz şunlardır:\n192 - Full INTRA-frame Request (FIR) 193 - Negative ACKnowledgements (NACK) 200 - Sender Report 201 - Receiver Report 205 - Generic RTP Feedback 206 - Payload Specific Feedback Bu paket türlerinin önemi aşağıda daha ayrıntılı olarak açıklanacaktır.\nFull INTRA-frame Request (FIR) ve Picture Loss Indication (PLI) # Hem FIR hem de PLI mesajları benzer bir amaca hizmet eder. Bu mesajlar gönderenden tam bir anahtar çerçeve ister. PLI, kısmi çerçeveler decoder\u0026rsquo;a verildiğinde ancak bunları decode edemediğinde kullanılır. Bu, çok fazla paket kaybınız olması veya belki decoder\u0026rsquo;ın çökmesi nedeniyle olabilir.\nRFC 5104\u0026rsquo;e göre, paketler veya çerçeveler kaybolduğunda FIR kullanılmamalıdır. Bu PLI\u0026lsquo;nin işidir. FIR, paket kaybı dışındaki nedenlerle bir anahtar çerçeve ister - örneğin yeni bir üye video konferansına girdiğinde. Video akışını decode etmeye başlamak için tam bir anahtar çerçeveye ihtiyaçları vardır, decoder anahtar çerçeve gelene kadar çerçeveleri atıyor olacaktır.\nAlıcının bağlandıktan hemen sonra tam bir anahtar çerçeve istemesi iyi bir fikirdir, bu bağlanma ile kullanıcının ekranında görüntü çıkması arasındaki gecikmeyi minimize eder.\nPLI paketleri Payload Specific Feedback mesajlarının bir parçasıdır.\nPratikte, hem PLI hem de FIR paketlerini işleyebilen yazılım her iki durumda da aynı şekilde davranacaktır. Encoder\u0026rsquo;a yeni bir tam anahtar çerçeve üretmesi için sinyal gönderecektir.\nNegative Acknowledgment # Bir NACK, gönderenin tek bir RTP paketini yeniden iletmesini ister. Bu genellikle bir RTP paketinin kaybolması nedeniyle olur, ancak geç kaldığı için de olabilir.\nNACK\u0026lsquo;ler, tüm çerçevenin tekrar gönderilmesini istemekten çok daha bant genişliği açısından verimlidir. RTP paketleri çok küçük parçalara böldüğü için, gerçekten sadece küçük eksik bir parça istiyorsunuz. Alıcı SSRC ve Sequence Number ile bir RTCP mesajı oluşturur. Gönderen bu RTP paketini yeniden göndermek için mevcut değilse, mesajı görmezden gelir.\nSender ve Receiver Reports # Bu raporlar ajanlar arasında istatistik göndermek için kullanılır. Bu, gerçekten alınan paket miktarını ve jitter\u0026rsquo;ı iletir.\nRaporlar tanılama ve tıkanıklık kontrolü için kullanılabilir.\nRTP/RTCP nasıl birlikte sorunları çözer # RTP ve RTCP daha sonra ağların neden olduğu tüm sorunları çözmek için birlikte çalışır. Bu teknikler hala sürekli değişiyor!\nForward Error Correction # FEC olarak da bilinir. Paket kaybıyla başa çıkmanın başka bir yöntemi. FEC, istenmeden bile aynı veriyi birden fazla kez göndermenizdir. Bu RTP seviyesinde veya codec ile daha da alt seviyede yapılır.\nBir çağrı için paket kaybı sabitiyse, FEC, NACK\u0026rsquo;ten çok daha düşük gecikmeli bir çözümdür. İstemek ve sonra eksik paketi yeniden iletmek zorunda kalmanın gidiş-dönüş süresi NACK\u0026rsquo;ler için önemli olabilir.\nAdaptive Bitrate ve Bandwidth Estimation # Real-time networking bölümünde tartışıldığı gibi, ağlar öngörülemez ve güvenilmezdir. Bant genişliği kullanılabilirliği bir oturum boyunca birden fazla kez değişebilir. Mevcut bant genişliğinin bir saniye içinde dramatik olarak (büyüklük mertebeleri) değiştiğini görmek nadir değildir.\nAna fikir, tahmin edilen, mevcut ve gelecekteki mevcut ağ bant genişliğine dayalı olarak kodlama bitrate\u0026rsquo;ini ayarlamaktır. Bu, mümkün olan en iyi kalitede video ve ses sinyalinin iletilmesini ve ağ tıkanıklığı nedeniyle bağlantının düşmemesini sağlar. Ağ davranışını modelleyen ve tahmin etmeye çalışan buluşsal yöntemler Bandwidth estimation olarak bilinir.\nBunun çok fazla nüansı vardır, bu yüzden daha ayrıntılı olarak inceleyelim.\nAğ Durumunu Tanımlama ve İletişim # RTP/RTCP her türlü farklı ağ üzerinde çalışır ve sonuç olarak, bazı iletişimin gönderenden alıcıya giderken düşürülmesi yaygındır. UDP üzerine kurulduğu için, paket yeniden iletimi için yerleşik bir mekanizma yoktur, tıkanıklık kontrolünü ele almak şöyle dursun.\nKullanıcılara en iyi deneyimi sağlamak için WebRTC, ağ yolu hakkındaki nitelikleri tahmin etmeli ve bu niteliklerin zaman içinde nasıl değiştiğine uyum sağlamalıdır. İzlenmesi gereken temel özellikler şunlardır: mevcut bant genişliği (her yönde, simetrik olmayabilir), gidiş-dönüş süresi ve jitter (gidiş-dönüş süresindeki dalgalanmalar). Paket kaybını hesaba katması ve ağ koşulları değiştikçe bu özelliklerdeki değişiklikleri iletmesi gerekir.\nBu protokoller için iki temel amaç vardır:\nAğ tarafından desteklenen mevcut bant genişliğini (her yönde) tahmin etmek. Gönderen ve alıcı arasında ağ özelliklerini iletmek. RTP/RTCP\u0026rsquo;nin bu sorunu ele almak için üç farklı yaklaşımı vardır. Hepsinin artıları ve eksileri vardır ve genellikle her nesil öncekilerine göre gelişmiştir. Hangi uygulamayı kullanacağınız öncelikle istemcileriniz için mevcut yazılım yığınına ve uygulamanızı oluşturmak için mevcut kütüphanelere bağlı olacaktır.\nReceiver Reports / Sender Reports # İlk uygulama, Receiver Reports çifti ve tamamlayıcısı Sender Reports\u0026rsquo;tır. Bu RTCP mesajları RFC 3550\u0026lsquo;de tanımlanmıştır ve uç noktalar arasında ağ durumunu iletmekten sorumludur. Receiver Reports, ağ hakkındaki nitelikleri (paket kaybı, gidiş-dönüş süresi ve jitter dahil) iletmeye odaklanır ve bu raporlara dayalı olarak mevcut bant genişliğini tahmin etmekten sorumlu diğer algoritmalarla eşleşir.\nSender ve Receiver raporları (SR ve RR) birlikte ağ kalitesinin bir resmini çizer. Her SSRC için bir programda gönderilirler ve mevcut bant genişliğini tahmin ederken kullanılan girdilerdir. Bu tahminler, aşağıdaki alanları içeren RR verilerini aldıktan sonra gönderen tarafından yapılır:\nFraction Lost - Son Receiver Report\u0026rsquo;tan bu yana paketlerin yüzde kaçı kayboldu. Cumulative Number of Packets Lost - Tüm çağrı boyunca kaç paket kayboldu. Extended Highest Sequence Number Received - Alınan son Sequence Number neydi ve kaç kez döndü. Interarrival Jitter - Tüm çağrı için rolling Jitter. Last Sender Report Timestamp - Gönderendeki son bilinen zaman, gidiş-dönüş süresi hesaplaması için kullanılır. SR ve RR, gidiş-dönüş süresini hesaplamak için birlikte çalışır.\nGönderen SR\u0026rsquo;de yerel zamanını sendertime1\u0026lsquo;i içerir. Alıcı bir SR paketi aldığında, RR\u0026rsquo;yi geri gönderir. Diğer şeylerin yanı sıra, RR gönderenden az önce alınan sendertime1\u0026lsquo;i içerir. SR\u0026rsquo;yi alma ve RR\u0026rsquo;yi gönderme arasında bir gecikme olacaktır. Bu nedenle, RR ayrıca bir \u0026ldquo;son gönderen raporundan bu yana gecikme\u0026rdquo; zamanını - DLSR\u0026lsquo;yi de içerir. DLSR, gidiş-dönüş süresini ayarlamak için kullanılır.\nİşlemde daha sonra gidiş-dönüş süresi tahminini yapmak için kullanılır. Gönderen RR\u0026rsquo;yi aldığında, mevcut zaman sendertime2\u0026lsquo;den sendertime1 ve DLSR\u0026lsquo;yi çıkarır. Bu zaman deltası gidiş-dönüş yayılma gecikmesi veya gidiş-dönüş süresi olarak adlandırılır.\nrtt = sendertime2 - sendertime1 - DLSR\nGidiş-dönüş süresi sade İngilizcede:\nSize saatimin mevcut okumasını içeren bir mesaj gönderirim, diyelim ki 16:20, 42 saniye ve 420 milisaniye. Siz de bu aynı zaman damgasını bana geri gönderirsiniz. Ayrıca mesajımı okumaktan mesajı geri göndermeye kadar geçen zamanı da dahil edersiniz, diyelim ki 5 milisaniye. Zamanı geri aldığımda, saate tekrar bakarım. Şimdi saatim 16:20, 42 saniye 690 milisaniye diyor. Bu, size ulaşıp bana geri dönmek için 265 milisaniye (690 - 420 - 5) aldığı anlamına gelir. Dolayısıyla, gidiş-dönüş süresi 265 milisaniyedir. TMMBR, TMMBN, REMB ve TWCC, GCC ile eşleştirilmiş # Google Congestion Control (GCC) # Google Congestion Control (GCC) algoritması (draft-ietf-rmcat-gcc-02\u0026lsquo;de özetlenmiştir) bant genişliği tahmininin zorluğunu ele alır. İlişkili iletişim gereksinimlerini kolaylaştırmak için çeşitli diğer protokollerle eşleşir. Sonuç olarak, alıcı tarafında (TMMBR/TMMBN veya REMB ile çalıştırıldığında) veya gönderen tarafında (TWCC ile çalıştırıldığında) çalışmaya çok uygundur.\nMevcut bant genişliği tahminlerine ulaşmak için GCC, iki temel metrik olarak paket kaybına ve çerçeve varış zamanındaki dalgalanmalara odaklanır. Bu metrikleri iki bağlantılı kontrolör üzerinden çalıştırır: kayıp-tabanlı kontrolör ve gecikme-tabanlı kontrolör.\nGCC\u0026rsquo;nin ilk bileşeni olan kayıp-tabanlı kontrolör basittir:\nPaket kaybı %10\u0026rsquo;un üzerindeyse, bant genişliği tahmini azaltılır. Paket kaybı %2-10 arasındaysa, bant genişliği tahmini aynı kalır. Paket kaybı %2\u0026rsquo;nin altındaysa, bant genişliği tahmini artırılır. Paket kaybı ölçümleri sık sık alınır. Eşleştirilmiş iletişim protokolüne bağlı olarak, paket kaybı ya açıkça iletilir (TWCC\u0026rsquo;de olduğu gibi) ya da çıkarılır (TMMBR/TMMBN ve REMB\u0026rsquo;de olduğu gibi). Bu yüzdeler yaklaşık bir saniye civarındaki zaman pencereleri üzerinde değerlendirilir.\nGecikme-tabanlı kontrolör, kayıp-tabanlı kontrolörle işbirliği yapar ve paket varış zamanındaki varyasyonlara bakar. Bu gecikme-tabanlı kontrolör, ağ bağlantılarının ne zaman giderek daha tıkanık hale geldiğini belirlemeyi amaçlar ve paket kaybı oluşmadan önce bile bant genişliği tahminlerini azaltabilir. Teori, yol boyunca en meşgul ağ arayüzünün, arayüz tamponlarının içindeki kapasitesi bitene kadar paketleri sıraya koymaya devam edeceğidir. Bu arayüz gönderebileceğinden daha fazla trafik almaya devam ederse, tampon alanına sığdıramadığı tüm paketleri düşmeye zorlanacaktır. Bu tür paket kaybı, düşük gecikmeli/gerçek zamanlı iletişim için özellikle yıkıcıdır, ancak aynı zamanda bu bağlantı üzerindeki tüm iletişim için verimi de bozabilir ve ideal olarak kaçınılmalıdır. Bu nedenle, GCC, paket kaybı gerçekten gerçekleşmeden önce ağ bağlantılarının giderek büyüyen kuyruk derinlikleri olup olmadığını anlamaya çalışır. Zaman içinde artan sıralama gecikmelerini gözlemlerse bant genişliği kullanımını azaltacaktır.\nBunu başarmak için GCC, gidiş-dönüş süresindeki ince artışları ölçerek kuyruk derinliğindeki artışları çıkarmaya çalışır. Çerçevelerin \u0026ldquo;varış-arası zamanını\u0026rdquo; kaydeder, t(i) - t(i-1): iki paket grubunun (genellikle ardışık video çerçeveleri) varış zamanındaki fark. Bu paket grupları sıklıkla düzenli zaman aralıklarında ayrılır (örneğin, 24 fps bir video için her 1/24 saniyede bir). Sonuç olarak, varış-arası zamanı ölçmek, ilk paket grubunun (yani çerçevenin) başlangıcı ile bir sonrakinin ilk çerçevesi arasındaki zaman farkını kaydetmek kadar basittir.\nAşağıdaki diyagramda, medyan paketler arası gecikme artışı +20 msn\u0026rsquo;dir, ağ tıkanıklığının açık bir göstergesidir.\nVarış-arası zaman zaman içinde artıyorsa, bu bağlayan ağ arayüzlerinde artan kuyruk derinliğinin kanıtı olarak kabul edilir ve ağ tıkanıklığı olarak değerlendirilir. (Not: GCC, çerçeve byte boyutlarındaki dalgalanmalar için bu ölçümleri kontrol edecek kadar akıllıdır.) GCC, gecikme ölçümlerini bir Kalman filtresini kullanarak rafine eder ve tıkanıklığı işaretlemeden önce ağ gidiş-dönüş sürelerinin (ve varyasyonlarının) birçok ölçümünü alır. GCC\u0026rsquo;nin Kalman filtresini doğrusal regresyonun yerini alacak şekilde düşünebilirsiniz: jitter zamanlama ölçümlerine gürültü eklediğinde bile doğru tahminler yapmaya yardımcı olur. Tıkanıklığı işaretledikten sonra, GCC mevcut bitrate\u0026rsquo;i azaltacaktır. Alternatif olarak, sabit ağ koşulları altında, daha yüksek yük değerlerini test etmek için bant genişliği tahminlerini yavaşça artırabilir.\nTMMBR, TMMBN ve REMB # TMMBR/TMMBN ve REMB için, alıcı taraf önce mevcut gelen bant genişliğini tahmin eder (GCC gibi bir protokol kullanarak) ve ardından bu bant genişliği tahminlerini uzak gönderenlere iletir. Paket kaybı veya ağ tıkanıklığı hakkındaki diğer nitelikler hakkında ayrıntı alışverişi yapmaları gerekmez çünkü alıcı tarafında çalışmak onların varış-arası zamanı ve paket kaybını doğrudan ölçmelerine olanak tanır. Bunun yerine, TMMBR, TMMBN ve REMB sadece bant genişliği tahminlerinin kendilerini alışverişi yapar:\nTemporary Maximum Media Stream Bit Rate Request - Tek bir SSRC için istenen bitrate\u0026rsquo;in mantissa/üssü. Temporary Maximum Media Stream Bit Rate Notification - Bir TMMBR\u0026rsquo;nin alındığını bildiren mesaj. Receiver Estimated Maximum Bitrate - Tüm oturum için istenen bitrate\u0026rsquo;in mantissa/üssü. TMMBR ve TMMBN önce geldi ve RFC 5104\u0026rsquo;te tanımlandı. REMB daha sonra geldi, draft-alvestrand-rmcat-remb\u0026lsquo;de bir taslak sunuldu, ancak hiçbir zaman standartlaştırılmadı.\nREMB kullanan örnek bir oturum aşağıdaki gibi davranabilir:\nBu yöntem kağıt üzerinde harika çalışır. Gönderen alıcıdan tahmin alır, encoder bitrate\u0026rsquo;ini alınan değere ayarlar. Tada! Ağ koşullarına uyum sağladık.\nAncak pratikte, REMB yaklaşımının birden fazla dezavantajı vardır.\nEncoder verimsizliği birincisidir. Encoder için bir bitrate ayarladığınızda, mutlaka istediğiniz tam bitrate\u0026rsquo;i çıkarmayacaktır. Kodlama, encoder ayarlarına ve kodlanan çerçeveye bağlı olarak daha fazla veya daha az bit çıkarabilir.\nÖrneğin, x264 encoder\u0026rsquo;ını tune=zerolatency ile kullanmak belirtilen hedef bitrate\u0026rsquo;ten önemli ölçüde sapabilir. İşte olası bir senaryo:\nDiyelim ki bitrate\u0026rsquo;i 1000 kbps\u0026rsquo;ye ayarlayarak başlıyoruz. Encoder sadece 700 kbps çıkarıyor, çünkü kodlamak için yeterli yüksek frekans özelliği yok. (AKA - \u0026ldquo;duvara bakmak\u0026rdquo;.) Ayrıca alıcının 700 kbps videoyu sıfır paket kaybıyla aldığını hayal edelim. Daha sonra gelen bitrate\u0026rsquo;i %8 artırmak için REMB kuralı 1\u0026rsquo;i uygular. Alıcı gönderene 756 kbps önerisi (700 kbps * 1.08) ile bir REMB paketi gönderir. Gönderen encoder bitrate\u0026rsquo;ini 756 kbps\u0026rsquo;ye ayarlar. Encoder daha da düşük bir bitrate çıkarır. Bu süreç kendini tekrar etmeye devam eder ve bitrate\u0026rsquo;i mutlak minimuma düşürür. Bunun nasıl ağır encoder parametre ayarlamasına neden olacağını ve harika bir bağlantıda bile izlenemez videoyla kullanıcıları şaşırtacağını görebilirsiniz.\nTransport Wide Congestion Control # Transport Wide Congestion Control, RTCP ağ durumu iletişimindeki en son gelişmedir. draft-holmer-rmcat-transport-wide-cc-extensions-01\u0026lsquo;de tanımlanmıştır, ancak aynı zamanda hiçbir zaman standartlaştırılmamıştır.\nTWCC oldukça basit bir prensip kullanır:\nREMB ile alıcı, gönderen tarafa mevcut indirme bitrate\u0026rsquo;ini bildirir. Çıkarılan paket kaybı hakkında kesin ölçümler ve sadece kendisinin sahip olduğu paketler arası varış zamanı hakkında veri kullanır.\nTWCC, SR/RR ve REMB protokol nesilleri arasında neredeyse hibrit bir yaklaşımdır. Bant genişliği tahminlerini gönderen tarafa geri getirir (SR/RR\u0026rsquo;ye benzer), ancak bant genişliği tahmin tekniği REMB nesline daha çok benzer.\nTWCC ile alıcı, gönderene her paketin varış zamanını bildirir. Bu, gönderenin paketler arası varış gecikme varyasyonunu ölçmesi ve ses/video beslemesine katkıda bulunamayacak kadar düşürülen veya geç gelen paketleri tanımlaması için yeterli bilgidir. Bu veriler sık sık alışverişi edildiğinde, gönderen değişen ağ koşullarına hızla uyum sağlayabilir ve GCC gibi bir algoritma kullanarak çıkış bant genişliğini değiştirebilir.\nGönderen gönderilen paketleri, sıra numaralarını, boyutlarını ve zaman damgalarını takip eder. Gönderen alıcıdan RTCP mesajları aldığında, gönderme paketler arası gecikmelerini alma gecikmeleriyle karşılaştırır. Alma gecikmeleri artıyorsa, ağ tıkanıklığını işaret eder ve gönderen düzeltici önlemler almalıdır.\nGönderene ham veri sağlayarak, TWCC gerçek zamanlı ağ koşullarına mükemmel bir görünüm sağlar:\nBireysel kayıp paketlere kadar neredeyse anında paket kaybı davranışı Doğru gönderme bitrate\u0026rsquo;i Doğru alma bitrate\u0026rsquo;i Jitter ölçümü Gönderme ve alma paket gecikmeleri arasındaki farklar Ağın patlamalı veya sabit bant genişliği teslimatını nasıl tolere ettiğinin açıklaması TWCC\u0026rsquo;nin en önemli katkılarından biri, WebRTC geliştiricilerine sağladığı esnekliktir. Tıkanıklık kontrol algoritmasını gönderen tarafa konsolide ederek, yaygın olarak kullanılabilen ve zaman içinde minimal geliştirmeler gerektiren basit istemci koduna olanak tanır. Karmaşık tıkanıklık kontrol algoritmaları daha sonra doğrudan kontrol ettikleri donanımda (Bölüm 8\u0026rsquo;de tartışılan Selective Forwarding Unit gibi) daha hızlı bir şekilde yinelenebilir. Tarayıcılar ve mobil cihazlar söz konusu olduğunda, bu, bu istemcilerin standartlaştırma veya tarayıcı güncellemelerini beklemek zorunda kalmadan (yaygın olarak kullanılabilir olması oldukça uzun sürebilir) algoritma geliştirmelerinden faydalanabileceği anlamına gelir.\nBant Genişliği Tahmini Alternatifleri # En çok dağıtılan uygulama, draft-alvestrand-rmcat-congestion\u0026lsquo;da tanımlanan \u0026ldquo;Gerçek Zamanlı İletişim için Google Tıkanıklık Kontrol Algoritması\u0026quot;dır.\nGCC\u0026rsquo;ye birkaç alternatif vardır, örneğin NADA: Gerçek Zamanlı Medya için Birleşik Tıkanıklık Kontrol Şeması ve SCReAM - Multimedya için Kendi Kendine Saatli Hız Adaptasyonu.\n"},{"id":6,"href":"/tr/docs/07-data-communication/","title":"Veri İletişimi","section":"Docs","content":" Veri İletişimi # WebRTC\u0026rsquo;nin veri iletişiminden ne elde ederim? # WebRTC, veri iletişimi için veri kanalları sağlar. İki eş arasında 65.534 veri kanalı açabilirsiniz. Veri kanalı datagram tabanlıdır ve her birinin kendi dayanıklılık ayarları vardır. Varsayılan olarak, her veri kanalının garantili sıralı teslimatı vardır.\nWebRTC\u0026rsquo;ye medya geçmişinden yaklaşıyorsanız veri kanalları savurgan görünebilir. HTTP veya WebSocket\u0026rsquo;leri kullanabileceğim zaman neden bu alt sisteme ihtiyacım var?\nVeri kanallarının gerçek gücü, onları sırasız/kayıplı teslimatla UDP gibi davranacak şekilde yapılandırabilmenizdir. Bu, düşük gecikme ve yüksek performans durumları için gereklidir. Backpressure\u0026rsquo;ı ölçebilir ve sadece ağınızın desteklediği kadar gönderdüğinizden emin olabilirsiniz.\nNasıl çalışır? # WebRTC, RFC 4960\u0026rsquo;ta tanımlanan Stream Control Transmission Protocol (SCTP) kullanır. SCTP, TCP veya UDP\u0026rsquo;ye alternatif olarak amaçlanan bir aktarım katmanı protokolüdür. WebRTC için bunu DTLS bağlantımız üzerinde çalışan bir uygulama katmanı protokolü olarak kullanırız.\nSCTP size akışlar verir ve her akış bağımsız olarak yapılandırılabilir. WebRTC veri kanalları bunların etrafındaki ince soyutlamalardır. Dayanıklılık ve sıralama etrafındaki ayarlar doğrudan SCTP Ajanına aktarılır.\nVeri kanallarının SCTP\u0026rsquo;nin ifade edemeyeceği bazı özellikleri vardır, örneğin kanal etiketleri. Bunu çözmek için WebRTC, RFC 8832\u0026lsquo;de tanımlanan Data Channel Establishment Protocol (DCEP) kullanır. DCEP, kanal etiketi ve protokolünü iletmek için bir mesaj tanımlar.\nDCEP # DCEP\u0026rsquo;in sadece iki mesajı vardır: DATA_CHANNEL_OPEN ve DATA_CHANNEL_ACK. Açılan her veri kanalı için uzak tarafın bir ack ile yanıt vermesi gerekir.\nDATA_CHANNEL_OPEN # Bu mesaj, kanal açmak isteyen WebRTC Ajanı tarafından gönderilir.\nPaket Formatı # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | Channel Type | Priority | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reliability Parameter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Label Length | Protocol Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Label / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Protocol / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Message Type # Message Type, 0x03\u0026lsquo;ün statik değeridir.\nChannel Type # Channel Type, kanalın dayanıklılık/sıralama özelliklerini kontrol eder. Aşağıdaki değerlere sahip olabilir:\nDATA_CHANNEL_RELIABLE (0x00) - Hiçbir mesaj kaybolmaz ve sırayla gelir DATA_CHANNEL_RELIABLE_UNORDERED (0x80) - Hiçbir mesaj kaybolmaz, ancak sıra dışı gelebilirler. DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT (0x01) - İstenen sayıda denedikten sonra mesajlar kaybolabilir, ancak sırayla gelirler. DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED (0x81) - İstenen sayıda denedikten sonra mesajlar kaybolabilir ve sıra dışı gelebilirler. DATA_CHANNEL_PARTIAL_RELIABLE_TIMED (0x02) - İstenen sürede gelmezlerse mesajlar kaybolabilir, ancak sırayla gelirler. DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED (0x82) - İstenen sürede gelmezlerse mesajlar kaybolabilir ve sıra dışı gelebilirler. Priority # Veri kanalının önceliği. Daha yüksek önceliğe sahip veri kanalları önce planlanacaktır. Büyük düşük öncelikli kullanıcı mesajları, yüksek öncelikli kullanıcı mesajlarının gönderimini geciktirmeyecektir.\nReliability Parameter # Veri kanalı türü DATA_CHANNEL_PARTIAL_RELIABLE ise, sonekler davranışı yapılandırır:\nREXMIT - Gönderenin vazgeçmeden önce mesajı kaç kez yeniden göndereceğini tanımlar. TIMED - Gönderenin vazgeçmeden önce mesajı ne kadar süre (ms cinsinden) yeniden göndereceğini tanımlar. Label # Veri kanalının adını içeren UTF-8 kodlu string. Bu string boş olabilir.\nProtocol # Bu boş bir string ise, protokol belirtilmemiştir. Boş olmayan bir string ise, RFC 6455\u0026rsquo;te tanımlanan \u0026ldquo;WebSocket Subprotocol Name Registry\u0026rdquo;\u0026lsquo;de kayıtlı bir protokol belirtmelidir.\nDATA_CHANNEL_ACK # Bu mesaj, bu veri kanalının açıldığını kabul etmek için WebRTC Ajanı tarafından gönderilir.\nPaket Formatı # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | +-+-+-+-+-+-+-+-+ Stream Control Transmission Protocol # SCTP, WebRTC veri kanallarının arkasındaki gerçek güçtür. Veri kanalının tüm bu özelliklerini sağlar:\nMultiplexing TCP benzeri yeniden iletim mekanizması kullanarak güvenilir teslimat Kısmi güvenilirlik seçenekleri Tıkanıklık Önleme Akış Kontrolü SCTP\u0026rsquo;yi anlamak için onu üç bölümde inceleyeceğiz. Amaç, bu bölümden sonra SCTP\u0026rsquo;yi hata ayıklamak ve derin detaylarını kendi başınıza öğrenmek için yeterince bilmenizdir.\nKavramlar # SCTP özellik bakımından zengin bir protokoldür. Bu bölüm sadece WebRTC tarafından kullanılan SCTP bölümlerini kapsayacaktır. WebRTC tarafından kullanılmayan SCTP\u0026rsquo;deki özellikler multi-homing ve yol seçimini içerir.\nYirmi yılı aşkın geliştirme ile SCTP\u0026rsquo;yi tam olarak kavramak zor olabilir.\nAssociation # Association, SCTP Oturumu için kullanılan terimdir. İki SCTP Ajanının iletişim halindeyken paylaştığı durumdur.\nStreams # Stream, tek yönlü kullanıcı verisi dizisidir. Veri kanalı oluşturduğunuzda aslında sadece SCTP stream oluşturuyorsunuz. Her SCTP Association, stream\u0026rsquo;lerin bir listesini içerir. Her stream farklı güvenilirlik türleri ile yapılandırılabilir.\nWebRTC sadece stream oluşturma sırasında yapılandırmanıza izin verir, ancak SCTP aslında yapılandırmayı istediğiniz zaman değiştirmeye izin verir.\nDatagram Based # SCTP verileri datagram olarak çerçeveler ve byte stream olarak değil. Veri gönderme ve alma TCP yerine UDP kullanmak gibi hissedilir. Tek stream üzerinden birden fazla dosya aktarmak için herhangi bir ekstra kod eklemeniz gerekmez.\nSCTP mesajlarının UDP gibi boyut sınırları yoktur. Tek bir SCTP mesajı boyut olarak birden fazla gigabayt olabilir.\nChunks # SCTP protokolü chunk\u0026rsquo;lardan oluşur. Birçok farklı chunk türü vardır. Bu chunk\u0026rsquo;lar tüm iletişim için kullanılır. Kullanıcı verisi, bağlantı başlatma, tıkanıklık kontrolü ve daha fazlası chunk\u0026rsquo;lar aracılığıyla yapılır.\nHer SCTP paketi chunk\u0026rsquo;ların bir listesini içerir. Böylece bir UDP paketinde farklı stream\u0026rsquo;lerden mesajlar taşıyan birden fazla chunk\u0026rsquo;ınız olabilir.\nTransmission Sequence Number # Transmission Sequence Number (TSN), DATA chunk\u0026rsquo;ları için global benzersiz tanımlayıcıdır. DATA chunk, kullanıcının göndermek istediği tüm mesajları taşıyan şeydir. TSN önemlidir çünkü alıcının paketlerin kayıp olup olmadığını veya sıra dışı olup olmadığını belirlemesine yardımcı olur.\nAlıcı eksik bir TSN fark ederse, yerine gelinene kadar veriyi kullanıcıya vermez.\nStream Identifier # Her stream\u0026rsquo;in benzersiz bir tanımlayıcısı vardır. Açık ID ile veri kanalı oluşturduğunuzda, aslında doğrudan SCTP\u0026rsquo;ye stream identifier olarak aktarılır. ID geçmezseniz stream identifier sizin için seçilir.\nPayload Protocol Identifier # Her DATA chunk\u0026rsquo;ının ayrıca bir Payload Protocol Identifier (PPID) vardır. Bu, ne tür verinin değiş tokuş edildiğini benzersiz şekilde tanımlamak için kullanılır. SCTP\u0026rsquo;nin birçok PPID\u0026rsquo;si vardır, ancak WebRTC sadece aşağıdaki beşini kullanır:\nWebRTC DCEP (50) - DCEP mesajları. WebRTC String (51) - DataChannel string mesajları. WebRTC Binary (53) - DataChannel binary mesajları. WebRTC String Empty (56) - 0 uzunluklu DataChannel string mesajları. WebRTC Binary Empty (57) - 0 uzunluklu DataChannel binary mesajları. Protokol # Aşağıdakiler SCTP protokolü tarafından kullanılan chunk\u0026rsquo;lardan bazılarıdır. Bu kapsamlı bir gösteri değildir. State machine\u0026rsquo;in anlamlı olması için yeterli yapıları sağlar.\nHer Chunk bir type alanı ile başlar. Chunk\u0026rsquo;ların listesinden önce, ayrıca bir header\u0026rsquo;ınız olacaktır.\nDATA Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 0 | Reserved|U|B|E| Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | TSN | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Stream Identifier | Stream Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload Protocol Identifier | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / User Data / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ DATA chunk, tüm kullanıcı verisinin nasıl değiş tokuş edildiğidir. Veri kanalı üzerinden herhangi bir şey gönderdiğinizde, bu şekilde değiş tokuş edilir.\nINIT Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 1 | Chunk Flags | Chunk Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Initiate Tag | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Advertised Receiver Window Credit (a_rwnd) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Number of Outbound Streams | Number of Inbound Streams | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Initial TSN | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Optional/Variable-Length Parameters / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ INIT chunk, association oluşturma sürecini başlatır.\nSACK Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 3 |Chunk Flags | Chunk Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Cumulative TSN Ack | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Advertised Receiver Window Credit (a_rwnd) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Number of Gap Ack Blocks = N | Number of Duplicate TSNs = X | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ SACK (Selective Acknowledgment) Chunk, alıcının gönderene paket aldığını nasıl bildirdiğidir.\nState Machine # Bunlar SCTP state machine\u0026rsquo;inin bazı ilginç bölümleridir. WebRTC, SCTP state machine\u0026rsquo;inin tüm özelliklerini kullanmaz.\nConnection Establishment Flow # INIT ve INIT ACK chunk\u0026rsquo;ları, her eşin yetenek ve yapılandırmalarını değiş tokuş etmek için kullanılır.\nKeep-Alive Mechanism # SCTP, bağlantıyı canlı tutmak için HEARTBEAT REQUEST ve HEARTBEAT ACK parçacıklarını kullanır. Bu parçacıklar, yapılandırılabilir bir aralıkla gönderilir. Ayrıca, SCTP bir paket ulaşmadığında üssel geri çekilme (exponential backoff) uygular.\nHEARTBEAT parçacığı ayrıca bir zaman değeri içerir. Bu, iki bağlantının (association) iki uç nokta arasındaki seyahat süresini (trip time) hesaplamasını sağlar.\n"},{"id":7,"href":"/tr/docs/08-applied-webrtc/","title":"Uygulamalı WebRTC","section":"Docs","content":" Uygulamalı WebRTC # Artık WebRTC\u0026rsquo;nin nasıl çalıştığını bildiğinize göre, onunla geliştirme zamanı! Bu bölüm insanların WebRTC ile ne geliştirdiğini ve nasıl geliştirdiğini araştırıyor. WebRTC ile olan tüm ilginç gelişmeleri öğreneceksiniz. WebRTC\u0026rsquo;nin gücü bir bedelle gelir. Üretim kalitesi WebRTC hizmetleri geliştirmek zorludur. Bu bölüm size bu zorlukları karşılaşmadan önce açıklamaya çalışacaktır.\nKullanım Durumuna Göre # Birçoğu WebRTC\u0026rsquo;nin sadece web tarayıcısında konferans için bir teknoloji olduğunu düşünür. Ama çok daha fazlasıdır! WebRTC geniş bir uygulama yelpazesinde kullanılır. Yeni kullanım durumları sürekli ortaya çıkıyor. Bu bölümde bazı yaygın olanları ve WebRTC\u0026rsquo;nin bunları nasıl devrimleştirdiğini listeleyeceğiz.\nKonferans # Konferans WebRTC\u0026rsquo;nin orijinal kullanım durumudur. Protokol, tarayıcıda başka hiçbir protokolün sunmadığı birkaç gerekli özellik içerir. WebSocket\u0026rsquo;lerle bir konferans sistemi geliştirebilirsiniz ve optimal koşullarda çalışabilir. Gerçek dünya ağ koşullarında dağıtılabilecek bir şey istiyorsanız, WebRTC en iyi seçenektir.\nWebRTC medya için tıkanıklık kontrolü ve uyarlanabilir bit hızı sağlar. Ağın koşulları değiştikçe, kullanıcılar yine de mümkün olan en iyi deneyimi alacaktır. Geliştiricilerin bu koşulları ölçmek için herhangi bir ek kod yazması da gerekmez.\nKatılımcılar birden fazla akış gönderip alabilir. Ayrıca çağrı sırasında istediği zaman bu akışları ekleyip çıkarabilirler. Codec\u0026rsquo;ler de müzakere edilir. Tüm bu işlevsellik tarayıcı tarafından sağlanır, geliştirici tarafından özel kod yazılması gerekmez.\nKonferans ayrıca veri kanallarından da yararlanır. Kullanıcılar metadata gönderebilir veya belge paylaşabilir. Güvenilirlikten çok performansa ihtiyacınız varsa birden fazla akış oluşturabilir ve bunları yapılandırabilirsiniz.\nYayıncılık # WebRTC kullanan yayın alanında birçok yeni proje ortaya çıkmaya başladı. Protokol hem medya yayıncısı hem de tüketicisi için çok şey sunuyor.\nWebRTC\u0026rsquo;nin tarayıcıda olması kullanıcıların video yayınlamasını kolaylaştırır. Kullanıcıların yeni bir istemci indirme gereksinimini ortadan kaldırır. Web tarayıcısına sahip herhangi bir platform video yayınlayabilir. Yayıncılar daha sonra birden fazla parça gönderebilir ve bunları istediği zaman değiştirebilir veya kaldırabilir. Bu, bağlantı başına sadece bir ses veya bir video parçasına izin veren eski protokollere göre büyük bir gelişmedir.\nWebRTC geliştiricilere gecikme ve kalite ödünleşimleri üzerinde daha fazla kontrol verir. Gecikmenin asla belirli bir eşiği aşmaması daha önemliyse ve bazı dekodlama hatalarını tolere etmeye istekliyseniz. Görüntüleyiciyi medyayı gelir gelmez oynatacak şekilde yapılandırabilirsiniz. TCP üzerinden çalışan diğer protokollerle bu o kadar kolay değildir. Tarayıcıda veri isteyebilirsiniz ve o kadar.\nUzaktan Erişim # Uzaktan Erişim, WebRTC aracılığıyla başka bir bilgisayara uzaktan erişmektir. Uzak ana makinenin tam kontrolüne sahip olabilir veya belki sadece tek bir uygulamaya. Bu, yerel donanım yapamadığında hesaplama açısından pahalı görevleri çalıştırmak için harikadır. Yeni bir video oyunu veya CAD yazılımı çalıştırmak gibi. WebRTC alanı üç şekilde devrimleştirebildi.\nWebRTC, dünya routable olmayan bir ana makineye uzaktan erişmek için kullanılabilir. NAT Geçişi ile sadece STUN aracılığıyla erişilebilen bir bilgisayara erişebilirsiniz. Bu güvenlik ve gizlilik için harikadır. Kullanıcılarınızın videoyu bir girdi veya \u0026ldquo;jump box\u0026rdquo; üzerinden yönlendirmesi gerekmez. NAT Geçişi ayrıca dağıtımları kolaylaştırır. Önceden port yönlendirme veya statik IP kurma konusunda endişelenmenize gerek yok.\nVeri kanalları da bu senaryoda gerçekten güçlüdür. Sadece en son verinin kabul edilecek şekilde yapılandırılabilirler. TCP ile Head-of-line blocking ile karşılaşma riski yaşarsınız. Eski bir fare tıklaması veya tuş basımı geç gelebilir ve sonraki olanların kabul edilmesini engelleyebilir. WebRTC\u0026rsquo;nin veri kanalları bunu ele almak için tasarlanmıştır ve kayıp paketleri yeniden göndermeyecek şekilde yapılandırılabilir. Ayrıca geri basıncı ölçebilir ve ağınızın desteklediğinden fazla veri göndermediğinizden emin olabilirsiniz.\nWebRTC\u0026rsquo;nin tarayıcıda mevcut olması büyük bir yaşam kalitesi gelişimi olmuştur. Oturumu başlatmak için özel bir istemci indirmeniz gerekmez. Giderek daha fazla istemci WebRTC ile birlikte geliyor, akıllı TV\u0026rsquo;ler artık tam web tarayıcıları alıyor.\nDosya Paylaşımı ve Sansür Aşma # Dosya Paylaşımı ve Sansür Aşma dramatik olarak farklı problemlerdir. Ancak WebRTC her ikisi için de aynı problemleri çözer. Her ikisini de kolayca erişilebilir hale getirir ve engellenmesi daha zor hale getirir.\nWebRTC\u0026rsquo;nin çözdüğü ilk problem istemciyi almaktır. Bir dosya paylaşım ağına katılmak istiyorsanız, istemciyi indirmeniz gerekir. Ağ dağıtılmış olsa bile yine de önce istemciyi almanız gerekir. Kısıtlı bir ağda indirme genellikle engellenecektir. İndirebilseniz bile kullanıcı istemciyi kurup çalıştıramayabilir. WebRTC her web tarayıcısında zaten mevcut olduğu için kolayca erişilebilir.\nWebRTC\u0026rsquo;nin çözdüğü ikinci problem trafiğinizin engellenmesidir. Sadece dosya paylaşımı veya sansür aşma için bir protokol kullanırsanız engellenmesi çok daha kolaydır. WebRTC genel amaçlı bir protokol olduğundan, onu engellemek herkesi etkiler. WebRTC\u0026rsquo;yi engellemek ağın diğer kullanıcılarının konferans görüşmelerine katılmasını engelleyebilir.\nNesnelerin İnterneti # Nesnelerin İnterneti (IoT) birkaç farklı kullanım durumunu kapsar. Birçoğu için bu ağa bağlı güvenlik kameraları anlamına gelir. WebRTC kullanarak videoyu telefonunuz veya tarayıcı gibi başka bir WebRTC eşine aktarabilirsiniz. Başka bir kullanım durumu cihazların bağlanıp sensör verilerini değiş tokuş etmesidir. LAN\u0026rsquo;ınızdaki iki cihazın iklim, gürültü veya ışık okumalarını değiş tokuş etmesini sağlayabilirsiniz.\nWebRTC\u0026rsquo;nin burada eski video akış protokollerine göre büyük bir gizlilik avantajı vardır. WebRTC P2P bağlantısını desteklediğinden kamera videoyu doğrudan tarayıcınıza gönderebilir. Videonuzun 3. taraf sunucuya gönderilmesi için hiçbir neden yoktur. Video şifreli olsa bile, saldırgan çağrının metadata\u0026rsquo;sından varsayımlarda bulunabilir.\nBirlikte çalışabilirlik IoT alanı için başka bir avantajdır. WebRTC birçok farklı dilde mevcuttur; C#, C++, C, Go, Java, Python, Rust ve TypeScript. Bu sizin için en iyi işleyen dili kullanabileceğiniz anlamına gelir. Ayrıca istemcilerinizi bağlayabilmek için özel protokollere veya formatlara yönelmenize gerek yoktur.\nMedya Protokol Köprüleme # Mevcut donanımınız ve yazılımınız video üretiyor, ancak henüz yükseltemiyor. Kullanıcıların video izlemek için özel bir istemci indirmesini beklemek sinir bozucudur. Cevap bir WebRTC köprüsü çalıştırmaktır. Köprü iki protokol arasında çeviri yapar böylece kullanıcılar eski kurulumunuzla tarayıcıyı kullanabilir.\nGeliştiricilerin köprülediği formatların çoğu WebRTC ile aynı protokolleri kullanır. SIP yaygın olarak WebRTC aracılığıyla açığa çıkarılır ve kullanıcıların tarayıcılarından telefon aramaları yapmalarına izin verir. RTSP birçok eski güvenlik kamerasında kullanılır. Her ikisi de aynı temel protokolleri (RTP ve SDP) kullanır bu yüzden çalıştırması hesaplama açısından ucuzdur. Köprü sadece WebRTC\u0026rsquo;ye özgü şeyleri eklemek veya çıkarmak için gereklidir.\nVeri Protokol Köprüleme # Bir web tarayıcısı sadece kısıtlı bir protokol setini konuşabilir. HTTP, WebSocket\u0026rsquo;ler, WebRTC ve QUIC kullanabilirsiniz. Başka bir şeye bağlanmak istiyorsanız, bir protokol köprüsü kullanmanız gerekir. Protokol köprüsü yabancı trafiği tarayıcının erişebileceği bir şeye dönüştüren bir sunucudur. Popüler bir örnek tarayıcınızdan SSH kullanarak bir sunucuya erişmektir. WebRTC\u0026rsquo;nin veri kanalları rakiplerine göre iki avantaja sahiptir.\nWebRTC\u0026rsquo;nin veri kanalları güvenilmez ve sırasız teslimat sağlar. Düşük gecikmenin kritik olduğu durumlarda bu gereklidir. Yeni verilerin eski veriler tarafından engellenmesini istemezsiniz, bu head-of-line blocking olarak bilinir. Çok oyunculu bir First-person shooter oynadığınızı hayal edin. Oyuncunun iki saniye önce nerede olduğunu gerçekten umursayor musunuz? Bu veri zamanında gelmediysе, göndermeye devam etmenin anlamı yoktur. Güvenilmez ve sırasız teslimat verileri gelir gelmez kullanmanıza izin verir.\nVeri kanalları ayrıca geri bildirim basıncı sağlar. Bu size bağlantınızın destekleyebileceğinden daha hızlı veri gönderip göndermediğinizi söyler. Bu durumda iki seçeneğiniz vardır. Veri kanalı verileri tamponlayacak ve geç teslim edecek şekilde yapılandırılabilir veya gerçek zamanda gelmemiş verileri düşürebilirsiniz.\nTeleoperasyon # Teleoperasyon WebRTC veri kanalları aracılığıyla bir cihazı uzaktan kontrol etme ve videoyu RTP aracılığıyla geri gönderme eylemidir. Geliştiriciler bugün WebRTC aracılığıyla arabaları uzaktan kullanıyor! Bu inşaat sahalarında robotları kontrol etmek ve paket teslim etmek için kullanılıyor. Bu problemler için WebRTC kullanmak iki nedenden dolayı mantıklıdır.\nWebRTC\u0026rsquo;nin yaygınlığı kullanıcılara kontrol vermeyi kolaylaştırır. Kullanıcının ihtiyacı olan tek şey bir web tarayıcısı ve bir girdi cihazıdır. Tarayıcılar joystick ve gamepad\u0026rsquo;lerden girdi almayı bile destekler. WebRTC kullanıcının cihazına ek istemci kurma ihtiyacını tamamen ortadan kaldırır.\nDağıtılmış CDN # Dağıtılmış CDN\u0026rsquo;ler dosya paylaşımının bir alt kümesidir. Dağıtılan dosyalar bunun yerine CDN operatörü tarafından yapılandırılır. Kullanıcılar CDN ağına katıldıklarında izin verilen dosyaları indirebilir ve paylaşabilirler. Kullanıcılar dosya paylaşımı ile aynı tüm faydaları alır.\nBu CDN\u0026rsquo;ler kötü dış bağlantıya sahip ancak harika LAN bağlantısına sahip bir ofisteyken harika çalışır. Bir kullanıcının video indirmesini ve sonra herkesle paylaşmasını sağlayabilirsiniz. Herkes aynı dosyayı dış ağ üzerinden almaya çalışmadığından, aktarım daha hızlı tamamlanacaktır.\nWebRTC Topolojileri # WebRTC iki aracıyı bağlamaya yönelik bir protokoldür, peki geliştiriciler aynı anda yüzlerce insanı nasıl bağlıyor? Bunu yapmanın birkaç farklı yolu vardır ve hepsinin artıları ve eksileri vardır. Bu çözümler geniş olarak iki kategoriye ayrılır; Eşten-Eşe veya İstemci/Sunucu. WebRTC\u0026rsquo;nin esnekliği her ikisini de yaratmamıza olanak tanır.\nBire-Bir # Bire-Bir WebRTC ile kullanacağınız ilk bağlantı türüdür. İki WebRTC Aracısını doğrudan bağlarsınız ve çift yönlü medya ve veri gönderebilirler.\nTam Mesh # Tam Mesh, bire-bir modelin mantıksal uzantısıdır. Her WebRTC Aracısı diğer tüm WebRTC Aracılarıyla doğrudan bağlantı kurar. Büyük bir çok noktaya yayında her üye diğer tüm üyelere doğrudan gönderir.\nTam Mesh avantajları şunlardır:\nMinimum Gecikme - Medya direkt olarak gönderilir, hiçbir aracı sunucu yoktur. Gelişmiş Gizlilik - Medya sunuculardan geçmez. Tam Mesh dezavantajları şunlardır:\nSınırlı Ölçeklendirme - Her bir eş, oturumdaki her bir diğer eş için medya kodlaması ve karşıya yükleme yapmalıdır. Tam Mesh genellikle 4 kişiden az olan küçük konferanslar için kullanılır.\nHibrit Mesh # Hibrit Mesh, Tam Mesh ile aynı teknolojide çalışır ancak her eş her eşle bağlanmaz. Bu tasarım medya kalitesini artırmak için de kullanılabilir. Yüksek bant genişliğine sahip olmayan eşler düşük kalite akışı sağlayabilir.\nHibrit Mesh avantajları şunlardır:\nKonfigürasyona uygun ölçeklendirme - Ağın karmaşıklığını kontrol edebilirsiniz. Gelişmiş Gizlilik - Medya sunuculardan geçmez. Hibrit Mesh dezavantajları şunlardır:\nKarmaşık sinyalleşme - Konfigürasyonunuz ne kadar karmaşık olursa karar vermeniz o kadar zor olur. Seçici Yönlendirme Birimi # Seçici Yönlendirme Birimi (SFU), her eşin kendi medyasını merkezi sunucuya gönderdiği ve daha sonra sunucunun her eşe hangi medya akışını alacağını belirlediği bir topolojidir. Bu tipik olarak her eş için birden fazla kodlama sağlanarak (simulcast) ve her bir alıcının tercihine/yeteneğine göre en uygun kodlama seçilerek yapılır.\nSFU avantajları şunlardır:\nVerimli Bant Genişliği Kullanımı - Her eş medyasını yalnızca bir kez karşıya yükler. Heterojen İstemci Desteği - SFU her alıcı için optimal medya akışını seçebilir. Gelişmiş Gizlilik - Medya sunucu tarafından incelenmez yalnızca yönlendirilir. SFU dezavantajları şunlardır:\nDaha Fazla Gecikme - Medya artık peer-to-peer değil, bir sunucu üzerinden geçiyor. Çok Nokta Konferans Birimi # Çok Nokta Konferans Birimi (MCU), tüm eşlerin kendi medyasını merkezi sunucuya gönderdiği ve daha sonra sunucunun tüm akışları tek bir medya akışında birleştirdiği topolojidir. Her katılımcı sadece bu karışık medya akışını alır.\nMCU avantajları şunlardır:\nVerimli İndirme Bant Genişliği - Her eş sadece tek bir video alır. Heterojen İstemci Desteği - MCU\u0026rsquo;nun hedeflediği düşük güçlü cihazları destekleyebilir. MCU dezavantajları şunlardır:\nKayıplı İşlem - Çünkü medya yeniden kodlanıyor, orijinal kalitesi kaybediliyor. Artan Gecikme - Medya işlem için zaman alır. Gizlilik Yok - Medya MCU tarafından incelenir ve işlenir. Bu CDN\u0026rsquo;ler zayıf dış bağlantıya sahip ancak harika LAN bağlantısına sahip bir ofisteyken harika çalışır. Bir kullanıcının video indirmesini ve daha sonra herkesle paylaşmasını sağlayabilirsiniz. Herkes aynı dosyayı dış ağ üzerinden almaya çalışmadığından, aktarım daha hızlı tamamlanacaktır.\nWebRTC Topolojileri # WebRTC iki ajanı bağlamak için bir protokoldür, peki geliştiriciler aynı anda yüzlerce kişiyi nasıl bağlıyor? Bunu yapmanın birkaç farklı yolu vardır ve hepsinin artıları ve eksileri vardır. Bu çözümler genel olarak iki kategoriye ayrılır; Eşten-Eşe veya İstemci/Sunucu. WebRTC\u0026rsquo;nin esnekliği her ikisini de oluşturmamıza izin verir.\nBirden-Bire # Birden-Bire WebRTC ile kullanacağınız ilk bağlantı türüdür. İki WebRTC Ajanını doğrudan bağlarsınız ve çift yönlü medya ve veri gönderebilirler. Bağlantı şöyle görünür.\nTam Mesh # Tam mesh bir konferans görüşmesi veya çok oyunculu oyun geliştirmek istiyorsanız cevaptır. Bu topolojide her kullanıcı doğrudan diğer her kullanıcıyla bağlantı kurar. Bu uygulamanızı geliştirmenize izin verir, ancak bazı dezavantajları da vardır.\nTam Mesh topolojisinde her kullanıcı doğrudan bağlıdır. Bu, çağrının her üyesi için bağımsız olarak video kodlamanız ve yüklemeniz gerektiği anlamına gelir. Her bağlantı arasındaki ağ koşulları farklı olacaktır, bu yüzden aynı videoyu yeniden kullanamazsınız. Bu dağıtımlarda hata işleme de zordur. Tam bağlantıyı mı kaybettiğinizi yoksa sadece bir uzak eşle bağlantıyı mı kaybettiğinizi dikkatli bir şekilde değerlendirmeniz gerekir.\nBu endişeler nedeniyle, Tam Mesh en iyi küçük gruplar için kullanılır. Daha büyük herhangi bir şey için istemci/sunucu topolojisi en iyisidir.\nHibrit Mesh # Hibrit Mesh, Tam Mesh\u0026rsquo;in bazı sorunlarını hafifletebilen Tam Mesh\u0026rsquo;e bir alternatiftir. Hibrit Mesh\u0026rsquo;te her kullanıcı arasında bağlantı kurulmaz. Bunun yerine medya ağdaki eşler aracılığıyla aktarılır. Bu medya yaratıcısının medyayı dağıtmak için o kadar fazla bant genişliği kullanması gerekmediği anlamına gelir.\nBunun bazı dezavantajları vardır. Bu kurulumda medyanın orijinal yaratıcısının videosunun kime gönderildiği veya başarıyla ulaşıp ulaşmadığı hakkında hiçbir fikri yoktur. Ayrıca Hibrit Mesh ağınızdaki her atlama ile gecikme artışı yaşayacaksınız.\nSeçici Yönlendirme Birimi # Bir SFU (Seçici Yönlendirme Birimi) de Tam Mesh\u0026rsquo;in sorunlarını çözer, ancak tamamen farklı bir şekilde. SFU, P2P yerine istemci/sunucu topolojisi uygular. Her WebRTC eşi SFU\u0026rsquo;ya bağlanır ve medyasını yükler. SFU daha sonra bu medyayı her bağlı istemciye iletir.\nSFU ile her WebRTC Ajanının videosunu sadece bir kez kodlaması ve yüklemesi gerekir. Tüm görüntüleyicilere dağıtma yükü SFU\u0026rsquo;dadır. SFU ile bağlantı da P2P\u0026rsquo;den çok daha kolaydır. Dünya routable adresinde bir SFU çalıştırabilirsiniz, bu da istemcilerin bağlanmasını çok daha kolay hale getirir. NAT Eşlemeleri konusunda endişelenmenize gerek yoktur. Yine de SFU\u0026rsquo;nuzun TCP aracılığıyla erişilebilir olduğundan emin olmanız gerekir (ICE-TCP veya TURN aracılığıyla).\nBasit bir SFU bir hafta sonunda yapılabilir. Her türlü istemciyi kaldırabilen iyi bir SFU geliştirmek hiç bitmez. Tıkanıklık Kontrolü, Hata Düzeltme ve Performansı ayarlamak hiç bitmeyen bir görevdir.\nMCU # MCU (Çok Nokta Konferans Birimi) SFU gibi istemci/sunucu topolojisidir, ancak çıktı akışlarını birleştirir. Giden medyayı değiştirilmeden dağıtmak yerine bunları tek bir beslem olarak yeniden kodlar.\n"},{"id":8,"href":"/tr/docs/09-debugging/","title":"Hata Ayıklama","section":"Docs","content":" Hata Ayıklama # WebRTC hata ayıklama göz korkutucu bir görev olabilir. Çok sayıda hareketli parça vardır ve hepsi bağımsız olarak bozulabilir. Dikkatli olmazsanız, yanlış şeylere bakarak haftalar kaybedebilirsiniz. Sonunda bozuk olan kısmı bulduğunuzda, nedenini anlamak için biraz öğrenmeniz gerekecek.\nBu bölüm sizi WebRTC hata ayıklama zihniyetine sokacaktır. Size problemi nasıl parçalara ayıracağınızı gösterecektir. Problemi öğrendikten sonra, popüler hata ayıklama araçlarının hızlı bir turunu vereceğiz.\nProblemi İzole Edin # Hata ayıklama yaparken, sorunun nereden geldiğini izole etmeniz gerekir. Başlangıçtan başlayın\u0026hellip;\nSinyalleşme Hatası # Ağ Hatası # STUN sunucunuzu netcat kullanarak test edin:\n20-byte bağlama istek paketini hazırlayın:\necho -ne \u0026#34;\\x00\\x01\\x00\\x00\\x21\\x12\\xA4\\x42TESTTESTTEST\u0026#34; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 Yorumlama:\n00 01 mesaj türüdür. 00 00 veri bölümünün uzunluğudur. 21 12 a4 42 sihirli çerezdır. ve 54 45 53 54 54 45 53 54 54 45 53 54 (ASCII\u0026rsquo;ye dekod edildiğinde: TESTTESTTEST) 12-byte işlem ID\u0026rsquo;sidir. İsteği gönderin ve 32 byte yanıtı bekleyin:\nstunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne \u0026#34;\\x00\\x01\\x00\\x00\\x21\\x12\\xA4\\x42TESTTESTTEST\u0026#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C 00000000 01 01 00 0c 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 00 20 00 08 00 01 6f 32 7f 36 de 89 |TEST. ....o2.6..| 00000020 Yorumlama:\n01 01 mesaj türüdür 00 0c veri bölümünün uzunluğudur (ondalık olarak 12\u0026rsquo;ye dekod edilir) 21 12 a4 42 sihirli çerezdır ve 54 45 53 54 54 45 53 54 54 45 53 54 (ASCII\u0026rsquo;ye dekod edildiğinde: TESTTESTTEST) 12-byte işlem ID\u0026rsquo;sidir. 00 20 00 08 00 01 6f 32 7f 36 de 89 12-byte veridir, yorumlama: 00 20 tür: XOR-MAPPED-ADDRESS 00 08 değer bölümünün uzunluğudur (ondalık olarak 8\u0026rsquo;e dekod edilir) 00 01 6f 32 7f 36 de 89 veri değeridir, yorumlama: 00 01 adres türüdür (IPv4) 6f 32 XOR-eşlenen porttur 7f 36 de 89 XOR-eşlenen IP adresidir XOR-eşlenen bölümü dekod etmek zahmetlidir, ancak 00 00 00 00\u0026lsquo;a ayarlanmış (geçersiz) sahte sihirli çerez sağlayarak stun sunucusunu sahte XOR-eşleme gerçekleştirmesi için kandırabiliriz:\nstunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne \u0026#34;\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00TESTTESTTEST\u0026#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C 00000000 01 01 00 0c 00 00 00 00 54 45 53 54 54 45 53 54 |........TESTTEST| 00000010 54 45 53 54 00 01 00 08 00 01 4e 20 5e 24 7a cb |TEST......N ^$z.| 00000020 Sahte sihirli çereze karşı XOR yapmak idempotanttır, bu yüzden port ve adres yanıtta açık olacaktır. Bu tüm durumlarda çalışmayacaktır, çünkü bazı router\u0026rsquo;lar geçen paketleri manipüle eder, IP adresinde hile yapar. Döndürülen veri değerine (son sekiz byte) bakarsak:\n00 01 4e 20 5e 24 7a cb veri değeridir, yorumlama: 00 01 adres türüdür (IPv4) 4e 20 eşlenen porttur (ondalık olarak 20000\u0026rsquo;e dekod edilir) 5e 24 7a cb IP adresidir (noktalı ondalık notasyonda 94.36.122.203\u0026lsquo;e dekod edilir). Güvenlik Hatası # Medya Hatası # Veri Hatası # Mesleğin Araçları # netcat (nc) # netcat, TCP veya UDP kullanan ağ bağlantılarından okuma ve yazma için komut satırı ağ yardımcı programıdır. Genellikle nc komutu olarak mevcuttur.\ntcpdump # tcpdump komut satırı veri ağı paket analizörüdür.\nYaygın komutlar:\nPort 19302\u0026rsquo;ye gelen ve giden UDP paketlerini yakalayın, paket içeriğinin hexdump\u0026rsquo;ını yazdırın:\nsudo tcpdump 'udp port 19302' -xx\nAynısı, ancak paketleri daha sonra inceleme için PCAP (paket yakalama) dosyasına kaydedin:\nsudo tcpdump 'udp port 19302' -w stun.pcap\nPCAP dosyası Wireshark uygulamasıyla açılabilir: wireshark stun.pcap\nWireshark # Wireshark yaygın olarak kullanılan ağ protokol analizörüdür.\nWebRTC tarayıcı araçları # Tarayıcılar kurduğunuz bağlantıları incelemek için kullanabileceğiniz yerleşik araçlarla gelir. Chrome\u0026rsquo;da chrome://webrtc-internals ve chrome://webrtc-logs vardır. Firefox\u0026rsquo;ta about:webrtc vardır.\nGecikme # Yüksek gecikmeniz olduğunu nasıl bilirsiniz? Videonuzun gecikmeli olduğunu fark etmiş olabilirsiniz, ancak tam olarak ne kadar geciktiğini biliyor musunuz? Bu gecikmeyi azaltabilmek için önce onu ölçerek başlamanız gerekir.\nGerçek gecikme uçtan uca ölçülmesi beklenir. Bu, sadece gönderen ve alıcı arasındaki ağ yolunun gecikmesi değil, kamera yakalama, çerçeve kodlama, iletim, alma, dekodlama ve görüntüleme ile bu adımlardan herhangi biri arasında olası kuyruklama gecikmesinin birleşik gecikmesi anlamına gelir.\nUçtan uca gecikme, her bileşenin gecikmelerinin basit toplamı değildir.\nTeorik olarak canlı video iletim hattının bileşenlerinin gecikmesini ayrı ayrı ölçüp sonra bunları toplayabilseniz de, pratikte en azından bazı bileşenler ya enstrümantasyon için erişilemez olacak ya da hat dışında ölçüldüğünde önemli ölçüde farklı sonuçlar üretecektir. Hat aşamaları arasındaki değişken kuyruk derinlikleri, ağ topolojisi ve kamera pozlama değişiklikleri uçtan uca gecikmeyi etkileyen bileşenlerin sadece birkaç örneğidir.\nCanlı yayın sisteminizde her bileşenin içsel gecikmesi değişebilir ve aşağı akış bileşenlerini etkileyebilir. Yakalanan videonun içeriği bile gecikmeyi etkiler. Örneğin, ağaç dalları gibi yüksek frekans özellikler için, açık mavi gökyüzü gibi düşük frekanslıya kıyasla çok daha fazla bit gerekir. Otomatik pozlama açık olan kamera, yakalama hızı saniyede 30 kareye ayarlanmış olsa bile bir kareyi yakalamak için beklenen 33 milisaniyeden çok daha uzun sürebilir. Ağ üzerinden iletim, özellikle hücresel, değişen talep nedeniyle çok dinamiktir. Daha fazla kullanıcı havada daha fazla konuşma getirir. Fiziksel konumunuz (kötü şöhretli düşük sinyal bölgeleri) ve diğer birçok faktör paket kaybını ve gecikmeyi artırır. Teslimat için bir ağ arayüzüne, diyelim WiFi adaptörü veya LTE modeme paket gönderdiğinizde ne olur? Hemen teslim edilemezse arayüzde kuyruğa alınır, kuyruk ne kadar büyükse böyle ağ arayüzü o kadar gecikme getirir.\nManuel uçtan uca gecikme ölçümü # Uçtan uca gecikmeden bahsettiğimizde, bir olayın gerçekleşmesi ile gözlemlenmesi arasındaki zamanı kastediyoruz, yani video karelerinin ekranda görünmesi.\nUctanUcaGecikme = T(gözlemle) - T(gerçekleş) Naif yaklaşım, bir olayın gerçekleştiği zamanı kaydetmek ve bunu gözlem zamanından çıkarmaktır. Ancak, hassasiyet milisaniyelere düştüğünde zaman senkronizasyonu sorun haline gelir. Dağıtık sistemlerde saatleri senkronize etmeye çalışmak çoğunlukla boşunadır, zaman senkronizasyonundaki küçük bir hata bile güvenilmez gecikme ölçümü üretir.\nSaat senkronizasyon sorunları için basit bir geçici çözüm aynı saati kullanmaktır. Gönderen ve alıcıyı aynı referans çerçevesine koyun.\nMilisaniyelik tikan bir saatiniz veya gerçekten başka herhangi bir olay kaynağınız olduğunu hayal edin. Saati kameraya doğrultarak uzak ekrana canlı yayın yapan sistemde gecikmeyi ölçmek istiyorsunuz. Milisaniye zamanlayıcısının tiklemesi (Tgerçekleş) ile saatin video karelerinin ekranda görünmesi (Tgözlemle) arasındaki zamanı ölçmenin açık yolu şudur:\nKameranızı milisaniyelik saate doğrultun. Video karelerini aynı fiziksel konumda olan alıcıya gönderin. Milisaniyelik zamanlayıcının ve ekranda alınan videonun fotoğrafını çekin (telefonunuzu kullanın). İki zamanı çıkarın. Bu en gerçek uçtan uca gecikme ölçümüdür. Tüm bileşen gecikmelerini (kamera, kodlayıcı, ağ, dekoder) hesaba katar ve herhangi bir saat senkronizasyonuna dayanmaz.\n. Yukarıdaki fotoğrafta ölçülen uçtan uca gecikme 101 msn\u0026rsquo;dir. Şu anda gerçekleşen olay 10:16:02.862, ancak canlı yayın sistemi gözlemcisi 10:16:02.761\u0026rsquo;i görüyor.\nOtomatik uçtan uca gecikme ölçümü # Bu yazının yazıldığı tarih itibariyle (Mayıs 2021) uçtan uca gecikme için WebRTC standardı aktif olarak tartışılmaktadır. Firefox, kullanıcıların standart WebRTC API\u0026rsquo;lerinin üstünde otomatik gecikme ölçümü oluşturmalarına izin veren bir dizi API uyguladı. Ancak bu paragrafta, gecikmeyi otomatik olarak ölçmenin en uyumlu yolunu tartışıyoruz.\nGidiş-dönüş süresi özetle: Size zamanımı tR1 gönderiyorum, tR1\u0026lsquo;imi tR2 zamanında geri aldığımda, gidiş-dönüş süresinin tR2 - tR1 olduğunu biliyorum.\nGönderen ve alıcı arasında bir iletişim kanalı verildiğinde (örneğin DataChannel), alıcı aşağıdaki adımları izleyerek gönderenin monotonik saatini modelleyebilir:\ntR1 zamanında, alıcı yerel monotonik saat zaman damgası ile bir mesaj gönderir. Yerel zaman tS1 ile gönderene ulaştığında, gönderen tR1\u0026lsquo;in kopyası ile birlikte gönderenin tS1\u0026lsquo;i ve gönderenin video track zamanı tSV1\u0026lsquo;i ile yanıt verir. Alıcı tarafta tR2 zamanında, gidiş-dönüş süresi mesajın gönderme ve alma zamanları çıkarılarak hesaplanır: RTT = tR2 - tR1. Gidiş-dönüş süresi RTT ile gönderen yerel zaman damgası tS1 birlikte gönderenin monotonik saatinin tahmini oluşturmak için yeterlidir. tR2 zamanında gönderendeki mevcut zaman tS1 artı gidiş-dönüş süresinin yarısına eşit olur. Gönderenin yerel saat zaman damgası tS1\u0026lsquo;in video track zaman damgası tSV1 ile eşleştirilmesi ve gidiş-dönüş süresi RTT ile birlikte alıcı video track zamanını gönderen video track\u0026rsquo;e senkronize etmek için yeterlidir. Şimdi son bilinen gönderen video karesi zamanından tSV1\u0026lsquo;den ne kadar zaman geçtiğini bildiğimize göre, şu anda görüntülenen video karesinin zamanını (actual_video_time) beklenen zamandan çıkararak gecikmeyi yaklaşık olarak hesaplayabiliriz:\nexpected_video_time = tSV1 + time_since(tSV1) latency = expected_video_time - actual_video_time Bu yöntemin dezavantajı kameranın içsel gecikmesini içermemesidir. Çoğu video sistemi kare yakalama zaman damgasını kameradan kareyi ana belleğe teslim etme zamanı olarak kabul eder, bu kayıt edilen olayın gerçekten gerçekleşmesinden birkaç an sonra olacaktır.\nÖrnek gecikme tahmini # Örnek uygulama alıcıda bir latency veri kanalı açar ve periyodik olarak alıcının monotonik zamanlayıcı zaman damgalarını gönderene gönderir. Gönderen JSON mesajı ile geri yanıt verir ve alıcı mesaja dayalı gecikmeyi hesaplar.\n{ \u0026#34;received_time\u0026#34;: 64714, // Alıcı tarafından gönderilen zaman damgası, gönderen zaman damgasını yansıtır. \u0026#34;delay_since_received\u0026#34;: 46, // Gönderici üzerinde son `received_time` alındığından beri geçen zaman. \u0026#34;local_clock\u0026#34;: 1597366470336, // Gönderenin mevcut monotonik saat zamanı. \u0026#34;track_times_msec\u0026#34;: { \u0026#34;myvideo_track1\u0026#34;: [ 13100, // Video karesi RTP zaman damgası (milisaniye cinsinden). 1597366470289 // Video karesi monotonik saat zaman damgası. ] } } Alıcıda veri kanalını açın:\ndataChannel = peerConnection.createDataChannel(\u0026#34;latency\u0026#34;); Alıcının zamanını tR1 periyodik olarak gönderin. Bu örnek özel bir nedeni olmadan 2 saniye kullanır:\nsetInterval(() =\u0026gt; { let tR1 = Math.trunc(performance.now()); dataChannel.send(\u0026#34;\u0026#34; + tR1); }, 2000); Gönderici üzerinde alıcıdan gelen mesajı işleyin:\n// event.data\u0026#39;nın \u0026#34;1234567\u0026#34; gibi bir string olduğunu varsayarak. tR1 = event.data; now = Math.trunc(performance.now()); tSV1 = 42000; // Mevcut kare RTP zaman damgası milisaniye zaman ölçeğine dönüştürülmüş. tS1 = 1597366470289; // Mevcut kare monotonik saat zaman damgası. msg = { received_time: tR1, delay_since_received: 0, local_clock: now, track_times_msec: { myvideo_track1: [tSV1, tS1], }, }; dataChannel.send(JSON.stringify(msg)); Gönderenden gelen mesajı işleyin ve tahmini gecikmeyi console\u0026lsquo;a yazdırın:\nlet tR2 = performance.now(); let fromSender = JSON.parse(event.data); let tR1 = fromSender[\u0026#34;received_time\u0026#34;]; let delay = fromSender[\u0026#34;delay_since_received\u0026#34;]; // Gönderenin alma ve yanıt gönderme arasında geçen zaman. let senderTimeFromResponse = fromSender[\u0026#34;local_clock\u0026#34;]; let rtt = tR2 - delay - tR1; let networkLatency = rtt / 2; let senderTime = senderTimeFromResponse + delay + networkLatency; VIDEO.requestVideoFrameCallback((now, framemeta) =\u0026gt; { // Gönderenin mevcut zamanını tahmin edin. let delaySinceVideoCallbackRequested = now - tR2; senderTime += delaySinceVideoCallbackRequested; let [tSV1, tS1] = Object.entries(fromSender[\u0026#34;track_times_msec\u0026#34;])[0][1]; let timeSinceLastKnownFrame = senderTime - tS1; let expectedVideoTimeMsec = tSV1 + timeSinceLastKnownFrame; let actualVideoTimeMsec = Math.trunc(framemeta.rtpTimestamp / 90); // RTP timebase\u0026#39;ini (90000) milisaniye timebase\u0026#39;ine dönüştür. let latency = expectedVideoTimeMsec - actualVideoTimeMsec; console.log(\u0026#34;latency\u0026#34;, latency, \u0026#34;msec\u0026#34;); }); Tarayıcıda gerçek video zamanı # \u0026lt;video\u0026gt;.requestVideoFrameCallback() web yazarlarının kompozisyon için bir kare sunulduğunda bilgilendirilmelerine izin verir.\nÇok yakın zamana kadar (Mayıs 2020), tarayıcılarda şu anda görüntülenen video karesinin zaman damgasını güvenilir şekilde almak neredeyse imkansızdı. video.currentTime tabanlı geçici çözüm yöntemleri vardı, ancak özellikle hassas değildi. Hem Chrome hem de Mozilla tarayıcı geliştiricileri mevcut video kare zamanına erişim için API callback\u0026rsquo;i ekleyen yeni W3C standardı HTMLVideoElement.requestVideoFrameCallback()\u0026rsquo;nin tanıtımını desteklediler. Ekleme basit gelir, ancak web üzerinde ses ve video senkronizasyonu gerektiren birden fazla gelişmiş medya uygulamasını etkinleştirmiştir. Özellikle WebRTC için callback, mevcut video karesi ile ilişkili RTP zaman damgası olan rtpTimestamp alanını içerecektir. Bu WebRTC uygulamaları için mevcut olmalı, aksi takdirde mevcut olmamalıdır.\nGecikme Hata Ayıklama İpuçları # Hata ayıklama muhtemelen ölçülen gecikmeyi etkileyeceği için, genel kural kurulumunuzu sorunu hala yeniden üretebilecek en küçük olasılığa basitleştirmektir. Ne kadar çok bileşeni kaldırabilirseniz, hangi bileşenin gecikme problemine neden olduğunu anlamak o kadar kolay olacaktır.\nKamera gecikmesi # Kamera ayarlarına bağlı olarak kamera gecikmesi değişebilir. Otomatik pozlama, otomatik odaklama ve otomatik beyaz denge ayarlarını kontrol edin. Web kameralarının tüm \u0026ldquo;otomatik\u0026rdquo; özellikleri, yakalanan görüntüyü WebRTC yığınına kullanılabilir hale getirmeden önce analiz etmek için ekstra zaman alır.\nLinux\u0026rsquo;taysanız, kamera ayarlarını kontrol etmek için v4l2-ctl komut satırı aracını kullanabilirsiniz:\n# Otomatik odaklamayı devre dışı bırakın: v4l2-ctl -d /dev/video0 -c focus_auto=0 # Odağı sonsuzluğa ayarlayın: v4l2-ctl -d /dev/video0 -c focus_absolute=0 Kamera ayarlarını hızla kontrol etmek ve ayarlamak için guvcview grafik UI aracını da kullanabilirsiniz.\nKodlayıcı gecikmesi # Çoğu modern kodlayıcı kodlanmış bir tane çıkarmadan önce bazı kareleri tamponlayacaktır. Öncelikleri üretilen resmin kalitesi ve bitrate arasında bir denge kurmaktır. Çok geçişli kodlama, kodlayıcının çıkış gecikmesini umursamamasının aşırı örneğidir. İlk geçiş sırasında kodlayıcı tüm videoyu alır ve ancak ondan sonra kareleri çıkarmaya başlar.\nAncak, uygun ayarlama ile insanlar alt-kare gecikmelerine ulaştılar. Kodlayıcınızın aşırı referans kareleri kullanmadığından veya B-karelerine dayanmadığından emin olun. Her codec\u0026rsquo;in gecikme ayarlama ayarları farklıdır, ancak x264 için en düşük kare çıkış gecikmesi için tune=zerolatency ve profile=baseline kullanmanızı öneririz.\nAğ gecikmesi # Ağ gecikmesi, daha iyi ağ bağlantısına yükseltmek dışında tartışmalı olarak en az yapabileceğiniz şeydir. Ağ gecikmesi hava durumu gibidir - yağmuru durduramazsınız, ancak hava durumunu kontrol edip şemsiye alabilirsiniz. WebRTC ağ koşullarını milisaniye hassasiyetle ölçer. Önemli metrikler:\nGidiş-dönüş süresi. Paket kaybı ve paket yeniden iletimleri. Gidiş-Dönüş Süresi\nWebRTC yığınının yerleşik ağ gidiş dönüş süresi (RTT) ölçüm mekanizması vardır. Gecikmenin yeterince iyi yaklaşımı RTT\u0026rsquo;nin yarısıdır. Paket gönderme ve alma süresinin aynı olduğunu varsayar, ki bu her zaman böyle değildir. RTT uçtan uca gecikmenin alt sınırını belirler. Video kareleriniz kamera-kodlayıcı hattınız ne kadar optimize olursa olsun alıcıya RTT/2\u0026lsquo;den daha hızlı ulaşamaz.\nYerleşik RTT mekanizması gönderen/alıcı raporları adlı özel RTCP paketlerine dayanır. Gönderen zaman okumasını alıcıya gönderir, alıcı aynı zaman damgasını gönderene yansıtır. Böylece gönderen paketin alıcıya gidip geri dönmesi için ne kadar zaman aldığını bilir. RTT ölçümünün daha fazla detayı için Sender/Receiver Reports bölümüne bakın.\nPaket kaybı ve paket yeniden iletimleri\nHem RTP hem de RTCP, sıralama, başarılı teslimat veya tekrarlama garantisi olmayan UDP tabanlı protokollerdir. Yukarıdakilerin hepsi gerçek dünya WebRTC uygulamalarında olabilir ve olur. Sofistike olmayan dekoder uygulaması dekoderin görüntüyü başarıyla yeniden birleştirebilmesi için bir karenin tüm paketlerinin teslim edilmesini bekler. Paket kaybı varlığında P-frame paketleri kaybolursa dekodlama artefaktları görünebilir. I-frame paketleri kaybolursa tüm bağımlı kareler ya ağır artefaktlar alacak ya da hiç dekod edilmeyeceklerdir. Büyük olasılıkla bu videonun bir an için \u0026ldquo;donmasına\u0026rdquo; neden olacaktır.\nVideo donmasını veya dekodlama artefaktlarını önlemek için (en azından önlemeye çalışmak için), WebRTC olumsuz onay mesajları (NACK) kullanır. Alıcı beklenen RTP paketini almadığında, gönderene eksik paketi tekrar göndermesini söylemek için NACK mesajı döndürür. Alıcı paketin yeniden iletimini bekler. Bu tür yeniden iletimler artan gecikmeye neden olur. Gönderilen ve alınan NACK paketlerinin sayısı WebRTC\u0026rsquo;nin yerleşik istatistik alanlarında outbound stream nackCount ve inbound stream nackCount kaydedilir.\nwebrtc internals sayfasında gelen ve giden nackCount\u0026lsquo;un güzel grafiklerini görebilirsiniz. nackCount\u0026lsquo;un arttığını görüyorsanız, ağın yüksek paket kaybı yaşadığı ve WebRTC yığının buna rağmen düzgün video/ses deneyimi oluşturmak için elinden geleni yaptığı anlamına gelir.\nPaket kaybı o kadar yüksek ki dekoder görüntü üretemiyor veya tamamen kayıp I-frame durumunda olduğu gibi sonraki bağımlı görüntüleri üretemiyor, gelecekteki tüm P-frameler dekod edilmeyecek. Alıcı özel Picture Loss Indication mesajı (PLI) göndererek bunu hafifletmeye çalışacaktır. Gönderen PLI aldığında, alıcının dekoderine yardımcı olmak için yeni I-frame üretecektir. I-frameler normalde P-framelerden boyut olarak daha büyüktür. Bu iletilmesi gereken paket sayısını artırır. NACK mesajları gibi, alıcının yeni I-frame\u0026rsquo;i beklemesi gerekecek, ek gecikme getirecektir.\nwebrtc internals sayfasında pliCount\u0026lsquo;u izleyin. Artıyorsa, kodlayıcınızı daha az paket üretecek şekilde ayarlayın veya daha hata dirençli modu etkinleştirin.\nAlıcı tarafı gecikmesi # Gecikme, sıra dışı gelen paketlerden etkilenecektir. Görüntü paketinin alt yarısı üstten önce gelirse dekodlamadan önce üstü beklemeniz gerekir. Bu Solving Jitter bölümünde büyük detayda açıklanmıştır.\nBir karenin dekodere serbest bırakılmadan önce tüm paketlerini beklerken alma tamponunda ne kadar süre tutulduğunu görmek için yerleşik jitterBufferDelay metriğine de başvurabilirsiniz.\n"},{"id":9,"href":"/tr/docs/10-history-of-webrtc/","title":"Tarihçe","section":"Docs","content":" Tarihçe # WebRTC öğrenirken geliştiriciler genellikle karmaşıklık nedeniyle hayal kırıklığı yaşarlar. Mevcut projelerine alakasız WebRTC özelliklerini görür ve WebRTC\u0026rsquo;nin daha basit olmasını dilerler. Sorun herkesin farklı bir kullanım durumu setine sahip olmasıdır. Gerçek zamanlı iletişimin zengin bir geçmişi vardır ve birçok farklı insan birçok farklı şey inşa eder.\nBu bölüm WebRTC\u0026rsquo;yi oluşturan protokollerin yazarlarıyla yapılan röportajları içerir. Her protokolü inşa ederken yapılan tasarımlara dair içgörü verir ve WebRTC\u0026rsquo;nin kendisi hakkında bir röportajla biter. Yazılımın niyetlerini ve tasarımlarını anlarsanız onunla daha etkili sistemler inşa edebilirsiniz.\nRTP # RTP ve RTCP WebRTC için tüm medya aktarımını yöneten protokoldür. Ocak 1996\u0026rsquo;da RFC 1889\u0026lsquo;da tanımlandı. Yazarlarından biri olan Ron Frederick\u0026lsquo;in bunu kendisinin anlatma şansımız olduğu için çok şanslıyız. Ron yakın zamanda RTP\u0026rsquo;yi bilgilendiren bir proje olan Network Video tool\u0026lsquo;u GitHub\u0026rsquo;a yükledi.\nKendi Sözleriyle # Ekim 1992\u0026rsquo;de, IP multicast tabanlı bir ağ video konferans aracı yazma fikriyle Sun VideoPix çerçeve yakalayıcı kartıyla deneyler yapmaya başladım. LBL\u0026rsquo;de geliştirilen bir ses konferans aracı olan \u0026ldquo;vat\u0026quot;ı model aldı, çünkü kullanıcıların konferanslara katılması için benzer hafif oturum protokolü kullanıyordu, burada sadece belirli bir multicast grubuna veri gönderiyordunuz ve diğer grup üyelerinden gelen herhangi bir trafik için o grubu izliyordunuz.\nProgramın gerçekten başarılı olması için video verilerini ağa koymadan önce sıkıştırması gerekiyordu. Hedefim yaklaşık 128 kbps\u0026rsquo;ye sığacak kabul edilebilir görünümlü bir veri akışı yapmaktı, veya standart ev ISDN hattında mevcut bant genişliği. Ayrıca bu bant genişliğinin yarısına sığan hala izlenebilir bir şey üretmeyi umuyordum. Bu, çalıştığım belirli görüntü boyutu ve kare hızı için yaklaşık 20 kat sıkıştırma faktörüne ihtiyacım olduğu anlamına geliyordu. Bu sıkıştırmayı başardım ve kullandığım teknikler için patent başvurusunda bulundum, daha sonra verildi, ancak bu tamamen farklı bir hikaye.\n1993 yazının başında, San Francisco\u0026rsquo;daki Multimedia Computing and Networking konferansında kendim yazıp \u0026ldquo;Network Video (nv)\u0026rdquo; diye adlandırdığım bu programı gösterdim. Bu gösterim \u0026ldquo;vat\u0026quot;ın yaratıcısı Van Jacobson\u0026rsquo;dan iyi gözüktü ve ondan bu proje üzerinde birlikte çalışmak isteyip istemediğimi sordu. Elinden geldiğince bana yardım etmeyi kabul etti.\nVan ile çalışırken öğrendiğim ilk şeylerden biri bu tür gerçek zamanlı uygulamalar için yayın kontrolü ve kalite kontrolünün önemiydi. vat\u0026rsquo;ta yaptıkları şey herkesin trafiğini dinlemekti ve eğer network tıkanıklığına dair işaretler görürlerse transmisyon kalitelerini azaltırlardı.\nnv için, bu birkaç şeyle gerçekleştirildi. İlk olarak, biz diğer gönderenlerden gelen farklı veri hızlarını ölçtük. Network\u0026rsquo;e çok fazla trafik gönderdiğimizi fark edersek, kare hızını ve kaliteyi azaltırdık. İkinci olarak, herhangi bir alıcıya gönderenin kalitesini azaltmasını isteyebileceğini söylememize izin veren \u0026ldquo;komutu gönder\u0026rdquo; mesajları gönderdik. Bunu, özellikle bant genişliği gereksinimlerimizi kendi ağ kapasitesine uydurmak isteyen alıcılar için yaptık.\nnv, Mart 1993\u0026rsquo;te Sun\u0026rsquo;dan halka yayınlandı ve hızla çok popüler oldu. Bu konuyla ilgili çok sayıda email aldığım hatırlıyorum. İnsanlar bunu dünya çapında Mbone üzerinden üniversiteler arası video konferanslar için kullanıyorlardı, ve birçok insan kendi video konferans araçlarını bu kod üzerine inşa etti.\nnv\u0026rsquo;de kullandığımız formatın artık RTP diye bilinen şeyin ilk versiyonu olduğunu söyleyebilirim. Video verilerinin başında, kare hızı ve kalite hakkında alıcılara bilgi veren küçük bir başlık vardı. Bu başlık ayrıca gönderenin bir parçası olduğu farklı oturumları, hangi kullanıcıdan geldiğini ve benzer şeyleri tanımlamaya yardımcı olacak alanlar içeriyordu.\nAslında başlık formatını tasarlarken, vat\u0026rsquo;ta kullanılan basit yaklaşımdan sonra modellendirdi. Ancak, nv o zamanlar daha karmaşık bir medya türü olduğundan daha fazla bilgiye ihtiyacı vardı. Daha sonra, RTP komitesinde çalıştığımızda, nv\u0026rsquo;de kullandığımız format, daha sonra RTP\u0026rsquo;nin standardı haline gelecek şeyin temelini oluşturdu.\nNitekim, nv\u0026rsquo;de kullandığımız format ile RTP v1 RFC\u0026rsquo;si arasında doğrudan bir çizgi vardır. Bu o zamandan beri evrildi, ancak temel konseptler aynı kalıyor.\nVat\u0026rsquo;ta Van\u0026rsquo;ın yaptığı işin gerçekten akıllıcaydı. Ağ tıkanıklığıyla nasıl başa çıkılacağı konusunda öncü bir iş yaptı ve bu RTP ve daha sonra RTCP\u0026rsquo;nin gelişiminde gerçekten önemliydi.\nNeden paket başına zaman damgası? # Bu günlerde, paket başına zaman damgası oldukça açık görünüyor, ancak o zamanlar bunun böyle açık olup olmadığından emin değildim. Ben bu işe başladığımda, çerçeveleri düşünce alışkanlığındaydım, paketleri değil.\nHer pakette zaman damgası bulunmasının nedenlerinden biri ses ve video arasında yeterince senkronizasyon sağlayabilmekti. Bu, özellikle genellikle çerçeveler arasında dağıtılan ve genellikle düşük bir kare hızından dolayı çerçeveler arasında önemli miktarda zaman olan video için önemliydi.\nDiğer nedeni ise bant genişliği yönetimi içindi. Bir çerçeve içinde farklı bölümlere farklı öncelikler atayabilsek, alıcıların network koşulları kötüleştiğinde hangi paketleri düşüreceğini bilmelerine izin verseydik yardımcı olacaktı. Bu, çerçeve düzeyinde değil paket düzeyinde öncelik bilgilerine sahip olmayı gerektirdi.\nRTP/RTCP\u0026rsquo;nin geleceği # RTP, ilk oluşturulduğundan bu yana oldukça başarılı olduğunu düşünüyorum. Bu, İnternet\u0026rsquo;teki gerçek zamanlı uygulamaların çoğunun temelini oluşturuyor ve çok geniş bir alanda kullanılıyor.\nRTP\u0026rsquo;nin en başarılı kısımlarından biri esnekliği olmuştur. Genelleştirilmiş bir çerçeve olacak şekilde tasarlandı, bu da belirli medya türleri için özelleştirilebileceği anlamına geliyordu. Bu, RTP\u0026rsquo;nin başlangıçta tasarlandığından çok daha fazla uygulama alanında kullanılmasına izin verdi.\nWebRTC ile ilgili özellikle heyecanlandıran şey, RTP\u0026rsquo;yi sadece nokta-nokta konferans çağrıları için değil, çok daha karmaşık uygulamalar için de kullanıyor olmasıdır. Bu benim başlangıçta hayal ettiğim türden kullanımın ötesinde.\nICE # ICE, internet bağlantısı kurma (Internet Connection Establishment) anlamına gelir. ICE, WebRTC\u0026rsquo;nin NAT geçişi nasıl yaptığıdır. Birden fazla ağda NAT\u0026rsquo;ların arkasındaki iki WebRTC ajanının birbirlerini nasıl bulduğudur.\nICE RFC 8445\u0026rsquo;te tanımlanmıştır ve Jonathan Rosenberg tarafından yazılmıştır. İCANN\u0026rsquo;ın eski CTO\u0026rsquo;su ve şu anda Five9\u0026lsquo;un CTO\u0026rsquo;sudur.\nKendi Sözleriyle # Ben şirketimde video konferans teknolojileri üzerinde çalışıyordum. 1999 gibi erken bir tarihte enterprise video konferans sistemleri inşa ediyorduk. Bu sistemler, ağ içinde iki nokta arasında çağrılar yapmak için tasarlanmıştı.\nSorun, kullanıcılar bu sistemleri iş yerlerinin dışında kullanmaya başladığında ortaya çıktı. Evdeki kullanıcıların çoğu NAT\u0026rsquo;ın arkasındaydı ve bizim sistemimiz çalışmıyordu. O zamanlar NAT geçişi bu kadar yaygın değildi - aslında hiç yoktu.\nInsanların internet üzerinden ses ve video konferansı yapabilmesi için NAT geçişi problemini çözmemiz gerekiyordu. Bu problemin birçok farklı parçası vardı: NAT tespiti, NAT tipi belirleme, NAT geçişi, ve bağlantı kurma.\nBunu çözmek için birkaç farklı yöntem denedik. Bunlardan biri UPnP\u0026rsquo;yi kullanmaktı, ancak bu yeterince yaygın değildi. Diğeri de STUN ve TURN kullanmaktı, ancak bunlar her durumda çalışmıyordu.\nICE, tüm bu farklı yöntemleri birleştirmeye çalışan bir yaklaşımdı. Temel fikir şuydu: bağlantı kurmaya çalışırken mümkün olan tüm yöntemleri deneyin ve hangisi çalışırsa onu kullanın.\nICE\u0026rsquo;ın ilk versiyonu oldukça karmaşıktı. Birçok farklı bağlantı yöntemini koordine etmeye çalışıyordu ve implementasyon oldukça zordu. Zamanla protokol basitleşti ve daha pratik hale geldi.\nICE\u0026rsquo;ın en büyük katkısı, farklı NAT geçiş yöntemlerini standart bir şekilde birleştirmesi oldu. Bu, geliştiricilerin her durum için özel çözümler yazmak zorunda kalmaması anlamına geldi.\nICE bugün WebRTC\u0026rsquo;nin temel bir parçası. NAT\u0026rsquo;ların arkasındaki aygıtların birbirleriyle güvenilir bir şekilde bağlantı kurmasını sağlıyor. Bu olmadan, WebRTC bugünkü kadar yaygın bir şekilde kullanılamazdı.\nICE\u0026rsquo;ın geleceği # ICE teknolojisi olarak oldukça olgun. Temel protokol iyi çalışıyor ve büyük değişikliklere ihtiyaç duymuyoru. Gelecekteki gelişmelerin çoğu performans optimizasyonları ve belirli kullanım durumları için iyileştirmeler olacak.\nÖzellikle mobile cihazlar için pil ömrünü iyileştirme üzerine çok çalışma yapılıyor. ICE süreçlerinin daha verimli olması ve daha az enerji tüketmesi için yöntemler araştırılıyor.\nmDNS # mDNS (multicast DNS), WebRTC\u0026rsquo;nin yerel ağda eş keşfi için kullandığı teknolojilerden biridir. Bu, WebRTC ajanlarının aynı yerel ağdaki diğer ajanları bulmasına olanak tanır.\nmDNS, RFC 6763\u0026rsquo;te tanımlanmıştır ve Apple tarafından geliştirilmiştir. Bonjour teknolojisinin bir parçasıdır.\nNeden mDNS? # WebRTC\u0026rsquo;de gizlilik giderek daha önemli hale geldi. Kullanıcıların IP adreslerinin gereksiz yere ifşa edilmemesi önemli. mDNS, yerel ağdaki eş keşfi için IP adreslerini ifşa etmeyen bir yöntem sağlar.\nGeleneksel ICE sürecinde, WebRTC ajanları kendi IP adreslerini ICE adayları olarak paylaşır. Bu, kullanıcının ağ topolojisi hakkında bilgi verebilir ve gizlilik endişeleri yaratabilir.\nmDNS kullanarak, WebRTC ajanları gerçek IP adresleri yerine .local etki alanı adları kullanabilir. Bu adlar sadece yerel ağ içinde çözülebilir ve dış ağlara bilgi sızdırmaz.\nmDNS\u0026rsquo;in WebRTC\u0026rsquo;deki kullanımı # WebRTC\u0026rsquo;de mDNS öncelikle aynı yerel ağdaki eşler arasında bağlantı kurmak için kullanılır. Bu özellikle aynı WiFi ağındaki cihazlar arasında doğrudan bağlantı kurmak için yararlıdır.\nmDNS kullanımı, WebRTC\u0026rsquo;nin gizlilik özelliklerini artırırken aynı zamanda yerel ağ performansını da iyileştirir. Yerel bağlantılar genellikle internet üzerinden gelen bağlantılardan daha hızlı ve daha düşük gecikmeye sahiptir.\nWebRTC kendisi # WebRTC\u0026rsquo;nin hikayesini anlatmak için Justin Uberti\u0026lsquo;yi davet ettik. Justin Google\u0026rsquo;da WebRTC\u0026rsquo;nin temel kurucularından biriydi ve standardizasyon sürecinin büyük bir parçasıydı. Şu anda Clubhouse\u0026lsquo;da çalışıyor.\nKendi Sözleriyle # WebRTC\u0026rsquo;ye giden yol uzundu. 2003\u0026rsquo;te Google\u0026rsquo;a katıldığımda, şirket gerçek zamanlı iletişim alanında henüz aktif değildi. Ancak zaman geçtikçe, bu alanın gelecekte önemli olacağını gördük.\n2005 civarında Google Talk\u0026rsquo;ı piyasaya sürdük. Bu bizim ilk gerçek zamanlı iletişim ürünümüzdü ve Jabber/XMPP tabanlıydı. Bu ürünü geliştirirken, mevcut teknolojilerin sınırlarını gördük.\nO zamanlar, web tarayıcılarında gerçek zamanlı iletişim yapmak çok zordu. Flash veya Java gibi eklentiler kullanmanız gerekiyordu. Bu hem güvenlik hem de kullanılabilirlik açısından sorunluydu.\n2009\u0026rsquo;da HTML5 ortaya çıktığında, web\u0026rsquo;in yerel olarak gerçek zamanlı iletişimi destekleyebileceği fikri daha gerçekçi hale geldi. Ancak bu için browserlara önemli yeni API\u0026rsquo;ler eklenmesi gerekiyordu.\nNeden browser-tabanlı? # Browser-tabanlı gerçek zamanlı iletişim yapmanın birçok avantajı vardı:\nÖncelikle, platform bağımsızlığı. Aynı kod Windows, Mac, Linux ve mobile platformlarda çalışabilirdi. Bu, geliştiriciler için büyük bir kolaylıktı.\nİkincisi, güvenlik. Browser\u0026rsquo;lar zaten güvenlik odaklı tasarlanmıştı ve sandbox modeli vardı. Bu, gerçek zamanlı iletişimin de güvenli olmasını sağlardı.\nÜçüncüsü, kolay dağıtım. Kullanıcılar herhangi bir yazılım indirmek zorunda kalmadan uygulamaları kullanabilirdi. Bu, adapsiyon için kritikti.\nTeknik zorluklar # WebRTC\u0026rsquo;yi geliştirirken karşılaştığımız birçok teknik zorluk vardı:\nNAT geçişi büyük bir sorundu. Internet\u0026rsquo;teki cihazların çoğu NAT\u0026rsquo;ların arkasındaydı ve birbirleriyle doğrudan iletişim kuramazlardı. ICE protokolü bu sorunu çözmek için geliştirildi.\nCodec seçimi başka bir zorlukhti. Farklı platformlar farklı audio/video codec\u0026rsquo;lerini destekliyordu. WebRTC için ortak bir set belirlemek zordu.\nEcho cancellation ve noise reduction gibi ses işleme algoritmaları da zordu. Bunların web browserlarında gerçek zamanlı çalışması gerekiyordu.\nAçık kaynak yaklaşımı # WebRTC\u0026rsquo;yi açık kaynak yapmak stratejik bir karardı. Bunun birkaç nedeni vardı:\nİlk olarak, standardizasyon. Açık kaynak olmayan bir teknoloji internet standardı olmaya uygun değildi.\nİkincisi, güven. Güvenlik açısından kritik bir teknoloji için kod şeffaflığı önemliydi.\nÜçüncüsü, ekosistem. Geniş bir geliştirici ekosistemi yaratmak için açık kaynak gerekliyde.\nNPAPI\u0026rsquo;den uzaklaşma # NPAPI\u0026rsquo;den uzaklaşma büyük bir odak noktası haline geldi. Bu güçlü bir API\u0026rsquo;ydi, ancak büyük güvenlik sonuçları vardı. Chrome kullanıcıları güvende tutmak için sandbox tasarımı kullanır. Potansiyel olarak güvenli olmayan işlemler farklı süreçlerde çalışır. Bir şeyler ters gitse bile, saldırgan hala kullanıcı verilerine erişime sahip olmaz.\nWebRTC\u0026rsquo;nin doğuşu # Benim için WebRTC birkaç motivasyonla doğdu. Bunlar birleşerek bu çabayı doğurdu.\nRTC deneyimleri inşa etmek bu kadar zor olmamalıydı. Çok fazla çaba farklı geliştiricilerin aynı şeyi yeniden uygulamasıyla harcandı. Bu sinir bozucu entegrasyon problemlerini bir kez çözmeli ve diğer şeylere odaklanmalıydık.\nİnsan iletişimi engellenmemeli ve açık olmalıydı. Metin ve HTML\u0026rsquo;nin açık olması tamam da, sesim ve gerçek zamanlı görüntümün açık olmaması nasıl kabul edilebilir?\nGüvenlik bir önceliktir. NPAPI kullanmak kullanıcılar için en iyisi değildi. Bu aynı zamanda varsayılan olarak güvenli bir protokol yapma şansıydı.\nWebRTC\u0026rsquo;yi gerçekleştirmek için Google daha önce kullandığımız bileşenleri satın aldı ve Açık Kaynak yaptı. Video teknolojisi için On2 satın alındı ve RTC teknolojisi için Global IP Solutions. GIPS\u0026rsquo;i satın alma çabasının sorumlusu bendim. Bunları birleştirme ve browser içinde ve dışında kullanımı kolay hale getirme işine koyulduk.\nStandardizasyon # WebRTC\u0026rsquo;yi standardize etmek gerçekten yapmak istediğimiz bir şeydi, ancak daha önce yaptığım bir şey değildi, yakın ekibimizden hiç kimse de yapmamıştı. Bunun için Google\u0026rsquo;da Harald Alvestrand\u0026rsquo;a sahip olmak gerçekten şanslıydık. IETF\u0026rsquo;te zaten kapsamlı çalışmalar yapmıştı ve WebRTC standardizasyon sürecini başlattı.\n2010 yazında Maastricht\u0026rsquo;te gayri resmi bir öğle yemeği planlandı. Birçok şirketten geliştiriciler WebRTC\u0026rsquo;nin ne olması gerektiğini tartışmak için bir araya geldi. Öğle yemeğinde Google, Cisco, Ericsson, Skype, Mozilla, Linden Labs ve daha fazlasından mühendisler vardı. Tam katılım ve sunucu slaytlarını rtc-web.alvestrand.com\u0026lsquo;da bulabilirsiniz.\nSkype ayrıca IETF\u0026rsquo;te Opus ile yaptıkları çalışma nedeniyle harika rehberlik sağladı.\nDevlerin omuzlarında durmak # IETF\u0026rsquo;te çalışırken sizden önce gelen çalışmaları genişletiyorsunuz. WebRTC ile çok fazla şeyin mevcut olması şansımıza oldu. Her problemi üstlenmek zorunda değildik çünkü zaten çözülmüşlerdi. Önceden var olan teknolojiyi sevmiyorsanız bu sinir bozucu olabilir. Mevcut çalışmayı yok saymak için oldukça büyük bir nedene sahip olmanız gerekir, bu yüzden kendi başınıza yapmak bir seçenek değil.\nAyrıca sinyalleşme gibi şeyleri yeniden standardize etmeye bilinçli olarak girişmedik. Bu zaten SIP ve diğer IETF dışı çabalarla çözülmüştü ve çok politik olabileceği hissiyatı vardı. Sonunda bu alana eklecek çok fazla değer olmadığı hissiyatı vardı.\nStandardizasyon konusunda Justin ve Harald kadar dahil olmadım, ancak yaptığım süreyi sevdim. Kullanıcılar için bir şeyler inşa etmeye geri dönme konusunda daha heyecanlıydım.\nGelecek # WebRTC bugün harika bir yerde. Birçok yinelemeli değişiklik oluyor, ancak özellikle üzerinde çalıştığım bir şey yok.\nİletişim için bulut bilişimin yapabilecekleri konusunda en çok heyecanlıyım. Gelişmiş algoritmalar kullanarak bir çağrıdan arka plan gürültüsünü kaldırabilir ve daha önce mümkün olmayan yerlerde iletişimi mümkün kılabiliyoruz. Ayrıca WebRTC\u0026rsquo;nin iletişimin çok ötesine geçtiğini görüyoruz\u0026hellip; 9 yıl sonra bulut tabanlı oyunları destekleyeceğini kim bilebilirdi? Bunların hiçbiri WebRTC\u0026rsquo;nin temeli olmadan mümkün olmazdı.\n"},{"id":10,"href":"/tr/docs/11-faq/","title":"SSS","section":"Docs","content":" SSS (Sıkça Sorulan Sorular) # WebRTC neden UDP kullanıyor? NAT Geçişi UDP gerektirir. NAT Geçişi olmadan P2P bağlantı kurmak mümkün olmazdı. UDP, TCP gibi \u0026ldquo;garantili teslimat\u0026rdquo; sağlamaz, bu yüzden WebRTC bunu kullanıcı seviyesinde sağlar.\nDaha fazla bilgi için Bağlanma bölümüne bakın.\nKaç tane DataChannel\u0026rsquo;ım olabilir? Akış tanımlayıcısı 16 bit olduğu için 65534 kanal. İstediğiniz zaman kapatıp yeni bir tane açabilirsiniz. WebRTC bant genişliği sınırları koyuyor mu? Hem DataChannel\u0026rsquo;lar hem de RTP tıkanıklık kontrolü kullanır. Bu, WebRTC\u0026rsquo;nin aktif olarak bant genişliğinizi ölçtüğü ve optimal miktarı kullanmaya çalıştığı anlamına gelir. Bu, mümkün olduğu kadar fazla gönderme ile bağlantıyı bunaltmama arasında bir dengedir. Binary veri gönderebilir miyim? Evet, DataChannel\u0026rsquo;lar aracılığıyla hem metin hem de binary veri gönderebilirsiniz. WebRTC ile ne kadar gecikme bekleyebilirim? Ayarlanmamış medya için 500 milisaniyenin altında gecikme bekleyebilirsiniz. Gecikme için kaliteyi ayarlamaya veya feda etmeye istekliyseniz, geliştiriciler 100ms\u0026rsquo;nin altında gecikme elde etmişlerdir.\nDataChannel\u0026rsquo;lar, kayıplı bağlantı üzerinden veri yeniden iletimlerinin neden olduğu gecikmeyi azaltabilen \u0026ldquo;Kısmi-güvenilirlik\u0026rdquo; seçeneğini destekler. Doğru yapılandırılırsa, TCP TLS bağlantılarını geçtiği gösterilmiştir.\nDataChannel\u0026rsquo;lar için neden sırasız teslimat isteyeyim? Bir nesnenin konumsal bilgisi gibi yeni bilginin eskisini geçersiz kıldığı durumlarda, veya her mesajın diğerlerinden bağımsız olduğu ve baş-of-line engelleme gecikmesinden kaçınması gerektiği durumlarda. DataChannel üzerinden ses veya video gönderebilir miyim? Evet, DataChannel üzerinden herhangi bir veri gönderebilirsiniz. Tarayıcı durumunda, verileri decode etmek ve rendering için bir medya oynatıcısına geçmek sizin sorumluluğunuz olacaktır, medya kanallarını kullanırsanız tüm bunlar otomatik olarak yapılırken. "},{"id":11,"href":"/tr/docs/12-glossary/","title":"Sözlük","section":"Docs","content":" Sözlük # ACK: Onay (Acknowledgment) AVP: Ses ve Video profili (Audio and Video profile) B-Frame: Çift Yönlü Tahminli Çerçeve. Kısmi bir resim, önceki ve gelecekteki resimlerin modifikasyonudur. DCEP: Veri Kanalı Kurma Protokolü RFC 8832\u0026lsquo;de tanımlanmıştır DeMux: Çoklayıcı çözücü (Demultiplexer) DLSR: Son gönderen raporundan beri gecikme (Delay since last sender report) DTLS: Datagram Aktarım Katmanı Güvenliği RFC 6347\u0026lsquo;de tanımlanmıştır E2E: Uçtan Uca (End-to-End) FEC: İleri Hata Düzeltme FIR: Tam INTRA-çerçeve İsteği G.711: Dar bant ses codec\u0026rsquo;i GCC: Google Tıkanıklık Kontrolü draft-ietf-rmcat-gcc-02\u0026lsquo;de tanımlanmıştır H.264: Genel görsel-işitsel hizmetler için gelişmiş video kodlama H.265: ITU-T H.265 yüksek verimli video kodlama için uygunluk spesifikasyonu HEVC: Yüksek Verimli Video Kodlama (High Efficiency Video Coding) HTTP: Hipermetin Aktarım Protokolü (Hypertext Transfer Protocol) HTTPS: TLS Üzerinden HTTP, RFC 2818\u0026lsquo;de tanımlanmıştır I-Frame: Çerçeve içi Kodlanmış Çerçeve. Tam bir resim, başka hiçbir şey olmadan dekod edilebilir. ICE: Etkileşimli Bağlantı Kurma RFC 8445\u0026rsquo;te tanımlanmıştır INIT: Başlat (Initiate) IoT: Nesnelerin İnterneti (Internet of Things) IPv4: İnternet Protokolü, Sürüm 4 IPv6: İnternet Protokolü, Sürüm 6 ITU-T: Uluslararası Telekomünikasyon Birliği Telekomünikasyon Standardizasyon Sektörü JSEP: JavaScript Oturum Kurma Protokolü RFC 8829\u0026lsquo;da tanımlanmıştır MCU: Çok Nokta Konferans Birimi mDNS: Multicast DNS RFC 6762\u0026lsquo;de tanımlanmıştır MITM: Ortadaki Adam (Man-In-The-Middle) MTU: Maksimum İletim Birimi, paket boyutu MUX: Çoklama (Multiplexing) NACK: Negatif Onay (Negative Acknowledgment) NADA: ağ destekli dinamik adaptasyon draft-zhu-rmcat-nada-04\u0026rsquo;te tanımlanmıştır NAT: Ağ Adresi Çevirisi RFC 4787\u0026lsquo;de tanımlanmıştır Opus: Tamamen açık, telif hakkı ücretsiz, son derece çok yönlü ses codec\u0026rsquo;i P-Frame: Tahminli Çerçeve. Kısmi bir resim, sadece önceki resimden değişiklikleri içerir. P2P: Eşten-Eşe (Peer-to-Peer) PLI: Resim Kaybı Göstergesi PPID: Yük Protokolü Tanımlayıcısı REMB: Alıcı Tahmini Maksimum Bit Hızı RFC: Yorum İsteği (Request for Comments) RMCAT: RTP Medya Tıkanıklık Önleme Teknikleri RR: Alıcı Raporu (Receiver Report) RTCP: RTP Kontrol Protokolü RFC 3550\u0026lsquo;de tanımlanmıştır RTP: Gerçek zamanlı aktarım protokolü RFC 3550\u0026lsquo;de tanımlanmıştır RTT: Gidiş-Geliş Süresi (Round-Trip Time) SACK: Seçici Onay (Selective Acknowledgment) SCReAM: Multimedya için Kendinden Saatli Hız Adaptasyonu draft-johansson-rmcat-scream-cc-05\u0026rsquo;te tanımlanmıştır SCTP: Akış Kontrol İletim Protokolü RFC 4960\u0026rsquo;ta tanımlanmıştır SDP: Oturum Tanımlama Protokolü RFC 8866\u0026lsquo;da tanımlanmıştır SFU: Seçici Yönlendirme Birimi SR: Gönderen Raporu (Sender Report) SRTP: Güvenli Gerçek zamanlı Aktarım Protokolü RFC 3711\u0026lsquo;de tanımlanmıştır SSRC: Senkronizasyon Kaynağı (Synchronization Source) STUN: NAT için Oturum Geçiş Yardımcı Programları RFC 8489\u0026lsquo;da tanımlanmıştır TCP: İletim Kontrol Protokolü (Transmission Control Protocol) TLS: RFC 8446\u0026lsquo;da tanımlanan Aktarım Katmanı Güvenliği TMMBN: Geçici Maksimum Medya Akışı Bit Hızı Bildirimi TMMBR: Geçici Maksimum Medya Akışı Bit Hızı İsteği TSN: İletim Sıra Numarası TURN: NAT Etrafında Röle Kullanarak Geçiş RFC 8656\u0026lsquo;da tanımlanmıştır TWCC: Aktarım Genişliği Tıkanıklık Kontrolü UDP: Kullanıcı Datagram Protokolü (User Datagram Protocol) VP8, VP9: WebM Projesi tarafından geliştirilen son derece verimli video sıkıştırma teknolojileri (video \u0026ldquo;codec\u0026rsquo;leri\u0026rdquo;). Herkes bu codec\u0026rsquo;leri telif hakkı ücreti ödemeden kullanabilir. WebM: Web için tasarlanmış açık medya dosya formatı. WebRTC: Web Gerçek Zamanlı İletişimleri. W3C WebRTC 1.0: Tarayıcılar Arası Gerçek Zamanlı İletişim "},{"id":12,"href":"/tr/docs/13-reference/","title":"Referans","section":"Docs","content":" Referans # WebRTC(W3C) # WebRTC 1.0: Tarayıcılar Arası Gerçek Zamanlı İletişim [26 Ocak 2021] (Durum: Öneri) Web Gerçek Zamanlı İletişim Çalışma Grubu - Yayınlar WebRTC(RFC) # RFC8825: Genel Bakış: Tarayıcı Tabanlı Uygulamalar için Gerçek Zamanlı Protokoller H. Alvestrand [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8826: WebRTC için Güvenlik Değerlendirmeleri E. Rescorla [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8836: Etkileşimli Gerçek Zamanlı Medya için Tıkanıklık Kontrol Gereksinimleri R. Jesup, Z. Sarker [Ocak 2021] (Durum: BİLGİLENDİRME) RFC8854: WebRTC İleri Hata Düzeltme Gereksinimleri J. Uberti [Ocak 2021] (Durum: ÖNERİLEN STANDART) DTLS # RFC6347: Datagram Aktarım Katmanı Güvenliği Sürüm 1.2 E. Rescorla, N. Modadugu [Ocak 2012] (Eskitilenler RFC4347) (Eskiten RFC9147) (Güncelleyenler RFC7507, RFC7905, RFC8996, RFC9146) (Durum: ÖNERİLEN STANDART) RFC9147: Datagram Aktarım Katmanı Güvenliği (DTLS) Protokolü Sürüm 1.3 E. Rescorla, H. Tschofenig, N. Modadugu [Nisan 2022] (Eskitilenler RFC6347) (Durum: ÖNERİLEN STANDART) (Ayrıca bakınız: OpenSSL DTLS 1.3 durumu) Veri Kanalı # RFC8831: WebRTC Veri Kanalları R. Jesup, S. Loreto, M. Tüxen [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8832: WebRTC Veri Kanalı Kurma Protokolü R. Jesup, S. Loreto, M. Tüxen [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8864: Oturum Tanımlama Protokolü (SDP) Kullanarak Veri Kanalları Müzakeresi K. Drage, M. Makaraju, R. Ejzak, J. Marcon, R. Even [Ocak 2021] (Durum: ÖNERİLEN STANDART) Medya Aktarımı # RFC8834: WebRTC\u0026rsquo;de Medya Aktarımı ve RTP Kullanımı C. Perkins, M. Westerlund, J. Ott [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8837: WebRTC QoS için Farklılaştırılmış Hizmetler Kod Noktası (DSCP) Paket İşaretlemeleri P. Jones, S. Dhesikan, C. Jennings, D. Druta [Ocak 2021] (Durum: ÖNERİLEN STANDART) SCTP # RFC3758: Akış Kontrol İletim Protokolü (SCTP) Kısmi Güvenilirlik Uzantısı R. Stewart, M. Ramalho, Q. Xie, M. Tuexen, P. Conrad [Mayıs 2004] (Durum: ÖNERİLEN STANDART) RFC5061: Akış Kontrol İletim Protokolü (SCTP) Dinamik Adres Yeniden Yapılandırması R. Stewart, Q. Xie, M. Tuexen, S. Maruyama, M. Kozuka [Eylül 2007] (Durum: ÖNERİLEN STANDART) RFC5827: TCP ve Akış Kontrol İletim Protokolü (SCTP) için Erken Yeniden İletim M. Allman, K. Avrachenkov, U. Ayesta, J. Blanton, P. Hurtig [Mayıs 2010] (Durum: DENEYSEL) RFC6083: Akış Kontrol İletim Protokolü (SCTP) için Datagram Aktarım Katmanı Güvenliği (DTLS) M. Tuexen, R. Seggelmann, E. Rescorla [Ocak 2011] (Güncelleyenler RFC8996) (Durum: ÖNERİLEN STANDART) RFC6525: Akış Kontrol İletim Protokolü (SCTP) Akış Yeniden Yapılandırması R. Stewart, M. Tuexen, P. Lei [Şubat 2012] (Durum: ÖNERİLEN STANDART) RFC6951: Uç-Nokta\u0026rsquo;dan Uç-Nokta\u0026rsquo;ya İletişim için Akış Kontrol İletim Protokolü (SCTP) Paketlerinin UDP Kapsüllenmesi M. Tuexen, R. Stewart [Mayıs 2013] (Güncelleyenler RFC8899) (Durum: ÖNERİLEN STANDART) RFC7765: TCP ve Akış Kontrol İletim Protokolü (SCTP) RTO Yeniden Başlatma P. Hurtig, A. Brunstrom, A. Petlund, M. Welzl [Şubat 2016] (Durum: DENEYSEL) RFC8260: Akış Kontrol İletim Protokolü için Akış Zamanlayıcıları ve Kullanıcı Mesajı Ara Yerleştirme R. Stewart, M. Tuexen, S. Loreto, R. Seggelmann [Kasım 2017] (Durum: ÖNERİLEN STANDART) RFC8261: SCTP Paketlerinin Datagram Aktarım Katmanı Güvenliği (DTLS) Kapsüllenmesi M. Tuexen, R. Stewart, R. Jesup, S. Loreto [Kasım 2017] (Güncelleyenler RFC8899, RFC8996) (Durum: ÖNERİLEN STANDART) RFC8841: Datagram Aktarım Katmanı Güvenliği (DTLS) Aktarımı Üzerinden Akış Kontrol İletim Protokolü (SCTP) için Oturum Tanımlama Protokolü (SDP) Teklif/Yanıt Prosedürleri C. Holmberg, R. Shpount, S. Loreto, G. Camarillo [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8899: Datagram Aktarımları için Paketleme Katmanı Yol MTU Keşfi G. Fairhurst, T. Jones, M. Tüxen, I. Rüngeler, T. Völker [Eylül 2020] (Güncelleyenler RFC4821, RFC4960, RFC6951, RFC8085, RFC8261) (Durum: ÖNERİLEN STANDART) RFC9260: Akış Kontrol İletim Protokolü R. Stewart, M. Tüxen, K. Nielsen [Haziran 2022] (Eskitilenler RFC4460, RFC4960, RFC6096, RFC7053, RFC8540) (Durum: ÖNERİLEN STANDART) SDP # RFC8829: JavaScript Oturum Kurma Protokolü (JSEP) J. Uberti, C. Jennings, E. Rescorla [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8830: WebRTC MediaStream Oturum Tanımlama Protokolünde Tanımlama H. Alvestrand [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8839: Etkileşimli Bağlantı Kurma (ICE) için Oturum Tanımlama Protokolü (SDP) Teklif/Yanıt Prosedürleri M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [Ocak 2021] (Eskitilenler RFC5245, RFC6336) (Durum: ÖNERİLEN STANDART) RFC8841: Datagram Aktarım Katmanı Güvenliği (DTLS) Aktarımı Üzerinden Akış Kontrol İletim Protokolü (SCTP) için Oturum Tanımlama Protokolü (SDP) Teklif/Yanıt Prosedürleri C. Holmberg, R. Shpount, S. Loreto, G. Camarillo [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8843: Oturum Tanımlama Protokolü (SDP) Kullanarak Medya Çoğullama Müzakeresi C. Holmberg, H. Alvestrand, C. Jennings [Ocak 2021] (Eskiten RFC9143) (Güncelleyenler RFC3264, RFC5888, RFC7941) (Durum: ÖNERİLEN STANDART) RFC8844: Oturum Tanımlama Protokolü (SDP) ile TLS Kullanımlarında Bilinmeyen Anahtar-Paylaşım Saldırıları M. Thomson, E. Rescorla [Ocak 2021] (Güncelleyenler RFC8122) (Durum: ÖNERİLEN STANDART) RFC8851: RTP Yük Formatı Kısıtlamaları A.B. Roach [Ocak 2021] (Güncelleyenler RFC4855) (Durum: ÖNERİLEN STANDART) RFC8852: RTP Akış Tanımlayıcısı Kaynak Tanımlama (SDES) A.B. Roach, S. Nandakumar, P. Thatcher [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8853: Oturum Tanımlama Protokolü (SDP) ve RTP Oturumlarında Simulcast Kullanımı B. Burman, M. Westerlund, S. Nandakumar, M. Zanaty [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8866: SDP: Oturum Tanımlama Protokolü A. Begen, P. Kyzivat, C. Perkins, M. Handley [Ocak 2021] (Eskitilenler RFC4566) (Durum: ÖNERİLEN STANDART) RTP # RFC3550: RTP: Gerçek Zamanlı Uygulamalar için Aktarım Protokolü H. Schulzrinne, S. Casner, R. Frederick, V. Jacobson [Temmuz 2003] (Eskitilenler RFC1889) (Güncelleyenler RFC5506, RFC5761, RFC6051, RFC6222, RFC7022, RFC7160, RFC7164, RFC8083, RFC8108, RFC8860) (Ayrıca STD0064) (Durum: İNTERNET STANDARDI) RFC3611: RTP Kontrol Protokolü Genişletilmiş Raporları (RTCP XR) T. Friedman, R. Caceres, A. Clark [Kasım 2003] (Durum: ÖNERİLEN STANDART) RFC3711: Güvenli Gerçek zamanlı Aktarım Protokolü (SRTP) M. Baugher, D. McGrew, M. Naslund, E. Carrara, K. Norrman [Mart 2004] (Güncelleyenler RFC5506, RFC6904) (Durum: ÖNERİLEN STANDART) RFC4585: Gerçek zamanlı Aktarım Kontrol Protokolü (RTCP) Tabanlı Geri Bildirim için Genişletilmiş RTP Profili (RTP/AVPF) J. Ott, S. Wenger, N. Sato, C. Burmeister, J. Rey [Temmuz 2006] (Güncelleyenler RFC5506, RFC8108) (Durum: ÖNERİLEN STANDART) RFC5104: Geri Bildirimli RTP Ses-Görüntü Profilinde (AVPF) Codec Kontrol Mesajları S. Wenger, U. Chandra, M. Westerlund, B. Burman [Şubat 2008] (Güncelleyenler RFC7728, RFC8082) (Durum: ÖNERİLEN STANDART) RFC5764: Güvenli Gerçek zamanlı Aktarım Protokolü (SRTP) için Anahtarları Kurmak İçin Datagram Aktarım Katmanı Güvenliği (DTLS) Uzantısı D. McGrew, E. Rescorla [Mayıs 2010] (Güncelleyenler RFC7983) (Durum: ÖNERİLEN STANDART) RFC6904: Güvenli Gerçek zamanlı Aktarım Protokolünde (SRTP) Başlık Uzantılarının Şifrelemesi J. Lennox [Nisan 2013] (Güncelleyenler RFC3711) (Durum: ÖNERİLEN STANDART) RFC7741: VP8 Video için RTP Yük Formatı P. Westin, H. Lundin, M. Glover, J. Uberti, F. Galligan [Mart 2016] (Durum: ÖNERİLEN STANDART) RFC8285: RTP Başlık Uzantıları için Genel Mekanizma D. Singer, H. Desineni, R. Even [Ekim 2017] (Eskitilenler RFC5285) (Durum: ÖNERİLEN STANDART) RFC8852: RTP Akış Tanımlayıcısı Kaynak Tanımlama (SDES) A.B. Roach, S. Nandakumar, P. Thatcher [Ocak 2021] (Durum: ÖNERİLEN STANDART) RFC8858: Oturum Tanımlama Protokolü (SDP) Kullanarak RTP ve RTP Kontrol Protokolü (RTCP) Çoğullamanın Özel Desteğini Belirtme C. Holmberg [Ocak 2021] (Güncelleyenler RFC5761) (Durum: ÖNERİLEN STANDART) RFC8860: Tek RTP Oturumunda Birden Fazla Medya Türü Gönderme M. Westerlund, C. Perkins, J. Lennox [Ocak 2021] (Güncelleyenler RFC3550, RFC3551) (Durum: ÖNERİLEN STANDART) RFC8867: Etkileşimli Gerçek Zamanlı Medya için Tıkanıklık Kontrolünü Değerlendirme Test Durumları Z. Sarker, V. Singh, X. Zhu, M. Ramalho [Ocak 2021] (Durum: BİLGİLENDİRME) RFC8868: Etkileşimli Gerçek Zamanlı Medya için Tıkanıklık Kontrolünü Değerlendirme V. Singh, J. Ott, S. Holmer [Ocak 2021] (Durum: BİLGİLENDİRME) RFC8869: Kablosuz Ağlar Üzerinde Etkileşimli Gerçek Zamanlı Medya için Değerlendirme Test Durumları Z. Sarker, X. Zhu, J. Fu [Ocak 2021] (Durum: BİLGİLENDİRME) RFC8872: Birden Fazla Medya Akışını Desteklemek için RTP\u0026rsquo;nin Çoğullama Özelliklerini Kullanma Kılavuzu M. Westerlund, B. Burman, C. Perkins, H. Alvestrand, R. Even [Ocak 2021] (Durum: BİLGİLENDİRME) RFC8888: Tıkanıklık Kontrolü için RTP Kontrol Protokolü (RTCP) Geri Bildirimi Z. Sarker, C. Perkins, V. Singh, M. Ramalho [Ocak 2021] (Durum: ÖNERİLEN STANDART) ICE, TURN ve STUN # RFC5780: NAT için Oturum Geçiş Yardımcıları (STUN) Kullanarak NAT Davranış Keşfi D. MacDonald, B. Lowekamp [Mayıs 2010] (Güncelleyenler RFC8553) (Durum: DENEYSEL)\nRFC8445: Etkileşimli Bağlantı Kurma (ICE): Ağ Adres Çeviricisi (NAT) Geçişi için Protokol A. Keranen, C. Holmberg, J. Rosenberg [Temmuz 2018] (Eskitilenler RFC5245) (Güncelleyenler RFC8863) (Durum: ÖNERİLEN STANDART)\nRFC8489: NAT için Oturum Geçiş Yardımcıları (STUN) M. Petit-Huguenin, G. Salgueiro, J. Rosenberg, D. Wing, R. Mahy, P. Matthews [Şubat 2020] (Eskitilenler RFC5389) (Durum: ÖNERİLEN STANDART)\nRFC8656: NAT Etrafında Röle Kullanarak Geçiş (TURN): NAT için Oturum Geçiş Yardımcılarına (STUN) Röle Uzantıları T. Reddy, A. Johnston, P. Matthews, J. Rosenberg [Şubat 2020] (Eskitilenler RFC5766, RFC6156) (Durum: ÖNERİLEN STANDART)\nRFC8835: WebRTC için Aktarımlar H. Alvestrand [Ocak 2021] (Durum: ÖNERİLEN STANDART)\nRFC8838: Trickle ICE: Etkileşimli Bağlantı Kurma (ICE) Protokolü için Adayların Artımlı Sağlanması E. Ivov, J. Uberti, P. Saint-Andre [Ocak 2021] (Güncelleyenler RFC8863) (Durum: ÖNERİLEN STANDART)\nRFC8839: Etkileşimli Bağlantı Kurma (ICE) için Oturum Tanımlama Protokolü (SDP) Teklif/Yanıt Prosedürleri M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [Ocak 2021] (Eskitilenler RFC5245, RFC6336) (Durum: ÖNERİLEN STANDART)\nRFC8863: Etkileşimli Bağlantı Kurma Sabırla Bağlantı Beklemesi (ICE PAC) C. Holmberg, J. Uberti [Ocak 2021] (Güncelleyenler RFC8445, RFC8838) (Durum: ÖNERİLEN STANDART)\nRFC3550: RTP: Gerçek Zamanlı Uygulamalar için Aktarım Protokolü H. Schulzrinne, S. Casner, R. Frederick, V. Jacobson [Temmuz 2003] (Eskitilenler RFC1889) (Durum: İNTERNET STANDARDI)\nRFC3711: Güvenli Gerçek Zamanlı Aktarım Protokolü (SRTP) M. Baugher, D. McGrew, M. Naslund, E. Carrara, K. Norrman [Mart 2004] (Durum: ÖNERİLEN STANDART)\nRFC4585: Gerçek Zamanlı Aktarım Kontrol Protokolü (RTCP) Tabanlı Geri Bildirim için Genişletilmiş RTP Profili (RTP/AVPF) J. Ott, S. Wenger, N. Sato, C. Burmeister, J. Rey [Temmuz 2006] (Durum: ÖNERİLEN STANDART)\nICE, TURN ve STUN # RFC5780: NAT Davranışını Keşfetmek için Oturum Geçiş Araçları (STUN) kullanımı Yazarlar: D. MacDonald, B. Lowekamp [Mayıs 2010] (Güncellendi: RFC8553) (Durum: DENEYSEL)\nRFC8445: Etkileşimli Bağlantı Kurulumu (ICE): NAT (Ağ Adresi Çevirici) Geçişi için Bir Protokol Yazarlar: A. Keranen, C. Holmberg, J. Rosenberg [Temmuz 2018] (Yerine geçtiği belge: RFC5245) (Güncellendi: RFC8863) (Durum: ÖNERİLEN STANDART)\nRFC8489: NAT Geçişi için Oturum Geçiş Araçları (STUN) Yazarlar: M. Petit-Huguenin, G. Salgueiro, J. Rosenberg, D. Wing, R. Mahy, P. Matthews [Şubat 2020] (Yerine geçtiği belge: RFC5389) (Durum: ÖNERİLEN STANDART)\nRFC8656: NAT Üzerinden Aktarıcı Kullanarak Geçiş (TURN): STUN’a Aktarıcı Genişletmeleri Yazarlar: T. Reddy, A. Johnston, P. Matthews, J. Rosenberg [Şubat 2020] (Yerine geçtiği belgeler: RFC5766, RFC6156) (Durum: ÖNERİLEN STANDART)\nRFC8835: WebRTC için Taşıma Katmanları Yazar: H. Alvestrand [Ocak 2021] (Durum: ÖNERİLEN STANDART)\nRFC8838: Trickle ICE: ICE Protokolü için Adayların Artımlı Sağlanması Yazarlar: E. Ivov, J. Uberti, P. Saint-Andre [Ocak 2021] (Güncellendi: RFC8863) (Durum: ÖNERİLEN STANDART)\nRFC8839: ICE için SDP (Oturum Açıklama Protokolü) Teklif/Cevap Prosedürleri Yazarlar: M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [Ocak 2021] (Yerine geçtiği belgeler: RFC5245, RFC6336) (Durum: ÖNERİLEN STANDART)\nRFC8863: Etkileşimli Bağlantı Kurulumu – Sabırla Bağlantı Bekleme (ICE PAC) Yazarlar: C. Holmberg, J. Uberti [Ocak 2021] (Günceller: RFC8445, RFC8838) (Durum: ÖNERİLEN STANDART)\n"}]