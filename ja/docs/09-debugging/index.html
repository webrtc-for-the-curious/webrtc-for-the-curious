<!doctype html><html lang=ja dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="デバッグ #  WebRTCのデバッグは、非常に困難な作業です。たくさんの可動部品があり、それらがすべて独立して壊れる可能性があります。注意していないと、間違ったものを探すために何週間もの時間を費やすことになります。やっと壊れた部品を見つけても、その原因を理解するためには、少し勉強する必要があります。
本章では、WebRTC をデバッグするための心構えを身につけます。問題をどのように分解するかを説明します。問題を把握した後は、一般的なデバッグツールを簡単にご紹介します。
問題の切り分け #  デバッグの際には、問題がどこから発生しているのかを切り分ける必要があります。問題の始まりから始めてみましょう。
シグナリングの失敗 #  ネットワーキングの失敗 #  netcatを使ってSTUNサーバーをテストします。
  20バイトのバインディングリクエストパケットを準備します。
echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 の解釈を行います。
  0001 はメッセージタイプ
  00 00 はデータセクションの長さです。
  21 12 a4 42 はマジック・クッキーです。
  54 45 53 54 54 45 53 54 54 45 53 54 (ASCIIでは TESTTESTTEST とデコードされます)は12バイトのトランザクションIDです。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="デバッグ"><meta property="og:description" content="デバッグ #  WebRTCのデバッグは、非常に困難な作業です。たくさんの可動部品があり、それらがすべて独立して壊れる可能性があります。注意していないと、間違ったものを探すために何週間もの時間を費やすことになります。やっと壊れた部品を見つけても、その原因を理解するためには、少し勉強する必要があります。
本章では、WebRTC をデバッグするための心構えを身につけます。問題をどのように分解するかを説明します。問題を把握した後は、一般的なデバッグツールを簡単にご紹介します。
問題の切り分け #  デバッグの際には、問題がどこから発生しているのかを切り分ける必要があります。問題の始まりから始めてみましょう。
シグナリングの失敗 #  ネットワーキングの失敗 #  netcatを使ってSTUNサーバーをテストします。
  20バイトのバインディングリクエストパケットを準備します。
echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 の解釈を行います。
  0001 はメッセージタイプ
  00 00 はデータセクションの長さです。
  21 12 a4 42 はマジック・クッキーです。
  54 45 53 54 54 45 53 54 54 45 53 54 (ASCIIでは TESTTESTTEST とデコードされます)は12バイトのトランザクションIDです。"><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/ja/docs/09-debugging/"><meta property="article:modified_time" content="2021-05-21T10:24:46-07:00"><meta property="og:site_name" content="好奇心旺盛な人のためのWebRTC"><title>デバッグ | 好奇心旺盛な人のためのWebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/09-debugging/ title=Felsökning><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/09-debugging/ title=调试><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/ja.search.min.dc08451a6854b22c8b1c548ad5f43cc0d9d52b4ef206f059e58b4ff6e0ccf731.js integrity="sha256-3AhFGmhUsiyLHFSK1fQ8wNnVK07yBvBZ5YtP9uDM9zE="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/ja><span>好奇心旺盛な人のためのWebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/>何を、なぜ、どのように</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/02-signaling/>シグナリング</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>接続</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>セキュリティ対策</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/05-real-time-networking/>リアルタイム・ネットワーキング</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/06-media-communication/>メディア・コミュニケーション</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>データ・コミュニケーション</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/08-applied-webrtc/>応用WebRTC</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/ class=active>デバッグ</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/10-history-of-webrtc/>歴史</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/11-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>デバッグ</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#問題の切り分け>問題の切り分け</a></li><li><a href=#tools-of-the-trade>Tools of the trade</a></li></ul></li><li><a href=#レイテンシー>レイテンシー</a><ul><li><a href=#手動によるエンドツーエンドのレイテンシー測定>手動によるエンド・ツー・エンドのレイテンシー測定</a></li><li><a href=#エンドツーエンドの遅延の自動測定>エンドツーエンドの遅延の自動測定</a></li><li><a href=#レイテンシーのデバッグのヒント>レイテンシーのデバッグのヒント</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=デバッグ>デバッグ
<a class=anchor href=#%e3%83%87%e3%83%90%e3%83%83%e3%82%b0>#</a></h1><p>WebRTCのデバッグは、非常に困難な作業です。たくさんの可動部品があり、それらがすべて独立して壊れる可能性があります。注意していないと、間違ったものを探すために何週間もの時間を費やすことになります。やっと壊れた部品を見つけても、その原因を理解するためには、少し勉強する必要があります。</p><p>本章では、WebRTC をデバッグするための心構えを身につけます。問題をどのように分解するかを説明します。問題を把握した後は、一般的なデバッグツールを簡単にご紹介します。</p><h3 id=問題の切り分け>問題の切り分け
<a class=anchor href=#%e5%95%8f%e9%a1%8c%e3%81%ae%e5%88%87%e3%82%8a%e5%88%86%e3%81%91>#</a></h3><p>デバッグの際には、問題がどこから発生しているのかを切り分ける必要があります。問題の始まりから始めてみましょう。</p><h4 id=シグナリングの失敗>シグナリングの失敗
<a class=anchor href=#%e3%82%b7%e3%82%b0%e3%83%8a%e3%83%aa%e3%83%b3%e3%82%b0%e3%81%ae%e5%a4%b1%e6%95%97>#</a></h4><h4 id=ネットワーキングの失敗>ネットワーキングの失敗
<a class=anchor href=#%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%ad%e3%83%b3%e3%82%b0%e3%81%ae%e5%a4%b1%e6%95%97>#</a></h4><p>netcatを使ってSTUNサーバーをテストします。</p><ol><li><p><strong>20バイト</strong>のバインディングリクエストパケットを準備します。</p><pre><code>echo -ne &quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&quot; | hexdump -C
00000000  00 01 00 00 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54                                       |TEST|
00000014
</code></pre><p>の解釈を行います。</p><ul><li><p><code>0001</code> はメッセージタイプ</p></li><li><p><code>00 00</code> はデータセクションの長さです。</p></li><li><p><code>21 12 a4 42</code> はマジック・クッキーです。</p></li><li><p><code>54 45 53 54 54 45 53 54 54 45 53 54</code> (ASCIIでは <code>TESTTESTTEST</code> とデコードされます)は12バイトのトランザクションIDです。</p></li></ul></li><li><p>リクエストを送信し、<strong>32バイト</strong>のレスポンスを待ちます。</p><pre><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &quot;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54 00 20 00 08  00 01 6f 32 7f 36 de 89  |TEST. ....o2.6..|
00000020
</code></pre><p>の解釈を行います:</p><ul><li><p><code>01 01</code> はメッセージタイプ</p></li><li><p><code>00 0c</code> はデータセクションの長さで、10進数では12にデコードされます。</p></li><li><p><code>21 12 a4 42</code> は、マジッククッキーです。</p></li><li><p>そして、<code>54 45 53 54 54 45 53 54 54 45 53 54</code>（ASCIIでは<code>TESTTESTTEST</code>とデコードされる）は、12バイトのトランザクションIDです。</p></li><li><p><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> は 12 バイトのデータで解釈は次のようになります:</p><ul><li><p><code>00 20</code> はタイプ: <code>xor-mapped-address</code> です。</p></li><li><p><code>00 08</code> は値の部分の長さで、10進数では8にデコードされます。</p></li><li><p><code>00 01 6f 32 7f 36 de 89</code> はデータの値で、以下のように解釈します:</p><ul><li><p><code>00 01</code> はアドレスタイプ(IPv4)です</p></li><li><p><code>6f 32</code> は XOR マップされたポートです</p></li><li><p><code>7f 36 de 89</code> はXORマップされたIPアドレスです</p></li></ul></li></ul></li></ul></li></ol><p>XORマップされた部分を解読するのは面倒ですが、<code>00 00 00 00</code>に設定された(無効な)ダミーのマジッククッキーを与えることで、stunサーバを騙してダミーのXORマップを実行させることができます。</p><pre><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &quot;\x00\x01\x00\x00\x00\x00\x00\x00TESTTESTTEST&quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 00 00 00 00  54 45 53 54 54 45 53 54  |........TESTTEST|
00000010  54 45 53 54 00 01 00 08  00 01 4e 20 5e 24 7a cb  |TEST......N ^$z.|
00000020
</code></pre><p>ダミーのマジッククッキーとのXORは冪等であるため、ポートとアドレスはレスポンスに明確に表示されます（IPアドレスをごまかして通過するパケットを操作するルータもあるため、すべての状況でこれが機能するわけではありません）。</p><ul><li><p><code>00 01 4e 20 5e 24 7a cb</code> がデータ値で、解釈は次のようになります:</p><ul><li><p><code>00 01</code> はアドレスタイプ（IPv4）です</p></li><li><p><code>4e 20</code> はマップされたポートで，10進数で 20000 にデコードされます</p></li><li><p><code>5e 24 7a cb</code> は IP アドレスで，ドット 10 進表記では <code>94.36.122.203</code> となります</p></li></ul></li></ul><h4 id=セキュリティの失敗>セキュリティの失敗
<a class=anchor href=#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%81%ae%e5%a4%b1%e6%95%97>#</a></h4><h4 id=メディアの障害>メディアの障害
<a class=anchor href=#%e3%83%a1%e3%83%87%e3%82%a3%e3%82%a2%e3%81%ae%e9%9a%9c%e5%ae%b3>#</a></h4><h4 id=データの障害>データの障害
<a class=anchor href=#%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ae%e9%9a%9c%e5%ae%b3>#</a></h4><h3 id=tools-of-the-trade>Tools of the trade
<a class=anchor href=#tools-of-the-trade>#</a></h3><h4 id=netcat-nc>netcat (nc)
<a class=anchor href=#netcat-nc>#</a></h4><p><a href=https://en.wikipedia.org/wiki/Netcat>netcat</a>は、TCP や UDP を使ったネットワーク接続を読み書きするためのコマンドラインネットワークユーティリティです。主に <code>nc</code> コマンドとして利用できます。</p><h4 id=tcpdump>tcpdump
<a class=anchor href=#tcpdump>#</a></h4><p><a href=https://en.wikipedia.org/wiki/Tcpdump>tcpdump</a> は、コマンドラインのデータネットワークパケットアナライザです。</p><p>一般的なコマンドです。</p><ul><li><p>19302 番ポートとの間の UDP パケットをキャプチャし、パケットの内容を 16 進数で表示します。</p><p><code>sudo tcpdump 'udp port 19302' -xx</code></p></li><li><p>同じくパケットをPCAP(packet capture)ファイルに保存して後で確認する。</p><p><code>sudo tcpdump 'udp port 19302' -w stun.pcap</code></p><p>PCAPファイルは、wiresharkのGUIで開くことができます。<code>wireshark stun.pcap</code> です。</p></li></ul><h4 id=wireshark>wireshark
<a class=anchor href=#wireshark>#</a></h4><h4 id=webrtc-internals>webrtc-internals
<a class=anchor href=#webrtc-internals>#</a></h4><p>Chromeには、<a href=chrome://webrtc-internals>chrome://webrtc-internals</a>で利用できる WebRTC の統計ページが組み込まれています。</p><h2 id=レイテンシー>レイテンシー
<a class=anchor href=#%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc>#</a></h2><p>レイテンシーが高いことをどうやって知ることができますか？</p><p>映像が遅れていることに気づいているかもしれませんが、どれくらい遅れているか正確に知っていますか？遅延を減らすためには、まず遅延を測定することから始めなければなりません。</p><p>本当の意味での遅延は、エンドツーエンドで測定することになっています。</p><p>つまり、送信者と受信者の間のネットワークパスのレイテンシーだけでなく、カメラのキャプチャ、フレームのエンコード、送信、受信、デコード、表示などの複合的なレイテンシーや、これらのステップ間のキューイングの可能性も含めて測定します。</p><p>エンド・ツー・エンドのレイテンシーは、各コンポーネントのレイテンシーの単純な合計ではありません。</p><p>理論的には、ライブビデオ伝送パイプラインの各コンポーネントのレイテンシーを個別に測定し、それらを合計することができますが、実際には、少なくともいくつかのコンポーネントは計測のためにアクセスできないか、パイプラインの外で測定すると大きく異なる結果になります。パイプラインステージ間のキューデプスの変化、ネットワークトポロジー、カメラの露出変化などは、エンドツーエンドのレイテンシーに影響を与えるコンポーネントのほんの一例です。</p><p>ライブストリーミングシステムの各コンポーネントの固有のレイテンシーが変化し、下流のコンポーネントに影響を与える可能性があります。キャプチャーしたビデオの内容も、レイテンシーに影響を与えます。例えば、木の枝などの高周波数の特徴には、低周波数の澄んだ青空に比べて多くのビットが必要となります。また、自動露出をオンにしたカメラでは、キャプチャレートを毎秒30フレームに設定しても、1フレームをキャプチャするのに予想される33ミリ秒よりもはるかに長い時間がかかることがあります。また、ネットワーク（特に携帯電話）での通信は、需要の変化に応じて非常にダイナミックに変化します。ユーザーが増えれば増えるほど、放送中のおしゃべりも増えます。また、ユーザーの物理的な位置（悪名高い低信号ゾーン）やその他の要因により、パケットロスやレイテンシーが増加します。無線LANアダプターやLTEモデムなどのネットワークインターフェースにパケットを送信するとどうなるでしょうか。すぐに配送できない場合は、インターフェース上でキューに入れられます。キューが大きいほど、そのネットワークインターフェースがもたらす遅延も大きくなります。</p><h3 id=手動によるエンドツーエンドのレイテンシー測定>手動によるエンド・ツー・エンドのレイテンシー測定
<a class=anchor href=#%e6%89%8b%e5%8b%95%e3%81%ab%e3%82%88%e3%82%8b%e3%82%a8%e3%83%b3%e3%83%89%e3%83%84%e3%83%bc%e3%82%a8%e3%83%b3%e3%83%89%e3%81%ae%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc%e6%b8%ac%e5%ae%9a>#</a></h3><p>エンド・ツー・エンドのレイテンシーとは、ある事象が発生してから、それが観測されるまでの時間、つまりビデオのフレームが画面に表示されるまでの時間を意味します。</p><pre><code>EndToEndLatency = T(observe) - T(happen)
</code></pre><p>素朴なアプローチとしては、イベント発生時の時間を記録し、それを観測時の時間から差し引くという方法があります。
しかし、精度がミリ秒単位になると、時間の同期が問題になります。
分散したシステム間で時計を同期させようとしても、ほとんどの場合は無駄であり、時間同期のわずかな誤差でさえ、信頼性の低い遅延測定になってしまいます。</p><p>クロック同期の問題を回避する簡単な方法は、同じクロックを使用することです。
送信者と受信者を同じ基準のフレームに入れます。</p><p>時を刻むミリ秒クロックやその他のイベントソースがあるとします。
カメラをリモートスクリーンに向けて、クロックをライブストリーミングするシステムのレイテンシーを測定したいとします。
ミリ秒のタイマーがカチカチと音を立ててから (T<code>happen</code>)、時計のビデオフレームが画面に表示される (T<code>observe</code>) までの時間を計測するには、次のような方法があります。</p><ul><li>ミリ秒の時計にカメラを向ける。</li><li>物理的に同じ場所にある受信機にビデオフレームを送る。</li><li>ミリ秒のタイマーと受信した映像を画面上で撮影する（携帯電話を使用）。</li><li>2回分を引く。
これが最も正確なエンド・ツー・エンドのレイテンシー測定法です。
これはすべてのコンポーネント（カメラ、エンコーダー、ネットワーク、デコーダー）のレイテンシーを考慮しており、クロック同期に依存していません。</li></ul><p><img src=../../images/09-diy-latency.png alt="DIY Latency" title="DIY Latency Measurement">を参照してください。
<img src=../../images/09-diy-latency-happen-observe.png alt="DIY Latency Example" title="DIY Latency Measurement Example"></p><p>上の写真では、測定されたエンドツーエンドのレイテンシーは101ミリ秒です。現在発生しているイベントは10:16:02.862ですが、ライブストリーミングシステムのオブザーバーは10:16:02.761を見ています。</p><h3 id=エンドツーエンドの遅延の自動測定>エンドツーエンドの遅延の自動測定
<a class=anchor href=#%e3%82%a8%e3%83%b3%e3%83%89%e3%83%84%e3%83%bc%e3%82%a8%e3%83%b3%e3%83%89%e3%81%ae%e9%81%85%e5%bb%b6%e3%81%ae%e8%87%aa%e5%8b%95%e6%b8%ac%e5%ae%9a>#</a></h3><p>執筆時点(2021年5月)では、エンドツーエンドの遅延に関するWebRTC規格が活発に<a href=https://github.com/w3c/webrtc-stats/issues/537>議論</a>されています。
Firefoxは、標準的なWebRTC APIの上に、ユーザーが自動遅延測定を作成できるようにするための一連のAPIを実装しました。
しかし、この段落では、遅延を自動的に測定する最も互換性のある方法について説明します。</p><p><img src=../../images/09-ntp-latency.png alt="NTP Style Latency Measurement" title="NTP Style Latency Measurement"></p><p>ラウンドトリップタイムを簡単に説明すると 私はあなたに私の時間 <code>tR1</code> を送り、私の <code>tR1</code> を時間 <code>tR2</code> で受け取ると、ラウンドトリップタイムは <code>tR2 - tR1</code> であることがわかります。</p><p>送信者と受信者の間に通信チャネル（例：<a href=https://webrtc.org/getting-started/data-channels>DataChannel</a>）が与えられた場合、受信者は以下のプロトコルに従って送信者のモノトニッククロックをモデル化することができます。</p><ol><li>時刻 <code>tR1</code> に、受信者はそのローカル・モノトニック・クロックのタイムスタンプをメッセージとして送信します。</li><li>送信者のローカル時間 <code>tS1</code> に受信すると、送信者は <code>tR1</code> のコピーに加えて、送信者の <code>tS1</code> と送信者のビデオトラック時間 <code>tSV1</code> を返信します。
送信者のビデオトラックの時間 <code>tSV1</code> を含む。</li><li>受信側の時刻<code>tR2</code>において，メッセージの送信時間と受信時間を差し引くことでラウンド・トリップ・タイムを計算する。<code>RTT = tR2 - tR1</code> となります。</li><li>ラウンド・トリップ・タイム <code>RTT</code> と送信者のローカル・タイムスタンプ <code>tS1</code> を合わせれば、送信者のモノトニック・クロックの推定値が得られます。時刻 <code>tR2</code> における送信者の現在の時刻は、<code>tS1</code> にラウンド・トリップ・タイムの半分を加えたものになります。</li><li>送信者のローカルクロックのタイムスタンプ <code>tS1</code> とビデオトラックのタイムスタンプ <code>tSV1</code> のペア、およびラウンドトリップタイム <code>RTT</code> は、受信者のビデオトラックの時間を送信者のビデオトラックに同期させるのに十分です。</li></ol><p>最後に確認した送信側ビデオフレームの時間 <code>tSV1</code> からどれだけの時間が経過したかがわかったので、現在表示されているビデオフレームの時間と <code>tSV1</code> からの経過時間を比較することで、遅延を概算することができます。</p><pre><code>expected_video_time = tSV1 + time_since(tSV1)
latency = expected_video_time - actual_video_time
</code></pre><p>この方法の欠点は、カメラの固有のレイテンシーが含まれていないことです。
ほとんどのビデオシステムでは，フレームキャプチャのタイムスタンプを，カメラからのフレームがメインメモリに送られた時刻とみなしていますが，これは記録されるイベントが実際に起こってから数秒後になります。</p><h4 id=レイテンシー推定の例>レイテンシー推定の例
<a class=anchor href=#%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc%e6%8e%a8%e5%ae%9a%e3%81%ae%e4%be%8b>#</a></h4><p>サンプルの実装では、受信機で <code>latency</code> データチャネルを開き、受信機の単調なタイマーのタイムスタンプを送信機に定期的に送信します。
送信者は、JSONメッセージで応答を返します。
受信機はこのメッセージに基づいてレイテンシーを計算します。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:#f92672>&#34;received_time&#34;</span>: <span style=color:#ae81ff>64714</span>, <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>受信者が送信したタイムスタンプ、送信者はそのタイムスタンプを反映する</span> 
    <span style=color:#f92672>&#34;delay_since_received&#34;</span>: <span style=color:#ae81ff>46</span>, <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>送信者が最後に受信した</span> <span style=color:#960050;background-color:#1e0010>`received_time`</span> <span style=color:#960050;background-color:#1e0010>から経過した時間</span>
    <span style=color:#f92672>&#34;local_clock&#34;</span>: <span style=color:#ae81ff>1597366470336</span>, <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>送信者の現在の単調なクロック時間</span>
    <span style=color:#f92672>&#34;track_times_msec&#34;</span>: {
        <span style=color:#f92672>&#34;myvideo_track1&#34;</span>: [
            <span style=color:#ae81ff>13100</span>, <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>ビデオフレームのrtpタイムスタンプ</span> <span style=color:#960050;background-color:#1e0010>(ミリ秒のタイムスケール)</span>
            <span style=color:#ae81ff>1597366470289</span> <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>ビデオフレームのモノトニッククロックのタイムスタンプ</span>
        ]
    }
}
</code></pre></div><p>受信機でデータチャンネルを開く</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>dataChannel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>createDataChannel</span>(<span style=color:#e6db74>&#39;latency&#39;</span>);
</code></pre></div><p>受信機の時間 <code>tR1</code> を定期的に送信する。この例では特に理由なく2秒を使用している。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>setInterval</span>(() =&gt; {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
    <span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>tR1</span>);
}, <span style=color:#ae81ff>2000</span>);
</code></pre></div><p>受信者から送信者に届くメッセージを処理する</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>//イベントデータが以下のような文字列であると仮定します。&#34;1234567&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>
<span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
<span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>42000</span>; <span style=color:#75715e>//現在のフレームのrtpのタイムスタンプをミリ秒のタイムスケールに変換
</span><span style=color:#75715e></span><span style=color:#a6e22e>tS1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1597366470289</span>; <span style=color:#75715e>//カレントフレームのモノトニッククロックのタイムスタンプ
</span><span style=color:#75715e></span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> {
  <span style=color:#e6db74>&#34;received_time&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>tR1</span>,
  <span style=color:#e6db74>&#34;delay_since_received&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
  <span style=color:#e6db74>&#34;local_clock&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>now</span>,
  <span style=color:#e6db74>&#34;track_times_msec&#34;</span><span style=color:#f92672>:</span> {
    <span style=color:#e6db74>&#34;myvideo_track1&#34;</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>].
  }
}
<span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>msg</span>));
</code></pre></div><p>送信者からの受信メッセージを処理し、推定レイテンシーを <code>コンソール</code> に表示する</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>();
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>fromSender</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>);
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;received_time&#39;</span>];
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;delay_since_received&#39;</span>]; <span style=color:#75715e>// 送信者がレスポンスを受信してから送信するまでに経過した時間
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;local_clock&#39;</span>];
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR1</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>networkLatency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>networkLatency</span>);
<span style=color:#a6e22e>VIDEO</span>.<span style=color:#a6e22e>requestVideoFrameCallback</span>((<span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>framemeta</span>) =&gt; {<span style=color:#960050;background-color:#1e0010>。</span>
    <span style=color:#75715e>// 送信者の現在時刻を推定
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR2</span>;
    <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span>;
    <span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>] <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>entries</span>(<span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;track_times_msec&#39;</span>])[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>].
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tS1</span>;
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span>;
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>actualVideoTimeMsec</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>framemeta</span>.<span style=color:#a6e22e>rtpTimestamp</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>90</span>); <span style=color:#75715e>// rtpのタイムベース(90000)をミリ秒のタイムベースに変換する
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>latency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>actualVideoTimeMsec</span>;
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;latency&#39;</span>, <span style=color:#a6e22e>latency</span>, <span style=color:#e6db74>&#39;msec&#39;</span>);
});
</code></pre></div><h4 id=ブラウザでの実際のビデオ時間>ブラウザでの実際のビデオ時間
<a class=anchor href=#%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6%e3%81%a7%e3%81%ae%e5%ae%9f%e9%9a%9b%e3%81%ae%e3%83%93%e3%83%87%e3%82%aa%e6%99%82%e9%96%93>#</a></h4><blockquote><p><code>&lt;video>.requestVideoFrameCallback()</code>を使うと、ウェブ制作者は合成用のフレームが提示されたときに通知を受けることができます。</p></blockquote><p>ごく最近（2020年5月）まで、ブラウザで現在表示されているビデオフレームのタイムスタンプを確実に取得することは不可能に近かった。<code>video.currentTime</code> に基づく回避方法は存在していましたが、特に正確ではありませんでした。</p><p>Chrome と Mozilla の両ブラウザ開発者は、新しい W3C 標準である <a href=https://wicg.github.io/video-rvfc/><code>HTMLVideoElement.requestVideoFrameCallback()</code></a> の導入を <a href=https://github.com/mozilla/standards-positions/issues/250>サポート</a> しており、現在のビデオフレーム時間にアクセスするための API コールバックが追加されています。
この追加は些細なことのようですが、オーディオとビデオの同期を必要とするウェブ上の複数の高度なメディアアプリケーションを可能にしました。
特にWebRTCの場合、コールバックには、現在のビデオフレームに関連するRTPタイムスタンプである<code>rtpTimestamp</code>フィールドが含まれます。
これは、WebRTCアプリケーションでは存在すべきですが、それ以外では存在しません。</p><h3 id=レイテンシーのデバッグのヒント>レイテンシーのデバッグのヒント
<a class=anchor href=#%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc%e3%81%ae%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%81%ae%e3%83%92%e3%83%b3%e3%83%88>#</a></h3><p>まず第一に、デバッグは測定されたレイテンシーに影響を与える可能性が高いため、一般的なルールとして、問題を再現できる最小のセットアップに簡略化することが挙げられます。
より多くのコンポーネントを取り除くことができれば、どのコンポーネントがレイテンシーの問題を引き起こしているのかを簡単に把握することができます。</p><h4 id=カメラのレイテンシー>カメラのレイテンシー
<a class=anchor href=#%e3%82%ab%e3%83%a1%e3%83%a9%e3%81%ae%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc>#</a></h4><p>カメラの設定により、カメラの待ち時間が異なる場合があります。
自動露出、自動フォーカス、自動ホワイトバランスの設定を確認してください。
Webカメラの「自動」機能はすべて、撮影した画像を分析してからWebRTCスタックで利用できるようにするまでに時間がかかります。</p><p>Linux をお使いの場合は、カメラの設定を制御するために <code>v4l2-ctl</code> コマンドラインツールを使用してください。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># オートフォーカスの無効化</span>
v4l2-ctl -d /dev/video0 -c focus_auto<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
<span style=color:#75715e># フォーカスを無限大にする</span>
v4l2-ctl -d /dev/video0 -c focus_absolute<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</code></pre></div><p>また、カメラの設定を素早く確認したり調整したりするために、UIツールの<code>guvcview</code>を使用しています。</p><h4 id=エンコーダーのレイテンシー>エンコーダーのレイテンシー
<a class=anchor href=#%e3%82%a8%e3%83%b3%e3%82%b3%e3%83%bc%e3%83%80%e3%83%bc%e3%81%ae%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc>#</a></h4><p>最近のエンコーダーは、エンコードされたフレームを出力する前に、いくつかのフレームをバッファリングします。
画質とビットレートのバランスを第一に考えています。
マルチパスエンコーディングは、エンコーダーが出力レイテンシーを無視した極端な例です。
エンコーダーは、最初のパスで映像全体を取り込み、その後、フレームの出力を開始します。</p><p>しかし、適切な調整を行えば、サブフレームのレイテンシーを達成した人もいます。
エンコーダが過剰な参照フレームを使用したり、B-フレームに依存していないことを確認してください。
コーデックごとにレイテンシーチューニングの設定は異なりますが、x264 の場合、フレーム出力のレイテンシーを最小にするために、<code>tune=zerolatency</code> と <code>profile=baseline</code> を使用することをお勧めします。</p><h4 id=ネットワークのレイテンシー>ネットワークのレイテンシー
<a class=anchor href=#%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e3%81%ae%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc>#</a></h4><p>ネットワークの遅延は、より良いネットワーク接続にアップグレードする以外には、ほとんど何もできないと言っても過言ではありません。
ネットワークの遅延は天気とよく似ています。雨を止めることはできませんが、天気予報をチェックして傘を持つことはできます。
WebRTCでは、ネットワークの状態をミリ秒単位で測定しています。</p><p>重要な測定基準は</p><ul><li>ラウンド・トリップ・タイム</li><li>パケットロスとパケット再送</li></ul><p><strong>ラウンド・トリップ・タイム（Round-Trip Time）</strong></p><p>WebRTC スタックには、ネットワークのラウンドトリップタイム（RTT）の測定<a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime>メカニズム</a>が組み込まれています。
遅延の適切な近似値はRTTの半分です。RTT は、パケットの送信と受信に同じ時間がかかることを前提としていますが、必ずしもそうではありません。
RTTはエンドツーエンドのレイテンシーの下限を設定します。
カメラからエンコーダーまでのパイプラインがどれだけ最適化されていても、ビデオフレームはRTT/2よりも早く受信機に到達することはできません。</p><p>組み込みのRTTメカニズムは、送信者/受信者レポートと呼ばれる特別なRTCPパケットに基づいています。
送信者は受信者にタイムリーディングを送信し、受信者は同じタイムスタンプを送信者に反映させます。
これにより、送信者は、パケットが受信者まで移動して戻ってくるまでにかかった時間を知ることができます。
RTT測定の詳細については、<a href=06-media-communication/#senderreceiver-reports>送受信レポート</a>の章を参照してください。</p><p><strong>パケットロスとパケット再送</strong>について</p><p>RTPとRTCPの両プロトコルはUDPをベースにしていますが、UDPには順序付け、配送の成功、重複しないことなどの保証はありません。
上記のようなことは、実際のWebRTCアプリケーションでも起こり得ますし、実際に起こっています。
素朴なデコーダの実装では、デコーダが画像を正常に再構成するために、フレームのすべてのパケットが配信されることを期待します。
<a href=06-media-communication/#inter-frame-types>P-フレーム</a>のパケットが失われた場合、パケットロスがあると、デコーディングアーチファクトが発生する可能性があります。
I-フレームのパケットが失われると、それに依存するすべてのフレームに重いアーティファクトが発生するか、まったくデコードされません。
これは、ビデオが「フリーズ」しているように見えます。</p><p>ビデオのフリーズやデコードの不具合を避けるために（少なくとも避けようとするために）、WebRTCはネガティブアクノレッジメントメッセージ（<a href=../06-media-communication/#negative-acknowledgment>NACK</a>）を使用しています。
受信者が期待したRTPパケットを取得できなかった場合、送信者に不足しているパケットを再度送信するようにNACKメッセージを返します。
受信者は、パケットの再送を_待つことになります。
このような再送は明らかにレイテンシーの増加を引き起こします。
送受信された NACK パケットの数は、WebRTC の組み込み統計フィールド <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcoutboundrtpstreamstats-nackcount>outbound stream nackCount</a> および <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-nackcount>inbound stream nackCount</a> に記録されます。</p><p><a href=#webrtc-internals>webrtc internals page</a>では、インバウンドとアウトバウンドの <code>nackCount</code> の美しいグラフを見ることができます。
<code>nackCount</code>が増加している場合は、ネットワークで高いパケットロスが発生していることを意味し、WebRTCスタックはそれにもかかわらず、スムーズなビデオ/オーディオ体験を実現するために最善を尽くしています。</p><p>パケットロスが非常に大きく、デコーダーが画像を生成できない場合、または完全に失われたIフレームの場合のように後続の依存画像を生成できない場合、以降のすべてのPフレームがデコードされません。
受信側は、特別なピクチャ・ロス・インジケーション・メッセージ(<a href=../06-media-communication/#full-intra-frame-request-fir-and-picture-loss-indication-pli>PLI</a>)を送信することで、その影響を軽減しようとします。
送信者は<code>PLI</code>を受信すると、受信者のデコーダを助けるために新しいIフレームを生成します。
I-フレームは通常、P-フレームよりもサイズが大きくなります。これにより、送信しなければならないパケットの数が増えます。
NACKメッセージと同様に、受信者は新しいI-フレームを待つ必要があり、追加のレイテンシーが発生します。</p><p><a href=#webrtc-internals>webrtc internals page</a>の<code>pliCount</code>を見て、もし増えていたら、パケット数が少なくなるようにエンコーダを調整するか、error resilient modeを有効にしてください。</p><h4 id=受信側のレイテンシー>受信側のレイテンシー
<a class=anchor href=#%e5%8f%97%e4%bf%a1%e5%81%b4%e3%81%ae%e3%83%ac%e3%82%a4%e3%83%86%e3%83%b3%e3%82%b7%e3%83%bc>#</a></h4><p>パケットが順番通りに来ないと、レイテンシーに影響します。
イメージパケットの下半分が上半分より先に来た場合、デコードする前に上半分を待たなければなりません。
これについては、<a href=05-real-time-networking/#solving-jitter>ジッターの解決</a>の章で詳しく説明しています。</p><p>また、<a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay>jitterBufferDelay</a>というビルトインメトリックで、フレームがデコーダに解放されるまで受信バッファで全てのパケットを待っていた時間を確認することができます。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/09-debugging/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/09-debugging/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li class=active><a href=https://webrtcforthecurious.com/ja/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/1a70667159cd5b163978675a035fe32eadacca0b title="最終更新者 Claes Mogren | May 21, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 21, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.ja/docs/09-debugging.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>このページを編集する</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#問題の切り分け>問題の切り分け</a></li><li><a href=#tools-of-the-trade>Tools of the trade</a></li></ul></li><li><a href=#レイテンシー>レイテンシー</a><ul><li><a href=#手動によるエンドツーエンドのレイテンシー測定>手動によるエンド・ツー・エンドのレイテンシー測定</a></li><li><a href=#エンドツーエンドの遅延の自動測定>エンドツーエンドの遅延の自動測定</a></li><li><a href=#レイテンシーのデバッグのヒント>レイテンシーのデバッグのヒント</a></li></ul></li></ul></nav></div></aside></main></body></html>