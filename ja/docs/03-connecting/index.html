<!doctype html><html lang=ja dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="接続 # なぜWebRTCには接続用の専用サブシステムが必要なのでしょうか？ # 現在導入されているほとんどのアプリケーションは、クライアント/サーバー接続を確立しています。クライアント/サーバー接続では、サーバーが安定した周知のトランスポートアドレスを持っている必要があります。クライアントはサーバーにコンタクトし、サーバーはそれに応答します。
WebRTCは、クライアント/サーバーモデルを使用せず、ピアツーピア（P2P）接続を確立します。P2P接続では、接続を作成するタスクが両方のピアに均等に分配されます。これは、WebRTCのトランスポートアドレス（IPとポート）は想定できず、セッション中に変更される可能性もあるためです。WebRTCはできる限りの情報を収集し、2つのWebRTCエージェント間の双方向通信を実現するために多大な努力をします。
しかし、ピアツーピアの接続を確立するのは難しいことです。これらのエージェントは、直接接続されていない異なるネットワークに存在する可能性があります。直接的な接続性が存在する場合でも、別の問題が発生することがあります。クライアントが異なるプロトコル (UDP <-> TCP) や、IPバージョン (IPv4 <-> IPv6) を利用している場合もあります。
このようにP2P接続の設定が難しいにもかかわらず、WebRTCには以下のような特徴があるため、従来のクライアント/サーバー技術よりも有利になります。
帯域幅コストの削減 # メディアの通信はピア間で直接行われるため、メディアを中継するために別のサーバーを用意する必要がありません。
遅延の低減 # 通信は直接行われる方が速いです。ユーザーが全ての通信をサーバーを経由して行うと、通信速度が低下します。
安全なE2E通信 # 直接通信の方が安全です。ユーザーはサーバーを経由せずにデータを送信するので、ユーザーはサーバーがデータを解読しないことを信じる必要はありません。
どうやって使うの？ # 上記のプロセスは、Interactive Connectivity Establishment (ICE)と呼ばれています。WebRTCよりも前のプロトコルです。
ICEは、2つのICE Agent間の通信に最適な方法を見つけようとするプロトコルです。各ICEエージェントは、到達可能な方法を公開しており、これを候補と呼びます。候補とは、基本的に、相手が到達できると考えられるエージェントのトランスポートアドレスです。ICEは、候補の中から最適な組み合わせを決定します。
ICEの実際のプロセスについては、本章の後半で詳しく説明します。WebRTC がネットワークにおけるどのような挙動を克服しようとしているかを理解すると、ICEが存在する理由を理解できます。
ネットワークの現実的な制約 # ICEは、実世界のネットワークの制約を克服するためのものです。解決策を探る前に、実際の問題点について説明します。
同じネットワークにいない # ほとんどの場合、相手の WebRTC エージェントは同じネットワーク内にいるとは限りません。典型的な通話は、通常、直接接続されていない異なるネットワークにある2つのWebRTC Agent間で行われます。
下の図は、公衆インターネットで接続された2つの異なるネットワークのグラフです。各ネットワークには2つのホストがあります。
同一ネットワーク内のホストは、非常に簡単に接続できます。 192.168.0.1 -> 192.168.0.2 の間の通信は簡単にできます。これらの2つのホストは、外部の助けを借りずにお互いに接続できます。
しかし、 ルーターB を使っているホストは、 ルーターA の後ろにあるものに直接アクセスする方法がありません。 ルーターA の後ろにある 192.168.0.1 と ルーターB の後ろにある同じIPの違いをどうやって見分けるのでしょうか？これらはプライベートIPです。 ルーターB を使用しているホストは、 ルーターA に直接トラフィックを送信できますが、リクエストはそこで終了します。ルーターAはどのホストにメッセージを転送すべきか、どうやって知るのでしょうか?
プロトコルの制限 # ネットワークによっては、UDP トラフィックを全く許可していなかったり、TCP を許可していない場合があります。ネットワークによっては、MTU(Maximum Transmission Unit)が非常に低い場合があります。このように、ネットワーク管理者が変更できる変数はたくさんあり、それが通信を困難にしています。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ja/docs/03-connecting/"><meta property="og:site_name" content="好奇心旺盛な人のためのWebRTC"><meta property="og:title" content="接続"><meta property="og:description" content="接続 # なぜWebRTCには接続用の専用サブシステムが必要なのでしょうか？ # 現在導入されているほとんどのアプリケーションは、クライアント/サーバー接続を確立しています。クライアント/サーバー接続では、サーバーが安定した周知のトランスポートアドレスを持っている必要があります。クライアントはサーバーにコンタクトし、サーバーはそれに応答します。
WebRTCは、クライアント/サーバーモデルを使用せず、ピアツーピア（P2P）接続を確立します。P2P接続では、接続を作成するタスクが両方のピアに均等に分配されます。これは、WebRTCのトランスポートアドレス（IPとポート）は想定できず、セッション中に変更される可能性もあるためです。WebRTCはできる限りの情報を収集し、2つのWebRTCエージェント間の双方向通信を実現するために多大な努力をします。
しかし、ピアツーピアの接続を確立するのは難しいことです。これらのエージェントは、直接接続されていない異なるネットワークに存在する可能性があります。直接的な接続性が存在する場合でも、別の問題が発生することがあります。クライアントが異なるプロトコル (UDP <-> TCP) や、IPバージョン (IPv4 <-> IPv6) を利用している場合もあります。
このようにP2P接続の設定が難しいにもかかわらず、WebRTCには以下のような特徴があるため、従来のクライアント/サーバー技術よりも有利になります。
帯域幅コストの削減 # メディアの通信はピア間で直接行われるため、メディアを中継するために別のサーバーを用意する必要がありません。
遅延の低減 # 通信は直接行われる方が速いです。ユーザーが全ての通信をサーバーを経由して行うと、通信速度が低下します。
安全なE2E通信 # 直接通信の方が安全です。ユーザーはサーバーを経由せずにデータを送信するので、ユーザーはサーバーがデータを解読しないことを信じる必要はありません。
どうやって使うの？ # 上記のプロセスは、Interactive Connectivity Establishment (ICE)と呼ばれています。WebRTCよりも前のプロトコルです。
ICEは、2つのICE Agent間の通信に最適な方法を見つけようとするプロトコルです。各ICEエージェントは、到達可能な方法を公開しており、これを候補と呼びます。候補とは、基本的に、相手が到達できると考えられるエージェントのトランスポートアドレスです。ICEは、候補の中から最適な組み合わせを決定します。
ICEの実際のプロセスについては、本章の後半で詳しく説明します。WebRTC がネットワークにおけるどのような挙動を克服しようとしているかを理解すると、ICEが存在する理由を理解できます。
ネットワークの現実的な制約 # ICEは、実世界のネットワークの制約を克服するためのものです。解決策を探る前に、実際の問題点について説明します。
同じネットワークにいない # ほとんどの場合、相手の WebRTC エージェントは同じネットワーク内にいるとは限りません。典型的な通話は、通常、直接接続されていない異なるネットワークにある2つのWebRTC Agent間で行われます。
下の図は、公衆インターネットで接続された2つの異なるネットワークのグラフです。各ネットワークには2つのホストがあります。
同一ネットワーク内のホストは、非常に簡単に接続できます。 192.168.0.1 -> 192.168.0.2 の間の通信は簡単にできます。これらの2つのホストは、外部の助けを借りずにお互いに接続できます。
しかし、 ルーターB を使っているホストは、 ルーターA の後ろにあるものに直接アクセスする方法がありません。 ルーターA の後ろにある 192.168.0.1 と ルーターB の後ろにある同じIPの違いをどうやって見分けるのでしょうか？これらはプライベートIPです。 ルーターB を使用しているホストは、 ルーターA に直接トラフィックを送信できますが、リクエストはそこで終了します。ルーターAはどのホストにメッセージを転送すべきか、どうやって知るのでしょうか?
プロトコルの制限 # ネットワークによっては、UDP トラフィックを全く許可していなかったり、TCP を許可していない場合があります。ネットワークによっては、MTU(Maximum Transmission Unit)が非常に低い場合があります。このように、ネットワーク管理者が変更できる変数はたくさんあり、それが通信を困難にしています。"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-02-18T20:39:12+09:00"><title>接続 | 好奇心旺盛な人のためのWebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ja/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ja.search.min.b65272d5bf660afe8aa74038f8c9e7bbfcffaf9f174aa08435c489e245616282.js integrity="sha256-tlJy1b9mCv6Kp0A4+Mnnu/z/r58XSqCENcSJ4kVhYoI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ja/><span>好奇心旺盛な人のためのWebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/ja/docs/01-what-why-and-how/>何を、なぜ、どのように</a></li><li><a href=/ja/docs/02-signaling/>シグナリング</a></li><li><a href=/ja/docs/03-connecting/ class=active>接続</a></li><li><a href=/ja/docs/04-securing/>セキュリティ対策</a></li><li><a href=/ja/docs/05-real-time-networking/>リアルタイム・ネットワーキング</a></li><li><a href=/ja/docs/06-media-communication/>メディア・コミュニケーション</a></li><li><a href=/ja/docs/07-data-communication/>データ・コミュニケーション</a></li><li><a href=/ja/docs/08-applied-webrtc/>応用WebRTC</a></li><li><a href=/ja/docs/09-debugging/>デバッグ</a></li><li><a href=/ja/docs/10-history-of-webrtc/>歴史</a></li><li><a href=/ja/docs/11-faq/>FAQ</a></li><li><a href=/ja/docs/12-glossary/>用語集</a></li><li><a href=/ja/docs/13-reference/>参考文献</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>接続</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#なぜwebrtcには接続用の専用サブシステムが必要なのでしょうか>なぜWebRTCには接続用の専用サブシステムが必要なのでしょうか？</a><ul><li><a href=#帯域幅コストの削減>帯域幅コストの削減</a></li><li><a href=#遅延の低減>遅延の低減</a></li><li><a href=#安全なe2e通信>安全なE2E通信</a></li></ul></li><li><a href=#どうやって使うの>どうやって使うの？</a></li><li><a href=#ネットワークの現実的な制約>ネットワークの現実的な制約</a><ul><li><a href=#同じネットワークにいない>同じネットワークにいない</a></li><li><a href=#プロトコルの制限>プロトコルの制限</a></li><li><a href=#ファイアウォールidsルール>ファイアウォール/IDSルール</a></li></ul></li><li><a href=#natマッピング>NATマッピング</a><ul><li><a href=#マッピングの作成>マッピングの作成</a></li><li><a href=#マッピング作成時の動作>マッピング作成時の動作</a></li><li><a href=#マッピングフィルタリングの動作>マッピングフィルタリングの動作</a></li><li><a href=#マッピングの更新>マッピングの更新</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protocol-structure>Protocol Structure</a></li><li><a href=#nat-マッピングの作成>NAT マッピングの作成</a></li><li><a href=#nat-の種類の決定>NAT の種類の決定</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-ライフサイクル>TURN ライフサイクル</a></li><li><a href=#turnの使い方>TURNの使い方</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#ice-エージェントの作成>ICE エージェントの作成</a></li><li><a href=#候補者の収集>候補者の収集</a></li><li><a href=#接続性のチェック>接続性のチェック</a></li><li><a href=#候補者選定>候補者選定</a></li><li><a href=#リスタート>リスタート</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=接続>接続
<a class=anchor href=#%e6%8e%a5%e7%b6%9a>#</a></h1><h2 id=なぜwebrtcには接続用の専用サブシステムが必要なのでしょうか>なぜWebRTCには接続用の専用サブシステムが必要なのでしょうか？
<a class=anchor href=#%e3%81%aa%e3%81%9cwebrtc%e3%81%ab%e3%81%af%e6%8e%a5%e7%b6%9a%e7%94%a8%e3%81%ae%e5%b0%82%e7%94%a8%e3%82%b5%e3%83%96%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%8c%e5%bf%85%e8%a6%81%e3%81%aa%e3%81%ae%e3%81%a7%e3%81%97%e3%82%87%e3%81%86%e3%81%8b>#</a></h2><p>現在導入されているほとんどのアプリケーションは、クライアント/サーバー接続を確立しています。クライアント/サーバー接続では、サーバーが安定した周知のトランスポートアドレスを持っている必要があります。クライアントはサーバーにコンタクトし、サーバーはそれに応答します。</p><p>WebRTCは、クライアント/サーバーモデルを使用せず、ピアツーピア（P2P）接続を確立します。P2P接続では、接続を作成するタスクが両方のピアに均等に分配されます。これは、WebRTCのトランスポートアドレス（IPとポート）は想定できず、セッション中に変更される可能性もあるためです。WebRTCはできる限りの情報を収集し、2つのWebRTCエージェント間の双方向通信を実現するために多大な努力をします。</p><p>しかし、ピアツーピアの接続を確立するのは難しいことです。これらのエージェントは、直接接続されていない異なるネットワークに存在する可能性があります。直接的な接続性が存在する場合でも、別の問題が発生することがあります。クライアントが異なるプロトコル (UDP &lt;-> TCP) や、IPバージョン (IPv4 &lt;-> IPv6) を利用している場合もあります。</p><p>このようにP2P接続の設定が難しいにもかかわらず、WebRTCには以下のような特徴があるため、従来のクライアント/サーバー技術よりも有利になります。</p><h3 id=帯域幅コストの削減>帯域幅コストの削減
<a class=anchor href=#%e5%b8%af%e5%9f%9f%e5%b9%85%e3%82%b3%e3%82%b9%e3%83%88%e3%81%ae%e5%89%8a%e6%b8%9b>#</a></h3><p>メディアの通信はピア間で直接行われるため、メディアを中継するために別のサーバーを用意する必要がありません。</p><h3 id=遅延の低減>遅延の低減
<a class=anchor href=#%e9%81%85%e5%bb%b6%e3%81%ae%e4%bd%8e%e6%b8%9b>#</a></h3><p>通信は直接行われる方が速いです。ユーザーが全ての通信をサーバーを経由して行うと、通信速度が低下します。</p><h3 id=安全なe2e通信>安全なE2E通信
<a class=anchor href=#%e5%ae%89%e5%85%a8%e3%81%aae2e%e9%80%9a%e4%bf%a1>#</a></h3><p>直接通信の方が安全です。ユーザーはサーバーを経由せずにデータを送信するので、ユーザーはサーバーがデータを解読しないことを信じる必要はありません。</p><h2 id=どうやって使うの>どうやって使うの？
<a class=anchor href=#%e3%81%a9%e3%81%86%e3%82%84%e3%81%a3%e3%81%a6%e4%bd%bf%e3%81%86%e3%81%ae>#</a></h2><p>上記のプロセスは、Interactive Connectivity Establishment (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>)と呼ばれています。WebRTCよりも前のプロトコルです。</p><p>ICEは、2つのICE Agent間の通信に最適な方法を見つけようとするプロトコルです。各ICEエージェントは、到達可能な方法を公開しており、これを候補と呼びます。候補とは、基本的に、相手が到達できると考えられるエージェントのトランスポートアドレスです。ICEは、候補の中から最適な組み合わせを決定します。</p><p>ICEの実際のプロセスについては、本章の後半で詳しく説明します。WebRTC がネットワークにおけるどのような挙動を克服しようとしているかを理解すると、ICEが存在する理由を理解できます。</p><h2 id=ネットワークの現実的な制約>ネットワークの現実的な制約
<a class=anchor href=#%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e3%81%ae%e7%8f%be%e5%ae%9f%e7%9a%84%e3%81%aa%e5%88%b6%e7%b4%84>#</a></h2><p>ICEは、実世界のネットワークの制約を克服するためのものです。解決策を探る前に、実際の問題点について説明します。</p><h3 id=同じネットワークにいない>同じネットワークにいない
<a class=anchor href=#%e5%90%8c%e3%81%98%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e3%81%ab%e3%81%84%e3%81%aa%e3%81%84>#</a></h3><p>ほとんどの場合、相手の WebRTC エージェントは同じネットワーク内にいるとは限りません。典型的な通話は、通常、直接接続されていない異なるネットワークにある2つのWebRTC Agent間で行われます。</p><p>下の図は、公衆インターネットで接続された2つの異なるネットワークのグラフです。各ネットワークには2つのホストがあります。</p><p><img src=../../images/03-two-networks.png alt="Two networks" title="Two networks"></p><p>同一ネットワーク内のホストは、非常に簡単に接続できます。 <code>192.168.0.1</code> -> <code>192.168.0.2</code> の間の通信は簡単にできます。これらの2つのホストは、外部の助けを借りずにお互いに接続できます。</p><p>しかし、 <code>ルーターB</code> を使っているホストは、 <code>ルーターA</code> の後ろにあるものに直接アクセスする方法がありません。 <code>ルーターA</code> の後ろにある <code>192.168.0.1</code> と <code>ルーターB</code> の後ろにある同じIPの違いをどうやって見分けるのでしょうか？これらはプライベートIPです。 <code>ルーターB</code> を使用しているホストは、 <code>ルーターA</code> に直接トラフィックを送信できますが、リクエストはそこで終了します。<code>ルーターA</code>はどのホストにメッセージを転送すべきか、どうやって知るのでしょうか?</p><h3 id=プロトコルの制限>プロトコルの制限
<a class=anchor href=#%e3%83%97%e3%83%ad%e3%83%88%e3%82%b3%e3%83%ab%e3%81%ae%e5%88%b6%e9%99%90>#</a></h3><p>ネットワークによっては、UDP トラフィックを全く許可していなかったり、TCP を許可していない場合があります。ネットワークによっては、MTU(Maximum Transmission Unit)が非常に低い場合があります。このように、ネットワーク管理者が変更できる変数はたくさんあり、それが通信を困難にしています。</p><h3 id=ファイアウォールidsルール>ファイアウォール/IDSルール
<a class=anchor href=#%e3%83%95%e3%82%a1%e3%82%a4%e3%82%a2%e3%82%a6%e3%82%a9%e3%83%bc%e3%83%abids%e3%83%ab%e3%83%bc%e3%83%ab>#</a></h3><p>また、「ディープ・パケット・インスペクション」やその他のインテリジェントなフィルタリングもあります。ネットワーク管理者の中には、すべてのパケットを処理しようとするソフトウェアを実行する人がいます。このようなソフトウェアはWebRTCを理解していないことが多く、WebRTCパケットをホワイトリストに載っていない任意のポートの不審なUDPパケットとして扱うなど、何をしていいかわからずブロックします。</p><h2 id=natマッピング>NATマッピング
<a class=anchor href=#nat%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0>#</a></h2><p>NAT（Network Address Translation）マッピングは、WebRTCの接続性を実現する魔法です。これにより、WebRTCは全く異なるサブネットにいる2つのピアの通信を可能にし、上記の「同じネットワーク内にない」という問題に対処しています。新たな課題が生まれる一方で、そもそもNATマッピングがどのように機能するのかを説明しましょう。</p><p>NATマッピングは、リレーやプロキシ、サーバーを使用しません。ここでも、「エージェント1」と「エージェント2」がいて、それぞれ別のネットワークにいます。しかし、トラフィックは完全に通過しています。視覚的には次のようになります。</p><p><img src=../../images/03-nat-mapping.png alt="NAT mapping" title="NAT mapping"></p><p>この通信を実現するために、NATマッピングを確立します。エージェント1は、ポート7000を使用して、エージェント2とのWebRTC接続を確立します。これにより、 <code>192.168.0.1:7000</code> から <code>5.0.0.1:7000</code> へのバインディングが作成されます。これにより、エージェント2は、 <code>5.0.0.1:7000</code> にパケットを送信することで、エージェント1に到達できるようになります。この例のようにNATマッピングを作成することは、ルータでポートフォワーディングを行うことの自動化版のようなものです。</p><p>NATマッピングの欠点は、マッピングの形式が一つではないこと（例：静的ポートフォワーディング）と、ネットワーク間で動作が一貫していないことです。ISPやハードウェアメーカーが異なる方法で行う場合もあります。場合によっては、ネットワーク管理者がこれを無効にしていることもあります。</p><p>ICEエージェントは、NATマッピングを作成したことと、そのマッピングの属性を確認できます。</p><p>これらの動作を説明したドキュメントは、<a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>です。</p><h3 id=マッピングの作成>マッピングの作成
<a class=anchor href=#%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0%e3%81%ae%e4%bd%9c%e6%88%90>#</a></h3><p>マッピングの作成は最も簡単な作業です。ネットワーク外のアドレスにパケットを送信すると、マッピングが作成されます。NAT マッピングは、NAT によって割り当てられた一時的なパブリック IP/Port に過ぎません。送信メッセージは、新たにマッピングされたアドレスを送信元アドレスとするように書き換えられます。マッピングにメッセージが送信されると、マッピングを作成したNAT内部のホストに自動的にルーティングされます。</p><p>マッピングの詳細については、ここからが複雑になります。</p><h3 id=マッピング作成時の動作>マッピング作成時の動作
<a class=anchor href=#%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0%e4%bd%9c%e6%88%90%e6%99%82%e3%81%ae%e5%8b%95%e4%bd%9c>#</a></h3><p>マッピングの作成は3つのカテゴリーに分類されます。</p><h4 id=エンドポイントに依存しないマッピング>エンドポイントに依存しないマッピング
<a class=anchor href=#%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%97%e3%81%aa%e3%81%84%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0>#</a></h4><p>NAT内の送信者ごとに1つのマッピングが作成されます。2つのパケットを2つの異なるリモートアドレスに送信した場合、NATマッピングは再利用されます。両方のリモートホストには、同じソースIP/ポートが表示されます。リモートホストが応答すれば、同じローカルリスナーに送り返されます。</p><p>これは、最良のシナリオです。通話が機能するためには、少なくとも片側がこのタイプでなければならない。</p><h4 id=アドレスに依存するマッピング>アドレスに依存するマッピング
<a class=anchor href=#%e3%82%a2%e3%83%89%e3%83%ac%e3%82%b9%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%99%e3%82%8b%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0>#</a></h4><p>新しいアドレスにパケットを送信するたびに、新しいマッピングが作成されます。2つのパケットを異なるホストに送信すると、2つのマッピングが作成されます。同じリモートホストに2つのパケットを送信し、宛先ポートが異なる場合、新しいマッピングは作成されません。</p><h4 id=アドレスとポートに依存するマッピング>アドレスとポートに依存するマッピング
<a class=anchor href=#%e3%82%a2%e3%83%89%e3%83%ac%e3%82%b9%e3%81%a8%e3%83%9d%e3%83%bc%e3%83%88%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%99%e3%82%8b%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0>#</a></h4><p>リモートIPまたはポートが異なる場合、新しいマッピングが作成されます。同じリモートホストに2つのパケットを送信し、送信先のポートが異なる場合、新しいマッピングが作成されます。</p><h3 id=マッピングフィルタリングの動作>マッピングフィルタリングの動作
<a class=anchor href=#%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0%e3%83%95%e3%82%a3%e3%83%ab%e3%82%bf%e3%83%aa%e3%83%b3%e3%82%b0%e3%81%ae%e5%8b%95%e4%bd%9c>#</a></h3><p>マッピングのフィルタリングとは、マッピングの使用を許可する人に関するルールです。これらは3つの類似した分類に分類されます。</p><h4 id=エンドポイントに依存しないフィルタリング>エンドポイントに依存しないフィルタリング
<a class=anchor href=#%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%97%e3%81%aa%e3%81%84%e3%83%95%e3%82%a3%e3%83%ab%e3%82%bf%e3%83%aa%e3%83%b3%e3%82%b0>#</a></h4><p>誰でもマッピングを使用できる。マッピングを他の複数のピアと共有し、それらがすべてトラフィックを送信できます。</p><h4 id=アドレスに依存したフィルタリング>アドレスに依存したフィルタリング
<a class=anchor href=#%e3%82%a2%e3%83%89%e3%83%ac%e3%82%b9%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%97%e3%81%9f%e3%83%95%e3%82%a3%e3%83%ab%e3%82%bf%e3%83%aa%e3%83%b3%e3%82%b0>#</a></h4><p>マッピングが作成されたホストのみがマッピングを使用できます。ホスト <code>A</code> にパケットを送信すると、そのホストは好きなだけパケットを返してくることができます。ホスト<code>B</code>がそのマッピングにパケットを送ろうとしても、それは無視されます。</p><h4 id=アドレスとポートに依存したフィルタリング>アドレスとポートに依存したフィルタリング
<a class=anchor href=#%e3%82%a2%e3%83%89%e3%83%ac%e3%82%b9%e3%81%a8%e3%83%9d%e3%83%bc%e3%83%88%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%97%e3%81%9f%e3%83%95%e3%82%a3%e3%83%ab%e3%82%bf%e3%83%aa%e3%83%b3%e3%82%b0>#</a></h4><p>マッピングが作成されたホストとポートだけがそのマッピングを使用できます。ホスト <code>A:5000</code> にパケットを送信すると、必要なだけのパケットを返信できます。ホスト <code>A:5001</code> がそのマッピングにパケットを送ろうとしても、無視されます。</p><h3 id=マッピングの更新>マッピングの更新
<a class=anchor href=#%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0%e3%81%ae%e6%9b%b4%e6%96%b0>#</a></h3><p>マッピングが 5 分間使用されない場合、破棄することを推奨します。これは、ISP やハードウェアメーカーの判断によります。</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (Session Traversal Utilities for NAT) は、NAT を利用するために作られたプロトコルです。これもWebRTC（とICE！）よりも前の技術です。このプロトコルは<a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>で定義されており、STUNのパケット構造も定義されています。STUNプロトコルはICE/TURNでも使用されています。</p><p>STUNが便利なのは、NATマッピングをプログラムで作成することができるからです。STUN以前は、NATマッピングを作成することはできましたが、そのIP/Portが何であるかはわかりませんでした。STUNでは、マッピングを作成できるだけでなく、詳細を知ることができるので、他の人とマッピングを共有して、作成したマッピング経由でトラフィックを送ることができます。</p><p>まずは、STUNの基本的な説明から始めましょう。その後、TURNとICEの使い方について説明します。今のところ、マッピングを作成するためのリクエスト/レスポンスフローについてだけ説明します。その後、他の人と共有するためにその詳細を得る方法について話します。これは、WebRTC PeerConnectionのICEのURLに <code>stun:</code> サーバーがある場合に起こる処理です。簡単に言うと、STUNは、NATの外にあるSTUNサーバーに、観測された内容を報告してもらうことで、NATの後ろにいるエンドポイントが、どのようなマッピングが作成されたかを把握するのに役立ちます。</p><h3 id=protocol-structure>Protocol Structure
<a class=anchor href=#protocol-structure>#</a></h3><p>STUNのパケットは以下のような構造になっています。</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stunメッセージのタイプ>STUNメッセージのタイプ
<a class=anchor href=#stun%e3%83%a1%e3%83%83%e3%82%bb%e3%83%bc%e3%82%b8%e3%81%ae%e3%82%bf%e3%82%a4%e3%83%97>#</a></h4><p>各STUNパケットにはタイプがあります。今のところ、以下のものについてのみ関心があります。</p><ul><li>バインディング・リクエスト - <code>0x0001</code></li><li>バインディングレスポンス - <code>0x0101</code></li></ul><p>NATマッピングを作成するには、<code>Binding Request</code>を行います。その後、サーバーは <code>Binding Response</code> で応答します。</p><h4 id=メッセージの長さ-message-length>メッセージの長さ (Message Length)
<a class=anchor href=#%e3%83%a1%e3%83%83%e3%82%bb%e3%83%bc%e3%82%b8%e3%81%ae%e9%95%b7%e3%81%95-message-length>#</a></h4><p>これは<code>Data</code>セクションの長さです。このセクションには <code>Message Type</code> で定義された任意のデータが含まれます。</p><h4 id=マジッククッキー-magic-cookie>マジッククッキー (Magic Cookie)
<a class=anchor href=#%e3%83%9e%e3%82%b8%e3%83%83%e3%82%af%e3%82%af%e3%83%83%e3%82%ad%e3%83%bc-magic-cookie>#</a></h4><p>固定値 <code>0x2112A442</code> をネットワークのバイトオーダーで表したもので、STUN トラフィックを他のプロトコルと区別するのに役立ちます。</p><h4 id=トランザクションid-transaction-id>トランザクションID (Transaction ID)
<a class=anchor href=#%e3%83%88%e3%83%a9%e3%83%b3%e3%82%b6%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3id-transaction-id>#</a></h4><p>リクエスト/レスポンスを一意に識別する96ビットの識別子です。リクエストとレスポンスを組むのに役立ちます。</p><h4 id=データ-data>データ (Data)
<a class=anchor href=#%e3%83%87%e3%83%bc%e3%82%bf-data>#</a></h4><p>データには、STUN属性のリストが含まれます。STUNアトリビュートは以下のような構造になっています。</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><code>STUN Binding Request</code> は属性を使用しません。これは、<code>STUN Binding Request</code> がヘッダーのみを含むことを意味します。</p><p><code>STUN Binding Response</code> は <code>XOR-MAPPED-ADDRESS (0x0020)</code> という属性を使用します。この属性にはIP/Portが含まれる。これが、作成されるNATマッピングのIP/Portです!</p><h3 id=nat-マッピングの作成>NAT マッピングの作成
<a class=anchor href=#nat-%e3%83%9e%e3%83%83%e3%83%94%e3%83%b3%e3%82%b0%e3%81%ae%e4%bd%9c%e6%88%90>#</a></h3><p>STUNを使ってNATマッピングを作成するには、リクエストを1回送るだけです。STUNサーバに <code>STUN Binding Request</code> を送信します。STUNサーバは、 <code>STUN Binding Response</code> を返信します。
この <code>STUN Binding Response</code> には<code>マップされたアドレス</code>が含まれます。<code>マップされたアドレス</code>は、STUNサーバがあなたをどのように見るかであり、あなたの<code>NATマッピング</code>です。</p><p><code>マップされたアドレス</code>は、誰かにパケットを送ってもらいたいときに共有するものです。</p><p><code>マップされたアドレス</code>は、あなたの <code>Public IP</code> や <code>Server Reflexive Candidate</code> とも呼ばれています。</p><h3 id=nat-の種類の決定>NAT の種類の決定
<a class=anchor href=#nat-%e3%81%ae%e7%a8%ae%e9%a1%9e%e3%81%ae%e6%b1%ba%e5%ae%9a>#</a></h3><p>残念ながら、「マップされたアドレス」はすべてのケースで使えるわけではありません。 「アドレス依存」の場合、STUNサーバーだけが自分にトラフィックを送り返すことができます。もしあなたがこのアドレスを共有していて、他の相手がメッセージを送ろうとすると、そのメッセージはドロップされます。これでは他の人との通信には使えません。もし、STUNサーバーがあなたの代わりにパケットを相手に転送することができれば、「アドレス依存」のケースは実際に解決可能であることがわかるかもしれません。これは、以下のTURNを使った解決策につながります。</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a>では、NATタイプを決定するためのテストを行う方法を定義しています。これは、直接接続が可能かどうかを事前に知ることができるので便利です。</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN(Traversal Using Relays around NAT)は<a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a>で定義されており、直接接続ができない場合の解決策です。2つのNATタイプに互換性がない場合や、同じプロトコルを使用できない場合などに使用します。TURNは、プライバシー保護のためにも利用できます。すべての通信をTURN経由で行うことで、クライアントの実際のアドレスを見えなくできます。</p><p>TURNは専用のサーバーを使います。このサーバーは、クライアントのプロキシとして機能します。クライアントは、TURNサーバーに接続し、<code>アロケーション</code>を作成します。アロケーションを作成することで、クライアントは一時的なIP/ポート/プロトコルを取得し、それを使ってクライアントにトラフィックを送り返すことができます。この新しいリスナーは<code>中継トランスポートアドレス</code>として知られています。これは転送アドレスのようなもので、他の人が<code>TURN</code>を介してあなたにトラフィックを送れるように、このアドレスを提供します。<code>中継トランスポートアドレス</code>を渡した相手ごとに、自分との通信を許可するための新しい<code>パーミッション</code>を作成する必要があります。</p><p>TURNを介してアウトバウンド・トラフィックを送信する際には、<code>中継トランスポートアドレス</code>を介して送信されます。リモートピアがトラフィックを取得する際には、TURNサーバーから送られてきていることがわかります。</p><h3 id=turn-ライフサイクル>TURN ライフサイクル
<a class=anchor href=#turn-%e3%83%a9%e3%82%a4%e3%83%95%e3%82%b5%e3%82%a4%e3%82%af%e3%83%ab>#</a></h3><p>以下は、TURNのアロケーションを作成したいクライアントが行うべきことです。TURNを使っている相手との通信には、何の変更も必要ありません。相手はIP/Portを取得し、他のホストと同様に通信を行います。</p><h4 id=アロケーション>アロケーション
<a class=anchor href=#%e3%82%a2%e3%83%ad%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3>#</a></h4><p>アロケーションは、TURNの中核をなすものです。アロケーション」とは、基本的に「TURNセッション」のことです。TURNのアロケーションを作成するには、TURNの<code>サーバー・トランスポート・アドレス</code>（通常はポート<code>3478</code>）と通信します。</p><p>アロケーションを作成する際には、以下の項目を指定する必要があります。</p><ul><li>Username/Password - TURNのアロケーションを作成するには認証が必要です。</li><li>アロケーション・トランスポート - サーバー(<code>中継トランスポートアドレス</code>)と通信相手間のトランスポートプロトコルにはUDPまたはTCPを指定できます。</li><li>偶数ポート - 複数のアロケーションに対して連続したポートを要求できますが、WebRTCには関係ありません。</li></ul><p>リクエストが成功すると、TURNサーバーから、Dataセクションに以下のSTUN属性を持つレスポンスが得られます。</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>TURN クライアント</code> の<code>マップされたアドレス</code>です。誰かがデータを<code>中継トランスポートアドレス</code>に送ると、ここに転送されます。</li><li><code>RELAYED-ADDRESS</code> - これは他のクライアントに配るためのアドレスです。誰かがこのアドレスにパケットを送ると、TURNクライアントに中継されます。</li><li><code>LIFETIME</code> - このTURNアロケーションが破棄されるまでの期間です。 <code>リフレッシュ</code> リクエストを送ることで、寿命を延長できます。</li></ul><h4 id=パーミッション>パーミッション
<a class=anchor href=#%e3%83%91%e3%83%bc%e3%83%9f%e3%83%83%e3%82%b7%e3%83%a7%e3%83%b3>#</a></h4><p>リモートホストは、あなたがパーミッションを作成するまで、あなたの<code>中継トランスポートアドレス</code>に送信できません。パーミッションを作成すると、TURNサーバーに「このIP/Portはインバウンドトラフィックの送信が許可されています」と伝えることになります。</p><p>リモートホストは、TURNサーバーに表示されているIP/Portを伝える必要があります。つまり、TURNサーバーに<code>STUN Binding Request</code>を送る必要があります。よくあるエラーケースは、リモートホストが別のサーバーに<code>STUN Binding Request</code>を送信してしまうことです。そして、このIPに対してパーミッションを作成するように要求してきます。</p><p>例えば、<code>アドレスに依存したマッピング</code>の背後にあるホストに対するパーミッションを作成したいとします。別のTURNサーバーから<code>マップされたアドレス</code>を生成すると、すべてのインバウンドトラフィックがドロップされます。異なるホストと通信するたびに新しいマッピングが生成されます。パーミッションはリフレッシュされないと5分後に失効します。</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>これら2つのメッセージは、TURNクライアントがリモートピアにメッセージを送信するためのものです。</p><p>SendIndicationは自己完結型のメッセージです。その中には、送りたいデータと、誰に送るかが書かれています。これは、リモート・ピアにたくさんのメッセージを送信する場合には無駄になります。1,000通のメッセージを送信すると、相手のIPアドレスを1,000回繰り返すことになります。</p><p>ChannelDataでは、データを送ることはできますが、IPアドレスを繰り返すことはできません。IP/Portを持つChannelを作成します。その後、ChannelIdを使って送信すると、IP/Portはサーバー側で入力されます。たくさんのメッセージを送信する場合は、この方法が適しています。</p><h4 id=refreshing>Refreshing
<a class=anchor href=#refreshing>#</a></h4><p>割り当てられたデータは自動的に破棄されます。TURNクライアントは、アロケーション作成時に指定した<code>LIFETIME</code>よりも早くリフレッシュする必要があります。</p><h3 id=turnの使い方>TURNの使い方
<a class=anchor href=#turn%e3%81%ae%e4%bd%bf%e3%81%84%e6%96%b9>#</a></h3><p>TURNの使い方には2つの形態があります。通常は、片方のピアが「TURNクライアント」として動作し、もう片方が直接通信を行います。例えば、双方のクライアントがUDPをブロックしているネットワークにいるために、それぞれのTURNサーバーへの接続がTCP経由で行われるなど、双方にTURN Usageが存在する場合があります。</p><p>これらの図は、そのような場合を説明するのに役立ちます。</p><h4 id=通信のための1turnの割り当て>通信のための1TURNの割り当て
<a class=anchor href=#%e9%80%9a%e4%bf%a1%e3%81%ae%e3%81%9f%e3%82%81%e3%81%ae1turn%e3%81%ae%e5%89%b2%e3%82%8a%e5%bd%93%e3%81%a6>#</a></h4><p><img src=../../images/03-one-turn-allocation.png alt="One TURN allocation" title="One TURN allocation"></p><h4 id=コミュニケーションのための2つのturnアロケーション>コミュニケーションのための2つのTURNアロケーション
<a class=anchor href=#%e3%82%b3%e3%83%9f%e3%83%a5%e3%83%8b%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e3%81%9f%e3%82%81%e3%81%ae2%e3%81%a4%e3%81%aeturn%e3%82%a2%e3%83%ad%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3>#</a></h4><p><img src=../../images/03-two-turn-allocations.png alt="Two TURN allocations" title="Two TURN allocations"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE（Interactive Connectivity Establishment）は、WebRTCが2つのAgentを接続する方法です。<a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>で定義されていますが、これもWebRTCよりも前の技術です。ICEは、接続性を確立するためのプロトコルです。ICEは、2つのピア間で可能なすべてのルートを決定し、接続を維持します。</p><p>これらのルートは<code>候補ペア</code>と呼ばれ、ローカルとリモートのトランスポートアドレスのペアとなっています。ICEでは、ここでSTUNとTURNが活躍します。これらのアドレスは、ローカルIPアドレスにポートを加えたものや、<code>NATマッピング</code>、<code>中継トランスポートアドレス</code>などがあります。それぞれの側は、使用したいアドレスをすべて集めて交換し、接続を試みます。</p><p>2つのICEエージェントは、ICE pingパケット（正式には接続性チェックと呼ばれる）を使って通信し、接続性を確立します。接続が確立した後は、好きなものを送ることができます。通常のソケットと同じように使用できます。これらのチェックには STUN プロトコルを使用しています。</p><h3 id=ice-エージェントの作成>ICE エージェントの作成
<a class=anchor href=#ice-%e3%82%a8%e3%83%bc%e3%82%b8%e3%82%a7%e3%83%b3%e3%83%88%e3%81%ae%e4%bd%9c%e6%88%90>#</a></h3><p>ICE エージェントは、<code>コントロールする</code>または<code>コントロールされる</code>のいずれかです。<code>コントロールするエージェント</code>は、選択された<code>候補者ペア</code>を決定します。通常、オファーを送信している相手がコントロール側になります。</p><p>それぞれの側は<code>ユーザーフラグメント</code>と<code>パスワード</code>を持たなければならない。接続性のチェックを開始する前に、この2つの値を交換する必要があります。<code>ユーザーフラグメント</code>はプレーンテキストで送信され、複数のICEセッションをデマックスするのに役立ちます。
<code>パスワード</code>は<code>MESSAGE-INTEGRITY</code>属性の生成に使用されます。各STUNパケットの最後には、<code>パスワード</code>をキーにしてパケット全体をハッシュ化した属性があります。これは、パケットを認証し、改ざんされていないことを確認するために使用されます。</p><p>WebRTCでは、前章で説明したように、これらの値はすべて <code>Session Description</code> を介して配布されます。</p><h3 id=候補者の収集>候補者の収集
<a class=anchor href=#%e5%80%99%e8%a3%9c%e8%80%85%e3%81%ae%e5%8f%8e%e9%9b%86>#</a></h3><p>次に、到達可能なすべてのアドレスを収集する必要があります。これらのアドレスを候補と呼びます。</p><h4 id=ホスト>ホスト
<a class=anchor href=#%e3%83%9b%e3%82%b9%e3%83%88>#</a></h4><p>ホスト候補は、ローカルインターフェイス上で直接リッスンするものです。これはUDPでもTCPでも構いません。</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>mDNS候補は、ホスト候補と似ていますが、IPアドレスが見えません。相手に自分のIPアドレスを知らせるのではなく、UUIDをホスト名として与えます。そして、マルチキャストのリスナーを設定し、誰かがあなたの公開したUUIDを要求してきたら応答します。</p><p>もしあなたがエージェントと同じネットワーク内にいれば、マルチキャストでお互いを見つけることができます。同じネットワーク内にいない場合は、（ネットワーク管理者がマルチキャストパケットの通過を許可するようにネットワークを明示的に設定していない限り）接続することができません。</p><p>これは、プライバシー保護のために役立ちます。ユーザーは、Host候補であれば、WebRTC経由であなたのローカルIPアドレスを（あなたに接続しようとしなくても）知ることができますが、mDNS候補では、ランダムなUUIDしか得られません。</p><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><p>Server Reflexive 候補は、STUN サーバーに <code>STUN Binding Request</code> を行うことで生成されます。</p><p><code>STUN Binding Response</code>を取得すると、<code>XOR-MAPPED-ADDRESS</code>がサーバーリフレックス候補となる。</p><h4 id=peer-reflexive>Peer Reflexive
<a class=anchor href=#peer-reflexive>#</a></h4><p>Peer Reflexive候補とは、自分が知らないアドレスからインバウンドリクエストを受け取った場合のことです。ICEは認証されたプロトコルであるため、そのトラフィックが有効であることがわかります。これは、リモートピアが、自分の知らないアドレスから通信しているということです。</p><p>これは、<code>ホスト候補</code>が<code>サーバー反射候補</code>と通信している場合によく起こります。サブネットの外で通信しているため、新しい<code>NATマッピング</code>が作成されました。接続性チェックは実際にはSTUNパケットであると言ったことを覚えていますか？STUNレスポンスのフォーマットでは、当然、相手は相手リフレックスアドレスを報告します。</p><h4 id=リレー>リレー
<a class=anchor href=#%e3%83%aa%e3%83%ac%e3%83%bc>#</a></h4><p>リレー候補は、TURNサーバーを使って生成されます。</p><p>TURNサーバーとの最初のハンドシェイクの後、<code>RELAYED-ADDRESS</code>が与えられ、これがリレー候補となります。</p><h3 id=接続性のチェック>接続性のチェック
<a class=anchor href=#%e6%8e%a5%e7%b6%9a%e6%80%a7%e3%81%ae%e3%83%81%e3%82%a7%e3%83%83%e3%82%af>#</a></h3><p>これで、リモートエージェントの<code>ユーザフラグメント</code>、<code>パスワード</code>、候補者がわかりました。これで、接続を試みることができます。すべての候補者はお互いにペアになっています。つまり、片側3人の候補者がいる場合、9組の候補者がいることになります。</p><p>視覚的には次のようになります。</p><p><img src=../../images/03-connectivity-checks.png alt="Connectivity checks" title="Connectivity checks"></p><h3 id=候補者選定>候補者選定
<a class=anchor href=#%e5%80%99%e8%a3%9c%e8%80%85%e9%81%b8%e5%ae%9a>#</a></h3><p>コントロールするエージェントとコントロールされるエージェントは、それぞれのペアでトラフィックの送信を開始します。これは、一方のエージェントが<code>Address Dependent Mapping</code>を使用している場合に必要となり、<code>Peer Reflexive Candidate</code>が作成されます。</p><p>ネットワークトラフィックを確認した各<code>候補ペア</code>は、<code>有効な候補ペア</code>に昇格します。コントロールエージェントは、<code>有効な候補者</code>のペアを1組選び、それを指名します。これが<code>ノミネートペア</code>となります。コントロール側とコントロールされる側のエージェントは、もう一回、双方向通信を試みます。これが成功すると，<code>指名されたペア</code>は<code>選択された候補者ペア</code>になります。このペアは、その後のセッションでも使用されます。</p><h3 id=リスタート>リスタート
<a class=anchor href=#%e3%83%aa%e3%82%b9%e3%82%bf%e3%83%bc%e3%83%88>#</a></h3><p><code>選択された候補ペア</code>が何らかの理由（NATマッピングの期限切れ、TURNサーバーのクラッシュなど）で動作しなくなった場合、ICEエージェントは<code>失敗</code>状態になります。どちらのエージェントも再起動することで、すべてのプロセスをやり直すことができます。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/5dc030c54ab7ef2af636cfa7d858385066b0428f title='最終更新者 Takumi Suzuki | 2月 18, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>2月 18, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>このページを編集する</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#なぜwebrtcには接続用の専用サブシステムが必要なのでしょうか>なぜWebRTCには接続用の専用サブシステムが必要なのでしょうか？</a><ul><li><a href=#帯域幅コストの削減>帯域幅コストの削減</a></li><li><a href=#遅延の低減>遅延の低減</a></li><li><a href=#安全なe2e通信>安全なE2E通信</a></li></ul></li><li><a href=#どうやって使うの>どうやって使うの？</a></li><li><a href=#ネットワークの現実的な制約>ネットワークの現実的な制約</a><ul><li><a href=#同じネットワークにいない>同じネットワークにいない</a></li><li><a href=#プロトコルの制限>プロトコルの制限</a></li><li><a href=#ファイアウォールidsルール>ファイアウォール/IDSルール</a></li></ul></li><li><a href=#natマッピング>NATマッピング</a><ul><li><a href=#マッピングの作成>マッピングの作成</a></li><li><a href=#マッピング作成時の動作>マッピング作成時の動作</a></li><li><a href=#マッピングフィルタリングの動作>マッピングフィルタリングの動作</a></li><li><a href=#マッピングの更新>マッピングの更新</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protocol-structure>Protocol Structure</a></li><li><a href=#nat-マッピングの作成>NAT マッピングの作成</a></li><li><a href=#nat-の種類の決定>NAT の種類の決定</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-ライフサイクル>TURN ライフサイクル</a></li><li><a href=#turnの使い方>TURNの使い方</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#ice-エージェントの作成>ICE エージェントの作成</a></li><li><a href=#候補者の収集>候補者の収集</a></li><li><a href=#接続性のチェック>接続性のチェック</a></li><li><a href=#候補者選定>候補者選定</a></li><li><a href=#リスタート>リスタート</a></li></ul></li></ul></nav></div></aside></main></body></html>