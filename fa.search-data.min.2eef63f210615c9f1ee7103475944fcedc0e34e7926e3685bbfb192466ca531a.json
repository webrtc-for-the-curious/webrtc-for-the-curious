[{"id":0,"href":"/fa/docs/01-what-why-and-how/","title":"چه چیزی، چرا و چگونه","section":"Docs","content":" چه چیزی، چرا و چگونه # WebRTC چیست؟ # WebRTC، که اختصاری برای Web Real-Time Communication می باشد، هم یک API و هم یک پروتکل است. پروتکل WebRTC مجموعه ای از قوانین برای دو نماینده WebRTC برای مذاکره دو طرفه و ایمن در زمان بی درنگ است. WebRTC API نیز به توسعه دهنگان اجازه می دهد که از پروتکل WebRTC استفاده کنند. WebRTC API فقط برای زبان جاوا اسکریپت است.\nیک رابطه مشابه بین HTTP و Fetch API وجود دارد. پروتکل WebRTC همانند HTTP و WebRTC API مانند Fetch API است.\nپرونکل WebRTC در API ها و زبان های دیگر علاوه بر جاوا اسکریپت وجود دارد. شما می توانید سرورها و همچنین ابزار های domain-specific را پیدا کنید. همه ی این پیاده سازی ها از پروتکل WebRTC استفاده می کنند بنابراین آن ها می توانند با یکدیگر تعامل داشته باشند.\nپروتکل WebRTC در IETF و در گروه کاری rtcweb نگهداری می شود. WebRTC API نیز در W3C تحت عنوان webrtc مستند سازی شده است.\nچرا باید WebRTC را یاد بگیرم؟ # این های چیز هایی هستند که WebRTC به شما خواهد داد. این لیست جامع نیست، فقط یک نمونه از چیز هایست که ممکن است در خلال سفر یادگیریتان قدردان آن شوید. اگر تمامی این مباحث را نمی دانید نگران نباشید، این کتاب این ها را در مسیر یادگیری به شما آموزش خواهد داد.\nیک استاندارد باز چندین پیاده سازی دسترسی در مرورگر ها رمزنگاری اجباری پیمایش NAT فناوری موجود تغییر کاربری داده شده کنترل ازدحام تاخیری کمتر از یک ثانیه پروتکل WebRTC یک مجموعه از دیگر فناوری هاست # این یک عنوان است که به اندازه یک کتاب کامل برای توضیح دادنش وقت می برد. هرچند برای شروع ما این را به چهار بخش تقسیم کرده ایم.\nسیگنالینگ اتصال امنیت برقرای ارتباط این چهار گام به ترتیب اجرا می شوند. برای شروع گام بعدی، باید گام قبلی به صورت 100% موفقیت آمیز بوده باشد.\nیک حقیقت عجیب و غریب درباره WebRTC این است که هر گام در حقیقت از چندین پروتکل دیگر ساخته شده است! برای ساخت WebRTC ما خیلی از فناوری های دیگر را با هم پیوند زده ایم. از این رو، WebRTC بیشتر یک ترکیب و پیکربندی از فناوری های به خوبی درک شده است که از اویل دهه ی 2000 دور ما بوده است.\nهر یک از این گام ها یک بخش مختص به خود دارند، اما بسیار مفید است که اول آن ها را در سطح بالاتر درک کنیم. به دلیل این که آن ها به یکدیگر وابسه هستند، این به شما کمک خواهد کرد که وقتی توضیح بیشتری درباره اهداف هر کدام از این گام ها به شما می دهیم درک بهتری داشته باشید.\nسیگنالینگ: چگونه همتا ها(رایانه ها) همدیگر را در WebRTC پیدا می کنند # زمانی که یک نماینده WebRTC می خواهد شروع می کند، هیچ ایده ای ندارد که با چه کسی قرار است برقراری ارتباط را انجام دهد و با چه چیزی قرار است با آن ها در ارتباط باشد. سیگنالیگ این مسئله را حل کرده است! سیگنالیگ استفاده می شود که تماس را راه‌اندازی کند. بنابراین دو نماینده WebRTC می توانند ارتباط را آغاز کنند.\nسگتالینگ از یک پروتکل موجود به نام SDP (پروتکل توضیح نشست) استفاده می کند. SDP یک پروتکل متن ساده است. هر پیغام SDP از جفت های کلید/مقدار ساخته شده است و شامل یک لیست از \u0026ldquo;بخش های رسانه\u0026rdquo; است. SDP ی جزییات تبادل دو نماینده WebRTC مانند زیر است\nآی پی ها و درگاه های که به داوطلب ها، قابل دسترسی است. چه تعداد ویدیو و صدا نماینده می خواهد بفرستد. چه کدک ویدیو و صدا هر نماینده پشتیبانی می کند. مقادیری که بین اتصال استفاده می شود (uFrag/uPwd). مقادیری امنیتی (اثر انگشت گواهینامه امنیتی). توجه داشته باشید که سیگنالینگ معمولا وقتی \u0026ldquo;خارج از دسترس است\u0026rdquo; اتفاق می افتد؛ که به این معناست که، برنامه ها غالبا از خود WebRTC برای تبادل پیغام های WebRTC استفاده نمی کنند. از هر معماری مناسب برای ارسال پیام می توان برای انتقال SDP ها بین همتاهای متصل استفاده کرد و بسیاری از برنامه ها از زیرساخت موجود خود (مانند نقاط پایانی REST، اتصالات WebSocket یا پراکسی های احراز هویت) برای تسهیل تبادل آسان SDP ها بین کاربران استفاده می کنند.\nاتصالات و پیمایش NAT با استفاده از STUN/TURN # دو نماینده WebRTC اکنون جزئیات کافی برای اتصال به یکدیگر را می دانند. سپس WebRTC از یک فناوری دیگر به نام ICE استفاده می کند.\nICE (Interactive Connectivity Establishment) پروتکلی است که قدمت آن قبل از WebRTC است. ICE امکان برقراری ارتباط بین دو عامل را فراهم می کند. این عوامل می توانند در همان شبکه یا در آن سوی دنیا باشند. ICE راه حلی برای برقراری ارتباط مستقیم بدون سرور مرکزی است.\nجادوی واقعی اینجا \u0026lsquo;NAT Traversal\u0026rsquo; و STUN/TURN سرور است. این دو مفهوم تنها چیزی است که برای برقراری ارتباط با یک عامل ICE در زیرشبکه دیگر نیاز دارید. ما بعداً به بررسی عمیق این موضوعات خواهیم پرداخت.\nهنگامی که ICE با موفقیت وصل شد، WebRTC سپس به ایجاد یک انتقال رمزگذاری شده می‌پردازد. این انتقال برای صدا، تصویر و داده استفاده می شود.\nایمن سازی لایه انتقال با DTLS و SRTP # اکنون که ارتباط دو طرفه داریم (از طریق ICE) باید ارتباط امن برقرار کنیم. این کار از طریق دو پروتکل انجام می شود که قدمتی بیش از WebRTC دارند. اولین پروتکل DTLS (امنیت لایه انتقال داده) است که فقط TLS روی UDP است. TLS پروتکل رمزنگاری است که برای ایمن سازی ارتباطات از طریق HTTPS استفاده می شود. پروتکل دوم SRTP (پروتکل امن حمل و نقل بلادرنگ) است.\nابتدا WebRTC با انجام یک دست دادن(Hand Shaking) DTLS روی اتصال ایجاد شده توسط ICE متصل می شود. برخلاف HTTPS، WebRTC از مرجع مرکزی برای گواهی ها استفاده نمی کند. در عوض، WebRTC فقط ادعا می کند که گواهی مبادله شده از طریق DTLS با اثر انگشت به اشتراک گذاشته شده از طریق سیگنالینگ مطابقت دارد. این اتصال DTLS سپس برای پیام های DataChannel استفاده می شود.\nسپس WebRTC از پروتکل دیگری برای انتقال صدا/تصویر به نام RTP استفاده می کند. ما بسته های RTP خود را با استفاده از SRTP ایمن می کنیم. ما جلسه SRTP خود را با استخراج کلیدها از جلسه DTLS مذاکره شده اولیه ایمن می کنیم. در فصل بعدی، به این بحث خواهیم پرداخت که چرا انتقال رسانه، پروتکل خاص خود را دارد.\nحالا کار ما تمام شد! اکنون ارتباط دو طرفه و ایمن دارید. اگر یک ارتباط پایدار بین نمایندگان WebRTC خود دارید، به این همه پیچیدگی ممکن است نیاز داشته باشید. متأسفانه، دنیای واقعی محدودیت‌هایی برای از دست دادن بسته‌ها و پهنای باند دارد و بخش بعدی درباره نحوه برخورد ما با آن‌ها است.\nارتباط با همتایان از طریق RTP و SCTP # ما اکنون دو نماینده WebRTC با ارتباطات دوطرفه ایمن داریم. بیایید ارتباط را شروع کنیم! مجدداً از دو پروتکل از قبل موجود استفاده می کنیم: RTP (پروتکل حمل و نقل بلادرنگ) و SCTP (پروتکل انتقال کنترل جریان). از RTP برای تبادل رسانه های رمزگذاری شده با SRTP و از SCTP برای ارسال و دریافت پیام های DataChannel رمزگذاری شده با DTLS استفاده می کنیم.\nRTP بسیار کوچک است اما آنچه را که برای پیاده‌سازی جریان بلادرنگ نیاز است را فراهم می کند. نکته مهم این است که RTP به توسعه‌دهنده انعطاف‌پذیری می‌دهد، بنابراین آنها می‌توانند تاخیر، از دست دادن و تراکم داده را به دلخواه خود مدیریت کنند. در بخش رسانه بیشتر به این موضوع خواهیم پرداخت.\nپروتکل نهایی در این بخش SCTP است. SCTP اجازه می دهد گزینه های بسیاری برای تحویل پیام ها داشته باشیم. شما می توانید به صورت اختیاری انتخاب کنید که تحویل غیرقابل اعتماد و خارج از سفارش داشته باشید، بنابراین می توانید تاخیر مورد نیاز برای سیستم های بلادرنگ را دریافت کنید.\nWebRTC، مجموعه ای از پروتکل ها # WebRTC بسیاری از مشکلات را حل می کند. در ابتدا، این ممکن است حتی بیش از حد مهندسی شده به نظر برسد. نبوغ WebRTC واقعاً وصف نکردنی است. در ابتدا تصور نمی شد که بتواند همه چیز را بهتر حل کند. در عوض، بسیاری از فن‌آوری‌های تک منظوره موجود را در بر گرفت و آنها را با هم ترکیب کرد.\nاین به ما این امکان را می دهد که هر قسمت را به صورت جداگانه بررسی و یاد بگیریم بدون اینکه در آنغرق شویم. یک راه خوب برای یادگیری آن این است که \u0026ldquo;WebRTC Agent\u0026rdquo; را در واقع مثل یک ارکستراتور پروتکل های مختلف تجسم کنیم.\nWebRTC (API) چگونه کار می کند # این بخش نشان می دهد که چگونه API جاوا اسکریپت به پروتکل نگاشت می شود. این یک نسخه نمایشی گسترده از WebRTC API نیست، بلکه بیشتر برای ایجاد یک مدل ذهنی از نحوه پیوند آن با یکدیگر است. اگر با هیچکدام آشنا نیستید، اشکالی ندارد. این می تواند یک بخش سرگرم‌کننده برای یادگیری بیشتر برای شما باشد!\nnew RTCPeerConnection # RTCPeerConnection سطح بالای \u0026ldquo;نشست WebRTC\u0026rdquo; است. این شامل تمام پروتکل های ذکر شده در بالا است. زیرسیستم ها همه تخصیص داده شده اند اما هنوز هیچ اتفاقی نمی افتد.\naddTrack # addTrack یک جریان RTP جدید ایجاد می کند. یک منبع همگام سازی تصادفی (SSRC) برای این جریان ایجاد می شود. سپس این جریان در قسمت توضیحات جلسه ایجاد شده توسط createOffer در یک بخش رسانه قرار خواهد گرفت. هر تماس با addTrack یک بخش رسانه و SSRC جدید ایجاد می کند.\nبلافاصله پس از ایجاد یک جلسه SRTP، این بسته های رسانه ای پس از رمزگذاری با استفاده از SRTP از طریق ICE ارسال می شوند.\ncreateDataChannel # createDataChannel در صورت عدم وجود ارتباط SCTP، یک جریان SCTP جدید ایجاد می کند. به طور پیش‌فرض، SCTP فعال نیست، اما تنها زمانی شروع می‌شود که یک طرف درخواست کانال داده را داشته باشد.\nبلافاصله پس از ایجاد یک جلسه DTLS، انجمن SCTP شروع به ارسال بسته ها از طریق ICE و رمزگذاری شده با DTLS می کند.\ncreateOffer # createOffer یک Session Description از وضعیت محلی ایجاد می کند تا با همتای راه دور به اشتراک گذاشته شود.\nعمل فراخوانی createOffer چیزی را برای همتای محلی تغییر نمی‌دهد.\nsetLocalDescription # setLocalDescription هر گونه تغییر درخواستی را انجام می دهد. addTrack، createDataChannel و تماس‌های مشابه همگی تا برقراری این تماس، به تعویق می افتد. setLocalDescription با مقدار ایجاد شده توسط createOffer فراخوانی می شود.\nمعمولاً پس از این تماس، پیشنهاد را برای همتای راه دور ارسال می‌کنید و آنها با آن setRemoteDescription را فراخوانی می‌کنند.\nsetRemoteDescription # setRemoteDescription نحوه اطلاع رسانی به نماینده محلی در مورد وضعیت داوطلب ها راه دور است. به این ترتیب عمل \u0026lsquo;سیگنالینگ\u0026rsquo; با API جاوا اسکریپت انجام می شود.\nوقتی setRemoteDescription از هر دو طرف فراخوانی شد، نمایندگان WebRTC اکنون اطلاعات کافی برای شروع ارتباط Peer-To-Peer (P2P) را دارند!\naddIceCandidate # addIceCandidate به یک نماینده WebRTC اجازه می‌دهد تا هر زمان که بخواهد، نامزدهای ICE راه دور بیشتری را اضافه کند. این ICE Candidate ،API را مستقیماً به زیرسیستم ICE می فرستد و تأثیر بیشتر دیگری بر اتصال WebRTC ندارد.\nontrack # ontrack یک تابع بازگشتی است که زمانی که بسته RTP از همتای راه دور دریافت می‌شود، فعال می‌شود. بسته‌های دریافتی باید در توضیحات جلسه که به setRemoteDescription ارسال شده بود، تعیین شده باشند.\nWebRTC از SSRC استفاده می‌کند و توابع بازگشتی MediaStream و MediaStreamTrack مرتبط این جزئیات فراخوانی می‌کند.\noniceconnectionstatechange # oniceconnectionstatechange یک تابع بازگشتی است که وضعیت عامل ICE را فراخوانی می‌کند. هنگامی که شما به شبکه متصل هستید یا زمانی که اتصال شما قطع می شود به این ترتیب به شما اطلاع داده می شود.\nonconnectionstatechange # onconnectionstatechange ترکیبی از ICE Agent و وضعیت عامل DTLS است. این می‌تواند شما را زمانی که ICE و DTLS هر دو با موفقیت تکمیل شدند مطلع کند.\n"},{"id":1,"href":"/fa/docs/02-signaling/","title":"سیگنالینگ","section":"Docs","content":" سیگنالینگ WebRTC چیست؟ # هنگامی که یک عامل WebRTC ایجاد می کنید، چیزی در مورد همتای دیگر نمی داند. هیچ ایده ای ندارد که قرار است با چه کسی ارتباط برقرار کند یا قرار است چه چیزی بفرستد! سیگنالینگ راه‌اندازی اولیه است که تماس را ممکن می‌سازد. پس از رد و بدل شدن این مقادیر، عوامل WebRTC می توانند مستقیماً با یکدیگر ارتباط برقرار کنند.\nپیام های سیگنالینگ فقط متن هستند. عوامل WebRTC اهمیتی نمی دهند که چگونه پیام ها منتقل می شوند. آنها معمولاً از طریق سوکت های وب به اشتراک گذاشته می شوند، اما همیشه اینگونه نیست.\nسیگنالینگ WebRTC چگونه کار می کند؟ # WebRTC از یک پروتکل موجود به نام Session Description Protocol استفاده می کند. از طریق این پروتکل، دو عامل WebRTC تمام وضعیت مورد نیاز برای ایجاد یک اتصال را به اشتراک خواهند گذاشت. خود پروتکل برای خواندن و درک ساده است. پیچیدگی این عمل از فهمیدن مقادیری است که توسط WebRTC پر می شود.\nاین پروتکل مختص WebRTC نیست. ابتدا پروتکل توضیحات جلسه را بدون حتی صحبت در مورد WebRTC یاد خواهیم گرفت. WebRTC از زیرمجموعه ای از پروتکل بهره می برد، بنابراین ما فقط می خواهیم آنچه را که نیاز داریم پوشش دهیم. پس از درک پروتکل، ما نمونه استفاده شده در WebRTC را بررسی می کنیم.\nپروتکل Session Description Protocol (SDP) چیست؟ # پروتکل شرح جلسه در RFC 8866 معرفی شده است. این یک پروتکل کلید / مقدار با یک خط جدید پس از هر مقدار است. این همانند یک فایل INI خواهد بود. شرح جلسه، حاوی هیچ یا بیشتر از یک توضیحات رسانه است. از نظر ذهنی می‌توانید آن را به‌عنوان شرح جلسه که حاوی مجموعه‌ای از توضیحات رسانه است، مدل‌سازی کنید.\nتوصیف رسانه معمولاً به یک جریان رسانه منفرد نگاشت می شود. بنابراین اگر می‌خواهید تماسی را با سه جریان ویدیویی و دو آهنگ صوتی توصیف کنید، باید پنج توضیح رسانه داشته باشید.\nنحوه خواندن SDP # هر خط در توضیحات جلسه با یک کاراکتر شروع می شود، این کلید شماست. سپس علامت مساوی به دنبال آن خواهد آمد. همه چیز بعد از آن علامت مساوی، مقدار است. پس از تکمیل مقدار، یک خط جدید خواهید داشت.\nپروتکل Session Description تمام کلیدهای معتبر را تعریف می کند. شما فقط می توانید از حروف برای کلیدها همانطور که در پروتکل تعریف شده است استفاده کنید. این کلیدها همگی معنی قابل توجهی دارند که بعدا توضیح داده خواهد شد.\nاین گزیده توضیحات جلسه را در نظر بگیرید:\na=my-sdp-value a=second-value شما دو خط دارید. هر کدام با کلید a. خط اول دارای مقدار my-sdp-value است، خط دوم دارای مقدار second-value است.\nWebRTC فقط از برخی کلیدهای SDP استفاده می کند # تمام مقادیر کلیدی تعریف شده توسط پروتکل شرح جلسه توسط WebRTC استفاده نمی شود. فقط کلیدهای مورد استفاده در پروتکل ایجاد جلسه جاوا اسکریپت (JSEP) که در RFC 8829 تعریف شده است، مهم هستند. هفت کلید زیر تنها کلیدهایی هستند که در حال حاضر باید بدانید:\nv - نسخه، باید برابر با 0 باشد. o - مبدا، حاوی شناسه منحصر به فردی است که برای مذاکره مجدد مفید است. s - نام جلسه، باید برابر با - باشد. t - زمان بندی، باید برابر با 0 0 باشد. m - توضیحات رسانه ( m = \u0026lt;media\u0026gt; \u0026lt;port\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;fmt\u0026gt; ...)، به تفصیل در زیر توضیح داده شده است. a - ویژگی ها، یک فیلد متن آزاد. این رایج ترین خط در WebRTC است. c - داده های اتصال، باید برابر با` IN IP4 0.0.0.0 باشد. توضیحات رسانه در شرح جلسه # شرح جلسه می تواند شامل تعداد نامحدودی از توضیحات رسانه باشد.\nتعریف توصیف رسانه حاوی لیستی از قالب ها است. این قالب‌ها به انواع RTP Payload نگاشت می‌شوند. سپس کدک واقعی توسط یک ویژگی با مقدار rtpmap در توضیحات رسانه تعریف می شود. اهمیت انواع RTP و RTP Payload بعداً در فصل رسانه مورد بحث قرار می گیرد. هر توصیف رسانه می تواند شامل تعداد نامحدودی از ویژگی ها باشد.\nاین گزیده توضیحات جلسه را به عنوان مثال در نظر بگیرید:\nv=0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4000 RTP/AVP 96 a=rtpmap:96 VP8/90000 a=my-sdp-value شما دو توصیف رسانه دارید، یکی از نوع صوتی با فرمت 111 و یکی از نوع ویدیویی با فرمت 96. اولین توصیف رسانه ای تنها یک ویژگی دارد. این ویژگی نوع Payload \u0026lsquo;111\u0026rsquo; را به Opus ترسیم می کند. شرح رسانه دوم دو ویژگی دارد. ویژگی اول، نوع Payload ا96 را به عنوان VP8 ترسیم می کند، و ویژگی دوم فقط my-sdp-value است.\nمثال کامل # در ادامه تمام مفاهیمی که در مورد آنها صحبت کرده ایم را گرد هم آورده است. اینها همه ویژگی های پروتکل شرح جلسه است که WebRTC از آن استفاده می کند. اگر می توانید این را بخوانید، می توانید هر شرح جلسه WebRTC را بخوانید!\nv=0 o=- 0 0 IN IP4 127.0.0.1 s=- c=IN IP4 127.0.0.1 t=0 0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4002 RTP/AVP 96 a=rtpmap:96 VP8/90000 کلیدهای v, o, s, c, t تعریف شده اند، اما بر جلسه WebRTC تأثیری ندارند. دو شرح رسانه ای دارید. یکی از نوع صوتی و یکی از نوع ویدئو. هر کدام از آن ها یک ویژگی دارند. این ویژگی جزئیات پایپ لاین RTP را که در فصل ارتباطات رسانه ای مورد بحث قرار گرفته است، پیکربندی می کند. چگونه پروتکل شرح جلسه و WebRTC با هم کار می کنند # بخش بعدی این پازل درک این که چگونه WebRTC از پروتکل شرح جلسه استفاده می کند می باشد.\nپیشنهاداتOffers و پاسخ هاAnswers چیست؟ # WebRTC از مدل پیشنهاد/پاسخ استفاده می کند. همه اینها به این معنی است که یک نماینده WebRTC یک پیشنهاد برای شروع یک تماس ارائه می دهد، و سایر نمایندگان WebRTC در صورتی که مایل به پذیرش آنچه ارائه شده است پاسخ می دهند.\nاین به پاسخ دهنده فرصتی می دهد تا کدک های پشتیبانی نشده در توضیحات رسانه را رد کند. به این ترتیب دو همتا می توانند بفهمند که مایل به تبادل چه قالب هایی هستند.\nمفهوم Transceivers برای ارسال و دریافت است # واژه Transceivers یک مفهوم خاص WebRTC است که در API خواهید دید. کاری که انجام می دهد این است که توضیحات رسانه را در API جاوا اسکریپت قرار می دهد. هر توصیف رسانه ای تبدیل به یک Transceiver می شود. هر بار که یک Transceiver ایجاد می کنید، یک توضیح رسانه جدید به توضیحات جلسه محلی اضافه می شود.\nهر توضیح رسانه در WebRTC یک ویژگی direction دارد. این به یک نماینده WebRTC اجازه می دهد تا اعلام کند \u0026ldquo;من قصد دارم این کدک را برای شما ارسال کنم، اما حاضر نیستم چیزی را پس بگیرم\u0026rdquo;. چهار مقدار معتبر وجود دارد:\nsend recv sendrecv inactive مقادیر SDP استفاده شده توسط WebRTC # این لیستی از برخی ویژگی های رایج است که در توضیحات جلسه از یک عامل WebRTC مشاهده خواهید کرد. بسیاری از این مقادیر، زیرسیستم هایی را کنترل می کنند که ما هنوز در مورد آنها صحبت نکرده ایم.\ngroup:BUNDLE # باندلینگ عملی است برای اجرای چندین نوع ترافیک روی یک اتصال. برخی از پیاده سازی های WebRTC از یک اتصال اختصاصی از طریق جریان رسانه استفاده می کنند که باندلینگ باید در اولویت باشد.\nfingerprint:sha-256 # این هش گواهی است که یک همتا برای DTLS استفاده می کند. پس از تکمیل دست دادن DTLS، آن را با گواهی واقعی مقایسه می کند تا تأیید کند که با کسی که انتظار دارید در ارتباط هستید.\nsetup: # این رفتار عامل DTLS را کنترل می کند. این مشخص می کند که آیا پس از اتصال، ICE به عنوان مشتری یا سرور اجرا می شود. مقادیر ممکن عبارتند از:\nsetup:active - به عنوان سرویس گیرنده DTLS اجرا شود. setup:passive - به عنوان سرور DTLS اجرا شود. setup: actpass - از دیگر نماینده WebRTC بخواهد انتخاب کند. ice-ufrag # این مقدار قطعه کاربر برای عامل ICE است. برای احراز هویت ترافیک ICE استفاده می شود.\nice-pwd # این رمز عبور عامل ICE است. برای احراز هویت ترافیک ICE استفاده می شود.\nrtpmap # این مقدار برای نگاشت یک کدک خاص به نوع RTP Payload استفاده می شود. انواع بار(Payload) ثابت نیستند، بنابراین برای هر تماس پیشنهاد دهنده انواع بار(Payload) برای هر کدک را تعیین می کند.\nfmtp # مقادیر اضافی را برای یک نوع محموله تعریف می کند. این برای برقراری ارتباط با یک نمایه ویدیویی خاص یا تنظیمات رمزگذار مفید است.\ncandidate # این یک نامزد ICE است که از عامل ICE می آید. این یکی از آدرس‌های احتمالی است که WebRTC Agent در آن موجود است. این موارد در فصل بعدی به طور کامل توضیح داده می شود.\nsrc # منبع همگام سازی (SSRC) یک مسیر جریان رسانه واحد را تعریف می کند.\nlabel شناسه این جریان فردی است. mslabel شناسه کانتینری است که می‌تواند چندین جریان درون آن داشته باشد.\nمثالی از توضیحات جلسه WebRTC # در زیر شرح کامل جلسه(SDP) ایجاد شده توسط یک کلاینت WebRTC است:\nv=0 o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0 s=- t=0 0 a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E a=group:BUNDLE 0 1 m=audio 9 UDP/TLS/RTP/SAVPF 111 c=IN IP4 0.0.0.0 a=setup:active a=mid:0 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:111 opus/48000/2 a=fmtp:111 minptime=10;useinbandfec=1 a=ssrc:350842737 cname:yvKPspsHcYcwGFTw a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw a=ssrc:350842737 label:DfQnKjQQuwceLFdV a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates m=video 9 UDP/TLS/RTP/SAVPF 96 c=IN IP4 0.0.0.0 a=setup:active a=mid:1 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:96 VP8/90000 a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=sendrecv این چیزی است که ما از این پیام می دانیم:\nدو بخش رسانه داریم، یکی صوتی و دیگری تصویری. هر دوی آنها فرستنده گیرنده(Transceiver) sendrecv هستند. ما در حال دریافت دو جریان هستیم و می توانیم دو جریان را بفرستیم. ما جزئیات ICE Candidates و Authentication را داریم، بنابراین می‌توانیم برای اتصال تلاش کنیم. ما یک اثر انگشت گواهی داریم، بنابراین می توانیم تماس ایمن داشته باشیم. موضوعات بیشتر # در نسخه های بعدی این کتاب، به موضوعات زیر نیز پرداخته خواهد شد:\nمذاکره مجدد (Renegotiation) پخش همزمان (Simulcast) "},{"id":2,"href":"/fa/docs/03-connecting/","title":"اتصال","section":"Docs","content":" چرا WebRTC برای اتصال به یک زیرسیستم اختصاصی نیاز دارد؟ # اکثر برنامه های کاربردی که امروزه نوشته می شوند، اتصالات مشتری/سرور هستند. اتصال مشتری/سرور مستلزم آن است که سرور یک آدرس انتقال شناخته شده پایدار داشته باشد. یک کلاینت با یک سرور تماس می گیرد و سرور پاسخ می دهد.\nWebRTC از مدل کلاینت/سرور استفاده نمی کند، بلکه اتصالات همتا به همتا (P2P) را ایجاد می کند. در یک اتصال P2P وظیفه ایجاد یک اتصال به طور مساوی بین هر دو همتا توزیع می شود. این به این دلیل است که یک آدرس انتقال (IP و پورت) در WebRTC قابل فرض نیست و حتی ممکن است در طول جلسه تغییر کند. WebRTC تمام اطلاعاتی را که می تواند جمع آوری می کند و برای دستیابی به ارتباط دو طرفه بین دو نماینده WebRTC تمام تلاش خود را خواهد کرد.\nبا این حال، ایجاد اتصال همتا به همتا ممکن است دشوار باشد. این عوامل می توانند در شبکه های مختلف بدون اتصال مستقیم باشند. در شرایطی که اتصال مستقیم وجود دارد، همچنان می توانید مشکلات دیگری نیز داشته باشید. در برخی موارد، کلاینت های شما از پروتکل‌های شبکه یکسانی صحبت نمی‌کنند (UDP \u0026lt;-\u0026gt; TCP) یا ممکن است از نسخه‌های IP مختلف (IPv4 \u0026lt;-\u0026gt; IPv6) استفاده کنند.\nعلی‌رغم این مشکلات در راه‌اندازی اتصال P2P، به دلیل ویژگی‌های زیر که WebRTC ارائه می‌کند، مزایایی نسبت به فناوری سنتی Client/Server دارید.\nکاهش هزینه های پهنای باند # از آنجایی که ارتباطات رسانه ای مستقیماً بین همتایان انجام می شود، لازم نیست هزینه ای برای آن بپردازید، یا سرور جداگانه ای برای انتقال رسانه میزبانی کنید.\nتاخیر کمتر # ارتباط زمانی که مستقیم باشد سریعتر است! وقتی کاربر مجبور است همه چیز را از طریق سرور شما اجرا کند، انتقال را کندتر می کند.\nارتباط امن E2E # ارتباط مستقیم امن تر است. از آنجایی که کاربران داده ها را از طریق سرور شما مسیریابی نمی کنند، حتی نیازی نیست که آن ها به شما اعتماد کنند که داده ها را رمزگشایی می کنید یا نه.\nچگونه کار می کند؟ # فرآیندی که در بالا توضیح داده شد، ایجاد ارتباط تعاملی (ICE) نامیده می شود. پروتکل دیگری که پیش از WebRTC وجود داشته است.\nICE پروتکلی است که سعی می کند بهترین راه برای برقراری ارتباط بین دو عامل ICE را پیدا کند. هر عامل ICE راه‌هایی را که قابل دسترسی است منتشر می‌کند، اینها به عنوان نامزد شناخته می‌شوند. یک نامزد اساساً یک آدرس حمل و نقل نماینده است که معتقد است همتایان دیگر می توانند به آن دسترسی پیدا کنند. سپس ICE بهترین جفت کاندیداها را تعیین می کند.\nفرآیند ICE حقیقی در ادامه این فصل با جزئیات بیشتر توضیح داده می شود. این بخش برای درک اینکه چرا ICE وجود دارد و درک اینکه بر چه رفتارهای شبکه ای غلبه می کنیم مفید است.\nمحدودیت های دنیای واقعی شبکه # ICE همه چیز در مورد غلبه بر محدودیت های شبکه های دنیای حقیقی است. قبل از اینکه راه حل را بررسی کنیم، اجازه دهید در مورد مشکلات واقعی صحبت کنیم.\nدر یک شبکه نیست # در بیشتر مواقع عامل دیگر WebRTC حتی در همان شبکه نیست. و به اینگونه است که یک تماس معمولی معمولاً بین دو نماینده WebRTC در شبکه های مختلف بدون اتصال مستقیم است.\nدر زیر نمودار دو شبکه مجزا که از طریق اینترنت متصل شده‌اند، مشاهده می کنید. در هر شبکه شما دو هاست دارید.\nبرای هاست های موجود در یک شبکه اتصال بسیار آسان است. ارتباط بین 192.168.0.1 -\u0026gt; 192.168.0.2 آسان است! این دو هاست می توانند بدون هیچ کمک خارجی به یکدیگر متصل شوند.\nبا این حال، میزبانی که از روتر B استفاده می‌کند، راهی برای دسترسی مستقیم به چیزی در پشت روتر A است را ندارد. چگونه تفاوت بین 192.168.0.1 در پشت روتر A و همان IP پشت روتر B را بیان می کنید؟ آی پی های خصوصی هستند! میزبانی که از روتر B استفاده می‌کند، می‌تواند ترافیک را مستقیماً به روتر A ارسال کند، اما درخواست در آنجا به پایان می‌رسد. روتر A چگونه می داند که باید پیام را به کدام میزبان ارسال کند؟\nمحدودیت های پروتکل # برخی از شبکه ها به هیچ وجه اجازه ترافیک UDP را نمی دهند یا حتی ممکن است TCP را هم مجاز ندانند. برخی از شبکه ها ممکن است دارای MTU (واحد انتقال حداکثر) بسیار پایین باشند. متغیرهای زیادی وجود دارد که مدیران شبکه می توانند آنها را تغییر دهند که می تواند ارتباط را دشوار کند.\nقوانین فایروال/IDS # مشکل دیگر \u0026ldquo;بازرسی عمیق بسته\u0026rdquo; و فیلترهای هوشمند دیگر است. برخی از مدیران شبکه، نرم افزاری را اجرا می کنند که سعی می کند هر بسته را پردازش کند. بسیاری از اوقات این نرم افزار WebRTC را نمی فهمد، بنابراین آن را مسدود می کند زیرا نمی داند چه کاری انجام دهد، به عنوان مثال. در نظر گرفتن بسته های WebRTC به عنوان بسته های UDP مشکوک در یک پورت دلخواه که در لیست سفید نیست.\n##نگاشت NAT نگاشت NAT (ترجمه آدرس شبکه) جادویی است که اتصال WebRTC را ممکن می کند. به این صورت است که WebRTC به دو همتا در زیرشبکه های کاملاً متفاوت اجازه می دهد تا با هم ارتباط برقرار کنند و مشکل \u0026ldquo;در شبکه یکسانی\u0026rdquo; که در بالا گفته شد را برطرف می کند. در حالی که این چالش‌های جدیدی را نیز ایجاد می‌کند، اجازه دهید در وهله اول نحوه عملکرد نگاشت NAT را توضیح دهیم.\nاین از رله، پروکسی یا سرور استفاده نمی کند. باز هم \u0026ldquo;عامل 1\u0026rdquo; و \u0026ldquo;عامل 2\u0026rdquo; را داریم و آنها در شبکه های مختلف هستند. با این حال، ترافیک به طور کامل در جریان است. که به این شکل است:\nبرای ایجاد این ارتباط، یک نگاشت NAT ایجاد می کنید. عامل 1 از پورت 7000 برای ایجاد یک اتصال WebRTC با عامل 2 استفاده می کند. این یک اتصال از 192.168.0.1:7000 به5.0.0.1:7000 ایجاد می کند. سپس به عامل 2 اجازه می دهد تا با ارسال بسته ها به 5.0.0.1:7000 به عامل 1 برسد. ایجاد یک نگاشت NAT مانند این است که یک نسخه خودکار از انجام انتقال پورت در روتر شما باشد.\nنقطه ضعف نگاشت NAT این است که یک شکل واحد از نقشه برداری وجود ندارد (مثلاً ارسال پورت استاتیک)، و رفتار بین شبکه ها ناسازگار است. ISP ها و سازندگان سخت افزار ممکن است این کار را به روش های مختلف انجام دهند. در برخی موارد، مدیران شبکه ممکن است حتی آن را غیرفعال کنند.\nخبر خوب این است که طیف کامل رفتارها قابل درک و مشاهده است، بنابراین یک عامل ICE می تواند تأیید کند که نگاشت NAT و ویژگی های نگاشت را ایجاد کرده است.\nمستندی که این رفتارها را توصیف می کند در RFC 4787 است.\nایجاد نگاشت # ایجاد یک نگاشت ساده ترین بخش است. هنگامی که یک بسته را به آدرسی خارج از شبکه خود ارسال می کنید، یک نگاشت ایجاد می شود! نگاشت NAT فقط یک IP عمومی و پورت موقت است که توسط NAT شما اختصاص داده می شود. پیام خروجی بازنویسی می شود تا آدرس منبع آن به آدرس جدید نگاشت شده، بدهد. اگر پیامی به نگاشت ارسال شود، به طور خودکار به میزبان درون NAT که آن را ایجاد کرده است، هدایت می‌شود. جزئیات در مورد نگاشت پیچیده است.\nرفتارهای ایجاد نگاشت # ایجاد نگاشت به سه دسته مختلف تقسیم می شود:\nنگاشت Endpoint-Independent # یک نگاشت برای هر فرستنده در داخل NAT ایجاد می شود. اگر دو بسته را به دو آدرس راه دور مختلف ارسال کنید، نقشه NAT مجددا استفاده می شود. هر دو هاست راه دور یک منبع IP و پورت یکسانی را می بینند. اگر میزبان های راه دور پاسخ دهند، به همان شنونده محلی بازگردانده می شود.\nاین بهترین سناریو است. برای انجام یک تماس، حداقل یک طرف باید از این روش پشتیبانی کند.\nنگاشت وابسته به آدرس # هر بار که یک بسته را به آدرس جدیدی ارسال می کنید، یک نگاشت جدید ایجاد می شود. اگر دو بسته را به هاست های مختلف ارسال کنید، دو نگاشت ایجاد می شود. اگر دو بسته را به یک میزبان راه دور اما پورت های مقصد متفاوت ارسال کنید، نقشه جدیدی ایجاد نخواهد شد.\nنگاشت وابسته به آدرس و پورت # اگر IP یا پورت راه دور متفاوت باشد، نقشه جدیدی ایجاد می شود. اگر دو بسته را به یک میزبان راه دور، اما پورت های مقصد متفاوت ارسال کنید، یک نقشه جدید ایجاد می شود.\nرفتارهای فیلترینگ نگاشت # فیلترینگ نگاشت قوانینی است که در مورد افرادی است که مجاز به استفاده از نگاشت هستند. آنها به سه طبقه بندی مشابه تقسیم می شوند:\nفیلتر مستقل از نقطه پایانی # هر کسی می تواند از نگاشت استفاده کند. شما می توانید نگاشت را با چندین همتای دیگر به اشتراک بگذارید، و همه آنها می توانند ترافیک را به آن ارسال کنند.\nفیلتر وابسته به آدرس # فقط میزبانی که نگاشت برای آن ایجاد شده است می تواند از نگاشت استفاده کند. اگر بسته ای را به میزبان A ارسال کنید، می تواند با هر تعداد بسته که بخواهد پاسخ دهد. اگر میزبان B سعی کند بسته ای را به آن نگاشت ارسال کند، نادیده گرفته می شود.\nفیلتر وابسته به آدرس و پورت # فقط میزبان و پورتی که نقشه برداری برای آنها ایجاد شده است می توانند از آن نگاشت استفاده کنند. اگر بسته ای را به میزبان A:5000 بفرستید، می تواند با هر تعداد بسته که بخواهد پاسخ دهد. اگر میزبان A:5001 بخواهد بسته ای را به آن نگاشت ارسال کند، نادیده گرفته می شود.\nبه روز رسانی نگاشت # توصیه می شود در صورت عدم استفاده از نگاشت به مدت 5 دقیقه، خود به خوداز بین برود. این کاملا به ISP یا سازنده سخت افزار بستگی دارد.\nSTUN # STUN (Session Traversal Utilities for NAT) پروتکلی است که فقط برای کار با NAT ایجاد شده است. این یکی دیگر از فناوری‌هایی است که پیش از WebRTC (و ICE!) قدمت دارد. این پروتکل در RFC 8489 تعریف شده است، که همچنین ساختار بسته STUN را تعریف می کند. پروتکل STUN نیز توسط ICE/TURN استفاده می شود.\nSTUN مفید است زیرا امکان ایجاد برنامه‌ای NAT Mappings را فراهم می‌کند. قبل از STUN، ما می توانستیم یک نقشه NAT ایجاد کنیم، اما نمی دانستیم IP و پورت آن چیست! STUN نه تنها به شما توانایی ایجاد یک نقشه را می دهد، بلکه جزئیات را نیز در اختیار شما قرار می دهد تا بتوانید آنها را با دیگران به اشتراک بگذارید، بنابراین آنها می توانند از طریق نگاشتی که ایجاد کرده اید، ترافیک را برای شما ارسال کنند.\nبیایید با توضیح اولیه STUN شروع کنیم. بعداً، استفاده از TURN و ICE را گسترش خواهیم داد. در حال حاضر، ما فقط می خواهیم جریان درخواست/پاسخ را برای ایجاد یک نگاشت توصیف کنیم. سپس در مورد چگونگی به اشتراک گذاشتن جزئیات آن با دیگران صحبت خواهیم کرد. این فرآیند زمانی اتفاق می‌افتد که در URLهای ICE خود برای یک WebRTC PeerConnection یک سرور stun: داشته باشید. به طور خلاصه، STUN به یک نقطه پایانی در پشت NAT کمک می کند تا با درخواست از یک سرور STUN خارج از NAT برای گزارش آنچه مشاهده می کند، بفهمد که چه نگاشتی ایجاد شده است.\nساختار پروتکل # هر بسته STUN دارای ساختار زیر است:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ نوع پیام STUN # هر بسته STUN یک نوع دارد. در حال حاضر، ما فقط به موارد زیر اهمیت می دهیم:\nدرخواست الزام آور - 0x0001 پاسخ الزام آور - 0x0101 برای ایجاد یک نگاشت NAT، یک Binding Request ارائه می کنیم. سپس سرور با Binding Response پاسخ می دهد.\nطول پیام # طول بخش داده به این شکل است. این بخش حاوی داده های دلخواه است که با نوع پیام تعریف شده است.\nکوکی جادویی # مقدار ثابت 0x2112A442 به ترتیب بایت شبکه، به تشخیص ترافیک STUN از سایر پروتکل‌ها کمک می‌کند.\nشناسه تراکنش # این یک شناسه 96 بیتی که به طور منحصر به فرد درخواست/پاسخ را شناسایی می کند می باشد. این به شما کمک می کند تا درخواست ها و پاسخ های خود را جفت کنید.\nداده ها # داده ها حاوی لیستی از ویژگی های STUN هستند. یک ویژگی STUN ساختار زیر را دارد:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Value (variable) .... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \u0026ldquo;درخواست الزام آور STUN\u0026rdquo; از هیچ ویژگی استفاده نمی کند. این به این معنی است که درخواست الزام آور STUN فقط شامل سرصفحه است.\nمفهوم STUN Binding Request از یک \u0026ldquo;XOR-MAPPED-ADDRESS (0x0020)\u0026rdquo; استفاده می کند. این ویژگی شامل یک IP و پورت است. این آی پی و پورت نگاشت NAT است که ایجاد شده است!\nیک نگاشت NAT ایجاد کنید # ایجاد یک نگاشت NAT با استفاده از STUN فقط به ارسال یک درخواست کننده نیاز دارد! شما یک STUN Binding Request را به سرور STUN ارسال می کنید. سپس سرور STUN با STUN Binding Response پاسخ می دهد. این STUN Binding Request حاوی آدرس نگاشت شده خواهد بود. آدرس نگاشت شده روشی است که سرور STUN شما را می‌بیند و نگاشت NAT شما است. آدرس نگاشت شده همان چیزی است که اگر بخواهید شخصی بسته‌هایی را برای شما ارسال کند، به اشتراک می‌گذارید.\nهمچنین دیگران آدرس نگاشت شده شده را IP عمومی یا کاندیدای بازتابی سرور شما می‌خوانند.\nتعیین نوع NAT # متأسفانه، آدرس نگاشت شده ممکن است در همه موارد مفید نباشد. اگر وابسته به آدرس باشد، فقط سرور STUN می‌تواند ترافیک را برای شما ارسال کند. اگر آن را به اشتراک گذاشتید و همتای دیگری سعی کرد در آن پیام ارسال کند، حذف خواهند شد. این باعث می شود که برای برقراری ارتباط با دیگران بی فایده باشد. اگر سرور STUN بتواند بسته‌ها را برای شما به همتا ارسال کند، ممکن است در واقع مورد وابسته به آدرس قابل حل باشد! این ما را به راه حل با استفاده از TURN هدایت می کند.\nRFC 5780 روشی را برای اجرای تست تعیین نوع NAT شما تعریف می کند. این مفید است زیرا شما از قبل می دانید که آیا اتصال مستقیم امکان پذیر است یا خیر.\n##TURN TURN (پیمایی با استفاده از رله‌ها در اطراف NAT) در RFC 8656 تعریف شده است، زمانی که اتصال مستقیم امکان‌پذیر نیست. ممکن است به این دلیل باشد که شما دو نوع NAT دارید که ناسازگار هستند، یا شاید نمی‌توانید با یک پروتکل را صحبت کنید! TURN همچنین می تواند برای اهداف حفظ حریم خصوصی استفاده شود. با اجرای تمام ارتباطات خود از طریق TURN، آدرس واقعی کلاینت را مبهم می کنید.\nTURN از یک سرور اختصاصی استفاده می کند. این سرور به عنوان یک پروکسی برای یک کلاینت عمل می کند. کلاینت به یک سرور TURN متصل می شود و Allocation ایجاد می شود. با ایجاد یک تخصیص، یک کلاینت یک IP/پورت/پروتکل موقت دریافت می کند که می تواند برای ارسال ترافیک به کلاینت استفاده شود. این شنونده جدید به آدرس حمل و نقل رله شده معروف است. آن را به عنوان یک آدرس فوروارد در نظر بگیرید، این را می دهید تا دیگران بتوانند ترافیک را از طریق TURN برای شما ارسال کنند! برای هر همتای که آدرس حمل و نقل رله را به آن می دهید، باید مجوز جدیدی ایجاد کنید تا امکان ارتباط با شما فراهم شود.\nوقتی ترافیک خروجی را از طریق TURN ارسال می کنید، از طریق آدرس حمل و نقل رله شده ارسال می شود. وقتی یک همتای راه دور ترافیک دریافت می کند، آن را از سرور TURN دریافت می کند.\nچرخه حیات # موارد زیر تمام کارهایی است که وقتی یک کلاینت می خواهد یک تخصیص TURN ایجاد کند باید انجام دهد. برقراری ارتباط با فردی که از TURN استفاده می کند نیازی به تغییر ندارد. همتای دیگر یک IP و پورت دریافت می کند و مانند هر میزبان دیگری با آن ارتباط برقرار می کند.\nتخصیص # تخصیص ها در هسته TURN هستند. تخصیص اساساً یک جلسه TURN است. برای ایجاد یک تخصیص TURN، شما با آدرس حمل و نقل سرور TURN (معمولاً پورت 3478) ارتباط برقرار می کنید.\nهنگام ایجاد یک تخصیص، باید موارد زیر را ارائه دهید:\nنام کاربری / رمز عبور - ایجاد تخصیص TURN نیاز به احراز هویت دارد. تخصیص transport - پروتکل انتقال بین سرور (\u0026ldquo;آدرس حمل و نقل رله\u0026rdquo;) و همتایان، می تواند UDP یا TCP باشد. یک پورت زوج - می‌توانید پورت‌های متوالی را برای تخصیص‌های متعدد درخواست کنید، که برای WebRTC مرتبط نیستند. اگر درخواست با سرور TURN موفقیت آمیز بود، پاسخی با ویژگی های STUN زیر در بخش داده دریافت می کنید:\nXOR-MAPPED-ADDRESS - آدرس نگاشت شده TURN Client. وقتی که شخصی داده ها را به آدرس حمل و نقل رله شده می فرستد، همان جایی که داده به آن ارسال می شود. RELEYED-ADDRESS - این آدرسی است که شما به مشتریان دیگر می دهید. اگر شخصی بسته ای را به این آدرس بفرستد، به کلاینت TURN رله می شود. LIFETIME - طول عمر تخصیص TURN چقدر باشد. می‌توانید با ارسال درخواست Refresh طول عمر را افزایش دهید. مجوزها # یک میزبان راه دور نمی‌تواند به آدرس حمل و نقل رله شده شما داده ارسال کند تا زمانی که مجوزی برای آنها ایجاد شود. وقتی مجوز ایجاد می کنید، به سرور TURN می گویید که این IP و پورت مجاز به ارسال ترافیک ورودی هستند.\nمیزبان راه دور باید IP و پورت را همانطور که در سرور TURN ظاهر می شود به شما بدهد. این بدان معنی است که باید یک STUN Binding Request به سرور TURN ارسال کنید. یک مورد خطای رایج این است که یک میزبان راه دور یک درخواست اتصال STUN را به سرور دیگری ارسال می کند. سپس از شما می خواهند که برای این IP مجوز ایجاد کنید.\nفرض کنید می خواهید یک مجوز برای یک میزبان در پشت نگاشت وابسته به آدرس ایجاد کنید. اگر آدرس نگاشت شده را در سرور TURN دیگری ایجاد کنید، تمام ترافیک ورودی حذف می‌شود. هر بار که آنها با یک کلاینت جدید ارتباط برقرار می کنند، نگاشت جدیدی ایجاد می کند. مجوزها در صورت بازنگری نشدن پس از 5 دقیقه منقضی می شوند.\nSendIndication/ChannelData # این دو پیام برای TURN Client برای ارسال پیام به یک همتای راه دور است.\nSendIndication یک پیام مستقل است. در داخل آن داده‌ها وشخصی است که می‌خواهید برای او ارسال کنید. اگر پیام‌های زیادی به یک همتای راه دور ارسال می‌کنید، وقت تلف کردن است. اگر 1000 پیام ارسال کنید، آدرس IP آنها را 1000 بار تکرار خواهید کرد!\nChannelData به شما امکان می دهد داده ارسال کنید، اما یک آدرس IP را تکرار نکنید. شما یک کانال با IP و پورت ایجاد می کنید. سپس با ChannelId ارسال می‌کنید و IP و پورت در سمت سرور پر می‌شوند. اگر می خواهید پیام های زیادی ارسال می کنید این گزینه بهتر است.\nتازه سازی # تخصیص ها به طور خودکار خود را از بین می برند. TURN Client باید آنها را زودتر از LIFETIME داده شده هنگام ایجاد تخصیص، بازخوانی کند.\nTURN استفاده # استفاده از TURN به دو صورت امکان پذیر است. معمولاً، یکی از همتایان شما به عنوان کارخواه TURN عمل می کند و طرف دیگر مستقیماً با شما ارتباط برقرار می کند. در برخی موارد ممکن است هر دو طرف استفاده از TURN داشته باشند، برای مثال به این دلیل که هر دو کلاینت در شبکه هایی هستند که UDP را مسدود می کنند و بنابراین اتصال به سرورهای TURN مربوطه از طریق TCP انجام می شود.\nاین نمودارها به شما کمک می کند تا نشان دهید که چگونه به نظر می رسد.\nتخصیص یک نوبت برای ارتباطات # تخصیص دو نوبتی برای ارتباطات # ##ICE ICE (Interactive Connectivity Establishment) نحوه اتصال WebRTC دو عامل است. این فناوری که در RFC 8445 تعریف شده است، یکی دیگر از فناوری‌های پیش از WebRTC است! ICE یک پروتکل برای ایجاد اتصال است. تمام مسیرهای ممکن بین دو همتا را تعیین می‌کند و سپس تضمین می‌کند که در ارتباط باشید.\nاین مسیرها با نام Candidate Pairs شناخته می‌شوند که جفتی از آدرس Transport محلی و راه دور است. اینجاست که STUN و TURN با ICE وارد بازی می شوند. این آدرس‌ها می‌توانند آدرس IP محلی شما به‌علاوه یک پورت، نگاشت NAT یا آدرس انتقالی باشند. هر طرف تمام آدرس‌هایی را که می‌خواهند استفاده کنند جمع‌آوری می‌کنند، آنها را مبادله می‌کنند و سپس تلاش می‌کنند تا متصل شوند!\nدو عامل ICE با استفاده از بسته های پینگ ICE (یا به طور رسمی بررسی های اتصال نامیده می شوند) برای برقراری ارتباط با یکدیگر ارتباط برقرار می کنند. پس از برقراری ارتباط، آنها می توانند هر داده ای را که می خواهند ارسال کنند. مانند استفاده از یک سوکت معمولی خواهد بود. این چک ها از پروتکل STUN استفاده می کنند.\nایجاد یک عامل ICE # یک عامل ICE یا کنترل کننده یا کنترل شده است. عامل کنترل کننده کسی است که Candidate Pair انتخاب شده را تعیین می کند. معمولاً همتای ارسال کننده پیشنهاد، سمت کنترل کننده است.\nهر طرف باید یک بخش کاربر و یک گذرواژه داشته باشد. این دو مقدار باید قبل از شروع بررسی اتصال، مبادله شوند. بخش کاربر به صورت متن ساده ارسال می‌شود و برای دمکس کردن چندین جلسه ICE مفید است. گذرواژه برای ایجاد ویژگی MESSAGE-INTEGRITY استفاده می‌شود. در انتهای هر بسته STUN، یک ویژگی وجود دارد که هش کل بسته با استفاده از رمز عبور به عنوان یک کلید استفاده می شود. این برای احراز هویت بسته و اطمینان از دستکاری نشدن آن استفاده می شود.\nبرای WebRTC، همه این مقادیر از طریق شرح جلسه همانطور که در فصل قبل توضیح داده شد، مبادله می‌شوند.\n###دور هم جمع شدن کاندیدا هاا اکنون باید تمام آدرس های که ممکن است در دسترس باشند را جمع آوری کنیم. این آدرس ها به عنوان کاندید شناخته می شوند.\nمیزبان # یک کاندید میزبان به طور مستقیم در یک رابط محلی گوش می دهد. این می تواند UDP یا TCP باشد.\nmDNS # یک کاندید mDNS مشابه کاندید میزبان است، اما آدرس IP مبهم است. به جای اینکه به طرف مقابل در مورد آدرس IP خود اطلاع دهید، به آنها یک UUID به عنوان نام میزبان می دهید. سپس یک شنونده چندپخشی راه‌اندازی می‌کنید و اگر کسی UUID را که منتشر کرده‌اید درخواست کرد، پاسخ می‌دهید.\nاگر در یک شبکه با عامل هستید، می توانید از طریق Multicast یکدیگر را پیدا کنید. اگر در یک شبکه نباشید، نمی توانید متصل شوید (مگر اینکه مدیر شبکه به صراحت شبکه را طوری پیکربندی کرده باشد که به بسته های Multicast اجازه عبور داده شود).\nاین برای اهداف حفظ حریم خصوصی مفید است. یک کاربر می‌تواند آدرس IP محلی شما را از طریق WebRTC با یک کاندید میزبان (بدون تلاش برای اتصال به شما) پیدا کند، اما با یک کاندید mDNS، اکنون فقط یک UUID تصادفی کافیست دریافت می‌کند.\nسرور Reflexive # یک Server Reflexive کاندید با انجام StUN Binding Request به یک سرور STUN ایجاد می شود.\nهنگامی که پاسخ اتصال STUN را دریافت می کنید، XOR-MAPPED-ADDRESS کاندیدای ارسالی سرور شما است.\nPeer Reflexive # کاندیدای Peer Reflexive زمانی است که یک درخواست ورودی از آدرسی دریافت می کنید که برای شما ناشناخته است. از آنجایی که ICE یک پروتکل تأیید شده است، می دانید که ترافیک معتبر است. این فقط به این معنی است که همتای راه دور از آدرسی که از آن اطلاعی نداشته با شما ارتباط برقرار می کند.\nاین معمولاً زمانی اتفاق می‌افتد که یک کاندیدا میزبان با کاندیدا بازتابی سرور ارتباط برقرار کند. یک نگاشت NAT جدید ایجاد می شود زیرا شما در حال برقراری ارتباط در خارج از شبکه خود هستید. به خاطر داشته باشید که گفتیم بررسی های اتصال در واقع بسته های STUN هستند؟ فرمت پاسخ STUN به طور طبیعی به یک همتا اجازه می دهد تا آدرس بازتابی همتا را گزارش دهد.\nرله # یک Relay Candidate با استفاده از یک سرور TURN ایجاد می شود.\nپس از دست دادن اولیه با سرور TURN به شما یک RELAYED-ADDRESS داده می شود، این کاندیدای رله شما است.\nبررسی اتصال # اکنون بخش کاربر، گذرواژه و کاندیداهای عامل راه دور را می‌شناسیم. اکنون می توانیم برای اتصال تلاش کنیم! هر نامزدی با هم جفت می شود. بنابراین اگر 3 نامزد در هر طرف دارید، اکنون 9 جفت نامزد دارید.\nکه به این شکل است:\nانتخاب نامزد # عامل کنترل کننده و کنترل شده هر دو شروع به ارسال ترافیک روی هر جفت می کنند. اگر یک نماینده پشت یک نگاشت وابسته به آدرس باشد، این ضروری است، این امر باعث می‌شود نامزد بازتابی همتا ایجاد شود.\nهر جفت کاندید که ترافیک شبکه را دید، به یک جفت کاندیدا معتبر ارتقا داده می‌شود. سپس عامل کنترل یک جفت کاندید معتبر را می گیرد و آن را نامزد می کند. این به جفت کاندید شده تبدیل می شود. سپس عامل کنترل کننده و کنترل شده یک دور دیگر از ارتباط دو طرفه را انجام می دهد. در صورت موفقیت آمیز بودن، جفت نامزد شده به جفت نامزد منتخب تبدیل می شود! سپس این جفت برای بقیه جلسه استفاده می شود.\nراه اندازی مجدد # اگر جفت کاندیدای انتخاب‌شده به هر دلیلی کار نکند (نگاشت NAT منقضی می‌شود، سرور TURN خراب می‌شود)، عامل ICE به حالت ناموفق می‌رود. هر دو عامل می توانند مجدداً راه اندازی شوند و کل فرآیند را دوباره انجام می دهند.\n"},{"id":3,"href":"/fa/docs/04-securing/","title":"امنیت","section":"Docs","content":" WebRTC چه پروتکل های امنیتی دارد؟ # هر اتصال WebRTC احراز هویت و رمزگذاری شده است. می‌توانید مطمئن باشید که شخص ثالث نمی‌تواند آنچه را که ارسال می‌کنید ببیند یا پیام‌های جعلی درج کند. همچنین می توانید مطمئن باشید که عامل WebRTC که Session Description را ایجاد کرده است، همانی است که شما با آن در ارتباط هستید.\nبسیار مهم است که هیچ کس در آن پیام ها دستکاری نکند. اگر شخص ثالثی توضیحات جلسه را در حال انتقال بخواند مشکلی ندارد. با این حال، WebRTC هیچ حفاظتی در برابر تغییر آن ندارد. یک مهاجم می‌تواند با تغییر ICE Candidates و تغییر گواهی اثر انگشت، یک حمله مرد میانی به شما انجام دهد.\nچگونه کار می کند؟ # WebRTC از دو پروتکل موجود استفاده می‌کند، امنیت لایه انتقال داده‌گرام (DTLS) و پروتکل امن حمل و نقل بلادرنگ (SRTP).\nDTLS به شما این امکان را می دهد که در یک جلسه مذاکره کنید و سپس داده ها را به صورت امن بین دو همتا مبادله کنید. این پرتکل شبیه TLS است، همان فناوری که HTTPS را تقویت می کند، اما DTLS از UDP به جای TCP به عنوان لایه انتقال استفاده می کند. این بدان معناست که پروتکل باید چیزی را تحویل دهد که قابل اعتماد نیست. SRTP به طور خاص برای تبادل رسانه ایمن طراحی شده است. بهینه سازی هایی وجود دارد که می توانیم با استفاده از آن به جای DTLS انجام دهیم.\nدر ابتدا از DTLS استفاده می شود. یک دست دادن(Handshake) بر روی اتصالی که توسط ICE انجام می شد انجام می داد. DTLS یک پروتکل مشتری/سرور است، بنابراین یک طرف باید دست دادن را شروع کند. نقش های کلاینت/سرور در طول سیگنال دهی انتخاب می شوند. در طول دست دادن DTLS، هر دو طرف گواهی ارائه می دهند. پس از تکمیل دست دادن، این گواهی با هش گواهی در توضیحات جلسه مقایسه می شود. این برای اطمینان از اینکه دست دادن با عامل WebRTC که انتظار داشتید اتفاق افتاده است. سپس اتصال DTLS برای استفاده برای ارتباطات DataChannel در دسترس است.\nبرای ایجاد یک جلسه SRTP، آن را با استفاده از کلیدهای تولید شده توسط DTLS مقداردهی اولیه می کنیم. SRTP مکانیزم دست دادن ندارد، بنابراین باید با کلیدهای خارجی مقدار دهی شود. پس از انجام این کار، می توان رسانه ای را که با استفاده از SRTP رمزگذاری شده است، تبادل کرد!\nامنیت 101 # برای درک فناوری ارائه شده در این فصل، ابتدا باید این اصطلاحات را درک کنید. رمزنگاری موضوع پیچیده ای است، بنابراین ارزش مراجعه به منابع دیگر را نیز دارد!\nمتن ساده و متن رمزی # متن ساده ورودی یک رمز است. متن رمزی خروجی یک رمز است.\nرمز # رمز کردن یک سری مراحل است که متن ساده را به متن رمزی تبدیل می کند. سپس رمز را می توان معکوس کرد، بنابراین می توانید متن رمزی خود را به متن ساده برگردانید. یک رمز معمولا کلیدی برای تغییر رفتار خود دارد. اصطلاح دیگر برای این کار رمزگذاری و رمزگشایی است.\nیک رمز ساده ROT13 است. هر حرف 13 کاراکتر به جلو منتقل می شود. برای خنثی سازی رمز، 13 کاراکتر را به عقب حرکت می دهید. متن ساده HELLO به متن رمزی URYYB تبدیل می‌شود. در این حالت، رمز ROT است و کلید 13 است.\nتوابع هش # تابع هش یک فرآیند یک طرفه است که یک خلاصه متن تولید می کند. با توجه به یک ورودی، هر بار همان خروجی را تولید می کند. مهم است که خروجی بازگشتپذیر نباشد. اگر خروجی دارید، نباید ورودی آن را تعیین کنید. هش کردن زمانی مفید است که می‌خواهید تأیید کنید پیامی دستکاری نشده است.\nیک تابع هش ساده این است که فقط حروف دیگر را در بگیرد. HELLO به HLO تبدیل می‌شود. نمی‌توانید فرض کنید HELLO ورودی بوده است، اما می‌توانید تأیید کنید که HELLO با خلاصه هش مطابقت دارد.\nرمزنگاری کلید عمومی/خصوصی # رمزنگاری کلید عمومی/خصوصی نوع رمزهایی را که DTLS و SRTP استفاده می‌کنند. در این سیستم شما دو کلید عمومی و خصوصی دارید. کلید عمومی برای رمزگذاری پیام ها است و به اشتراک گذاری امن است. کلید خصوصی برای رمزگشایی است و هرگز نباید به اشتراک گذاشته شود. این تنها کلیدی است که می تواند پیام های رمزگذاری شده با کلید عمومی را رمزگشایی کند.\nتبادل دیفی–هلمن # تبادل Diffie–Hellman به دو کاربر که قبلا هرگز ملاقات نکرده‌اند اجازه می‌دهد تا یک رمز مشترک را به صورت ایمن از طریق اینترنت ایجاد کنند. کاربر A می تواند بدون نگرانی در مورد استراق سمع، یک رمز را برای کاربر B ارسال کند. پیچیدگی رمزنگاری به دشواری شکستن مسئله لگاریتم گسسته بستگی دارد. شما نیازی به درک کامل نحوه عملکرد این کار ندارید، اما دانستن اینکه این چیزی است که به دست دادن DTLS را ممکن می‌کند.\nویکی‌پدیا نمونه‌ای از این را در عمل دارد اینجا.\nتابع شبه تصادفی # یک تابع شبه تصادفی (PRF) یک تابع از پیش تعریف شده برای تولید مقداری است که تصادفی به نظر می رسد. ممکن است چندین ورودی بگیرد و یک خروجی تولید کند.\nتابع مشتق کلید # مشتق کلید نوعی تابع شبه تصادفی است. مشتق کلید تابعی است که برای قوی‌تر کردن کلید استفاده می‌شود. یکی از الگوهای رایج طولانی کردن کلید است.\nفرض کنید یک کلید به شما داده شده است که 8 بایت است. می توانید از KDF برای قوی تر کردن آن استفاده کنید.\nهیچ (Nonce) # یک nonce یک ورودی اضافی به یک رمز است. این مورد استفاده قرار می گیرد تا بتوانید خروجی های متفاوتی از رمز دریافت کنید، حتی اگرشما یک پیام را چندین بار رمزگذاری می کنید.\nاگر یک پیام را 10 بار رمزگذاری کنید، رمزگذار همان متن رمزی را 10 بار به شما می دهد. با استفاده از یک nonce می‌توانید خروجی‌های متفاوتی دریافت کنید، در حالی که همچنان از یک کلید استفاده می‌کنید. مهم است که برای هر پیام از یک nonce متفاوت استفاده کنید! در غیر این صورت، مقدار زیادی از ارزش را نفی می کند.\nکد احراز هویت پیام (MAC) # کد احراز هویت پیام، همان هش است که در انتهای پیام قرار می گیرد. MAC ثابت می کند که پیام از طرف کاربری که انتظار داشتید می آید.\nاگر از MAC استفاده نمی کنید، مهاجم می تواند پیام های نامعتبری را وارد کند. پس از رمزگشایی شما فقط زباله خواهید داشت زیرا آنها کلید را نمی دانند.\nچرخش کلید # چرخش کلید، تغییر کلید در یک بازه زمانی مشخص است. این باعث می شود کلید دزدیده شده تاثیر کمتری داشته باشد. اگر یک کلید به سرقت رفته یا فاش شود، داده های کمتری را می توان رمزگشایی کرد.\nDTLS # DTLS (امنیت لایه انتقال داده ها) به دو همتا اجازه می دهد تا ارتباط ایمن را بدون پیکربندی قبلی برقرار کنند. حتی اگر کسی مکالمه را استراق سمع کند، نمی تواند پیام ها را رمزگشایی کند.\nبرای ارتباط یک کلاینت DTLS و یک سرور، باید روی رمز و کلید به توافق برسند. آنها این مقادیر را با انجام یک دست دادن DTLS تعیین می کنند. در حین دست دادن، پیام ها به صورت متن ساده هستند. هنگامی که یک سرویس گیرنده/سرور DTLS جزئیات کافی را برای شروع رمزگذاری رد و بدل می کند، تغییر مشخصات رمز(Change Cipher Spec) را ارسال می کند. پس از این پیام، هر پیام بعدی رمزگذاری می شود!\nقالب بسته # هر بسته DTLS با یک هدر شروع می شود.\nنوع محتوا # شما می توانید نوع های زیر را انتظار داشته باشید:\n20 - تغییر مشخصات رمز 22 - دست دادن 23 - داده های برنامه Handshake برای تبادل جزئیات برای شروع جلسه استفاده می شود. از تغییر مشخصات رمز برای اطلاع دادن به طرف مقابل استفاده می‌شود که همه چیز رمزگذاری خواهد شد. Application Data پیام های رمزگذاری شده هستند.\nنسخه # نسخه می تواند 0x0000feff (DTLS v1.0) یا 0x0000fefd (DTLS v1.2) باشد، نسخه 1.1 وجود ندارد.\n####Epoch Epoch از 0 شروع می‌شود، اما پس از تغییر مشخصات رمز به 1 تبدیل می‌شود. هر پیامی با Epoch غیر صفر رمزگذاری شده است.\nشماره ترتیب # Sequence Number برای مرتب نگه داشتن پیام ها استفاده می شود. هر پیام تعداد توالی را افزایش می دهد. هنگامی که دوره افزایش می یابد، شماره توالی دوباره شروع می شود.\nطول و بار # Payload نوع محتوا خاص است. برای هر داده های برنامه، Payload رمزگذاری شده است. برای Handshake بسته به پیام متفاوت خواهد بود. طول به میزان بزرگی بار محموله است.\nمکانیسم حالت دست دادن # در حین دست دادن، مشتری/سرور یک سری پیام را مبادله می کند. این پیام ها در دسته هایی گروه بندی می شوند. هر دسته ممکن است چندین پیام در خود داشته باشد (یا فقط یک). یک دسته تا زمانی که تمام پیام‌های موجود در دسته دریافت نشده باشد کامل نمی‌شود. در زیر هدف هر پیام را با جزئیات بیشتر شرح خواهیم داد.\n![دست دادن](../images/04-handshake.png دست دادن)\n####ClientHello ClientHello پیام اولیه ارسال شده توسط مشتری است. این شامل لیستی از ویژگی ها است. این ویژگی ها رمزها و ویژگی هایی را که مشتری پشتیبانی می کند را به سرور می گوید. برای WebRTC به این صورت است که رمز SRTP را نیز انتخاب می کنیم. همچنین حاوی داده های تصادفی است که برای تولید کلیدهای جلسه استفاده می شود.\nHelloVerifyRequest # HelloVerifyRequest توسط سرور برای مشتری ارسال می شود. برای اطمینان از اینکه مشتری قصد ارسال درخواست را داشته است. سپس کلاینت ClientHello را مجدداً ارسال می کند، اما با یک توکن ارائه شده در HelloVerifyRequest.\n####ServerHello ServerHello پاسخ سرور برای پیکربندی این جلسه است. این شامل رمزی است که پس از پایان این جلسه استفاده می شود. همچنین حاوی داده های تصادفی سرور است.\nگواهی # گواهی شامل Certificate برای مشتری یا سرور است. از این برای شناسایی منحصر به فرد افرادی که با آنها در ارتباط بودیم استفاده می شود. پس از پایان دست دادن، مطمئن می شویم که این گواهی زمانی که هش می شود با اثر انگشت در Description Session مطابقت داشته باشد.\nServerKeyExchange/ClientKeyExchange # این پیام ها برای انتقال کلید عمومی استفاده می شود. هنگام راه اندازی، مشتری و سرور هر دو یک جفت کلید ایجاد می کنند. پس از دست دادن، از این مقادیر برای ایجاد Pre-Master Secret استفاده می شود.\n####CertificateRequest یک CertificateRequest توسط سرور ارسال می شود و به مشتری اطلاع می دهد که گواهی می خواهد. سرور می تواند درخواست یا نیاز به گواهی داشته باشد.\n####ServerHelloDone ServerHelloDone به مشتری اطلاع می دهد که کار سرور با دست دادن تمام شده است.\n####CertificateVerify CertificateVerify روشی است که فرستنده ثابت می کند که کلید خصوصی ارسال شده در پیام Certificate را دارد.\nChangeCipherSpec # ChangeCipherSpec به گیرنده اطلاع می دهد که هر چیزی که پس از این پیام ارسال می شود رمزگذاری خواهد شد.\n####Finished Finished رمزگذاری شده است و حاوی هش از همه پیام‌ها است. این برای اثبات این است که دست دادن دستکاری نشده است.\nنسل کلید # پس از اتمام Handshake، می توانید شروع به ارسال داده های رمزگذاری شده کنید. رمز توسط سرور انتخاب شده و در ServerHello قرار دارد. چگونه این کلید انتخاب می شود؟\nابتدا Pre-Master Secret را تولید می کنیم. برای به دست آوردن این مقدار، Diffie–Hellman روی کلیدهای مبادله شده توسط ServerKeyExchange و ClientKeyExchange استفاده می شود. جزئیات بسته به رمز انتخابی، متفاوت است.\nسپس Master Secret تولید می شود. هر نسخه از DTLS یک Pseudorandom function تعریف شده دارد. برای DTLS 1.2 این تابع مقادیر Pre-Master Secret و مقادیر تصادفی را در ClientHello و ServerHello می گیرد. خروجی اجرای Pseudorandom function Master Secret است. Master Secret مقداری است که برای رمز استفاده می شود.\nتبادل داده های برنامه # نقطه قوت DTLS چیزی جز ApplicationData نیست. اکنون که یک رمز اولیه داریم، می توانیم رمزگذاری و ارسال مقادیر را شروع کنیم.\nپیام‌های ApplicationData از هدر DTLS همانطور که قبلاً توضیح داده شد استفاده می‌کنند. Payload با متن رمز پر شده است. شما اکنون یک جلسه DTLS در حال کار دارید و می توانید به طور ایمن ارتباط برقرار کنید.\nDTLS دارای بسیاری از ویژگی های جالب دیگر مانند مذاکره مجدد است. آنها توسط WebRTC استفاده نمی شوند، بنابراین در اینجا پوشش داده نمی شوند.\nSRTP # SRTP یک پروتکل است که به طور خاص برای رمزگذاری بسته های RTP طراحی شده است. برای شروع یک جلسه SRTP، کلیدها و رمز خود را مشخص می کنید. برخلاف DTLS مکانیسم دست دادن ندارد. تمام تنظیمات و کلیدها در حین دست دادن DTLS ایجاد شدند.\nDTLS یک API اختصاصی برای صادر کردن کلیدها برای استفاده در فرآیند دیگری فراهم می کند که در RFC 5705 تعریف شده است.\nایجاد جلسه # SRTP یک تابع مشتق کلیدی را تعریف می کند که در ورودی ها استفاده می شود. هنگام ایجاد یک جلسه SRTP، ورودی ها از طریق آن اجرا می شوند تا کلیدهای ما را برای رمز SRTP تولید کنند. پس از این می توانید به پردازش رسانه بروید.\nتبادل رسانه # هر بسته RTP یک SequenceNumber 16 بیتی دارد. این اعداد ترتیبی برای مرتب نگه داشتن بسته ها مانند کلید اصلی استفاده می شود. در طول یک تماس، اینها جابجا می شوند. SRTP آن را ردیابی می کند و آن را rollover counter می نامد.\nهنگام رمزگذاری یک بسته، SRTP از شمارنده rollover و شماره دنباله به عنوان nonce استفاده می کند. این برای اطمینان از این است که حتی اگر یک داده را دو بار ارسال کنید، متن رمز متفاوت خواهد بود. این برای جلوگیری از شناسایی الگوها یا تلاش برای حمله مجدد توسط مهاجم مهم است.\n"},{"id":4,"href":"/fa/docs/05-real-time-networking/","title":"شبکه بی درنگ","section":"Docs","content":" چرا شبکه در ارتباطات بلادرنگ بسیار مهم است؟ # شبکه ها یکی از فاکتور های محدود کننده در ارتباطات بلادرنگ هستند. در دنیای ایده آل، پهنای باند نامحدودی خواهیم داشت و بسته ها فوراً می رسند. هرچند اینطور نیست شبکه ها محدود هستند و شرایط می تواند در هر زمان تغییر کند و اندازه گیری و مشاهده شرایط شبکه نیز در هر لحظه مشکل سختی است. شما می توانید رفتارهای مختلفی داشته باشید بسته به سخت افزار، نرم افزار و پیکربندی آن.\nارتباط بلادرنگ نیز مشکلی را ایجاد می کند که در اکثر حوزه های دیگر وجود ندارد. برای یک توسعه دهنده وب چالش بزرگی نیست اگر وب سایت شما در برخی از شبکه ها کندتر باشد. تا زمانی که همه داده ها به دست می آیند، کاربران خوشحال هستند. با WebRTC، اگر داده های شما دیر ارسال شوددیگر بی فایده است و هیچ کس به آنچه در یک کنفرانس تلفنی 5 ثانیه پیش گفته شد اهمیت نمی دهد. بنابراین هنگام توسعه یک سیستم ارتباطی بلادرنگ، شما باید یک معامله انجام دهید و آن هم این است که از خود بپرسید محدودیت زمانی من چقدر است و چه مقدار داده می توانم ارسال کنم؟\nاین فصل مفاهیمی را پوشش می دهد که هم برای داده ها و هم برای ارتباطات رسانه ای کاربرد دارند. در فصل های بعدی فراتر می رویم نظری و بحث در مورد اینکه چگونه رسانه ها و زیرسیستم های WebRTC این مشکلات را حل می کنند می پردازیم.\nویژگی های شبکه چیست که آن را دشوار می کند؟ # کدی که به طور موثر در تمامی شبکه ها کار کند، بسیار پیچیده است. شما عوامل مختلف زیادی دارید، و همه آنها می توانند به طور ماهرانه روی یکدیگر تأثیر بگذارند. اینها رایج ترین مشکلاتی هستند که توسعه دهندگان با آن ها مواجه می شوند.\nپهنای باند # پهنای باند حداکثر نرخ داده ای است که می تواند در یک مسیر مشخص منتقل شود. مهم است که به یاد داشته باشید این هم یک عدد ثابت نیست پهنای باند در طول مسیر تغییر می کند زیرا افراد بیشتر (یا کمتر) از آن استفاده می کنند.\nزمان انتقال و زمان رفت و برگشت # زمان انتقال مدت زمانی است که طول می کشد تا یک بسته به مقصد برسد. همانند پهنای باند این ثابت نیست. زمان انتقال می تواند در هر زمان تغییر کند.\n(زمان_انتقال = زمان_دریافت - زمان_ارسال) transmission_time = receive_time - send_time\nبرای محاسبه زمان ارسال، به ساعت های فرستنده و گیرنده نیاز دارید که با دقت میلی ثانیه همگام سازی شده باشند. حتی یک انحراف کوچک می تواند یک اندازه گیری زمان انتقال غیر قابل اعتماد ایجاد کند. از آنجایی که WebRTC در محیط‌های بسیار ناهمگن عمل می‌کند، تکیه بر همگام‌سازی زمانی کامل بین میزبان‌ها تقریباً غیرممکن است.\nاندازه گیری زمان رفت و برگشت راه حلی برای همگام سازی ناقص ساعت است.\nبه جای کار بر روی ساعت های توزیع شده، یک همتای WebRTC یک بسته ویژه با مهر زمانی خود sendertime1 ارسال می کند. همتای دیگر بسته را دریافت می کند و مهر زمانی را به فرستنده منعکس می کند. هنگامی که فرستنده اصلی زمان منعکس شده را دریافت می کند، مهر زمانی sendertime1 را از زمان فعلی sendertime2 کم می کند. این دلتای زمانی تاخیر انتشار رفت و برگشت یا معمولاً زمان رفت و برگشت نامیده می شود.\nrtt = sendertime2 - sendertime1\nنیمی از زمان رفت و برگشت به اندازه کافی تقریب خوبی را برای زمان انتقال، در نظر می گیرد. این راه حل هم بدون اشکال نیست. این فرض را ایجاد می کند که آیا ارسال و دریافت بسته ها زمان برابری را می برد. اما در شبکه های سلولی، عملیات ارسال و دریافت ممکن است متقارن زمان نباشد. شاید متوجه شده باشید که سرعت آپلود روی گوشی شما تقریباً همیشه کمتر از سرعت دانلود است.\ntransmission_time = rtt/2\nنکات فنی اندازه گیری زمان رفت و برگشت با جزئیات بیشتر در فصل گزارش های فرستنده و گیرنده RTCP توضیح داده شده است.\nJitter # جیتر این واقعیت است که زمان انتقال ممکن است برای هر بسته متفاوت باشد. بسته های شما ممکن است به تعویق بیفتد، اما سپس به صورت رگباری می رسند.\nاز دست دادن بسته # Packet Loss زمانی است که پیام ها در انتقال گم می شوند. نرخ از دست رفتن می تواند ثابت باشد، یا ممکن است به صورت ناگهانی رخ دهد. این ممکن است به دلیل نوع شبکه مانند ماهواره یا Wi-Fi باشد. یا ممکن است در طول مسیر توسط نرم افزار ایجاد شده باشد.\nحداکثر واحد انتقال # حداکثر واحد انتقال محدودیتی است که یک بسته واحد چقدر می تواند بزرگ باشد. اگر بسته شما بسیار بزرگ باشد، شبکه ها به شما اجازه ارسال نمی دهند یک پیام غول پیکر در سطح پروتکل، ممکن است پیام ها به چندین بسته کوچکتر تقسیم شوند.\nبسته به مسیر شبکه ای که انتخاب می کنید، MTU نیز متفاوت خواهد بود. می توانید از پروتکلی مانند Path MTU Discovery استفاده کنید تا بزرگترین اندازه بسته ای را که می توانید ارسال کنید، تعیین کنید.\nازدحام # ازدحام زمانی است که به محدودیت های شبکه رسیده باشد. این معمولاً به این دلیل است که شما به اوج رسیده اید پهنای باندی که مسیر فعلی می تواند از عهده آن برآید. یا ممکن است اپراتور اعمال شود مانند محدودیت های ساعتی که ISP شما را پیکربندی می کند.\nازدحام به طرق مختلف خود را نشان می دهد و هیچ رفتار استانداردی وجود ندارد. در بیشتر موارد زمانی که ازدحام رخ می دهد، شبکه بسته های اضافی را رها می کند. در موارد دیگر شبکه بافر خواهد شد. این باعث بالا رفتن زمان انتقال می شود . همچنین می توانید با شلوغ شدن شبکه خود، لگ های بیشتری را مشاهده کنید. این مبحث به سرعت در حال تغییر است و الگوریتم های جدید برای تشخیص تراکم هنوز در حال نوشتن هستند.\nپویا بودن # شبکه ها فوق العاده پویا هستند و شرایط می توانند به سرعت تغییر کند. در طول یک تماس می توانید صدها هزار بسته ارسال و دریافت کنید. این بسته‌ها از طریق چندین هاب منتقل خواهند شد. این هاب ها توسط میلیون ها کاربر دیگر به اشتراک گذاشته خواهد شد. حتی در شبکه محلی خود می توانید فیلم‌های HD در حال دانلود داشته باشید یا شاید دستگاهی تصمیم به دانلود به‌روزرسانی نرم‌افزاری بگیرد.\nداشتن یک تماس خوب به اندازه اندازه گیری شبکه در هنگام راه اندازی ساده نیست. باید مدام در حال ارزیابی باشید. شما همچنین نیاز دارید همه ی رفتار هایی که از نرم افرار و سخت افزار می آید را ارزیابی کنید.\nراه حلی برای از دست دادن بسته # مدیریت از دست دادن بسته اولین مشکلی است که باید حل شود. راه های مختلفی برای حل آن وجود دارد که هر کدام مزایای خاص خود را دارند. بسته به این که چه چیزی و یا چگونه ارسال می کنید ممکن است متحمل تاخیر شوید همچنین مهم است که همه از دست دادن بسته ها چالش پذیر نیستند. از دست دادن برخی ویدیوها ممکن است مشکلی ایجاد نکند، ممکن است چشم انسان مشکلی نداشته باشد حتی قادر به درک آن نباشد. از دست دادن پیام های متنی کاربران می ت.اند بسیار چالشی باشد است.\nفرض کنید 10 بسته ارسال می کنید و بسته های 5 و 6 گم می شوند. در اینجا راه هایی وجود دارد که می توانید آن را حل کنید.\nAcknowledgments # تصدیق زمانی است که گیرنده، فرستنده را از هر بسته ای که دریافت می کند مطلع می سازد. فرستنده زمانی از گم شدن بسته آگاه خواهد شد که برای یک بسته دو بار تصدیق دریافت کند در حالی که بسته ها تمام نشده اند. هنگامی که فرستنده دو بار یک ACK برای بسته 4 دریافت می کند، می داند که بسته 5 هنوز نرسیده است.\nAcknowledgment های انتخابی # تصدیق های انتخابی بهبودی از تصدیق است. یک گیرنده می تواند یک SACK ارسال کند که چندین بسته را تأیید می کند و به فرستنده از شکاف ها اطلاع می دهد. اکنون فرستنده می تواند یک SACK برای بسته 4 و 7 دریافت کند. سپس می داند که باید بسته های 5 و 6 را دوباره ارسال کند.\nAcknowledgment های منفی # قدردانی های منفی مشکل را برعکس حل می کند. گیرنده به جای اطلاع دادن به فرستنده که آنچه را دریافت کرده است، به فرستنده اطلاع می دهد که چه چیزی گم شده است. در مورد ما یک NACK برای بسته های 5 و 6 ارسال می شود. فرستنده فقط بسته هایی را می داند که گیرنده می خواهد دوباره ارسال کند.\nتصحیح خطای فوروارد # Forward Error Correction به طور پیشگیرانه از دست دادن بسته را برطرف می کند. فرستنده داده های اضافی را ارسال می کند، به این معنی که یک بسته از دست رفته بر نتیجه نهایی تأثیر نمی گذارد. یکی از الگوریتم های محبوب برای این تصحیح خطا Reed-Solomon است.\nاین امر تأخیر و پیچیدگی ارسال و رسیدگی به تصدیق ها را کاهش می دهد. اگر شبکه ای که در آن هستید صفر درصد هدر رفتن بسته داشته باشد، تصحیح خطای فوروارد اتلاف پهنای باند است.\nحل Jitter # جیتر در اکثر شبکه ها وجود دارد. حتی در داخل شبکه LAN، دستگاه‌های زیادی هستند که داده‌ها را با نرخ‌های متغیر ارسال می‌کنند. شما به راحتی می توانید با پینگ کردن دستگاه دیگری با فرمان ping و مشاهده نوسانات تأخیر رفت و برگشت و بالا و پایین شدن شبکه را مشاهده کنید.\nبرای حل جیتر، کلاینت ها از JitterBuffer استفاده می کنند. JitterBuffer زمان تحویل ثابت بسته ها را تضمین می کند. نکته منفی این است که JitterBuffer مقداری تاخیر به بسته هایی که زودتر می رسند اضافه می کند. نکته مثبت این است که بسته‌های دیرهنگام باعث Jitter نمی‌شوند. تصور کنید که در طول یک تماس، زمان‌های رسیدن بسته زیر را مشاهده می‌کنید:\n* time=1.46 ms * time=1.93 ms * time=1.57 ms * time=1.55 ms * time=1.54 ms * time=1.72 ms * time=1.45 ms * time=1.73 ms * time=1.80 ms در این مورد، حدود 1.8 میلی ثانیه انتخاب خوبی خواهد بود. بسته هایی که دیر می رسند از پنجره تاخیر استفاده می کنند. بسته‌هایی که زودتر می‌رسند کمی تأخیر خواهند داشت و می‌توانند پنجره تخلیه شده توسط بسته های تاخیری را پر کنید. این به این معنی است که ما دیگر وقفه نداریم و نرخ تحویل آرامی را برای مشتری فراهم می کنیم.\nعملیات JitterBuffer # هر بسته به محض دریافت به بافر jitter اضافه می شود. هنگامی که بسته های کافی برای بازسازی قاب وجود دارد، بسته هایی که فریم را تشکیل می دهند از بافر آزاد می شوند و برای دیکود شدن منتشر می شوند. دیکودر نیز به نوبه خود، فریم ویدیو را روی صفحه کاربر دیکود و ترسیم می کند. از آنجایی که بافر جیتر ظرفیت محدودی دارد، بسته هایی که برای مدت طولانی در بافر می مانند، دور ریخته می شوند.\nدر مورد چگونگی تبدیل فریم های ویدئویی به بسته های RTP و چرایی نیاز به بازسازی در فصل ارتباطات رسانه ای بیشتر بخوانید.\njitterBufferDelay بینشی عالی از عملکرد شبکه شما و تأثیر آن بر روان بودن پخش ارائه می دهد. این بخشی از WebRTC statistics API مربوط به جریان ورودی گیرنده است. تأخیر مقدار زمانی را که فریم‌های ویدیویی در بافر لرزاننده قبل از انتشار برای دیکود شدن می‌گذرد، را نشان می دهد. تاخیر طولانی بافر جیتر به این معنی است که شبکه شما به شدت شلوغ است.\nتشخیص ازدحام # قبل از اینکه بتوانیم ازدحام را حل کنیم، باید آن را تشخیص دهیم. برای تشخیص آن از یک کنترل کننده ازدحام استفاده می کنیم. این موضوع پیچیده ای است و هنوز هم به سرعت در حال تغییر است. الگوریتم های جدید هنوز در حال انتشار و آزمایش هستند. در سطح بالا، همه آنها یکسان عمل می کنند. یک کنترل کننده ازدحام با توجه به برخی ورودی ها، تخمین پهنای باند را ارائه می دهد. اینها برخی از ورودی های ممکن هستند:\nاز دست دادن بسته - با شلوغ شدن شبکه، بسته ها حذف می شوند Jitter - تجهیزات شبکه باعث سرریز شدن بسته در صف می شدن که موجب می شود که زمان به بی نهایت میل کند. زمان رفت و برگشت - بسته ها در صورت شلوغی زمان بیشتر طول می کشد تا بسته به دستشان برسند. برخلاف جیتر، زمان رفت و برگشت همچنان افزایش می یابد. اعلان تراکم صریح - شبکه های جدیدتر ممکن است بسته ها را به عنوان در معرض خطر رها شدن برای کاهش ازدحام برچسب گذاری کنند. این مقادیر باید به طور مداوم در طول تماس اندازه گیری شوند. استفاده از شبکه ممکن است افزایش یا کاهش یابد، بنابراین پهنای باند موجود می تواند دائما در حال تغییر باشد.\nحل تراکم # اکنون که پهنای باند تخمینی داریم باید آنچه را که ارسال می کنیم تنظیم کنیم. نحوه تنظیم بستگی به نوع داده ای دارد که می خواهیم ارسال کنیم.\nارسال کندتر # محدود کردن سرعت ارسال داده ها اولین راه حل برای جلوگیری از ازدحام است. کنترل ازدحام به شما تخمینی می دهد، که مسئولیت فرستنده است که نرخ را محدود کند.\nاین روشی است که برای اکثر ارتباطات داده استفاده می شود. با پروتکل هایی مانند TCP همه اینها توسط سیستم عامل انجام می شود و برای کاربران و توسعه دهندگان کاملاً شفاف است.\nارسال کمتر # در برخی موارد ما می توانیم اطلاعات کمتری برای برآورده کردن محدودیت های خود ارسال کنیم. ما همچنین ضرب الاجل های صفت و سختی برای رسیدن داده‌هایمان داریم، بنابراین نمی‌توانیم کندتر ارسال کنیم. اینها محدودیت هایی هستند که رسانه بلادرنگ تحت تتاثیر آن قرار می گیرد.\nاگر پهنای باند کافی در دسترس نداریم، می‌توانیم کیفیت ویدیویی را که ارسال می‌کنیم کاهش دهیم. این بستگی به دیکودر ویدیوی شما و کنترل کننده ازدحام شما دارد.\n"},{"id":5,"href":"/fa/docs/06-media-communication/","title":"ارتباط رسانه ای","section":"Docs","content":" #ارتباطات رسانه ای\nاز ارتباطات رسانه ای WebRTC چه چیزی دریافت می کنم؟ # WebRTC به شما امکان ارسال و دریافت تعداد نامحدودی از جریان های صوتی و تصویری را می دهد. می‌توانید این جریان‌ها را در هر زمانی در طول تماس اضافه و حذف کنید. این جریان ها می توانند همه مستقل باشند، یا می توانند با هم جمع شوند! می توانید یک فید ویدیویی از دسکتاپ خود ارسال کنید و سپس صدا و تصویر را از وب کم خود اضافه کنید.\nپروتکل WebRTC کدک آگنوستیک(با همه ی دستگاه ها و سیستم عامل ها کار می کند) است. حمل و نقل زیربنایی از همه چیز پشتیبانی می کند، حتی چیزهایی که هنوز وجود ندارند! با این حال، عامل WebRTC که با آن در ارتباط هستید ممکن است ابزار لازم برای پذیرش آن را نداشته باشد.\nWebRTC همچنین برای رسیدگی به شرایط شبکه پویا طراحی شده است. در طول تماس، پهنای باند شما ممکن است افزایش یا کاهش یابد. شاید به طور ناگهانی از دست دادن بسته های زیادی را تجربه کنید. پروتکل برای رسیدگی به همه اینها طراحی شده است. WebRTC به شرایط شبکه پاسخ می دهد و سعی می کند بهترین تجربه ممکن را با منابع موجود به شما ارائه دهد.\nچگونه کار می کند؟ # WebRTC از دو پروتکل از پیش موجود RTP و RTCP استفاده می کند که هر دو در RFC 1889 تعریف شده اند.\nRTP (پروتکل ارتباطی در زمان بی درنگ) پروتکلی است که رسانه(صدا و تصویر) را منتقل می کند. این به گونه ای طراحی شده است که امکان ارسال بلادرنگ ویدیو را فراهم کند. هیچ قاعده‌ای در مورد تأخیر یا قابلیت اطمینان تعیین نمی‌کند، اما ابزارهایی را برای پیاده‌سازی آنها در اختیار شما قرار می‌دهد. RTP به شما جریان رسانه ای (صدا و تصویر) ارایه می دهد، بنابراین می توانید چندین خط رسانه(چندین صدا و تصویر) را روی یک اتصال بفرستید. همچنین زمان بندی و اطلاعات سفارشی را که برای مقدار دهی اولیه خط رسانه نیاز دارید در اختیار شما قرار می دهد.\nRTCP (پروتکل کنترل RTP) پروتکلی است که فرا داده یا متادیتا را در مورد تماس تعیین می کند. قالب فراداده بسیار منعطف است و به شما امکان می دهد هر فراداده ای را که می خواهید اضافه کنید. از این مورد برای برقراری ارتباط آماری در مورد تماس استفاده می شود(مانند پهنای باند و نرخ فریم). همچنین برای کنترل از دست دادن بسته ها و اجرای کنترل ازدحام استفاده می شود. این پروتکل ارتباط دو طرفه لازم برای پاسخ به شرایط متغیر شبکه را به شما می دهد.\nتاخیر و کیفیت # در رسانه های بلادرنگ توازنی(تریدآف) بین تأخیر و کیفیت وجود دارد. هرچه زمان تاخیر بیشتری را تحمل کنید، می توانید انتظار ویدیوی با کیفیت بالاتری داشته باشید.\nمحدودیت های دنیای واقعی # این محدودیت ها همه ناشی از محدودیت های دنیای واقعی است. همه آنها ویژگی های شبکه شما هستند که باید بر آنها غلبه کنید.\nویدئو پیچیده است # ارتباط ویدئویی آسان نیست. برای ذخیره 30 دقیقه ویدیوی 720 8 بیتی فشرده نشده، به حدود 110 گیگابایت حافظه نیاز دارید. با این حجم از حافظه، یک کنفرانس تلفنی 4 نفره اتفاق نمی افتد. ما به راهی برای کوچکتر کردن آن نیاز داریم و پاسخ آن فشرده سازی ویدیو است. هر چند که مشکلاتی نیز به بار می آورد.\nویدئو 101 # ما قصد نداریم فشرده سازی ویدیو را به طور عمیق پوشش دهیم، بلکه به اندازه ای است که بفهمیم چرا RTP به این شکل طراحی شده توضیح خواهیم داد. فشرده‌سازی ویدیو، ویدیو را در قالب جدیدی کد می‌کند که برای نمایش همان ویدیو به بیت‌های کمتری نیاز دارد.\nفشرده سازی Lossy and Lossless # می‌توانید ویدیو را به گونه‌ای کد کنید که بدون اتلاف (هیچ اطلاعاتی از بین نرود) باشد یا با اتلاف (ممکن است اطلاعات از بین برود) باشد. از آنجایی که کد کردن بدون اتلاف نیاز به داده های بیشتری برای ارسال به همتا دارد، که باعث می شود جریان تاخیری بالاتر و بسته های حذف شده بیشتری ایجاد شود، RTP معمولاً از فشرده سازی با اتلاف استفاده می کند حتی اگر کیفیت ویدیو به خوبی نباشد.\nفشرده سازی درون و بین قاب # فشرده سازی ویدئو در دو نوع ارائه می شود. اولین مورد درون قاب یا فریم است(فشرده سازی خود فریم). فشرده سازی درون فریم بیت های مورد استفاده برای توصیف یک فریم ویدئو را کاهش می دهد. از همین روش ها برای فشرده سازی تصاویر ثابت استفاده می شود، مانند روش فشرده سازی JPEG.\nنوع دوم فشرده سازی بین قاب(فریم) است. از آنجایی که ویدیو از تصاویر زیادی تشکیل شده است، ما به دنبال راه هایی هستیم که اطلاعات یکسانی را دوبار ارسال نکنیم.\nانواع بین فریم # سپس شما سه نوع قاب دارید:\nI-Frame - یک تصویر کامل، می تواند بدون هیچ چیز دیگری رمزگشایی شود. P-Frame - یک تصویر جزئی که فقط شامل تغییرات نسبت به عکس قبلی است. B-Frame - یک تصویر جزئی، اصلاحی از تصاویر قبلی و آینده است. در زیر تصویر سه نوع قاب وجود دارد.\nویدئو حساس است # فشرده‌سازی ویدیو به‌طور باورنکردنی چند حالتی است و انتقال آن را از طریق اینترنت دشوار می‌کند. اگر بخشی از I-Frame را گم کنید چه اتفاقی می‌افتد؟ چگونه یک P-Frame می داند چه چیزی را باید تغییر دهد؟ همانطور که فشرده سازی ویدئو پیچیده تر می شود، این مشکل حتی بیشتر می شود. خوشبختانه RTP و RTCP راه حلی برای این مشکل دارند.\nRTP # قالب بسته # هر بسته RTP دارای ساختار زیر است:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Synchronization Source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | Contributing Source (CSRC) identifiers | | .... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ نسخه (V) # نسخه همیشه 2 است\nپدینگ (P) # Padding یک صفر و یک(بولین) است که کنترل می‌کند آیا محموله دارای بالشتک(پدینگ) است.\nآخرین بایت محموله، حاوی تعداد بایت های padding اضافه شده است.\nپسوند (X) # اگر تنظیم شود، هدر RTP پسوندهایی خواهد داشت. این با جزئیات بیشتر در زیر توضیح داده شده است.\nتعداد CSRC (CC) # تعداد شناسه‌های CSRC که بعد از SSRC و قبل از بارگذاری تعیین می شوند.\nنشانگر (M) # بیت نشانگر معنای از پیش تعیین شده ای ندارد و می تواند هر طور که کاربر دوست دارد استفاده شود.\nدر برخی موارد زمانی تنظیم می شود که کاربر در حال صحبت است. همچنین معمولاً برای علامت گذاری یک فریم کلیدی استفاده می شود.\nنوع بار (PT) # Payload Type یک شناسه منحصر به فرد برای کدک هایی است که توسط این بسته منتقل می شود.\nبرای WebRTC نوع بار پویا است. VP8 در یک تماس ممکن است با دیگری متفاوت باشد. پیشنهاد دهنده در تماس، نگاشت انواع بار را به کدک‌ها در شرح جلسه(SDP) تعیین می‌کند.\nشماره ترتیب # Sequence Number برای ترتیب گرفتن بسته ها در یک جریان استفاده می شود. هر بار که یک بسته ارسال می شود، شماره ترتیبی یک عدد افزایش می یابد.\nRTP به گونه ای طراحی شده است که در شبکه های با اتلاف قابل استفاده باشد. این به گیرنده راهی می دهد تا تشخیص دهد که چه زمانی بسته ها گم شده است.\nمهر زمانی # لحظه ای است که بسته برای ارسال آماده می شود. این مهر زمانی یک ساعت جهانی نیست، بلکه چقدر زمان در جریان رسانه ها سپری شده است. چندین بسته RTP می توانند دارای مهر زمانی یکسانی باشند اگر برای مثال همه آنها بخشی از یک قاب ویدیو باشند.\nمنبع همگام سازی (SSRC) # SSRC شناسه منحصربه‌فرد برای این جریان است. این به شما امکان می دهد چندین جریان رسانه را روی یک جریان RTP منتقل کنید.\nمنبع اضافه کننده (CSRC) # فهرستی که آنچه را که SSRC به این بسته اضافه کرده است را بیان می‌کند.\nاین معمولا برای نشان دادن صحبت کردن استفاده می شود. فرض کنید در سمت سرور چندین فید صوتی را در یک جریان RTP ترکیب کرده اید. سپس می توانید از این فیلد برای گفتن \u0026ldquo;جریان ورودی A و C در این لحظه صحبت می کردند\u0026rdquo; استفاده کنید.\nPayload # اگر پرچم padding تنظیم شده باشد، داده های بار واقعی ممکن است با شمارش تعداد بایت های padding اضافه شده به پایان برسد.\nبرنامه های افزودنی # RTCP # قالب بسته # هر بسته RTCP ساختار زیر را دارد:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| RC | PT | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ نسخه (V) # نسخه همیشه 2 است.\nPadding (P) # Padding یک صفر یا یک(بولین) است که کنترل می‌کند آیا محموله دارای بالشتک یا پدینگ است یا خیر.\nآخرین بایت محموله حاوی تعداد بایت های padding اضافه شده است.\nتعداد گزارش پذیرش (RC) # تعداد گزارش ها در یک بسته RTCP می تواند شامل چندین رویداد باشد.\nنوع بسته (PT) # شناسه منحصر به فرد برای نوع بسته RTCP را نوع بسته می گویند. یک نماینده WebRTC نیازی به پشتیبانی از همه این انواع ندارد و پشتیبانی بین Agent ها می تواند متفاوت باشد. اینها مواردی هستند که معمولاً ممکن است ببینید:\n192 - درخواست کامل درون فریم (FIR) 193 - تصدیق های(ACK) منفی (\u0026ldquo;NACK\u0026rdquo;) 200 - گزارش فرستنده 201 - گزارش گیرنده 205 - بازخورد عمومی RTP 206 - بازخورد ویژه بار اهمیت این انواع بسته در زیر با جزئیات بیشتر توضیح داده خواهد شد.\nدرخواست کامل درون فریم (FIR) و نشان از دست دادن تصویر (PLI) # هر دو پیام FIR و PLI هدفی مشابه دارند. این پیام‌ها یک فریم کلید کامل از فرستنده درخواست می‌کنند. PLI زمانی استفاده می‌شود که فریم‌های جزئی به رمزگشا داده می‌شود، اما قادر به رمزگشایی آنها نبوده است. این ممکن است به این دلیل اتفاق بیفتد که شما بسته های زیادی از دست داده اید، یا شاید رمزگشا از کار افتاده است.\nطبق تعریف RFC 5104 ، FIR نباید در هنگام از دست رفتن بسته ها یا فریم ها استفاده شود. این کار PLI است. FIR یک فریم کلیدی را به دلایلی غیر از دست دادن بسته درخواست می کند - برای مثال زمانی که یک عضو جدید وارد یک کنفرانس ویدیویی می شود. آنها برای شروع دیکود کردن جریان ویدئو به یک فریم کلید کامل نیاز دارند، رمزگشا تا رسیدن فریم کلیدی، فریم‌ها را دور می‌اندازد.\nاین ایده خوبی است که گیرنده بلافاصله پس از اتصال درخواست یک فریم کامل کلید را بدهد، این امر تأخیر بین اتصال و نمایش تصویر در صفحه کاربر را به حداقل می رساند.\nبسته‌های PLI بخشی از پیام‌های بازخورد خاص Payload هستند.\nدر عمل، نرم‌افزاری که قادر به مدیریت هر دو بسته PLI و FIR است، در هر دو حالت یکسان عمل می‌کند. این یک سیگنال به کد کننده ارسال می کند تا یک قاب کامل کلید جدید تولید کند.\nتصدیق منفی # NACK درخواست می کند که یک بسته RTP تکی دوباره ارسال شود. این معمولاً به دلیل از دست رفتن بسته RTP ایجاد می شود، اما ممکن است به دلیل تاخیر هم اتفاق بیفتد.\nNACKها پهنای باند بسیار بیشتری نسبت به درخواست ارسال مجدد کل فریم دارند. از آنجایی که RTP بسته ها را به قطعات بسیار کوچک تقسیم می کند، شما در واقع فقط یک قطعه کوچک از دست رفته را دوباره درخواست می کنید. گیرنده یک پیام RTCP با SSRC و شماره دنباله ایجاد می کند. اگر فرستنده این بسته RTP را برای ارسال مجدد در دسترس نداشته باشد، آن گاه پیام را نادیده می گیرد.\nگزارش فرستنده و گیرنده # این گزارش ها برای ارسال آمار بین عامل ها استفاده می شود. این مقدار بسته های واقعی دریافت شده و جیتر را با هم ارتباط می دهد.\nگزارش ها را می توان برای تشخیص و کنترل ازدحام استفاده کرد.\nچگونه RTP/RTCP مشکلات را با هم حل می کند # RTP و RTCP با هم کار می کنند تا تمام مشکلات ناشی از شبکه ها را حل کنند. این تکنیک ها همچنان در حال تغییر هستند!\nتصحیح خطای بازارسال # صحیح خطای بازارسال، همچنین به عنوان FEC نیز شناخته می شود. روش دیگری برای مقابله با از دست دادن بسته است. FEC زمانی است که شما یک داده را چندین بار ارسال می کنید، بدون اینکه حتی درخواست شود. این در سطح RTP یا حتی سطح پایین‌تر با کدک انجام می شود.\nاگر از دست دادن بسته برای یک تماس ثابت باشد، FEC راه حلی با تاخیر بسیار کمتری نسبت به NACK است. زمان رفت و برگشت درخواست، و سپس ارسال مجدد بسته از دست رفته می تواند برای NACK ها هم مهم باشد.\nتخمین نرخ بیت و پهنای باند تطبیقی # همانطور که در فصل شبکه بی درنگ بحث شد، شبکه ها غیرقابل پیش بینی و غیرقابل اعتماد هستند. در دسترس بودن پهنای باند می تواند چندین بار در طول یک جلسه تغییر کند. غیر معمول نیست که شاهد تغییر چشمگیر پهنای باند موجود در عرض یک ثانیه باشیم.\nایده اصلی تنظیم نرخ کدینگ بر اساس پهنای باند شبکه پیش‌بینی‌شده ی فعلی و آینده است. این تضمین می کند که سیگنال تصویری و صوتی با بهترین کیفیت ممکن منتقل می شود و اتصال به دلیل ازدحام شبکه قطع نمی شود. احتمالاتی که رفتار شبکه را مدل می کند و سعی می کند آن را پیش بینی کند به عنوان تخمین پهنای باند شناخته می شود.\nتفاوت های ظریف زیادی در این مورد وجود دارد، بنابراین اجازه دهید جزئیات بیشتری را بررسی کنیم.\nشناسایی و برقراری ارتباط وضعیت شبکه # RTP/RTCP روی انواع شبکه‌های مختلف اجرا می‌شود و در نتیجه برای برخی رایج است ارتباط در مسیر خود از فرستنده به گیرنده قطع شود. در سطح انتقال UDP ، هیچ مکانیزم داخلی برای ارسال مجدد بسته وجود ندارد، چه رسد به مدیریت ازدحام.\nبرای ارائه بهترین تجربه به کاربران، WebRTC باید کیفیت های مربوط به مسیر شبکه را تخمین بزند و با تغییر پارامتر های شبکه، کیفیت ها در طول زمان وفق دهد. مقادیر کلیدی برای نظارت عبارتند از: در دسترس بودن پهنای باند (در هر جهت، زیرا ممکن است متقارن نباشد)، زمان رفت و برگشت، و لرزش (نوسانات) در رفت و برگشت. باید از دست دادن بسته ها بررسی کند و تغییرات لازم را به کیفیت ویدیو بدهد.\nدو هدف اصلی برای این پروتکل ها وجود دارد:\nپهنای باند موجود (در هر جهت) توسط شبکه را تخمین بزند. ویژگی های ارتباطی شبکه بین فرستنده و گیرنده متوجه شود. RTP/RTCP سه رویکرد متفاوت برای رفع این مشکل دارد. همه آنها جوانب مثبت و منفی خود را دارند، و به طور کلی هر نسل نسبت به نسل های قبلی خود پیشرفت کرده است. این که کدام پیاده سازی را قرار استفاده می کنید، در درجه اول به پشته نرم افزاری که در دسترس مشتریان شما و کتابخانه های موجود است بستگی دارد\nگزارش های گیرنده / گزارش های فرستنده # اولین پیاده سازی، جفت Receiver Reports و مکمل آن Sender Reports است. اینها پیام‌های RTCP است که در RFC 3550 تعریف شده‌اند و مسئول ارتباط وضعیت شبکه بین نقاط پایانی است. Receiver Reports بر روی این تمرکز دارد که کیفیت های ارتباطی در مورد شبکه (از جمله از دست دادن بسته، زمان رفت و برگشت و جیتر)، و با الگوریتم های دیگر همگام شود بعد از آن مسئول تخمین پهنای باند موجود بر اساس این گزارش ها است.\nگزارش های فرستنده و گیرنده (SR و RR) با هم تصویری از کیفیت شبکه را ترسیم می کنند. این مقادیر برای هر SSRC در یک برنامه زمانی ارسال می شود، و این مقادیر ورودی هایی هستند که هنگام تخمین شبکه استفاده می شوند این تخمین ها توسط فرستنده پس از دریافت داده های RR ساخته می شوند که حاوی فیلد های زیر هستند:\nضریب از دست رفتن - چند درصد از بسته ها از آخرین گزارش گیرنده از بین رفته اند. مجموع تعداد بسته های از دست رفته - تعداد بسته هایی که در طول کل تماس از بین رفته اند. بزرگترین شماره دریافت شده - آخرین شماره دنباله دریافتی چه بوده است، و چند بار تکرار شده است مهر زمان گزارش آخرین فرستنده - آخرین زمان شناخته شده در فرستنده، برای محاسبه زمان رفت و برگشت استفاده می شود SR و RR با هم کار می کنند تا زمان رفت و برگشت را محاسبه کنند.\nفرستنده زمان محلی خود sendertime1 که در SR است را ذخیره می کند. هنگامی که گیرنده یک بسته SR دریافت می کند، آن را دوباره به RR پس می فرستد. و یک چیز دیگر، RR نیز sendertime1 است که به تازگی از فرستنده گرفته است ذخیره می کند. بین دریافت SR و ارسال RR تاخیر وجود خواهد داشت. به همین دلیل، RR نیز شامل زمان تأخیر از آخرین گزارش فرستنده است - که به آن DLSR گویند. DLSR برای تنظیم تخمین زمان رفت و برگشت در مراحل بعدی استفاده می شود. هنگامی که فرستنده RR را دریافت کرد، sendertime1 و DLSR از زمان کنونی sendertime2 کم می کند. این زمان دلتا را رفت و برگشت تاخیر یا انتشار یا زمان رفت و برگشت می نامند\nrtt = sendertime2 - sendertime1 - DLSR\nزمان رفت و برگشت به زبان فارسی ساده:\nمن برای شما پیامی با قرائت فعلی ساعتم ارسال می کنم، مثلا می گویم ساعت 16:20 و 42 ثانیه و 420 میلی ثانیه است. شما همان مُهر زمان را برای من باز می گردانید. شما همچنین زمان سپری شده از خواندن پیام من تا ارسال مجدد پیام، مثلاً 5 میلی ثانیه را در نظر می گیرید. هنگامی که زمان را به قبلی دریافت کردم، دوباره به ساعت نگاه می کنم. اکنون ساعت من می گوید 4:20 بعد از ظهر، 42 ثانیه و 690 میلی ثانیه. یعنی 265 میلی ثانیه (690 - 420 - 5) طول کشید تا بسته به شما رسید و به سمت من برگشت. بنابراین زمان رفت و برگشت 265 میلی ثانیه است. TMMBR، TMMBN، REMB و TWCC، جفت شده با GCC # Google Congestion Control (GCC) # الگوریتم کنترل ازدحام Google (GCC) (به طور خلاصه در draft-ietf-rmcat-gcc-02 توضیح داده شده است) به چالش تخمین پهنای باند می پردازد. این الگوریتم با انواع پروتکل های دیگر همگام می شود تا الزامات ارتباطی مرتبط را تسهیل کند. در نتیجه برای اجرا در هر دو طرف گیرنده (هنگامی که با TMMBR/TMMBN یا REMB اجرا می شود) و یا حتی در هر دو سمت ارسال کننده (هنگامی که با TWCC اجرا می شود) بسیار مناسب است.\nبرای رسیدن به تخمین‌هایی برای پهنای باند موجود، GCC روی از دست دادن بسته‌ها و نوسانات فریم تمرکز می‌کند. زمان رسیدن به عنوان دو معیار اصلی آن می باشد. این معیارها را از طریق دو کنترلر مرتبط اجرا می کند: کنترل کننده مبتنی بر از دست رفتن و کنترل کننده مبتنی بر تاخیر.\nاولین جزء GCC، کنترل کننده مبتنی بر از دست رفتن بسیار ساده است:\nاگر از دست دادن بسته بالاتر از 10٪ باشد، تخمین پهنای باند کاهش می یابد. اگر از دست دادن بسته بین 2-10٪ باشد، تخمین پهنای باند ثابت می ماند. اگر از دست دادن بسته کمتر از 2٪ باشد، تخمین پهنای باند افزایش می یابد. اندازه گیری از دست دادن بسته ها در بازه هایی انجام می شود. وابسته به پروتکل ارتباطی هنگام شده، از دست دادن بسته ممکن است به طور صریح اعلام شود (مانند TWCC) یا استنباط شود (مانند TMMBR/TMMBN و REMB). این درصدها در طول بازه های زمانی حدود یک ثانیه ارزیابی می شوند.\nتابع دوم با کنترل کننده مبتنی بر از دست رفتن کار می کند و به تغییرات بسته در هنگام رسیدن بسته نگاه می کند . هدف این کنترلر مبتنی بر تاخیر شناسایی زمانی است که شبکه های متصل به حالت ازدحام می روندو به طور فزاینده ای شلوغ می شود و ممکن است تخمین های پهنای باند را حتی قبل از دست دادن بسته ها کاهش دهد. در تئوری به این گونه است که شلوغ ترین محل اتصال شبکه در طول مسیر، بسته ها را تا زمان پر شدن بافر به صف می برد. اگر آن روتر به دریافت بسته ادامه دهد ممکن است ترافیک بیشتر از آنچه که بتواند باز ارسال کند شود و مجبور شود تمام بسته هایی را که نمی تواند بافر کند را رها(drop) کند. این نوع از دست رفتن بسته ها برای ارتباطات بی درنگ یا با تاخیر کم مخرب است ولی همچنین می تواند خروجی برای تمامی ارتباطات روی آن لینک را کاهش دهد و باید به صورت ایده آل از آن اجتناب شود. بنابراین GCC قبل از اینکه از دست رفتن بسته ها رخ دهد سعی می کند بفهمد که لینک های شبکه و صف های ژرف در حال بزرگتر شدن هستند یا خیر. اگر در طول زمان تاخیر های صف بیشتر مشاده شد، استفاده پهنای باند را کاهش می دهد.\nبرای رسیدن به این هدف، GCC سعی می‌کند با اندازه‌گیری افزایش‌های کم رفت و برگت بسته افزایش عمق صف را استنباط کند. \u0026ldquo;زمان بین ورود\u0026rdquo; فریم ها، را ثبت می کندt(i) - t(i-1): تفاوت در زمان رسیدن دو گروه بسته (به طور کلی، فریم های ویدیویی متوالی) می باشد. این گروه از بسته ها اغلبا در فواصل زمانی معین (مثلاً هر 1/24 ثانیه برای یک ویدیوی 24 فریم بر ثانیه) حرکت می کند. در نتیجه، اندازه گیری زمان بین ورود به سادگی ثبت اختلاف زمانی بین شروع اولین گروه بسته (یعنی فریم) و اولین فریم از گروه بعدی است.\nدر نمودار زیر، میانگین افزایش تاخیر بین بسته‌ها +20 میلی‌ثانیه است که نشانگر واضحی از ازدحام شبکه است\nاگر زمان بین ورود در طول زمان افزایش یابد، نشانه ای از افزایش عمق صف در رابط های شبکه متصل شده فرض می شود و به عنوان ازدحام شبکه در نظر گرفته می شود. (توجه: GCC به اندازه کافی هوشمند است که این اندازه‌گیری‌ها را برای نوسانات اندازه بایت فریم کنترل کند.) GCC اندازه‌گیری‌های تاخیر خود را با استفاده از Kalman filter اصلاح می‌کند و اندازه‌گیری‌های زیادی از شبکه انجام می‌دهد که شامل زمان های رفت و برگشت (و تغییرات آن) قبل از علامت گذاری ازدحام است می شود. می‌توان فیلتر کالمن GCC را به‌عنوان جایگزینی رگرسیون خطی در نظر گرفت: کمک به پیش‌بینی‌های دقیق حتی زمانی که جیتر نویز را به اندازه‌گیری‌های زمان‌بندی اضافه می‌کند. پس از علامت گذاری ازدحام، GCC نرخ بیت موجود را کاهش می دهد. از طرف دیگر، تحت شرایط ثابت شبکه، می‌تواند به آرامی تخمین‌های پهنای باند خود را افزایش دهد تا مقادیر بار بالاتر را آزمایش کند.\nTMMBR، TMMBN، و REMB # برای TMMBR/TMMBN و REMB، طرف دریافت کننده ابتدا پهنای باند ورودی موجود را تخمین می زند (با استفاده از پروتکلی مانند GCC)، و سپس این تخمین های پهنای باند را به فرستنده های راه دور ارسال می کند. آنها نیازی به مبادله جزئیات در مورد از دست دادن بسته یا سایر خصوصیات در مورد ازدحام شبکه ندارند زیرا عملکرد در سمت گیرنده به آنها اجازه می دهد تا زمان بین ورود و از دست دادن بسته را به طور مستقیم اندازه گیری کنند. در عوض، TMMBR، TMMBN، و REMB فقط پهنای باند را که خودشان تخمین می زنند، مبادله می کنند:\nدرخواست نرخ بیت حداکثر جریان رسانه موقت - یک مانتیس/نمای نرخ بیت درخواستی برای یک SSRC منفرد. اعلان نرخ بیت حداکثر جریان رسانه موقت - پیامی برای اطلاع از دریافت TMMBR. حداکثر نرخ بیت تخمینی گیرنده - یک مانتیس/نمای نرخ بیت درخواستی برای کل جلسه. TMMBR و TMMBN ابتدا آمدند و در RFC 5104 تعریف شده‌اند. REMB بعداً آمد، پیش‌نویسی درdraft-alvestrand-rmcat-remb فرستاده شد، اما هرگز استاندارد نشد.\nیک نمونه جلسه که از REMB استفاده می کند و ممکن است مانند زیر عمل کند:\nاین روش روی کاغذ عالی عمل می کند. فرستنده تخمینی را از گیرنده دریافت می کند، نرخ بیت کدینگ را روی مقدار دریافتی تنظیم می کند. تادا! ما با شرایط شبکه سازگار شده ایم.\nبا این حال در عمل، رویکرد REMB دارای اشکالات متعددی است.\nناکارآمدی کدینگ اولین مورد است. هنگامی که یک بیت ریت برای کدینگ تنظیم می کنید، لزوماً نرخ بیت دقیقی را که شما درخواست کرده اید، تولید نمی کند. بسته به تنظیمات کدینگ و فریمی که کدگذاری می‌شود، ممکن است کدینگ بیت‌های بیشتر یا کمتری تولید کند.\nبه عنوان مثال، استفاده از کدینگ x264 با tune= zeolatency می تواند به طور قابل توجهی از نرخ بیت هدف مشخص شده منحرف شود. در اینجا یک سناریوی احتمالی وجود دارد:\nفرض کنید با تنظیم بیت ریت روی 1000 کیلوبیت در ثانیه شروع می کنیم. انکودر تنها 700 کیلوبیت در ثانیه خروجی می دهد، زیرا ویژگی های فرکانس بالا برای کدینگ کافی وجود ندارد. (\u0026ldquo;نگاه به افق(از روی بیکاری)\u0026rdquo;.) بیایید همچنین تصور کنیم که گیرنده ویدیوی 700 کیلوبیت بر ثانیه را با اتلاف صفر دریافت کند. سپس قانون REMB 1 را اعمال می کند تا نرخ بیت ورودی را 8٪ افزایش دهد. گیرنده یک بسته REMB با پیشنهاد 756 کیلوبیت بر ثانیه (700 کیلوبیت در ثانیه * 1.08) برای فرستنده ارسال می کند. فرستنده نرخ بیت کدینگ را روی 756 کیلوبیت بر ثانیه تنظیم می کند. کدینگ نرخ بیت حتی کمتری را خروجی می دهد. این روند به تکرار خود ادامه می دهد و میزان بیت را به حداقل مطلق کاهش می دهد. می‌توانید ببینید که چگونه این باعث تنظیم پارامترهای کدینگ سنگین می‌شود و کاربران را با ویدیوهای غیرقابل تماشا حتی در یک اتصال عالی شگفت‌زده می‌کند.\nکنترل ازدحام گسترده ارتباطات # Transport Wide Congestion Control آخرین پیشرفت در ارتباط وضعیت شبکه RTCP است که در draft-holmer-rmcat-transport-wide-cc-extensions-01 تعریف شده است. ، اما هرگز استاندارد نشده است.\nTWCC از یک اصل ساده استفاده می کند:\nبا استفاده از REMB، گیرنده طرف فرستنده نرخ بیت دانلود موجود مطلع می کند. از اندازه‌گیری‌های دقیقی در مورد از دست دادن بسته استنباط‌شده استفاده می‌کند و تنها داده‌هایی را که در مورد رسیدن بین بسته‌ها دارد، استفاده می‌کند\nTWCC تقریباً یک رویکرد ترکیبی بین پروتکل‌های نسل SR/RR و REMB است. تخمین پهنای باند را به سمت فرستنده بازمی گرداند (مشابه SR/RR)، اما تکنیک تخمین پهنای باند آن بیشتر شبیه به نسل REMB است.\nبا TWCC، گیرنده به فرستنده اجازه می دهد زمان رسیدن هر بسته را بداند. این اطلاعات کافی برای فرستنده برای اندازه‌گیری تغییرات تأخیر رسیدن بین بسته‌ها، و همچنین شناسایی بسته‌هایی است که رها شده‌اند یا خیلی دیر رسیده‌اند تا به فید صوتی/تصویری کمک کنند. با رد و بدل شدن این داده ها به طور مکرر، فرستنده می تواند به سرعت با شرایط متغیر شبکه سازگار شود و پهنای باند خروجی خود را با استفاده از الگوریتمی مانند GCC تغییر دهد.\nفرستنده بسته‌های ارسالی، شماره‌های ترتیبی، اندازه‌ها و مُهرهای زمانی آنها را پیگیری می‌کند. هنگامی که فرستنده پیام های RTCP را از گیرنده دریافت می کند، تاخیرهای ارسال بین بسته ها را با تاخیرهای دریافت مقایسه می کند. اگر تأخیر دریافت افزایش یابد، سیگنال ازدحام شبکه می دهد و فرستنده باید اقدامات اصلاحی را انجام دهد.\nبا ارائه داده های خام به فرستنده، TWCC نمای عالی از شرایط شبکه را در زمان واقعی ارائه می دهد:\nاز رفتار از دست دادن بسته تقریباً فوری تا بسته های از دست رفته ی تکی ارسال بیت ریت دقیق نرخ بیت دریافت دقیق اندازه گیری Jitter تفاوت بین تاخیر ارسال و دریافت بسته شرح نحوه تحمل شبکه، انفجاری یا ثابت یکی از مهم ترین کمک های TWCC انعطاف پذیری است که برای توسعه دهندگان WebRTC فراهم می کند. با ادغام الگوریتم کنترل ازدحام در سمت ارسال، کد کلاینت ساده ای را امکان پذیر می کند که می تواند به طور گسترده مورد استفاده قرار گیرد و در طول زمان به حداقل پیشرفت هایی نیز نیاز دارد. الگوریتم‌های پیچیده کنترل تراکم را می‌توان با سرعت بیشتری روی سخت‌افزاری که مستقیماً کنترل می‌کنند، پیاده‌سازی کرد (مانند SFU، که در بخش 8 مورد بحث قرار گرفت). در مورد مرورگرها و دستگاه های تلفن همراه، این بدان معناست که آن کلاینت ها می توانند بدون نیاز به استانداردسازی یا به روز رسانی مرورگر (که ممکن است زمان زیادی طول بکشد تا به طور گسترده در دسترس باشند) از پیشرفت های الگوریتم بهره مند شوند.\nجایگزین های تخمین پهنای باند # بیشترین پیاده سازی \u0026ldquo;یک الگوریتم کنترل ازدحام Google برای ارتباطات بلادرنگ\u0026rdquo; است که در draft-alvestrand-rmcat-congestion تعریف شده است.\nچندین جایگزین برای GCC وجود دارد، به عنوان مثال NADA: یک طرح کنترل یکپارچه ازدحام برای رسانه های زمان واقعی و SCReAM - انطباق نرخ خودکار برای چند رسانه.\n"},{"id":6,"href":"/fa/docs/07-data-communication/","title":"ارتباط داده ای","section":"Docs","content":"TODO\n"},{"id":7,"href":"/fa/docs/08-applied-webrtc/","title":"اعمال کردن WebRTC","section":"Docs","content":"TODO\n"},{"id":8,"href":"/fa/docs/09-debugging/","title":"اشکال زدایی","section":"Docs","content":"TODO\n"},{"id":9,"href":"/fa/docs/11-faq/","title":"پرسش و پاسخ","section":"Docs","content":"TODO\n"},{"id":10,"href":"/fa/docs/12-glossary/","title":"واژه نامه","section":"Docs","content":"TODO\n"},{"id":11,"href":"/fa/docs/13-reference/","title":"Reference","section":"Docs","content":" Reference # WebRTC(W3C) # WebRTC 1.0: Real-Time Communication Between Browsers [26 January 2021] (Status: Recommendation) Web Real-Time Communications Working Group - Publications WebRTC(RFC) # RFC8825: Overview: Real-Time Protocols for Browser-Based Applications H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8826: Security Considerations for WebRTC E. Rescorla [January 2021] (Status: PROPOSED STANDARD) RFC8836: Congestion Control Requirements for Interactive Real-Time Media R. Jesup, Z. Sarker [January 2021] (Status: INFORMATIONAL) RFC8854: WebRTC Forward Error Correction Requirements J. Uberti [January 2021] (Status: PROPOSED STANDARD) DTLS # RFC6347: Datagram Transport Layer Security Version 1.2 E. Rescorla, N. Modadugu [January 2012] (Obsoletes RFC4347) (Obsoleted-By RFC9147) (Updated-By RFC7507, RFC7905, RFC8996, RFC9146) (Status: PROPOSED STANDARD) RFC9147: The Datagram Transport Layer Security (DTLS) Protocol Version 1.3 E. Rescorla, H. Tschofenig, N. Modadugu [April 2022] (Obsoletes RFC6347) (Status: PROPOSED STANDARD) (See also: OpenSSL DTLS 1.3 status) DataChannel # RFC8831: WebRTC Data Channels R. Jesup, S. Loreto, M. Tüxen [January 2021] (Status: PROPOSED STANDARD) RFC8832: WebRTC Data Channel Establishment Protocol R. Jesup, S. Loreto, M. Tüxen [January 2021] (Status: PROPOSED STANDARD) RFC8864: Negotiation Data Channels Using the Session Description Protocol (SDP) K. Drage, M. Makaraju, R. Ejzak, J. Marcon, R. Even [January 2021] (Status: PROPOSED STANDARD) MediaTransport # RFC8834: Media Transport and Use of RTP in WebRTC C. Perkins, M. Westerlund, J. Ott [January 2021] (Status: PROPOSED STANDARD) RFC8837: Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS P. Jones, S. Dhesikan, C. Jennings, D. Druta [January 2021] (Status: PROPOSED STANDARD) SCTP # RFC3758: Stream Control Transmission Protocol (SCTP) Partial Reliability Extension R. Stewart, M. Ramalho, Q. Xie, M. Tuexen, P. Conrad [May 2004] (Status: PROPOSED STANDARD) RFC5061: Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration R. Stewart, Q. Xie, M. Tuexen, S. Maruyama, M. Kozuka [September 2007] (Status: PROPOSED STANDARD) RFC5827: Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP) M. Allman, K. Avrachenkov, U. Ayesta, J. Blanton, P. Hurtig [May 2010] (Status: EXPERIMENTAL) RFC6083: Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP) M. Tuexen, R. Seggelmann, E. Rescorla [January 2011] (Updated-By RFC8996) (Status: PROPOSED STANDARD) RFC6525: Stream Control Transmission Protocol (SCTP) Stream Reconfiguration R. Stewart, M. Tuexen, P. Lei [February 2012] (Status: PROPOSED STANDARD) RFC6951: UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication M. Tuexen, R. Stewart [May 2013] (Updated-By RFC8899) (Status: PROPOSED STANDARD) RFC7765: TCP and Stream Control Transmission Protocol (SCTP) RTO Restart P. Hurtig, A. Brunstrom, A. Petlund, M. Welzl [February 2016] (Status: EXPERIMENTAL) RFC8260: Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol R. Stewart, M. Tuexen, S. Loreto, R. Seggelmann [November 2017] (Status: PROPOSED STANDARD) RFC8261: Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets M. Tuexen, R. Stewart, R. Jesup, S. Loreto [November 2017] (Updated-By RFC8899, RFC8996) (Status: PROPOSED STANDARD) RFC8841: Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport C. Holmberg, R. Shpount, S. Loreto, G. Camarillo [January 2021] (Status: PROPOSED STANDARD) RFC8899: Packetization Layer Path MTU Discovery for Datagram Transports G. Fairhurst, T. Jones, M. Tüxen, I. Rüngeler, T. Völker [September 2020] (Updates RFC4821, RFC4960, RFC6951, RFC8085, RFC8261) (Status: PROPOSED STANDARD) RFC9260: Stream Control Transmission Protocol R. Stewart, M. Tüxen, K. Nielsen [June 2022] (Obsoletes RFC4460, RFC4960, RFC6096, RFC7053, RFC8540) (Status: PROPOSED STANDARD) SDP # RFC8829: JavaScript Session Establishment Protocol (JSEP) J. Uberti, C. Jennings, E. Rescorla [January 2021] (Status: PROPOSED STANDARD) RFC8830: WebRTC MediaStream Identification in the Session Description Protocol H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8839: Session Description Protocol (SDP) Offer/Answer Procedures for Interactive Connectivity Establishment (ICE) M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [January 2021] (Obsoletes RFC5245, RFC6336) (Status: PROPOSED STANDARD) RFC8841: Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport C. Holmberg, R. Shpount, S. Loreto, G. Camarillo [January 2021] (Status: PROPOSED STANDARD) RFC8843: Negotiating Media Multiplexing Using the Session Description Protocol (SDP) C. Holmberg, H. Alvestrand, C. Jennings [January 2021] (Obsoleted-By RFC9143) (Updates RFC3264, RFC5888, RFC7941) (Status: PROPOSED STANDARD) RFC8844: Unknown Key-Share Attacks on Uses of TLS with the Session Description Protocol (SDP) M. Thomson, E. Rescorla [January 2021] (Updates RFC8122) (Status: PROPOSED STANDARD) RFC8851: RTP Payload Format Restrictions A.B. Roach [January 2021] (Updates RFC4855) (Status: PROPOSED STANDARD) RFC8852: RTP Stream Identifier Source Description (SDES) A.B. Roach, S. Nandakumar, P. Thatcher [January 2021] (Status: PROPOSED STANDARD) RFC8853: Using Simulcast in Session Description Protocol (SDP) and RTP Sessions B. Burman, M. Westerlund, S. Nandakumar, M. Zanaty [January 2021] (Status: PROPOSED STANDARD) RFC8866: SDP: Session Description Protocol A. Begen, P. Kyzivat, C. Perkins, M. Handley [January 2021] (Obsoletes RFC4566) (Status: PROPOSED STANDARD) RTP # RFC3550: RTP: A Transport Protocol for Real-Time Applications H. Schulzrinne, S. Casner, R. Frederick, V. Jacobson [July 2003] (Obsoletes RFC1889) (Updated-By RFC5506, RFC5761, RFC6051, RFC6222, RFC7022, RFC7160, RFC7164, RFC8083, RFC8108, RFC8860) (Also STD0064) (Status: INTERNET STANDARD) RFC3611: RTP Control Protocol Extended Reports (RTCP XR) T. Friedman, R. Caceres, A. Clark [November 2003] (Status: PROPOSED STANDARD) RFC3711: The Secure Real-time Transport Protocol (SRTP) M. Baugher, D. McGrew, M. Naslund, E. Carrara, K. Norrman [March 2004] (Updated-By RFC5506, RFC6904) (Status: PROPOSED STANDARD) RFC4585: Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF) J. Ott, S. Wenger, N. Sato, C. Burmeister, J. Rey [July 2006] (Updated-By RFC5506, RFC8108) (Status: PROPOSED STANDARD) RFC5104: Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF) S. Wenger, U. Chandra, M. Westerlund, B. Burman [February 2008] (Updated-By RFC7728, RFC8082) (Status: PROPOSED STANDARD) RFC5764: Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP) D. McGrew, E. Rescorla [May 2010] (Updated-By RFC7983) (Status: PROPOSED STANDARD) RFC6904: Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP) J. Lennox [April 2013] (Updates RFC3711) (Status: PROPOSED STANDARD) RFC7741: RTP Payload Format for VP8 Video P. Westin, H. Lundin, M. Glover, J. Uberti, F. Galligan [March 2016] (Status: PROPOSED STANDARD) RFC8285: A General Mechanism for RTP Header Extensions D. Singer, H. Desineni, R. Even [October 2017] (Obsoletes RFC5285) (Status: PROPOSED STANDARD) RFC8852: RTP Stream Identifier Source Description (SDES) A.B. Roach, S. Nandakumar, P. Thatcher [January 2021] (Status: PROPOSED STANDARD) RFC8858: Indicating Exclusive Support of RTP and RTP Control Protocol (RTCP) Multiplexing Using the Session Description Protocol (SDP) C. Holmberg [January 2021] (Updates RFC5761) (Status: PROPOSED STANDARD) RFC8860: Sending Multiple Types of Media in a Single RTP Session M. Westerlund, C. Perkins, J. Lennox [January 2021] (Updates RFC3550, RFC3551) (Status: PROPOSED STANDARD) RFC8867: Test Cases for Evaluating Congestion Control for Interactive Real-Time Media Z. Sarker, V. Singh, X. Zhu, M. Ramalho [January 2021] (Status: INFORMATIONAL) RFC8868: Evaluating Congestion Control for Interactive Real-Time Media V. Singh, J. Ott, S. Holmer [January 2021] (Status: INFORMATIONAL) RFC8869: Evaluation Test Cases for Interactive Real-Time Media over Wireless Networks Z. Sarker, X. Zhu, J. Fu [January 2021] (Status: INFORMATIONAL) RFC8872: Guidelines for Using the Multiplexing Features of RTP to Support Multiple Media Streams M. Westerlund, B. Burman, C. Perkins, H. Alvestrand, R. Even [January 2021] (Status: INFORMATIONAL) RFC8888: RTP Control Protocol (RTCP) Feedback for Congestion Control Z. Sarker, C. Perkins, V. Singh, M. Ramalho [January 2021] (Status: PROPOSED STANDARD) ICE, TURN and STUN # RFC5780: NAT Behavior Discovery Using Session Traversal Utilities for NAT (STUN) D. MacDonald, B. Lowekamp [May 2010] (Updated-By RFC8553) (Status: EXPERIMENTAL) RFC8445: Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal A. Keranen, C. Holmberg, J. Rosenberg [July 2018] (Obsoletes RFC5245) (Updated-By RFC8863) (Status: PROPOSED STANDARD) RFC8489: Session Traversal Utilities for NAT (STUN) M. Petit-Huguenin, G. Salgueiro, J. Rosenberg, D. Wing, R. Mahy, P. Matthews [February 2020] (Obsoletes RFC5389) (Status: PROPOSED STANDARD) RFC8656: Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN) T. Reddy, A. Johnston, P. Matthews, J. Rosenberg [February 2020] (Obsoletes RFC5766, RFC6156) (Status: PROPOSED STANDARD) RFC8835: Transports for WebRTC H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8838: Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol E. Ivov, J. Uberti, P. Saint-Andre [January 2021] (Updated-By RFC8863) (Status: PROPOSED STANDARD) RFC8839: Session Description Protocol (SDP) Offer/Answer Procedures for Interactive Connectivity Establishment (ICE) M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [January 2021] (Obsoletes RFC5245, RFC6336) (Status: PROPOSED STANDARD) RFC8863: Interactive Connectivity Establishment Patiently Awaiting Connectivity (ICE PAC) C. Holmberg, J. Uberti [January 2021] (Updates RFC8445, RFC8838) (Status: PROPOSED STANDARD) "}]