<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Media Communication # Apa yang saya dapatkan dari komunikasi media WebRTC? # WebRTC memungkinkan Anda mengirim dan menerima jumlah stream audio dan video yang tidak terbatas. Anda dapat menambah dan menghapus stream ini kapan saja selama panggilan. Stream ini semuanya bisa independen, atau bisa digabungkan bersama! Anda dapat mengirim feed video desktop Anda, dan kemudian menyertakan audio dan video dari webcam Anda.
Protokol WebRTC adalah codec agnostic. Transpor yang mendasarinya mendukung semuanya, bahkan hal-hal yang belum ada!"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/06-media-communication/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Media Communication"><meta property="og:description" content="Media Communication # Apa yang saya dapatkan dari komunikasi media WebRTC? # WebRTC memungkinkan Anda mengirim dan menerima jumlah stream audio dan video yang tidak terbatas. Anda dapat menambah dan menghapus stream ini kapan saja selama panggilan. Stream ini semuanya bisa independen, atau bisa digabungkan bersama! Anda dapat mengirim feed video desktop Anda, dan kemudian menyertakan audio dan video dari webcam Anda.
Protokol WebRTC adalah codec agnostic. Transpor yang mendasarinya mendukung semuanya, bahkan hal-hal yang belum ada!"><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Media Communication | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/06-media-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/06-media-communication/ title=Mediakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/06-media-communication/ title=Медиа-коммуникация><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/06-media-communication/ title=媒体通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/06-media-communication/ title=メディア・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/06-media-communication/ title="ارتباط رسانه ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/06-media-communication/ title="Communication média"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/06-media-communication/ title="Comunicación de Medios"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/06-media-communication/ title="Medya İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/06-media-communication/ title="미디어 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/06-media-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/06-media-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/06-media-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/06-media-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/06-media-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/06-media-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/06-media-communication/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/06-media-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/>Connecting</a></li><li><a href=/id/docs/04-securing/>Securing</a></li><li><a href=/id/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/ class=active>Media Communication</a></li><li><a href=/id/docs/07-data-communication/>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Media Communication</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#apa-yang-saya-dapatkan-dari-komunikasi-media-webrtc>Apa yang saya dapatkan dari komunikasi media WebRTC?</a></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#latensi-vs-kualitas>Latensi vs Kualitas</a><ul><li><a href=#keterbatasan-dunia-nyata>Keterbatasan Dunia Nyata</a></li><li><a href=#video-itu-kompleks>Video itu Kompleks</a></li></ul></li><li><a href=#video-101>Video 101</a><ul><li><a href=#kompresi-_lossy_-dan-_lossless_>Kompresi <em>Lossy</em> dan <em>Lossless</em></a></li><li><a href=#kompresi-_intra_-dan-_inter-frame_>Kompresi <em>Intra</em> dan <em>Inter frame</em></a></li><li><a href=#jenis-_inter-frame_>Jenis <em>Inter-frame</em></a></li><li><a href=#video-itu-rapuh>Video itu rapuh</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#format-paket>Format Paket</a></li><li><a href=#extensions>Extensions</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#format-paket-1>Format Paket</a></li><li><a href=#full-intra-frame-request-fir-dan-picture-loss-indication-pli>Full INTRA-frame Request (FIR) dan Picture Loss Indication (PLI)</a></li><li><a href=#negative-acknowledgment>Negative Acknowledgment</a></li><li><a href=#sender-dan-receiver-reports>Sender dan Receiver Reports</a></li></ul></li><li><a href=#bagaimana-rtprtcp-menyelesaikan-masalah-bersama-sama>Bagaimana RTP/RTCP menyelesaikan masalah bersama-sama</a><ul><li><a href=#forward-error-correction>Forward Error Correction</a></li><li><a href=#adaptive-bitrate-dan-bandwidth-estimation>Adaptive Bitrate dan Bandwidth Estimation</a></li></ul></li><li><a href=#mengidentifikasi-dan-mengomunikasikan-status-jaringan>Mengidentifikasi dan Mengomunikasikan Status Jaringan</a><ul><li><a href=#receiver-reports--sender-reports>Receiver Reports / Sender Reports</a></li><li><a href=#tmmbr-tmmbn-remb-dan-twcc-dipasangkan-dengan-gcc>TMMBR, TMMBN, REMB dan TWCC, dipasangkan dengan GCC</a></li></ul></li><li><a href=#alternatif-bandwidth-estimation>Alternatif Bandwidth Estimation</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=media-communication>Media Communication
<a class=anchor href=#media-communication>#</a></h1><h2 id=apa-yang-saya-dapatkan-dari-komunikasi-media-webrtc>Apa yang saya dapatkan dari komunikasi media WebRTC?
<a class=anchor href=#apa-yang-saya-dapatkan-dari-komunikasi-media-webrtc>#</a></h2><p>WebRTC memungkinkan Anda mengirim dan menerima jumlah <em>stream</em> audio dan video yang tidak terbatas. Anda dapat menambah dan menghapus <em>stream</em> ini kapan saja selama panggilan. <em>Stream</em> ini semuanya bisa independen, atau bisa digabungkan bersama! Anda dapat mengirim <em>feed</em> video desktop Anda, dan kemudian menyertakan audio dan video dari <em>webcam</em> Anda.</p><p>Protokol WebRTC adalah <em>codec agnostic</em>. Transpor yang mendasarinya mendukung semuanya, bahkan hal-hal yang belum ada! Namun, <em>Agent</em> WebRTC yang berkomunikasi dengan Anda mungkin tidak memiliki alat yang diperlukan untuk menerimanya.</p><p>WebRTC juga dirancang untuk menangani kondisi jaringan yang dinamis. Selama panggilan <em>bandwidth</em> Anda mungkin meningkat, atau menurun. Mungkin Anda tiba-tiba mengalami banyak <em>packet loss</em>. Protokol ini dirancang untuk menangani semua ini. WebRTC merespons kondisi jaringan dan mencoba memberi Anda pengalaman terbaik yang mungkin dengan sumber daya yang tersedia.</p><h2 id=bagaimana-cara-kerjanya>Bagaimana cara kerjanya?
<a class=anchor href=#bagaimana-cara-kerjanya>#</a></h2><p>WebRTC menggunakan dua protokol yang sudah ada sebelumnya RTP dan RTCP, keduanya didefinisikan dalam <a href=https://tools.ietf.org/html/rfc1889>RFC 1889</a>.</p><p>RTP (<em>Real-time Transport Protocol</em>) adalah protokol yang membawa media. Ini dirancang untuk memungkinkan pengiriman video <em>real-time</em>. Ini tidak menetapkan aturan apa pun mengenai latensi atau keandalan, tetapi memberi Anda alat untuk mengimplementasikannya. RTP memberi Anda <em>stream</em>, sehingga Anda dapat menjalankan beberapa <em>feed</em> media melalui satu koneksi. Ini juga memberi Anda informasi <em>timing</em> dan pengurutan yang Anda butuhkan untuk memberi makan <em>pipeline</em> media.</p><p>RTCP (<em>RTP Control Protocol</em>) adalah protokol yang mengomunikasikan metadata tentang panggilan. Formatnya sangat fleksibel dan memungkinkan Anda menambahkan metadata apa pun yang Anda inginkan. Ini digunakan untuk mengomunikasikan statistik tentang panggilan. Ini juga digunakan untuk menangani <em>packet loss</em> dan untuk mengimplementasikan <em>congestion control</em>. Ini memberi Anda komunikasi dua arah yang diperlukan untuk merespons kondisi jaringan yang berubah.</p><h2 id=latensi-vs-kualitas>Latensi vs Kualitas
<a class=anchor href=#latensi-vs-kualitas>#</a></h2><p>Media <em>real-time</em> adalah tentang membuat <em>trade-off</em> antara latensi dan kualitas. Semakin banyak latensi yang bersedia Anda toleransi, semakin tinggi kualitas video yang dapat Anda harapkan.</p><h3 id=keterbatasan-dunia-nyata>Keterbatasan Dunia Nyata
<a class=anchor href=#keterbatasan-dunia-nyata>#</a></h3><p>Batasan ini semua disebabkan oleh keterbatasan dunia nyata. Ini semua adalah karakteristik jaringan Anda yang perlu Anda atasi.</p><h3 id=video-itu-kompleks>Video itu Kompleks
<a class=anchor href=#video-itu-kompleks>#</a></h3><p>Mengangkut video tidaklah mudah. Untuk menyimpan 30 menit video 720 8-bit yang tidak dikompresi, Anda memerlukan sekitar 110 GB. Dengan angka-angka itu, panggilan konferensi 4 orang tidak akan terjadi. Kita memerlukan cara untuk membuatnya lebih kecil, dan jawabannya adalah kompresi video. Itu tidak datang tanpa kekurangan.</p><h2 id=video-101>Video 101
<a class=anchor href=#video-101>#</a></h2><p>Kami tidak akan membahas kompresi video secara mendalam, tetapi cukup untuk memahami mengapa RTP dirancang seperti itu. Kompresi video mengenkode video ke dalam format baru yang memerlukan lebih sedikit bit untuk merepresentasikan video yang sama.</p><h3 id=kompresi-_lossy_-dan-_lossless_>Kompresi <em>Lossy</em> dan <em>Lossless</em>
<a class=anchor href=#kompresi-_lossy_-dan-_lossless_>#</a></h3><p>Anda dapat mengenkode video menjadi <em>lossless</em> (tidak ada informasi yang hilang) atau <em>lossy</em> (informasi mungkin hilang). Karena pengkodean <em>lossless</em> memerlukan lebih banyak data yang dikirim ke <em>peer</em>, membuat <em>stream</em> latensi lebih tinggi dan lebih banyak paket yang dijatuhkan, RTP biasanya menggunakan kompresi <em>lossy</em> meskipun kualitas videonya tidak akan sebaik itu.</p><h3 id=kompresi-_intra_-dan-_inter-frame_>Kompresi <em>Intra</em> dan <em>Inter frame</em>
<a class=anchor href=#kompresi-_intra_-dan-_inter-frame_>#</a></h3><p>Kompresi video hadir dalam dua jenis. Yang pertama adalah <em>intra-frame</em>. Kompresi <em>intra-frame</em> mengurangi bit yang digunakan untuk mendeskripsikan satu <em>frame</em> video. Teknik yang sama digunakan untuk mengompresi gambar diam, seperti metode kompresi JPEG.</p><p>Jenis kedua adalah kompresi <em>inter-frame</em>. Karena video terdiri dari banyak gambar, kita mencari cara untuk tidak mengirim informasi yang sama dua kali.</p><h3 id=jenis-_inter-frame_>Jenis <em>Inter-frame</em>
<a class=anchor href=#jenis-_inter-frame_>#</a></h3><p>Anda kemudian memiliki tiga jenis <em>frame</em>:</p><ul><li><strong>I-Frame</strong> - Gambar lengkap, dapat didekode tanpa apa pun.</li><li><strong>P-Frame</strong> - Gambar parsial, hanya berisi perubahan dari gambar sebelumnya.</li><li><strong>B-Frame</strong> - Gambar parsial, adalah modifikasi dari gambar sebelumnya dan masa depan.</li></ul><p>Berikut adalah visualisasi dari tiga jenis <em>frame</em>.</p><p><img src=../images/06-frame-types.png alt="Frame types" title="Frame types"></p><h3 id=video-itu-rapuh>Video itu rapuh
<a class=anchor href=#video-itu-rapuh>#</a></h3><p>Kompresi video sangat <em>stateful</em>, membuatnya sulit untuk ditransfer melalui internet. Apa yang terjadi jika Anda kehilangan bagian dari I-Frame? Bagaimana P-Frame tahu apa yang harus dimodifikasi? Seiring kompresi video menjadi lebih kompleks, ini menjadi masalah yang lebih besar. Untungnya RTP dan RTCP memiliki solusinya.</p><h2 id=rtp>RTP
<a class=anchor href=#rtp>#</a></h2><h3 id=format-paket>Format Paket
<a class=anchor href=#format-paket>#</a></h3><p>Setiap paket RTP memiliki struktur berikut:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v>Version (V)
<a class=anchor href=#version-v>#</a></h4><p><code>Version</code> selalu <code>2</code></p><h4 id=padding-p>Padding (P)
<a class=anchor href=#padding-p>#</a></h4><p><code>Padding</code> adalah <em>bool</em> yang mengontrol apakah <em>payload</em> memiliki <em>padding</em>.</p><p><em>Byte</em> terakhir dari <em>payload</em> berisi hitungan berapa banyak <em>byte padding</em> yang ditambahkan.</p><h4 id=extension-x>Extension (X)
<a class=anchor href=#extension-x>#</a></h4><p>Jika disetel, <em>header</em> RTP akan memiliki ekstensi. Ini dijelaskan lebih detail di bawah ini.</p><h4 id=csrc-count-cc>CSRC count (CC)
<a class=anchor href=#csrc-count-cc>#</a></h4><p>Jumlah pengidentifikasi <code>CSRC</code> yang mengikuti setelah <code>SSRC</code>, dan sebelum <em>payload</em>.</p><h4 id=marker-m>Marker (M)
<a class=anchor href=#marker-m>#</a></h4><p><em>Marker bit</em> tidak memiliki arti yang telah ditetapkan, dan dapat digunakan sesuai keinginan pengguna.</p><p>Dalam beberapa kasus, ini disetel ketika pengguna sedang berbicara. Ini juga biasanya digunakan untuk menandai <em>keyframe</em>.</p><h4 id=payload-type-pt>Payload Type (PT)
<a class=anchor href=#payload-type-pt>#</a></h4><p><code>Payload Type</code> adalah pengidentifikasi unik untuk <em>codec</em> apa yang dibawa oleh paket ini.</p><p>Untuk WebRTC, <code>Payload Type</code> adalah dinamis. VP8 dalam satu panggilan mungkin berbeda dari yang lain. <em>Offerer</em> dalam panggilan menentukan pemetaan <code>Payload Types</code> ke <em>codec</em> dalam <code>Session Description</code>.</p><h4 id=sequence-number>Sequence Number
<a class=anchor href=#sequence-number>#</a></h4><p><code>Sequence Number</code> digunakan untuk mengurutkan paket dalam <em>stream</em>. Setiap kali paket dikirim, <code>Sequence Number</code> ditambah satu.</p><p>RTP dirancang agar berguna melalui jaringan yang <em>lossy</em>. Ini memberi penerima cara untuk mendeteksi kapan paket telah hilang.</p><h4 id=timestamp>Timestamp
<a class=anchor href=#timestamp>#</a></h4><p>Momen pengambilan sampel untuk paket ini. Ini bukan jam global, tetapi berapa banyak waktu yang telah berlalu dalam <em>stream</em> media. Beberapa paket RTP dapat memiliki <em>timestamp</em> yang sama jika mereka misalnya semua bagian dari <em>frame</em> video yang sama.</p><h4 id=synchronization-source-ssrc>Synchronization Source (SSRC)
<a class=anchor href=#synchronization-source-ssrc>#</a></h4><p><code>SSRC</code> adalah pengidentifikasi unik untuk <em>stream</em> ini. Ini memungkinkan Anda menjalankan beberapa <em>stream</em> media melalui satu <em>stream</em> RTP.</p><h4 id=contributing-source-csrc>Contributing Source (CSRC)
<a class=anchor href=#contributing-source-csrc>#</a></h4><p>Daftar yang mengomunikasikan <code>SSRC</code> mana yang berkontribusi pada paket ini.</p><p>Ini biasanya digunakan untuk indikator berbicara. Katakanlah <em>server side</em> Anda menggabungkan beberapa <em>feed</em> audio menjadi satu <em>stream</em> RTP. Anda kemudian dapat menggunakan bidang ini untuk mengatakan &ldquo;Input <em>stream</em> A dan C sedang berbicara pada saat ini&rdquo;.</p><h4 id=payload>Payload
<a class=anchor href=#payload>#</a></h4><p>Data <em>payload</em> yang sebenarnya. Mungkin diakhiri dengan hitungan berapa banyak <em>byte padding</em> yang ditambahkan, jika <em>flag padding</em> disetel.</p><h3 id=extensions>Extensions
<a class=anchor href=#extensions>#</a></h3><h2 id=rtcp>RTCP
<a class=anchor href=#rtcp>#</a></h2><h3 id=format-paket-1>Format Paket
<a class=anchor href=#format-paket-1>#</a></h3><p>Setiap paket RTCP memiliki struktur berikut:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |       PT      |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v-1>Version (V)
<a class=anchor href=#version-v-1>#</a></h4><p><code>Version</code> selalu <code>2</code>.</p><h4 id=padding-p-1>Padding (P)
<a class=anchor href=#padding-p-1>#</a></h4><p><code>Padding</code> adalah <em>bool</em> yang mengontrol apakah <em>payload</em> memiliki <em>padding</em>.</p><p><em>Byte</em> terakhir dari <em>payload</em> berisi hitungan berapa banyak <em>byte padding</em> yang ditambahkan.</p><h4 id=reception-report-count-rc>Reception Report Count (RC)
<a class=anchor href=#reception-report-count-rc>#</a></h4><p>Jumlah laporan dalam paket ini. Satu paket RTCP dapat berisi beberapa <em>event</em>.</p><h4 id=packet-type-pt>Packet Type (PT)
<a class=anchor href=#packet-type-pt>#</a></h4><p>Pengidentifikasi Unik untuk jenis paket RTCP apa ini. <em>Agent</em> WebRTC tidak perlu mendukung semua jenis ini, dan dukungan antar <em>Agent</em> dapat berbeda. Ini adalah yang mungkin sering Anda lihat:</p><ul><li><code>192</code> - Full INTRA-frame Request (<code>FIR</code>)</li><li><code>193</code> - Negative ACKnowledgements (<code>NACK</code>)</li><li><code>200</code> - Sender Report</li><li><code>201</code> - Receiver Report</li><li><code>205</code> - Generic RTP Feedback</li><li><code>206</code> - Payload Specific Feedback</li></ul><p>Signifikansi jenis paket ini akan dijelaskan lebih detail di bawah ini.</p><h3 id=full-intra-frame-request-fir-dan-picture-loss-indication-pli>Full INTRA-frame Request (FIR) dan Picture Loss Indication (PLI)
<a class=anchor href=#full-intra-frame-request-fir-dan-picture-loss-indication-pli>#</a></h3><p>Pesan <code>FIR</code> dan <code>PLI</code> melayani tujuan yang serupa. Pesan-pesan ini meminta <em>key frame</em> penuh dari pengirim.
<code>PLI</code> digunakan ketika <em>frame</em> parsial diberikan ke <em>decoder</em>, tetapi tidak dapat mendekodenya.
Ini bisa terjadi karena Anda memiliki banyak <em>packet loss</em>, atau mungkin <em>decoder</em> crash.</p><p>Menurut <a href=https://tools.ietf.org/html/rfc5104#section-4.3.1.2>RFC 5104</a>, <code>FIR</code> tidak boleh digunakan ketika paket atau <em>frame</em> hilang. Itu adalah tugas <code>PLI</code>. <code>FIR</code> meminta <em>key frame</em> untuk alasan selain <em>packet loss</em> - misalnya ketika anggota baru memasuki konferensi video. Mereka memerlukan <em>key frame</em> penuh untuk mulai mendekode <em>stream</em> video, <em>decoder</em> akan membuang <em>frame</em> sampai <em>key frame</em> tiba.</p><p>Ini adalah ide yang baik bagi penerima untuk meminta <em>key frame</em> penuh segera setelah terhubung, ini meminimalkan penundaan antara koneksi, dan gambar yang muncul di layar pengguna.</p><p>Paket <code>PLI</code> adalah bagian dari pesan <em>Payload Specific Feedback</em>.</p><p>Dalam praktiknya, perangkat lunak yang dapat menangani paket <code>PLI</code> dan <code>FIR</code> akan bertindak dengan cara yang sama dalam kedua kasus. Ini akan mengirim sinyal ke <em>encoder</em> untuk menghasilkan <em>key frame</em> penuh yang baru.</p><h3 id=negative-acknowledgment>Negative Acknowledgment
<a class=anchor href=#negative-acknowledgment>#</a></h3><p><code>NACK</code> meminta pengirim mengirim ulang satu paket RTP. Ini biasanya disebabkan oleh paket RTP yang hilang, tetapi juga bisa terjadi karena terlambat.</p><p><code>NACK</code> jauh lebih efisien <em>bandwidth</em> daripada meminta seluruh <em>frame</em> dikirim lagi. Karena RTP memecah paket menjadi potongan yang sangat kecil, Anda benar-benar hanya meminta satu bagian kecil yang hilang. Penerima membuat pesan RTCP dengan SSRC dan <em>Sequence Number</em>. Jika pengirim tidak memiliki paket RTP ini tersedia untuk dikirim ulang, ia hanya mengabaikan pesan tersebut.</p><h3 id=sender-dan-receiver-reports>Sender dan Receiver Reports
<a class=anchor href=#sender-dan-receiver-reports>#</a></h3><p>Laporan ini digunakan untuk mengirim statistik antar <em>agent</em>. Ini mengomunikasikan jumlah paket yang benar-benar diterima dan <em>jitter</em>.</p><p>Laporan dapat digunakan untuk diagnostik dan <em>congestion control</em>.</p><h2 id=bagaimana-rtprtcp-menyelesaikan-masalah-bersama-sama>Bagaimana RTP/RTCP menyelesaikan masalah bersama-sama
<a class=anchor href=#bagaimana-rtprtcp-menyelesaikan-masalah-bersama-sama>#</a></h2><p>RTP dan RTCP kemudian bekerja sama untuk menyelesaikan semua masalah yang disebabkan oleh jaringan. Teknik-teknik ini masih terus berubah!</p><h3 id=forward-error-correction>Forward Error Correction
<a class=anchor href=#forward-error-correction>#</a></h3><p>Juga dikenal sebagai FEC. Metode lain untuk menangani <em>packet loss</em>. FEC adalah ketika Anda mengirim data yang sama beberapa kali, tanpa diminta. Ini dilakukan pada level RTP, atau bahkan lebih rendah dengan <em>codec</em>.</p><p>Jika <em>packet loss</em> untuk panggilan stabil maka FEC adalah solusi latensi yang jauh lebih rendah daripada NACK. <em>Round trip time</em> untuk meminta, dan kemudian mengirim ulang paket yang hilang bisa signifikan untuk NACK.</p><h3 id=adaptive-bitrate-dan-bandwidth-estimation>Adaptive Bitrate dan Bandwidth Estimation
<a class=anchor href=#adaptive-bitrate-dan-bandwidth-estimation>#</a></h3><p>Seperti yang dibahas dalam bab <a href=../05-real-time-networking/>Real-time networking</a>, jaringan tidak dapat diprediksi dan tidak dapat diandalkan. Ketersediaan <em>bandwidth</em> dapat berubah beberapa kali sepanjang sesi.
Tidak jarang melihat <em>bandwidth</em> yang tersedia berubah secara dramatis (beberapa kali lipat) dalam satu detik.</p><p>Ide utamanya adalah menyesuaikan <em>bitrate</em> pengkodean berdasarkan <em>bandwidth</em> jaringan yang tersedia yang diprediksi, saat ini, dan masa depan.
Ini memastikan bahwa sinyal video dan audio dengan kualitas terbaik yang mungkin ditransmisikan, dan koneksi tidak terputus karena kemacetan jaringan.
Heuristik yang memodelkan perilaku jaringan dan mencoba memprediksinya dikenal sebagai <em>Bandwidth estimation</em>.</p><p>Ada banyak nuansa untuk ini, jadi mari kita jelajahi lebih detail.</p><h2 id=mengidentifikasi-dan-mengomunikasikan-status-jaringan>Mengidentifikasi dan Mengomunikasikan Status Jaringan
<a class=anchor href=#mengidentifikasi-dan-mengomunikasikan-status-jaringan>#</a></h2><p>RTP/RTCP berjalan di atas semua jenis jaringan yang berbeda, dan sebagai hasilnya, adalah umum untuk beberapa
komunikasi dijatuhkan dalam perjalanan dari pengirim ke penerima. Dibangun di atas UDP,
tidak ada mekanisme bawaan untuk retransmisi paket, apalagi menangani <em>congestion control</em>.</p><p>Untuk memberikan pengalaman terbaik kepada pengguna, WebRTC harus memperkirakan kualitas tentang jalur jaringan, dan
beradaptasi dengan bagaimana kualitas tersebut berubah dari waktu ke waktu. Sifat kunci untuk dipantau meliputi: <em>bandwidth</em> yang tersedia (di setiap arah, karena mungkin tidak simetris), <em>round trip time</em>, dan <em>jitter</em> (fluktuasi
dalam <em>round trip time</em>). Ini perlu memperhitungkan <em>packet loss</em>, dan mengomunikasikan perubahan dalam properti ini seiring kondisi jaringan berkembang.</p><p>Ada dua tujuan utama untuk protokol ini:</p><ol><li>Memperkirakan <em>bandwidth</em> yang tersedia (di setiap arah) yang didukung oleh jaringan.</li><li>Mengomunikasikan karakteristik jaringan antara pengirim dan penerima.</li></ol><p>RTP/RTCP memiliki tiga pendekatan berbeda untuk mengatasi masalah ini. Semuanya memiliki pro dan kontra,
dan umumnya setiap generasi telah meningkat dari pendahulunya. Implementasi mana yang Anda gunakan akan
bergantung terutama pada <em>stack</em> perangkat lunak yang tersedia untuk klien Anda dan <em>library</em> yang tersedia untuk
membangun aplikasi Anda.</p><h3 id=receiver-reports--sender-reports>Receiver Reports / Sender Reports
<a class=anchor href=#receiver-reports--sender-reports>#</a></h3><p>Implementasi pertama adalah pasangan <em>Receiver Reports</em> dan komplemennya, <em>Sender Reports</em>. Ini
pesan RTCP didefinisikan dalam <a href=https://tools.ietf.org/html/rfc3550#section-6.4>RFC 3550</a>, dan
bertanggung jawab untuk mengomunikasikan status jaringan antar <em>endpoint</em>. <em>Receiver Reports</em> berfokus pada
mengomunikasikan kualitas tentang jaringan (termasuk <em>packet loss</em>, <em>round-trip time</em>, dan <em>jitter</em>), dan
berpasangan dengan algoritma lain yang kemudian bertanggung jawab untuk memperkirakan <em>bandwidth</em> yang tersedia berdasarkan
laporan ini.</p><p><em>Sender</em> dan <em>Receiver report</em> (SR dan RR) bersama-sama melukiskan gambaran kualitas jaringan. Mereka
dikirim sesuai jadwal untuk setiap SSRC, dan mereka adalah input yang digunakan saat memperkirakan <em>bandwidth</em> yang tersedia. Perkiraan tersebut dibuat oleh pengirim setelah menerima data RR, yang berisi
bidang-bidang berikut:</p><ul><li><strong>Fraction Lost</strong> - Berapa persentase paket yang hilang sejak <em>Receiver Report</em> terakhir.</li><li><strong>Cumulative Number of Packets Lost</strong> - Berapa banyak paket yang hilang selama seluruh panggilan.</li><li><strong>Extended Highest Sequence Number Received</strong> - Apa <em>Sequence Number</em> terakhir yang diterima, dan
berapa kali telah berputar.</li><li><strong>Interarrival Jitter</strong> - <em>Jitter</em> bergulir untuk seluruh panggilan.</li><li><strong>Last Sender Report Timestamp</strong> - Waktu terakhir yang diketahui pada pengirim, digunakan untuk perhitungan <em>round-trip time</em>.</li></ul><p>SR dan RR bekerja bersama untuk menghitung <em>round-trip time</em>.</p><p>Pengirim menyertakan waktu lokalnya, <code>sendertime1</code> dalam SR. Ketika penerima mendapat paket SR, ia
mengirim kembali RR. Di antara hal-hal lain, RR menyertakan <code>sendertime1</code> yang baru saja diterima dari pengirim.
Akan ada penundaan antara menerima SR dan mengirim RR. Karena itu, RR juga
menyertakan waktu &ldquo;delay since last sender report&rdquo; - <code>DLSR</code>. <code>DLSR</code> digunakan untuk menyesuaikan
perkiraan <em>round-trip time</em> nanti dalam proses. Setelah pengirim menerima RR, ia mengurangi
<code>sendertime1</code> dan <code>DLSR</code> dari waktu saat ini <code>sendertime2</code>. Delta waktu ini disebut <em>round-trip
propagation delay</em> atau <em>round-trip time</em>.</p><p><code>rtt = sendertime2 - sendertime1 - DLSR</code></p><p><em>Round-trip time</em> dalam bahasa Inggris sederhana:</p><ul><li>Saya mengirim Anda pesan dengan pembacaan jam saya saat ini, katakanlah jam 4:20 sore, 42 detik dan 420 milidetik.</li><li>Anda mengirim saya <em>timestamp</em> yang sama ini kembali.</li><li>Anda juga menyertakan waktu yang berlalu dari membaca pesan saya hingga mengirim pesan kembali, katakanlah 5 milidetik.</li><li>Setelah saya menerima waktu kembali, saya melihat jam lagi.</li><li>Sekarang jam saya mengatakan jam 4:20 sore, 42 detik 690 milidetik.</li><li>Itu berarti dibutuhkan 265 milidetik (690 - 420 - 5) untuk mencapai Anda dan kembali ke saya.</li><li>Oleh karena itu, <em>round-trip time</em> adalah 265 milidetik.</li></ul><p><img src=../images/06-rtt.png alt="Round-trip time" title="Round-trip time"></p><h3 id=tmmbr-tmmbn-remb-dan-twcc-dipasangkan-dengan-gcc>TMMBR, TMMBN, REMB dan TWCC, dipasangkan dengan GCC
<a class=anchor href=#tmmbr-tmmbn-remb-dan-twcc-dipasangkan-dengan-gcc>#</a></h3><h4 id=google-congestion-control-gcc>Google Congestion Control (GCC)
<a class=anchor href=#google-congestion-control-gcc>#</a></h4><p>Algoritma <em>Google Congestion Control</em> (GCC) (dijelaskan dalam
<a href=https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>draft-ietf-rmcat-gcc-02</a>) mengatasi
tantangan estimasi <em>bandwidth</em>. Ini berpasangan dengan berbagai protokol lain untuk memfasilitasi
persyaratan komunikasi terkait. Akibatnya, ini sangat cocok untuk berjalan baik di sisi
penerima (ketika dijalankan dengan TMMBR/TMMBN atau REMB) atau di sisi pengirim (ketika dijalankan dengan TWCC).</p><p>Untuk mencapai perkiraan untuk <em>bandwidth</em> yang tersedia, GCC berfokus pada <em>packet loss</em> dan fluktuasi dalam waktu
kedatangan <em>frame</em> sebagai dua metrik utamanya. Ini menjalankan metrik ini melalui dua <em>controller</em> yang terhubung:
<em>controller</em> berbasis kehilangan dan <em>controller</em> berbasis penundaan.</p><p>Komponen pertama GCC, <em>loss-based controller</em>, sederhana:</p><ul><li>Jika <em>packet loss</em> di atas 10%, perkiraan <em>bandwidth</em> dikurangi.</li><li>Jika <em>packet loss</em> antara 2-10%, perkiraan <em>bandwidth</em> tetap sama.</li><li>Jika <em>packet loss</em> di bawah 2%, perkiraan <em>bandwidth</em> ditingkatkan.</li></ul><p>Pengukuran <em>packet loss</em> dilakukan dengan sering. Tergantung pada protokol komunikasi berpasangan,
<em>packet loss</em> dapat dikomunikasikan secara eksplisit (seperti dengan TWCC) atau disimpulkan (seperti dengan TMMBR/TMMBN
dan REMB). Persentase ini dievaluasi melalui jendela waktu sekitar satu detik.</p><p><em>Delay-based controller</em> bekerja sama dengan <em>loss-based controller</em>, dan melihat variasi dalam
waktu kedatangan paket. <em>Delay-based controller</em> ini bertujuan untuk mengidentifikasi kapan tautan jaringan menjadi
semakin padat, dan dapat mengurangi perkiraan <em>bandwidth</em> bahkan sebelum <em>packet loss</em> terjadi.
Teorinya adalah bahwa antarmuka jaringan yang paling sibuk di sepanjang jalur akan terus mengantri paket
sampai antarmuka kehabisan kapasitas di dalam <em>buffer</em>-nya. Jika antarmuka itu terus menerima
lebih banyak lalu lintas daripada yang dapat dikirimnya, ia akan dipaksa untuk menjatuhkan semua paket yang tidak dapat masuk ke dalam
ruang <em>buffer</em>-nya. Jenis <em>packet loss</em> ini sangat mengganggu untuk komunikasi latensi rendah/<em>real-time</em>,
tetapi juga dapat menurunkan throughput untuk semua komunikasi melalui tautan itu dan idealnya
harus dihindari. Dengan demikian, GCC mencoba mencari tahu apakah tautan jaringan menumbuhkan kedalaman antrian yang semakin besar dan lebih besar <em>sebelum</em> <em>packet loss</em> benar-benar terjadi. Ini akan mengurangi penggunaan <em>bandwidth</em> jika mengamati
peningkatan penundaan antrian dari waktu ke waktu.</p><p>Untuk mencapai ini, GCC mencoba menyimpulkan peningkatan kedalaman antrian dengan mengukur peningkatan halus dalam <em>round
trip time</em>. Ini mencatat &ldquo;inter-arrival time&rdquo; <em>frame</em>, <code>t(i) - t(i-1)</code>: perbedaan waktu kedatangan
dari dua kelompok paket (umumnya, <em>frame</em> video berturut-turut). Kelompok paket ini sering
berangkat pada interval waktu yang teratur (misalnya setiap 1/24 detik untuk video 24 fps). Sebagai hasilnya,
mengukur <em>inter-arrival time</em> kemudian sesederhana merekam perbedaan waktu antara awal dari
kelompok paket pertama (yaitu <em>frame</em>) dan <em>frame</em> pertama dari yang berikutnya.</p><p>Dalam diagram di bawah ini, peningkatan penundaan <em>inter-packet</em> median adalah +20 milidetik, indikator yang jelas dari
kemacetan jaringan.</p><p><img src=../images/06-twcc.png alt="TWCC with delay" title="TWCC with delay"></p><p>Jika <em>inter-arrival time</em> meningkat dari waktu ke waktu, itu dianggap bukti peningkatan kedalaman antrian pada
antarmuka jaringan yang menghubungkan dan dianggap kemacetan jaringan. (Catatan: GCC cukup pintar untuk
mengontrol pengukuran ini untuk fluktuasi dalam ukuran <em>byte frame</em>.) GCC memperbaiki pengukuran latensinya menggunakan <a href=https://en.wikipedia.org/wiki/Kalman_filter>filter Kalman</a> dan mengambil banyak
pengukuran <em>round-trip time</em> jaringan (dan variasinya) sebelum menandai kemacetan. Orang dapat
menganggap filter Kalman GCC sebagai pengganti regresi linier: membantu membuat prediksi yang akurat
bahkan ketika <em>jitter</em> menambahkan kebisingan ke dalam pengukuran <em>timing</em>. Setelah menandai kemacetan, GCC
akan mengurangi <em>bitrate</em> yang tersedia. Atau, dalam kondisi jaringan yang stabil, ia dapat perlahan-lahan
meningkatkan perkiraan <em>bandwidth</em>-nya untuk menguji nilai beban yang lebih tinggi.</p><h4 id=tmmbr-tmmbn-dan-remb>TMMBR, TMMBN, dan REMB
<a class=anchor href=#tmmbr-tmmbn-dan-remb>#</a></h4><p>Untuk TMMBR/TMMBN dan REMB, sisi penerima pertama-tama memperkirakan <em>bandwidth</em> masuk yang tersedia (menggunakan
protokol seperti GCC), dan kemudian mengomunikasikan perkiraan <em>bandwidth</em> ini ke pengirim <em>remote</em>. Mereka
tidak perlu bertukar detail tentang <em>packet loss</em> atau kualitas lain tentang kemacetan jaringan
karena beroperasi di sisi penerima memungkinkan mereka mengukur <em>inter-arrival time</em> dan <em>packet loss</em>
secara langsung. Sebaliknya, TMMBR, TMMBN, dan REMB hanya bertukar perkiraan <em>bandwidth</em> itu sendiri:</p><ul><li><strong>Temporary Maximum Media Stream Bit Rate Request</strong> - Mantissa/eksponen dari <em>bitrate</em> yang diminta
untuk satu SSRC.</li><li><strong>Temporary Maximum Media Stream Bit Rate Notification</strong> - Pesan untuk memberi tahu bahwa TMMBR telah
diterima.</li><li><strong>Receiver Estimated Maximum Bitrate</strong> - Mantissa/eksponen dari <em>bitrate</em> yang diminta untuk
seluruh sesi.</li></ul><p>TMMBR dan TMMBN datang pertama dan didefinisikan dalam <a href=https://tools.ietf.org/html/rfc5104>RFC 5104</a>. REMB
datang kemudian, ada <em>draft</em> yang diajukan dalam
<a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-remb-03>draft-alvestrand-rmcat-remb</a>, tetapi
tidak pernah distandarisasi.</p><p>Contoh sesi yang menggunakan REMB mungkin berperilaku seperti berikut:</p><p><img src=../images/06-remb.png alt=REMB title=REMB></p><p>Metode ini bekerja dengan baik di atas kertas. Pengirim menerima estimasi dari penerima, mengatur <em>bitrate encoder</em> ke nilai yang diterima. Tada! Kami telah menyesuaikan dengan kondisi jaringan.</p><p>Namun dalam praktiknya, pendekatan REMB memiliki beberapa kekurangan.</p><p>Ketidakefisienan <em>encoder</em> adalah yang pertama. Ketika Anda menetapkan <em>bitrate</em> untuk <em>encoder</em>, itu tidak selalu
menghasilkan <em>bitrate</em> yang tepat yang Anda minta. Pengkodean dapat menghasilkan lebih banyak atau lebih sedikit bit, tergantung pada
pengaturan <em>encoder</em> dan <em>frame</em> yang dikode.</p><p>Misalnya, menggunakan <em>encoder</em> x264 dengan <code>tune=zerolatency</code> dapat secara signifikan menyimpang dari <em>target bitrate</em> yang ditentukan. Berikut adalah skenario yang mungkin:</p><ul><li>Katakanlah kita mulai dengan mengatur <em>bitrate</em> ke 1000 kbps.</li><li><em>Encoder</em> hanya menghasilkan 700 kbps, karena tidak ada cukup fitur frekuensi tinggi untuk dikode. (AKA - &ldquo;menatap dinding&rdquo;.)</li><li>Mari kita juga bayangkan bahwa penerima mendapat video 700 kbps dengan nol <em>packet loss</em>. Kemudian ia menerapkan aturan REMB 1 untuk meningkatkan <em>bitrate</em> masuk sebesar 8%.</li><li>Penerima mengirim paket REMB dengan saran 756 kbps (700 kbps * 1.08) ke pengirim.</li><li>Pengirim mengatur <em>bitrate encoder</em> ke 756 kbps.</li><li><em>Encoder</em> menghasilkan <em>bitrate</em> yang lebih rendah lagi.</li><li>Proses ini terus berulang, menurunkan <em>bitrate</em> ke minimum absolut.</li></ul><p>Anda dapat melihat bagaimana ini akan menyebabkan penyetelan parameter <em>encoder</em> yang berat, dan mengejutkan pengguna dengan video yang tidak dapat ditonton bahkan pada koneksi yang bagus.</p><h4 id=transport-wide-congestion-control>Transport Wide Congestion Control
<a class=anchor href=#transport-wide-congestion-control>#</a></h4><p><em>Transport Wide Congestion Control</em> adalah perkembangan terbaru dalam komunikasi status jaringan RTCP. Ini didefinisikan dalam
<a href=https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01>draft-holmer-rmcat-transport-wide-cc-extensions-01</a>,
tetapi juga tidak pernah distandarisasi.</p><p>TWCC menggunakan prinsip yang cukup sederhana:</p><p><img src=../images/06-twcc-idea.png alt=TWCC title=TWCC></p><p>Dengan REMB, penerima menginstruksikan sisi pengirim dalam <em>bitrate download</em> yang tersedia. Ini menggunakan
pengukuran yang tepat tentang <em>packet loss</em> yang disimpulkan dan data hanya yang dimilikinya tentang waktu kedatangan <em>inter-packet</em>.</p><p>TWCC hampir merupakan pendekatan hibrida antara SR/RR dan generasi protokol REMB. Ini membawa
perkiraan <em>bandwidth</em> kembali ke sisi pengirim (mirip dengan SR/RR), tetapi teknik estimasi <em>bandwidth</em>-nya
lebih mirip dengan generasi REMB.</p><p>Dengan TWCC, penerima memberi tahu pengirim waktu kedatangan setiap paket. Ini adalah informasi yang cukup
untuk pengirim mengukur variasi penundaan kedatangan <em>inter-packet</em>, serta mengidentifikasi
paket mana yang dijatuhkan atau tiba terlambat untuk berkontribusi pada <em>feed</em> audio/video. Dengan data ini
yang dipertukarkan dengan sering, pengirim dapat dengan cepat menyesuaikan dengan kondisi jaringan yang berubah dan
bervariasi <em>output bandwidth</em>-nya menggunakan algoritma seperti GCC.</p><p>Pengirim melacak paket yang dikirim, nomor urutnya, ukuran dan <em>timestamp</em>. Ketika
pengirim menerima pesan RTCP dari penerima, ia membandingkan penundaan <em>inter-packet</em> pengiriman dengan
penundaan penerimaan. Jika penundaan penerimaan meningkat, ini menandakan kemacetan jaringan, dan pengirim
harus mengambil tindakan korektif.</p><p>Dengan memberikan pengirim data mentah, TWCC menyediakan pandangan yang sangat baik ke dalam kondisi jaringan <em>real time</em>:</p><ul><li>Perilaku <em>packet loss</em> hampir instan, hingga paket individual yang hilang</li><li><em>Bitrate</em> pengiriman yang akurat</li><li><em>Bitrate</em> penerimaan yang akurat</li><li>Pengukuran <em>jitter</em></li><li>Perbedaan antara penundaan paket pengiriman dan penerimaan</li><li>Deskripsi tentang bagaimana jaringan mentolerir pengiriman <em>bandwidth</em> yang <em>bursty</em> atau stabil</li></ul><p>Salah satu kontribusi paling signifikan dari TWCC adalah fleksibilitas yang diberikannya kepada <em>developer</em> WebRTC. Dengan mengkonsolidasikan algoritma <em>congestion control</em> ke sisi pengirim, ini memungkinkan kode klien sederhana yang dapat digunakan secara luas dan memerlukan peningkatan minimal dari waktu ke waktu. Algoritma <em>congestion control</em> yang kompleks kemudian dapat diiterasi lebih cepat pada perangkat keras yang mereka kontrol langsung (seperti <em>Selective Forwarding Unit</em>, dibahas di bagian 8). Dalam kasus peramban dan perangkat seluler, ini berarti klien tersebut dapat mengambil manfaat dari peningkatan algoritma tanpa harus menunggu standardisasi atau pembaruan peramban (yang dapat memakan waktu cukup lama untuk tersedia secara luas).</p><h2 id=alternatif-bandwidth-estimation>Alternatif Bandwidth Estimation
<a class=anchor href=#alternatif-bandwidth-estimation>#</a></h2><p>Implementasi yang paling banyak diterapkan adalah &ldquo;A Google Congestion Control Algorithm for Real-Time
Communication&rdquo; yang didefinisikan dalam
<a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-congestion-02>draft-alvestrand-rmcat-congestion</a>.</p><p>Ada beberapa alternatif untuk GCC, misalnya <a href=https://tools.ietf.org/html/draft-zhu-rmcat-nada-04>NADA: A Unified Congestion Control Scheme for
Real-Time Media</a> dan <a href=https://tools.ietf.org/html/draft-johansson-rmcat-scream-cc-05>SCReAM - Self-Clocked
Rate Adaptation for Multimedia</a>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/06-media-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#apa-yang-saya-dapatkan-dari-komunikasi-media-webrtc>Apa yang saya dapatkan dari komunikasi media WebRTC?</a></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#latensi-vs-kualitas>Latensi vs Kualitas</a><ul><li><a href=#keterbatasan-dunia-nyata>Keterbatasan Dunia Nyata</a></li><li><a href=#video-itu-kompleks>Video itu Kompleks</a></li></ul></li><li><a href=#video-101>Video 101</a><ul><li><a href=#kompresi-_lossy_-dan-_lossless_>Kompresi <em>Lossy</em> dan <em>Lossless</em></a></li><li><a href=#kompresi-_intra_-dan-_inter-frame_>Kompresi <em>Intra</em> dan <em>Inter frame</em></a></li><li><a href=#jenis-_inter-frame_>Jenis <em>Inter-frame</em></a></li><li><a href=#video-itu-rapuh>Video itu rapuh</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#format-paket>Format Paket</a></li><li><a href=#extensions>Extensions</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#format-paket-1>Format Paket</a></li><li><a href=#full-intra-frame-request-fir-dan-picture-loss-indication-pli>Full INTRA-frame Request (FIR) dan Picture Loss Indication (PLI)</a></li><li><a href=#negative-acknowledgment>Negative Acknowledgment</a></li><li><a href=#sender-dan-receiver-reports>Sender dan Receiver Reports</a></li></ul></li><li><a href=#bagaimana-rtprtcp-menyelesaikan-masalah-bersama-sama>Bagaimana RTP/RTCP menyelesaikan masalah bersama-sama</a><ul><li><a href=#forward-error-correction>Forward Error Correction</a></li><li><a href=#adaptive-bitrate-dan-bandwidth-estimation>Adaptive Bitrate dan Bandwidth Estimation</a></li></ul></li><li><a href=#mengidentifikasi-dan-mengomunikasikan-status-jaringan>Mengidentifikasi dan Mengomunikasikan Status Jaringan</a><ul><li><a href=#receiver-reports--sender-reports>Receiver Reports / Sender Reports</a></li><li><a href=#tmmbr-tmmbn-remb-dan-twcc-dipasangkan-dengan-gcc>TMMBR, TMMBN, REMB dan TWCC, dipasangkan dengan GCC</a></li></ul></li><li><a href=#alternatif-bandwidth-estimation>Alternatif Bandwidth Estimation</a></li></ul></nav></div></aside></main></body></html>