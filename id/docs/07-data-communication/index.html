<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Data Communication # Apa yang saya dapatkan dari komunikasi data WebRTC? # WebRTC menyediakan data channel untuk komunikasi data. Antara dua peer Anda dapat membuka 65.534 data channel. Data channel berbasis datagram, dan masing-masing memiliki pengaturan daya tahan sendiri. Secara default, setiap data channel memiliki pengiriman berurutan yang dijamin.
Jika Anda mendekati WebRTC dari latar belakang media, data channel mungkin tampak boros. Mengapa saya memerlukan seluruh subsistem ini ketika saya bisa menggunakan HTTP atau WebSocket?"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/07-data-communication/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Data Communication"><meta property="og:description" content="Data Communication # Apa yang saya dapatkan dari komunikasi data WebRTC? # WebRTC menyediakan data channel untuk komunikasi data. Antara dua peer Anda dapat membuka 65.534 data channel. Data channel berbasis datagram, dan masing-masing memiliki pengaturan daya tahan sendiri. Secara default, setiap data channel memiliki pengiriman berurutan yang dijamin.
Jika Anda mendekati WebRTC dari latar belakang media, data channel mungkin tampak boros. Mengapa saya memerlukan seluruh subsistem ini ketika saya bisa menggunakan HTTP atau WebSocket?"><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Data Communication | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/07-data-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/07-data-communication/ title=Datakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/07-data-communication/ title="Коммуникация данных"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/07-data-communication/ title=数据通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/07-data-communication/ title=データ・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/07-data-communication/ title="ارتباط داده ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/07-data-communication/ title="Communication de données"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/07-data-communication/ title="Comunicación de Datos"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/07-data-communication/ title="Veri İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/07-data-communication/ title="데이터 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/07-data-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/07-data-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/07-data-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/07-data-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/07-data-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/07-data-communication/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/07-data-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/>Connecting</a></li><li><a href=/id/docs/04-securing/>Securing</a></li><li><a href=/id/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/>Media Communication</a></li><li><a href=/id/docs/07-data-communication/ class=active>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Data Communication</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#apa-yang-saya-dapatkan-dari-komunikasi-data-webrtc>Apa yang saya dapatkan dari komunikasi data WebRTC?</a></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#stream-control-transmission-protocol>Stream Control Transmission Protocol</a></li><li><a href=#konsep>Konsep</a><ul><li><a href=#association>Association</a></li><li><a href=#streams>Streams</a></li><li><a href=#berbasis-datagram>Berbasis Datagram</a></li><li><a href=#chunks>Chunks</a></li><li><a href=#transmission-sequence-number>Transmission Sequence Number</a></li><li><a href=#stream-identifier>Stream Identifier</a></li><li><a href=#payload-protocol-identifier>Payload Protocol Identifier</a></li></ul></li><li><a href=#protokol>Protokol</a><ul><li><a href=#data-chunk>DATA Chunk</a></li><li><a href=#init-chunk>INIT Chunk</a></li><li><a href=#sack-chunk>SACK Chunk</a></li><li><a href=#heartbeat-chunk>HEARTBEAT Chunk</a></li><li><a href=#abort-chunk>ABORT Chunk</a></li><li><a href=#shutdown-chunk>SHUTDOWN Chunk</a></li><li><a href=#error-chunk>ERROR Chunk</a></li><li><a href=#forward-tsn-chunk>FORWARD TSN Chunk</a></li></ul></li><li><a href=#state-machine>State Machine</a><ul><li><a href=#connection-establishment-flow>Connection Establishment Flow</a></li><li><a href=#connection-teardown-flow>Connection Teardown Flow</a></li><li><a href=#keep-alive-mechanism>Keep-Alive Mechanism</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=data-communication>Data Communication
<a class=anchor href=#data-communication>#</a></h1><h2 id=apa-yang-saya-dapatkan-dari-komunikasi-data-webrtc>Apa yang saya dapatkan dari komunikasi data WebRTC?
<a class=anchor href=#apa-yang-saya-dapatkan-dari-komunikasi-data-webrtc>#</a></h2><p>WebRTC menyediakan <em>data channel</em> untuk komunikasi data. Antara dua <em>peer</em> Anda dapat membuka 65.534 <em>data channel</em>.
<em>Data channel</em> berbasis datagram, dan masing-masing memiliki pengaturan daya tahan sendiri. Secara default, setiap <em>data channel</em> memiliki pengiriman berurutan yang dijamin.</p><p>Jika Anda mendekati WebRTC dari latar belakang media, <em>data channel</em> mungkin tampak boros. Mengapa saya memerlukan seluruh subsistem ini ketika saya bisa menggunakan HTTP atau WebSocket?</p><p>Kekuatan sebenarnya dengan <em>data channel</em> adalah Anda dapat mengonfigurasinya untuk berperilaku seperti UDP dengan pengiriman tidak berurutan/<em>lossy</em>.
Ini diperlukan untuk situasi latensi rendah dan kinerja tinggi. Anda dapat mengukur <em>backpressure</em> dan memastikan Anda hanya mengirim sebanyak yang didukung jaringan Anda.</p><h2 id=bagaimana-cara-kerjanya>Bagaimana cara kerjanya?
<a class=anchor href=#bagaimana-cara-kerjanya>#</a></h2><p>WebRTC menggunakan <em>Stream Control Transmission Protocol</em> (SCTP), didefinisikan dalam <a href=https://tools.ietf.org/html/rfc4960>RFC 4960</a>. SCTP adalah
protokol lapisan transpor yang dimaksudkan sebagai alternatif untuk TCP atau UDP. Untuk WebRTC kami menggunakannya sebagai protokol lapisan aplikasi yang berjalan di atas koneksi DTLS kami.</p><p>SCTP memberi Anda <em>stream</em> dan setiap <em>stream</em> dapat dikonfigurasi secara independen. <em>Data channel</em> WebRTC hanyalah abstraksi tipis di sekitarnya. Pengaturan
sekitar daya tahan dan pengurutan hanya diteruskan langsung ke <em>Agent</em> SCTP.</p><p><em>Data channel</em> memiliki beberapa fitur yang tidak dapat diekspresikan oleh SCTP, seperti <em>label channel</em>. Untuk mengatasi itu WebRTC menggunakan <em>Data Channel Establishment Protocol</em> (DCEP)
yang didefinisikan dalam <a href=https://tools.ietf.org/html/rfc8832>RFC 8832</a>. DCEP mendefinisikan pesan untuk mengomunikasikan <em>label channel</em> dan protokol.</p><h2 id=dcep>DCEP
<a class=anchor href=#dcep>#</a></h2><p>DCEP hanya memiliki dua pesan <code>DATA_CHANNEL_OPEN</code> dan <code>DATA_CHANNEL_ACK</code>. Untuk setiap <em>data channel</em> yang dibuka, <em>remote</em> harus merespons dengan <em>ack</em>.</p><h3 id=data_channel_open>DATA_CHANNEL_OPEN
<a class=anchor href=#data_channel_open>#</a></h3><p>Pesan ini dikirim oleh <em>Agent</em> WebRTC yang ingin membuka <em>channel</em>.</p><h4 id=format-paket>Format Paket
<a class=anchor href=#format-paket>#</a></h4><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |  Channel Type |            Priority           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Reliability Parameter                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Label Length          |       Protocol Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                             Label                             /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                            Protocol                           /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=message-type>Message Type
<a class=anchor href=#message-type>#</a></h4><p><em>Message Type</em> adalah nilai statis <code>0x03</code>.</p><h4 id=channel-type>Channel Type
<a class=anchor href=#channel-type>#</a></h4><p><em>Channel Type</em> mengontrol atribut daya tahan/pengurutan dari <em>channel</em>. Ini mungkin memiliki nilai berikut:</p><ul><li><code>DATA_CHANNEL_RELIABLE</code> (<code>0x00</code>) - Tidak ada pesan yang hilang dan akan tiba secara berurutan</li><li><code>DATA_CHANNEL_RELIABLE_UNORDERED</code> (<code>0x80</code>) - Tidak ada pesan yang hilang, tetapi mereka mungkin tiba tidak berurutan.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT</code> (<code>0x01</code>) - Pesan mungkin hilang setelah mencoba jumlah yang diminta, tetapi mereka akan tiba secara berurutan.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED</code> (<code>0x81</code>) - Pesan mungkin hilang setelah mencoba jumlah yang diminta dan mungkin tiba tidak berurutan.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED</code> (<code>0x02</code>) - Pesan mungkin hilang jika mereka tidak tiba dalam jumlah waktu yang diminta, tetapi mereka akan tiba secara berurutan.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED</code> (<code>0x82</code>) - Pesan mungkin hilang jika mereka tidak tiba dalam jumlah waktu yang diminta dan mungkin tiba tidak berurutan.</li></ul><h4 id=priority>Priority
<a class=anchor href=#priority>#</a></h4><p>Prioritas dari <em>data channel</em>. <em>Data channel</em> yang memiliki prioritas lebih tinggi akan dijadwalkan terlebih dahulu. Pesan pengguna prioritas rendah yang besar tidak akan menunda pengiriman pesan pengguna prioritas lebih tinggi.</p><h4 id=reliability-parameter>Reliability Parameter
<a class=anchor href=#reliability-parameter>#</a></h4><p>Jika tipe <em>data channel</em> adalah <code>DATA_CHANNEL_PARTIAL_RELIABLE</code>, akhiran mengonfigurasi perilaku:</p><ul><li><code>REXMIT</code> - Mendefinisikan berapa kali pengirim akan mengirim ulang pesan sebelum menyerah.</li><li><code>TIMED</code> - Mendefinisikan berapa lama waktu (dalam ms) pengirim akan mengirim ulang pesan sebelum menyerah.</li></ul><h4 id=label>Label
<a class=anchor href=#label>#</a></h4><p><em>String</em> yang dikode UTF-8 yang berisi nama <em>data channel</em>. <em>String</em> ini mungkin kosong.</p><h4 id=protocol>Protocol
<a class=anchor href=#protocol>#</a></h4><p>Jika ini adalah <em>string</em> kosong, protokol tidak ditentukan. Jika itu adalah <em>string</em> yang tidak kosong, itu harus menentukan protokol yang terdaftar dalam &ldquo;<em>WebSocket Subprotocol Name Registry</em>&rdquo;, didefinisikan dalam <a href=https://tools.ietf.org/html/rfc6455#page-61>RFC 6455</a>.</p><h3 id=data_channel_ack>DATA_CHANNEL_ACK
<a class=anchor href=#data_channel_ack>#</a></h3><p>Pesan ini dikirim oleh <em>Agent</em> WebRTC untuk mengakui bahwa <em>data channel</em> ini telah dibuka.</p><h4 id=format-paket-1>Format Paket
<a class=anchor href=#format-paket-1>#</a></h4><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |
+-+-+-+-+-+-+-+-+
</code></pre><h2 id=stream-control-transmission-protocol>Stream Control Transmission Protocol
<a class=anchor href=#stream-control-transmission-protocol>#</a></h2><p>SCTP adalah kekuatan sebenarnya di balik <em>data channel</em> WebRTC. Ini menyediakan semua fitur <em>data channel</em> ini:</p><ul><li>Multiplexing</li><li>Pengiriman andal menggunakan mekanisme retransmisi seperti TCP</li><li>Opsi keandalan parsial</li><li><em>Congestion Avoidance</em></li><li><em>Flow Control</em></li></ul><p>Untuk memahami SCTP kita akan menjelajahinya dalam tiga bagian. Tujuannya adalah Anda akan tahu cukup untuk men-<em>debug</em> dan mempelajari detail mendalam SCTP sendiri setelah bab ini.</p><h2 id=konsep>Konsep
<a class=anchor href=#konsep>#</a></h2><p>SCTP adalah protokol yang kaya fitur. Bagian ini hanya akan membahas bagian-bagian SCTP yang digunakan oleh WebRTC.
Fitur dalam SCTP yang tidak digunakan oleh WebRTC termasuk <em>multi-homing</em> dan <em>path selection</em>.</p><p>Dengan lebih dari dua puluh tahun pengembangan SCTP bisa sulit untuk sepenuhnya dipahami.</p><h3 id=association>Association
<a class=anchor href=#association>#</a></h3><p><em>Association</em> adalah istilah yang digunakan untuk Sesi SCTP. Ini adalah <em>state</em> yang dibagikan
antara dua <em>Agent</em> SCTP saat mereka berkomunikasi.</p><h3 id=streams>Streams
<a class=anchor href=#streams>#</a></h3><p><em>Stream</em> adalah satu urutan data pengguna dua arah. Ketika Anda membuat <em>data channel</em>, Anda sebenarnya hanya membuat <em>stream</em> SCTP. Setiap <em>Association</em> SCTP berisi daftar <em>stream</em>. Setiap <em>stream</em> dapat dikonfigurasi dengan jenis keandalan yang berbeda.</p><p>WebRTC hanya memungkinkan Anda mengonfigurasi saat pembuatan <em>stream</em>, tetapi SCTP sebenarnya memungkinkan mengubah konfigurasi kapan saja.</p><h3 id=berbasis-datagram>Berbasis Datagram
<a class=anchor href=#berbasis-datagram>#</a></h3><p>SCTP membingkai data sebagai datagram dan bukan sebagai <em>byte stream</em>. Mengirim dan menerima data terasa seperti menggunakan UDP daripada TCP.
Anda tidak perlu menambahkan kode tambahan untuk mentransfer beberapa file melalui satu <em>stream</em>.</p><p>Pesan SCTP tidak memiliki batas ukuran seperti UDP. Satu pesan SCTP bisa berukuran beberapa gigabyte.</p><h3 id=chunks>Chunks
<a class=anchor href=#chunks>#</a></h3><p>Protokol SCTP terdiri dari <em>chunk</em>. Ada banyak jenis <em>chunk</em> yang berbeda. <em>Chunk</em> ini digunakan untuk semua komunikasi.
Data pengguna, inisialisasi koneksi, <em>congestion control</em>, dan lainnya semuanya dilakukan melalui <em>chunk</em>.</p><p>Setiap paket SCTP berisi daftar <em>chunk</em>. Jadi dalam satu paket UDP Anda dapat memiliki beberapa <em>chunk</em> yang membawa pesan dari <em>stream</em> yang berbeda.</p><h3 id=transmission-sequence-number>Transmission Sequence Number
<a class=anchor href=#transmission-sequence-number>#</a></h3><p><em>Transmission Sequence Number</em> (TSN) adalah pengidentifikasi unik global untuk <em>chunk</em> DATA. <em>Chunk</em> DATA adalah yang membawa semua pesan yang ingin dikirim pengguna. TSN penting karena membantu penerima menentukan apakah paket hilang atau tidak berurutan.</p><p>Jika penerima menyadari TSN yang hilang, ia tidak memberikan data kepada pengguna sampai dipenuhi.</p><h3 id=stream-identifier>Stream Identifier
<a class=anchor href=#stream-identifier>#</a></h3><p>Setiap <em>stream</em> memiliki pengidentifikasi unik. Ketika Anda membuat <em>data channel</em> dengan ID eksplisit, itu sebenarnya hanya diteruskan langsung ke SCTP sebagai <em>stream identifier</em>. Jika Anda tidak memberikan ID, <em>stream identifier</em> dipilih untuk Anda.</p><h3 id=payload-protocol-identifier>Payload Protocol Identifier
<a class=anchor href=#payload-protocol-identifier>#</a></h3><p>Setiap <em>chunk</em> DATA juga memiliki <em>Payload Protocol Identifier</em> (PPID). Ini digunakan untuk mengidentifikasi secara unik jenis data apa yang sedang dipertukarkan.
SCTP memiliki banyak PPID, tetapi WebRTC hanya menggunakan lima berikut:</p><ul><li><code>WebRTC DCEP</code> (<code>50</code>) - Pesan DCEP.</li><li><code>WebRTC String</code> (<code>51</code>) - Pesan <em>string</em> DataChannel.</li><li><code>WebRTC Binary</code> (<code>53</code>) - Pesan biner DataChannel.</li><li><code>WebRTC String Empty</code> (<code>56</code>) - Pesan <em>string</em> DataChannel dengan panjang 0.</li><li><code>WebRTC Binary Empty</code> (<code>57</code>) - Pesan biner DataChannel dengan panjang 0.</li></ul><h2 id=protokol>Protokol
<a class=anchor href=#protokol>#</a></h2><p>Berikut adalah beberapa <em>chunk</em> yang digunakan oleh protokol SCTP. Ini
bukan demonstrasi lengkap. Ini memberikan cukup struktur agar <em>state
machine</em> masuk akal.</p><p>Setiap <em>Chunk</em> dimulai dengan bidang <code>type</code>. Sebelum daftar <em>chunk</em>, Anda juga
akan memiliki <em>header</em>.</p><h3 id=data-chunk>DATA Chunk
<a class=anchor href=#data-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0    | Reserved|U|B|E|    Length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TSN                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Stream Identifier        |   Stream Sequence Number      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Payload Protocol Identifier                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                            User Data                          /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> DATA adalah bagaimana semua data pengguna dipertukarkan. Ketika Anda mengirim
apa pun melalui <em>data channel</em>, ini adalah cara pertukaran.</p><p><em>Bit</em> <code>U</code> disetel jika ini adalah paket tidak berurutan. Kita dapat mengabaikan
<em>Stream Sequence Number</em>.</p><p><code>B</code> dan <code>E</code> adalah <em>bit</em> awal dan akhir. Jika Anda ingin mengirim
pesan yang terlalu besar untuk satu <em>chunk</em> DATA, ia perlu difragmentasi menjadi beberapa <em>chunk</em> DATA yang dikirim dalam paket terpisah.
Dengan <em>bit</em> <code>B</code> dan <code>E</code> dan <em>Sequence Number</em> SCTP dapat mengekspresikan
ini.</p><ul><li><code>B=1</code>, <code>E=0</code> - Bagian pertama dari pesan pengguna yang terfragmentasi.</li><li><code>B=0</code>, <code>E=0</code> - Bagian tengah dari pesan pengguna yang terfragmentasi.</li><li><code>B=0</code>, <code>E=1</code> - Bagian terakhir dari pesan pengguna yang terfragmentasi.</li><li><code>B=1</code>, <code>E=1</code> - Pesan yang tidak terfragmentasi.</li></ul><p><code>TSN</code> adalah <em>Transmission Sequence Number</em>. Ini adalah pengidentifikasi unik global
untuk <em>chunk</em> DATA ini. Setelah 4.294.967.295 <em>chunk</em> ini akan kembali ke 0.
TSN ditambah untuk setiap <em>chunk</em> dalam pesan pengguna yang terfragmentasi sehingga penerima tahu cara mengurutkan <em>chunk</em> yang diterima untuk merekonstruksi pesan asli.</p><p><code>Stream Identifier</code> adalah pengidentifikasi unik untuk <em>stream</em> tempat data ini berada.</p><p><code>Stream Sequence Number</code> adalah angka 16-bit yang ditambah setiap pesan pengguna dan disertakan dalam <em>header chunk</em> pesan DATA. Setelah 65535 pesan ini akan kembali ke 0. Angka ini digunakan untuk memutuskan urutan pengiriman pesan ke penerima jika <code>U</code> disetel ke 0. Mirip dengan TSN, kecuali <em>Stream Sequence Number</em> hanya ditambah untuk setiap pesan secara keseluruhan dan bukan setiap <em>chunk</em> DATA individual.</p><p><code>Payload Protocol Identifier</code> adalah jenis data yang mengalir melalui
<em>stream</em> ini. Untuk WebRTC, itu akan menjadi DCEP, String atau Binary.</p><p><code>User Data</code> adalah apa yang Anda kirim. Semua data yang Anda kirim melalui <em>data channel</em> WebRTC
ditransmisikan melalui <em>chunk</em> DATA.</p><h3 id=init-chunk>INIT Chunk
<a class=anchor href=#init-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 1    |  Chunk Flags  |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Initiate Tag                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Advertised Receiver Window Credit (a_rwnd)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Number of Outbound Streams   |  Number of Inbound Streams    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Initial TSN                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/              Optional/Variable-Length Parameters              /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> INIT memulai proses pembuatan <em>association</em>.</p><p><code>Initiate Tag</code> digunakan untuk pembuatan <em>cookie</em>. <em>Cookie</em> digunakan untuk perlindungan <em>Man-In-The-Middle</em>
dan <em>Denial of Service</em>. Mereka dijelaskan lebih detail di bagian <em>state
machine</em>.</p><p><code>Advertised Receiver Window Credit</code> digunakan untuk <em>Congestion Control</em> SCTP. Ini
mengomunikasikan seberapa besar <em>buffer</em> yang dialokasikan penerima untuk <em>association</em> ini.</p><p><code>Number of Outbound/Inbound Streams</code> memberi tahu <em>remote</em> berapa banyak <em>stream</em> yang didukung <em>agent</em> ini.</p><p><code>Initial TSN</code> adalah <code>uint32</code> acak untuk memulai TSN lokal.</p><p><code>Optional Parameters</code> memungkinkan SCTP memperkenalkan fitur baru ke protokol.</p><h3 id=sack-chunk>SACK Chunk
<a class=anchor href=#sack-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 3    |Chunk  Flags   |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Advertised Receiver Window Credit (a_rwnd)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Gap Ack Block #N Start      |  Gap Ack Block #N End         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Duplicate TSN 1                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Duplicate TSN X                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> SACK (<em>Selective Acknowledgment</em>) adalah bagaimana penerima memberi tahu
pengirim bahwa ia telah mendapatkan paket. Sampai pengirim mendapat SACK untuk TSN
ia akan mengirim ulang <em>chunk</em> DATA yang dimaksud. SACK melakukan lebih dari sekedar
memperbarui TSN.</p><p><code>Cumulative TSN ACK</code> TSN tertinggi yang telah diterima.</p><p><code>Advertised Receiver Window Credit</code> ukuran <em>buffer</em> penerima. Penerima
mungkin mengubah ini selama sesi jika lebih banyak memori menjadi tersedia.</p><p><code>Ack Blocks</code> TSN yang telah diterima setelah <code>Cumulative TSN ACK</code>.
Ini digunakan jika ada kesenjangan dalam paket yang dikirim. Katakanlah <em>chunk</em> DATA dengan TSN
<code>100</code>, <code>102</code>, <code>103</code> dan <code>104</code> dikirim. <code>Cumulative TSN ACK</code> akan menjadi <code>100</code>, tetapi
<code>Ack Blocks</code> dapat digunakan untuk memberi tahu pengirim bahwa ia tidak perlu mengirim ulang <code>102</code>, <code>103</code> atau <code>104</code>.</p><p><code>Duplicate TSN</code> menginformasikan pengirim bahwa ia telah menerima <em>chunk</em> DATA berikut lebih dari sekali.</p><h3 id=heartbeat-chunk>HEARTBEAT Chunk
<a class=anchor href=#heartbeat-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 4    | Chunk  Flags  |      Heartbeat Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/            Heartbeat Information TLV (Variable-Length)        /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> HEARTBEAT digunakan untuk menegaskan <em>remote</em> masih merespons.
Berguna jika Anda tidak mengirim <em>chunk</em> DATA apa pun dan perlu menjaga <em>mapping</em> NAT
tetap terbuka.</p><h3 id=abort-chunk>ABORT Chunk
<a class=anchor href=#abort-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 6    |Reserved     |T|           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\               Zero or more Error Causes                       \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> ABORT menutup <em>association</em> secara tiba-tiba. Digunakan ketika
satu sisi memasuki <em>state</em> kesalahan. Mengakhiri koneksi dengan anggun menggunakan
<em>chunk</em> SHUTDOWN.</p><h3 id=shutdown-chunk>SHUTDOWN Chunk
<a class=anchor href=#shutdown-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 7    | Chunk  Flags  |      Length = 8               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> SHUTDOWN memulai penutupan anggun dari <em>association</em> SCTP.
Setiap <em>agent</em> menginformasikan <em>remote</em> tentang TSN terakhir yang dikirimnya. Ini memastikan
bahwa tidak ada paket yang hilang. WebRTC tidak melakukan penutupan anggun dari
<em>association</em> SCTP. Anda perlu merobohkan setiap <em>data channel</em> sendiri
untuk menanganinya dengan anggun.</p><p><code>Cumulative TSN ACK</code> adalah TSN terakhir yang dikirim. Setiap sisi tahu
untuk tidak mengakhiri sampai mereka menerima <em>chunk</em> DATA dengan TSN ini.</p><h3 id=error-chunk>ERROR Chunk
<a class=anchor href=#error-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 9    | Chunk  Flags  |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                    One or more Error Causes                   /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> ERROR digunakan untuk memberi tahu <em>Agent</em> SCTP <em>remote</em> bahwa kesalahan non-fatal
telah terjadi.</p><h3 id=forward-tsn-chunk>FORWARD TSN Chunk
<a class=anchor href=#forward-tsn-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 192  |  Flags = 0x00 |        Length = Variable      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      New Cumulative TSN                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Stream-1              |       Stream Sequence-1       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               /
/                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Stream-N              |       Stream Sequence-N       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><em>Chunk</em> <code>FORWARD TSN</code> memindahkan TSN global ke depan. SCTP melakukan ini,
sehingga Anda dapat melewati beberapa paket yang tidak Anda pedulikan lagi. Katakanlah
Anda mengirim <code>10 11 12 13 14 15</code> dan paket-paket ini hanya valid jika mereka
semua tiba. Data ini juga sensitif terhadap <em>real-time</em>, jadi jika tiba
terlambat itu tidak berguna.</p><p>Jika Anda kehilangan <code>12</code> dan <code>13</code> tidak ada alasan untuk mengirim <code>14</code> dan <code>15</code>!
SCTP menggunakan <em>chunk</em> <code>FORWARD TSN</code> untuk mencapai itu. Ini memberi tahu penerima
bahwa <code>14</code> dan <code>15</code> tidak akan dikirim lagi.</p><p><code>New Cumulative TSN</code> ini adalah TSN baru dari koneksi. Setiap paket
sebelum TSN ini tidak akan dipertahankan.</p><p><code>Stream</code> dan <code>Stream Sequence</code> digunakan untuk melompat <code>Stream Sequence Number</code>
nomor ke depan. Rujuk kembali ke DATA Chunk untuk signifikansi bidang ini.</p><h2 id=state-machine>State Machine
<a class=anchor href=#state-machine>#</a></h2><p>Ini adalah beberapa bagian menarik dari <em>state machine</em> SCTP. WebRTC tidak menggunakan semua
fitur <em>state machine</em> SCTP, jadi kami telah mengecualikan bagian-bagian itu. Kami juga telah menyederhanakan beberapa komponen untuk membuatnya dapat dipahami sendiri.</p><h3 id=connection-establishment-flow>Connection Establishment Flow
<a class=anchor href=#connection-establishment-flow>#</a></h3><p><em>Chunk</em> <code>INIT</code> dan <code>INIT ACK</code> digunakan untuk bertukar kemampuan dan konfigurasi
dari setiap <em>peer</em>. SCTP menggunakan <em>cookie</em> selama <em>handshake</em> untuk memvalidasi <em>peer</em> yang berkomunikasi dengannya.
Ini untuk memastikan bahwa <em>handshake</em> tidak dicegat dan untuk mencegah serangan DoS.</p><p><em>Chunk</em> <code>INIT ACK</code> berisi <em>cookie</em>. <em>Cookie</em> kemudian dikembalikan ke pembuatnya
menggunakan <code>COOKIE ECHO</code>. Jika verifikasi <em>cookie</em> berhasil, <code>COOKIE ACK</code> dikirim dan <em>chunk</em> DATA siap untuk dipertukarkan.</p><p><img src=../images/07-connection-establishment.png alt="Connection establishment" title="Connection establishment"></p><h3 id=connection-teardown-flow>Connection Teardown Flow
<a class=anchor href=#connection-teardown-flow>#</a></h3><p>SCTP menggunakan <em>chunk</em> <code>SHUTDOWN</code>. Ketika <em>agent</em> menerima <em>chunk</em> <code>SHUTDOWN</code> ia akan menunggu sampai ia
menerima <code>Cumulative TSN ACK</code> yang diminta. Ini memungkinkan pengguna untuk memastikan bahwa semua data
dikirim bahkan jika koneksi <em>lossy</em>.</p><h3 id=keep-alive-mechanism>Keep-Alive Mechanism
<a class=anchor href=#keep-alive-mechanism>#</a></h3><p>SCTP menggunakan <em>Chunk</em> <code>HEARTBEAT REQUEST</code> dan <code>HEARTBEAT ACK</code> untuk menjaga koneksi tetap hidup. Ini dikirim
pada interval yang dapat dikonfigurasi. SCTP juga melakukan <em>exponential backoff</em> jika paket belum tiba.</p><p><em>Chunk</em> <code>HEARTBEAT</code> juga berisi nilai waktu. Ini memungkinkan dua <em>association</em> menghitung waktu perjalanan antara dua <em>agent</em>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/07-data-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#apa-yang-saya-dapatkan-dari-komunikasi-data-webrtc>Apa yang saya dapatkan dari komunikasi data WebRTC?</a></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#stream-control-transmission-protocol>Stream Control Transmission Protocol</a></li><li><a href=#konsep>Konsep</a><ul><li><a href=#association>Association</a></li><li><a href=#streams>Streams</a></li><li><a href=#berbasis-datagram>Berbasis Datagram</a></li><li><a href=#chunks>Chunks</a></li><li><a href=#transmission-sequence-number>Transmission Sequence Number</a></li><li><a href=#stream-identifier>Stream Identifier</a></li><li><a href=#payload-protocol-identifier>Payload Protocol Identifier</a></li></ul></li><li><a href=#protokol>Protokol</a><ul><li><a href=#data-chunk>DATA Chunk</a></li><li><a href=#init-chunk>INIT Chunk</a></li><li><a href=#sack-chunk>SACK Chunk</a></li><li><a href=#heartbeat-chunk>HEARTBEAT Chunk</a></li><li><a href=#abort-chunk>ABORT Chunk</a></li><li><a href=#shutdown-chunk>SHUTDOWN Chunk</a></li><li><a href=#error-chunk>ERROR Chunk</a></li><li><a href=#forward-tsn-chunk>FORWARD TSN Chunk</a></li></ul></li><li><a href=#state-machine>State Machine</a><ul><li><a href=#connection-establishment-flow>Connection Establishment Flow</a></li><li><a href=#connection-teardown-flow>Connection Teardown Flow</a></li><li><a href=#keep-alive-mechanism>Keep-Alive Mechanism</a></li></ul></li></ul></nav></div></aside></main></body></html>