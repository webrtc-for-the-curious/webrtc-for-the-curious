<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Connecting # Mengapa WebRTC membutuhkan subsistem khusus untuk tersambung? # Sebagian besar aplikasi yang digunakan saat ini membangun koneksi client/server. Koneksi client/server mengharuskan server memiliki alamat transpor yang stabil dan diketahui. Client menghubungi server, dan server merespons.
WebRTC tidak menggunakan model client/server, melainkan membangun koneksi peer-to-peer (P2P). Dalam koneksi P2P, tugas membuat koneksi didistribusikan secara merata ke kedua peer. Ini karena alamat transpor (IP dan port) di WebRTC tidak dapat diasumsikan, dan bahkan mungkin berubah selama sesi."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/03-connecting/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Connecting"><meta property="og:description" content="Connecting # Mengapa WebRTC membutuhkan subsistem khusus untuk tersambung? # Sebagian besar aplikasi yang digunakan saat ini membangun koneksi client/server. Koneksi client/server mengharuskan server memiliki alamat transpor yang stabil dan diketahui. Client menghubungi server, dan server merespons.
WebRTC tidak menggunakan model client/server, melainkan membangun koneksi peer-to-peer (P2P). Dalam koneksi P2P, tugas membuat koneksi didistribusikan secara merata ke kedua peer. Ini karena alamat transpor (IP dan port) di WebRTC tidak dapat diasumsikan, dan bahkan mungkin berubah selama sesi."><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Connecting | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Подключение><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connexion><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Conexión><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/ class=active>Connecting</a></li><li><a href=/id/docs/04-securing/>Securing</a></li><li><a href=/id/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/>Media Communication</a></li><li><a href=/id/docs/07-data-communication/>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Connecting</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#mengapa-webrtc-membutuhkan-subsistem-khusus-untuk-tersambung>Mengapa WebRTC membutuhkan subsistem khusus untuk tersambung?</a><ul><li><a href=#pengurangan-biaya-_bandwidth_>Pengurangan Biaya <em>Bandwidth</em></a></li><li><a href=#latensi-lebih-rendah>Latensi Lebih Rendah</a></li><li><a href=#komunikasi-e2e-yang-aman>Komunikasi E2E yang Aman</a></li></ul></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#kendala-jaringan-di-dunia-nyata>Kendala jaringan di dunia nyata</a><ul><li><a href=#tidak-dalam-jaringan-yang-sama>Tidak dalam jaringan yang sama</a></li><li><a href=#pembatasan-protokol>Pembatasan Protokol</a></li><li><a href=#aturan-_firewall_ids>Aturan <em>Firewall</em>/IDS</a></li></ul></li><li><a href=#pemetaan-nat>Pemetaan NAT</a><ul><li><a href=#membuat-pemetaan>Membuat pemetaan</a></li><li><a href=#perilaku-pembuatan-pemetaan>Perilaku Pembuatan Pemetaan</a></li><li><a href=#perilaku-penyaringan-pemetaan>Perilaku Penyaringan Pemetaan</a></li><li><a href=#penyegaran-pemetaan>Penyegaran Pemetaan</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#struktur-protokol>Struktur Protokol</a></li><li><a href=#membuat-pemetaan-nat>Membuat Pemetaan NAT</a></li><li><a href=#menentukan-tipe-nat>Menentukan Tipe NAT</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#siklus-hidup-turn>Siklus Hidup TURN</a></li><li><a href=#penggunaan-turn>Penggunaan TURN</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#membuat-ice-agent>Membuat ICE Agent</a></li><li><a href=#pengumpulan-_candidate_>Pengumpulan <em>Candidate</em></a></li><li><a href=#pemeriksaan-konektivitas>Pemeriksaan Konektivitas</a></li><li><a href=#pemilihan-_candidate_>Pemilihan <em>Candidate</em></a></li><li><a href=#restart>Restart</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=connecting>Connecting
<a class=anchor href=#connecting>#</a></h1><h2 id=mengapa-webrtc-membutuhkan-subsistem-khusus-untuk-tersambung>Mengapa WebRTC membutuhkan subsistem khusus untuk tersambung?
<a class=anchor href=#mengapa-webrtc-membutuhkan-subsistem-khusus-untuk-tersambung>#</a></h2><p>Sebagian besar aplikasi yang digunakan saat ini membangun koneksi <em>client/server</em>. Koneksi <em>client/server</em> mengharuskan <em>server</em> memiliki alamat transpor yang stabil dan diketahui. <em>Client</em> menghubungi <em>server</em>, dan <em>server</em> merespons.</p><p>WebRTC tidak menggunakan model <em>client/server</em>, melainkan membangun koneksi <em>peer-to-peer</em> (P2P). Dalam koneksi P2P, tugas membuat koneksi didistribusikan secara merata ke kedua <em>peer</em>. Ini karena alamat transpor (IP dan <em>port</em>) di WebRTC tidak dapat diasumsikan, dan bahkan mungkin berubah selama sesi. WebRTC akan mengumpulkan semua informasi yang bisa didapat dan akan berusaha keras untuk mencapai komunikasi dua arah antara dua klien WebRTC.</p><p>Membangun konektivitas <em>peer-to-peer</em> bisa sulit. Klien-klien ini bisa berada di jaringan yang berbeda tanpa konektivitas langsung. Dalam situasi di mana konektivitas langsung memang ada, Anda masih bisa menghadapi masalah lain. Dalam beberapa kasus, klien Anda tidak menggunakan protokol jaringan yang sama (UDP &lt;-> TCP) atau mungkin menggunakan Versi IP yang berbeda (IPv4 &lt;-> IPv6).</p><p>Terlepas dari kesulitan dalam mengatur koneksi P2P, Anda mendapatkan keuntungan dibanding teknologi Client/Server tradisional karena atribut berikut yang ditawarkan WebRTC.</p><h3 id=pengurangan-biaya-_bandwidth_>Pengurangan Biaya <em>Bandwidth</em>
<a class=anchor href=#pengurangan-biaya-_bandwidth_>#</a></h3><p>Karena komunikasi media terjadi langsung antar <em>peer</em>, Anda tidak perlu membayar atau meng-<em>host</em> <em>server</em> terpisah untuk meneruskan media.</p><h3 id=latensi-lebih-rendah>Latensi Lebih Rendah
<a class=anchor href=#latensi-lebih-rendah>#</a></h3><p>Komunikasi lebih cepat ketika langsung! Ketika pengguna harus menjalankan semua melalui <em>server</em> Anda, itu membuat transmisi lebih lambat.</p><h3 id=komunikasi-e2e-yang-aman>Komunikasi E2E yang Aman
<a class=anchor href=#komunikasi-e2e-yang-aman>#</a></h3><p>Komunikasi langsung lebih aman. Karena pengguna tidak merutekan data melalui <em>server</em> Anda, mereka bahkan tidak perlu mempercayai Anda untuk tidak mendekripsinya.</p><h2 id=bagaimana-cara-kerjanya>Bagaimana cara kerjanya?
<a class=anchor href=#bagaimana-cara-kerjanya>#</a></h2><p>Proses yang dijelaskan di atas disebut Interactive Connectivity Establishment (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>). Protokol lain yang sudah ada sebelum WebRTC.</p><p>ICE adalah protokol yang mencoba menemukan cara terbaik untuk berkomunikasi antara dua ICE Agent. Setiap ICE Agent mempublikasikan cara-cara ia dapat dijangkau, ini dikenal sebagai <em>candidate</em>. <em>Candidate</em> pada dasarnya adalah alamat transpor dari <em>agent</em> yang ia yakini dapat dijangkau oleh <em>peer</em> lainnya. ICE kemudian menentukan pasangan <em>candidate</em> terbaik.</p><p>Proses ICE yang sebenarnya dijelaskan lebih detail nanti di bab ini. Untuk memahami mengapa ICE ada, berguna untuk memahami perilaku jaringan apa yang kita atasi.</p><h2 id=kendala-jaringan-di-dunia-nyata>Kendala jaringan di dunia nyata
<a class=anchor href=#kendala-jaringan-di-dunia-nyata>#</a></h2><p>ICE adalah tentang mengatasi kendala jaringan di dunia nyata. Sebelum kita mengeksplorasi solusinya, mari kita bicarakan masalah sebenarnya.</p><h3 id=tidak-dalam-jaringan-yang-sama>Tidak dalam jaringan yang sama
<a class=anchor href=#tidak-dalam-jaringan-yang-sama>#</a></h3><p>Sebagian besar waktu, klien WebRTC lainnya bahkan tidak akan berada dalam jaringan yang sama. Panggilan khas biasanya terjadi antara dua klien WebRTC di jaringan yang berbeda tanpa konektivitas langsung.</p><p>Berikut adalah grafik dari dua jaringan yang berbeda, terhubung melalui internet publik. Di setiap jaringan Anda memiliki dua <em>host</em>.</p><p><img src=../images/03-two-networks.png alt="Two networks" title="Two networks"></p><p>Untuk <em>host</em> dalam jaringan yang sama, sangat mudah untuk terhubung. Komunikasi antara <code>192.168.0.1 -> 192.168.0.2</code> mudah dilakukan! Kedua <em>host</em> ini dapat terhubung satu sama lain tanpa bantuan luar.</p><p>Namun, <em>host</em> yang menggunakan <code>Router B</code> tidak memiliki cara untuk langsung mengakses apapun di belakang <code>Router A</code>. Bagaimana Anda membedakan antara <code>192.168.0.1</code> di belakang <code>Router A</code> dan IP yang sama di belakang <code>Router B</code>? Mereka adalah IP pribadi! <em>Host</em> yang menggunakan <code>Router B</code> dapat mengirim traffic langsung ke <code>Router A</code>, tetapi permintaan akan berakhir di situ. Bagaimana <code>Router A</code> tahu <em>host</em> mana yang harus ia teruskan pesannya?</p><h3 id=pembatasan-protokol>Pembatasan Protokol
<a class=anchor href=#pembatasan-protokol>#</a></h3><p>Beberapa jaringan tidak mengizinkan traffic UDP sama sekali, atau mungkin mereka tidak mengizinkan TCP. Beberapa jaringan mungkin memiliki MTU (Maximum Transmission Unit) yang sangat rendah. Ada banyak variabel yang dapat diubah oleh administrator jaringan yang dapat menyulitkan komunikasi.</p><h3 id=aturan-_firewall_ids>Aturan <em>Firewall</em>/IDS
<a class=anchor href=#aturan-_firewall_ids>#</a></h3><p>Lainnya adalah &ldquo;Deep Packet Inspection&rdquo; dan penyaringan cerdas lainnya. Beberapa administrator jaringan akan menjalankan perangkat lunak yang mencoba memproses setiap paket. Seringkali perangkat lunak ini tidak memahami WebRTC, jadi ia memblokirnya karena tidak tahu harus berbuat apa, misalnya memperlakukan paket WebRTC sebagai paket UDP yang mencurigakan pada <em>port</em> acak yang tidak masuk <em>whitelist</em>.</p><h2 id=pemetaan-nat>Pemetaan NAT
<a class=anchor href=#pemetaan-nat>#</a></h2><p>Pemetaan NAT (Network Address Translation) adalah keajaiban yang membuat konektivitas WebRTC mungkin. Inilah cara WebRTC memungkinkan dua <em>peer</em> di subnet yang benar-benar berbeda untuk berkomunikasi, menangani masalah &ldquo;tidak dalam jaringan yang sama&rdquo; di atas. Meskipun ini menciptakan tantangan baru, mari kita jelaskan bagaimana pemetaan NAT bekerja pada awalnya.</p><p>Ini tidak menggunakan relay, proxy, atau <em>server</em>. Sekali lagi kita memiliki <code>Agent 1</code> dan <code>Agent 2</code> dan mereka berada di jaringan yang berbeda. Namun, traffic mengalir sepenuhnya. Divisualisasikan terlihat seperti ini:</p><p><img src=../images/03-nat-mapping.png alt="NAT mapping" title="NAT mapping"></p><p>Untuk membuat komunikasi ini terjadi, Anda membentuk pemetaan NAT. Agent 1 menggunakan <em>port</em> 7000 untuk membangun koneksi WebRTC dengan Agent 2. Ini menciptakan pengikatan dari <code>192.168.0.1:7000</code> ke <code>5.0.0.1:7000</code>. Ini kemudian memungkinkan Agent 2 untuk mencapai Agent 1 dengan mengirimkan paket ke <code>5.0.0.1:7000</code>. Membuat pemetaan NAT seperti dalam contoh ini seperti versi otomatis dari melakukan <em>port forwarding</em> di <em>router</em> Anda.</p><p>Kelemahan pemetaan NAT adalah bahwa tidak ada satu bentuk pemetaan tunggal (misalnya <em>port forwarding</em> statis), dan perilakunya tidak konsisten antar jaringan. ISP dan produsen perangkat keras mungkin melakukannya dengan cara berbeda. Dalam beberapa kasus, administrator jaringan bahkan mungkin menonaktifkannya.</p><p>Kabar baiknya adalah rentang lengkap perilaku dipahami dan dapat diamati, sehingga ICE Agent mampu mengonfirmasi ia telah membuat pemetaan NAT, dan atribut pemetaan.</p><p>Dokumen yang menjelaskan perilaku ini adalah <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>.</p><h3 id=membuat-pemetaan>Membuat pemetaan
<a class=anchor href=#membuat-pemetaan>#</a></h3><p>Membuat pemetaan adalah bagian paling mudah. Ketika Anda mengirim paket ke alamat di luar jaringan Anda, pemetaan dibuat! Pemetaan NAT hanyalah IP publik sementara dan <em>port</em> yang dialokasikan oleh NAT Anda. Pesan keluar akan ditulis ulang agar alamat sumbernya diberikan oleh alamat pemetaan yang baru. Jika pesan dikirim ke pemetaan, itu akan secara otomatis dirutekan kembali ke <em>host</em> di dalam NAT yang membuatnya. Detail seputar pemetaan adalah di mana ia menjadi rumit.</p><h3 id=perilaku-pembuatan-pemetaan>Perilaku Pembuatan Pemetaan
<a class=anchor href=#perilaku-pembuatan-pemetaan>#</a></h3><p>Pembuatan pemetaan terbagi dalam tiga kategori berbeda:</p><h4 id=endpoint-independent-mapping>Endpoint-Independent Mapping
<a class=anchor href=#endpoint-independent-mapping>#</a></h4><p>Satu pemetaan dibuat untuk setiap pengirim di dalam NAT. Jika Anda mengirim dua paket ke dua alamat <em>remote</em> yang berbeda, pemetaan NAT akan digunakan kembali. Kedua <em>host remote</em> akan melihat IP dan <em>port</em> sumber yang sama. Jika <em>host remote</em> merespons, itu akan dikirim kembali ke pendengar lokal yang sama.</p><p>Ini adalah skenario terbaik. Agar panggilan berfungsi, setidaknya satu sisi HARUS dari tipe ini.</p><h4 id=address-dependent-mapping>Address Dependent Mapping
<a class=anchor href=#address-dependent-mapping>#</a></h4><p>Pemetaan baru dibuat setiap kali Anda mengirim paket ke alamat baru. Jika Anda mengirim dua paket ke <em>host</em> yang berbeda, dua pemetaan akan dibuat. Jika Anda mengirim dua paket ke <em>host remote</em> yang sama tetapi <em>port</em> tujuan yang berbeda, pemetaan baru TIDAK akan dibuat.</p><h4 id=address-and-port-dependent-mapping>Address and Port Dependent Mapping
<a class=anchor href=#address-and-port-dependent-mapping>#</a></h4><p>Pemetaan baru dibuat jika IP atau <em>port remote</em> berbeda. Jika Anda mengirim dua paket ke <em>host remote</em> yang sama, tetapi <em>port</em> tujuan yang berbeda, pemetaan baru akan dibuat.</p><h3 id=perilaku-penyaringan-pemetaan>Perilaku Penyaringan Pemetaan
<a class=anchor href=#perilaku-penyaringan-pemetaan>#</a></h3><p>Penyaringan pemetaan adalah aturan tentang siapa yang diizinkan menggunakan pemetaan. Mereka terbagi dalam tiga klasifikasi serupa:</p><h4 id=endpoint-independent-filtering>Endpoint-Independent Filtering
<a class=anchor href=#endpoint-independent-filtering>#</a></h4><p>Siapa saja dapat menggunakan pemetaan. Anda dapat membagikan pemetaan dengan beberapa <em>peer</em> lain, dan mereka semua dapat mengirim traffic ke sana.</p><h4 id=address-dependent-filtering>Address Dependent Filtering
<a class=anchor href=#address-dependent-filtering>#</a></h4><p>Hanya <em>host</em> untuk siapa pemetaan dibuat yang dapat menggunakan pemetaan. Jika Anda mengirim paket ke <em>host</em> <code>A</code> Anda hanya dapat mendapat respons dari <em>host</em> yang sama. Jika <em>host</em> <code>B</code> mencoba mengirim paket ke pemetaan itu, itu akan diabaikan.</p><h4 id=address-and-port-dependent-filtering>Address and Port Dependent Filtering
<a class=anchor href=#address-and-port-dependent-filtering>#</a></h4><p>Hanya <em>host</em> dan <em>port</em> untuk siapa pemetaan dibuat yang dapat menggunakan pemetaan itu. Jika Anda mengirim paket ke <code>A:5000</code> Anda hanya dapat mendapat respons dari <em>host</em> dan <em>port</em> yang sama. Jika <code>A:5001</code> mencoba mengirim paket ke pemetaan itu, itu akan diabaikan.</p><h3 id=penyegaran-pemetaan>Penyegaran Pemetaan
<a class=anchor href=#penyegaran-pemetaan>#</a></h3><p>Disarankan agar jika pemetaan tidak digunakan selama 5 menit, pemetaan harus dihancurkan. Ini sepenuhnya tergantung pada ISP atau produsen perangkat keras.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (Session Traversal Utilities for NAT) adalah protokol yang dibuat khusus untuk bekerja dengan NAT. Ini adalah teknologi lain yang sudah ada sebelum WebRTC (dan ICE!). Ini didefinisikan oleh <a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>, yang juga mendefinisikan struktur paket STUN. Protokol STUN juga digunakan oleh ICE/TURN.</p><p>STUN berguna karena memungkinkan pembuatan pemetaan NAT secara programatik. Sebelum STUN, kita dapat membuat pemetaan NAT, tetapi kita tidak tahu apa IP dan <em>port</em>-nya! STUN tidak hanya memberi Anda kemampuan untuk membuat pemetaan, tetapi juga memberi Anda detailnya sehingga Anda dapat membagikannya dengan orang lain, sehingga mereka dapat mengirim traffic kembali kepada Anda melalui pemetaan yang baru saja Anda buat.</p><p>Mari kita mulai dengan deskripsi dasar STUN. Nanti, kita akan memperluas penggunaan TURN dan ICE. Untuk saat ini, kita hanya akan menjelaskan alur Request/Response untuk membuat pemetaan. Kemudian kita akan membicarakan cara mendapatkan detailnya untuk dibagikan dengan orang lain. Ini adalah proses yang terjadi ketika Anda memiliki <em>server</em> <code>stun:</code> dalam ICE URL Anda untuk WebRTC PeerConnection. Singkatnya, STUN membantu <em>endpoint</em> di belakang NAT mengetahui pemetaan apa yang dibuat dengan meminta <em>server</em> STUN di luar NAT untuk melaporkan apa yang diamatinya.</p><h3 id=struktur-protokol>Struktur Protokol
<a class=anchor href=#struktur-protokol>#</a></h3><p>Setiap paket STUN memiliki struktur berikut:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-message-type>STUN Message Type
<a class=anchor href=#stun-message-type>#</a></h4><p>Setiap paket STUN memiliki tipe. Untuk saat ini, kita hanya peduli tentang yang berikut:</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><p>Untuk membuat pemetaan NAT kita membuat <code>Binding Request</code>. Kemudian <em>server</em> merespons dengan <code>Binding Response</code>.</p><h4 id=message-length>Message Length
<a class=anchor href=#message-length>#</a></h4><p>Ini adalah panjang bagian <code>Data</code>. Bagian ini berisi data sembarang yang didefinisikan oleh <code>Message Type</code>.</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>Nilai tetap <code>0x2112A442</code> dalam urutan <em>byte</em> jaringan, ini membantu membedakan traffic STUN dari protokol lain.</p><h4 id=transaction-id>Transaction ID
<a class=anchor href=#transaction-id>#</a></h4><p>Pengenal 96-bit yang secara unik mengidentifikasi <em>request/response</em>. Ini membantu Anda memasangkan <em>request</em> dan <em>response</em> Anda.</p><h4 id=data>Data
<a class=anchor href=#data>#</a></h4><p>Data akan berisi daftar atribut STUN. Atribut STUN memiliki struktur berikut:</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><code>STUN Binding Request</code> tidak menggunakan atribut. Ini berarti <code>STUN Binding Request</code> hanya berisi <em>header</em>.</p><p><code>STUN Binding Response</code> menggunakan <code>XOR-MAPPED-ADDRESS (0x0020)</code>. Atribut ini berisi IP dan <em>port</em>. Ini adalah IP dan <em>port</em> dari pemetaan NAT yang dibuat!</p><h3 id=membuat-pemetaan-nat>Membuat Pemetaan NAT
<a class=anchor href=#membuat-pemetaan-nat>#</a></h3><p>Membuat pemetaan NAT menggunakan STUN hanya memerlukan pengiriman satu <em>request</em>! Anda mengirim <code>STUN Binding Request</code> ke STUN Server. STUN Server kemudian merespons dengan <code>STUN Binding Response</code>.
<code>STUN Binding Response</code> ini akan berisi <code>Mapped Address</code>. <code>Mapped Address</code> adalah bagaimana STUN Server melihat Anda dan merupakan <code>pemetaan NAT</code> Anda.
<code>Mapped Address</code> adalah yang akan Anda bagikan jika Anda ingin seseorang mengirimkan paket kepada Anda.</p><p>Orang juga akan menyebut <code>Mapped Address</code> sebagai <code>Public IP</code> atau <code>Server Reflexive Candidate</code> Anda.</p><h3 id=menentukan-tipe-nat>Menentukan Tipe NAT
<a class=anchor href=#menentukan-tipe-nat>#</a></h3><p>Sayangnya, <code>Mapped Address</code> mungkin tidak berguna dalam semua kasus. Jika itu adalah <code>Address Dependent</code>, hanya <em>server</em> STUN yang dapat mengirim traffic kembali kepada Anda. Jika Anda membagikannya dan <em>peer</em> lain mencoba mengirim pesan masuk, mereka akan dijatuhkan. Ini membuatnya tidak berguna untuk berkomunikasi dengan orang lain. Anda mungkin menemukan kasus <code>Address Dependent</code> sebenarnya dapat dipecahkan, jika <em>host</em> yang menjalankan <em>server</em> STUN juga dapat meneruskan paket untuk Anda ke <em>peer</em>! Ini membawa kita ke solusi menggunakan TURN di bawah ini.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a> mendefinisikan metode untuk menjalankan tes untuk menentukan Tipe NAT Anda. Ini berguna karena Anda akan tahu sebelumnya apakah konektivitas langsung mungkin.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (Traversal Using Relays around NAT) didefinisikan dalam <a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a> adalah solusi ketika konektivitas langsung tidak mungkin. Ini bisa karena Anda memiliki dua Tipe NAT yang tidak kompatibel, atau mungkin tidak dapat berbicara dengan protokol yang sama! TURN juga dapat digunakan untuk tujuan privasi. Dengan menjalankan semua komunikasi Anda melalui TURN Anda menyembunyikan alamat sebenarnya klien.</p><p>TURN menggunakan <em>server</em> khusus. <em>Server</em> ini bertindak sebagai proxy untuk klien. Klien terhubung ke TURN Server dan membuat <code>Allocation</code>. Dengan membuat alokasi, klien mendapatkan IP/Port/Protokol sementara yang dapat digunakan untuk mengirim traffic kembali ke klien. Pendengar baru ini dikenal sebagai <code>Relayed Transport Address</code>. Anggap itu sebagai alamat penerusan, Anda memberikan ini sehingga orang lain dapat mengirimkan traffic kepada Anda melalui TURN! Untuk setiap <em>peer</em> yang Anda berikan <code>Relay Transport Address</code>, Anda harus membuat <code>Permission</code> baru untuk mengizinkan komunikasi dengan Anda.</p><p>Ketika Anda mengirim traffic keluar melalui TURN, itu dikirim melalui <code>Relayed Transport Address</code>. Ketika <em>peer remote</em> mendapat traffic, mereka melihatnya datang dari TURN Server.</p><h3 id=siklus-hidup-turn>Siklus Hidup TURN
<a class=anchor href=#siklus-hidup-turn>#</a></h3><p>Berikut adalah semua yang harus dilakukan oleh klien yang ingin membuat alokasi TURN. Berkomunikasi dengan seseorang yang menggunakan TURN tidak memerlukan perubahan. <em>Peer</em> lain mendapat IP dan <em>port</em>, dan mereka berkomunikasi dengannya seperti <em>host</em> lainnya.</p><h4 id=allocations>Allocations
<a class=anchor href=#allocations>#</a></h4><p>Allocation adalah inti dari TURN. <code>Allocation</code> pada dasarnya adalah &ldquo;TURN Session&rdquo;. Untuk membuat alokasi TURN, Anda berkomunikasi dengan TURN <code>Server Transport Address</code> (biasanya <em>port</em> <code>3478</code>).</p><p>Saat membuat alokasi, Anda perlu memberikan yang berikut:</p><ul><li>Username/Password - Membuat alokasi TURN memerlukan autentikasi.</li><li>Allocation Transport - Protokol transpor antara <em>server</em> (<code>Relayed Transport Address</code>) dan <em>peer</em>, bisa UDP atau TCP.</li><li>Even-Port - Anda dapat meminta <em>port</em> berurutan untuk beberapa alokasi, tidak relevan untuk WebRTC.</li></ul><p>Jika <em>request</em> berhasil, Anda mendapat respons dengan TURN Server dengan Atribut STUN berikut di bagian Data:</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>Mapped Address</code> dari <code>TURN Client</code>. Ketika seseorang mengirim data ke <code>Relayed Transport Address</code> ini adalah tempat ia diteruskan.</li><li><code>RELAYED-ADDRESS</code> - Ini adalah alamat yang Anda berikan kepada klien lain. Jika seseorang mengirim paket ke alamat ini, itu diteruskan ke klien TURN.</li><li><code>LIFETIME</code> - Berapa lama sampai Alokasi TURN ini dihancurkan. Anda dapat memperpanjang masa hidup dengan mengirim <em>request</em> <code>Refresh</code>.</li></ul><h4 id=permissions>Permissions
<a class=anchor href=#permissions>#</a></h4><p><em>Host remote</em> tidak dapat mengirim ke <code>Relayed Transport Address</code> Anda sampai Anda membuat izin untuk mereka. Ketika Anda membuat izin, Anda memberi tahu <em>server</em> TURN bahwa IP dan <em>port</em> ini diizinkan untuk mengirim traffic masuk.</p><p><em>Host remote</em> perlu memberi Anda IP dan <em>port</em> seperti yang terlihat oleh <em>server</em> TURN. Ini berarti ia harus mengirim <code>STUN Binding Request</code> ke TURN Server. Kasus kesalahan umum adalah bahwa <em>host remote</em> akan mengirim <code>STUN Binding Request</code> ke <em>server</em> yang berbeda. Mereka kemudian akan meminta Anda untuk membuat izin untuk IP ini.</p><p>Katakanlah Anda ingin membuat izin untuk <em>host</em> di belakang <code>Address Dependent Mapping</code>. Jika Anda menghasilkan <code>Mapped Address</code> dari <em>server</em> TURN yang berbeda, semua traffic masuk akan dijatuhkan. Setiap kali mereka berkomunikasi dengan <em>host</em> yang berbeda, itu menghasilkan pemetaan baru. Izin kedaluwarsa setelah 5 menit jika tidak disegarkan.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>Kedua pesan ini adalah untuk TURN Client mengirim pesan ke <em>peer remote</em>.</p><p>SendIndication adalah pesan yang berdiri sendiri. Di dalamnya adalah data yang ingin Anda kirim, dan kepada siapa Anda ingin mengirimnya. Ini boros jika Anda mengirim banyak pesan ke <em>peer remote</em>. Jika Anda mengirim 1.000 pesan, Anda akan mengulangi Alamat IP mereka 1.000 kali!</p><p>ChannelData memungkinkan Anda mengirim data, tetapi tidak mengulangi Alamat IP. Anda membuat Channel dengan IP dan <em>port</em>. Anda kemudian mengirim dengan ChannelId, dan IP serta <em>port</em> akan diisi di sisi <em>server</em>. Ini adalah pilihan yang lebih baik jika Anda mengirim banyak pesan.</p><h4 id=refreshing>Refreshing
<a class=anchor href=#refreshing>#</a></h4><p>Alokasi akan menghancurkan diri mereka sendiri secara otomatis. TURN Client harus menyegarkannya lebih cepat dari <code>LIFETIME</code> yang diberikan saat membuat alokasi.</p><h3 id=penggunaan-turn>Penggunaan TURN
<a class=anchor href=#penggunaan-turn>#</a></h3><p>Penggunaan TURN ada dalam dua bentuk. Biasanya, Anda memiliki satu <em>peer</em> yang bertindak sebagai &ldquo;TURN Client&rdquo; dan sisi lain berkomunikasi langsung. Dalam beberapa kasus Anda mungkin memiliki penggunaan TURN di kedua sisi, misalnya karena kedua klien berada di jaringan yang memblokir UDP dan oleh karena itu koneksi ke <em>server</em> TURN masing-masing terjadi melalui TCP.</p><p>Diagram ini membantu menggambarkan seperti apa itu.</p><h4 id=satu-alokasi-turn-untuk-komunikasi>Satu Alokasi TURN untuk Komunikasi
<a class=anchor href=#satu-alokasi-turn-untuk-komunikasi>#</a></h4><p><img src=../images/03-one-turn-allocation.png alt="One TURN allocation" title="One TURN allocation"></p><h4 id=dua-alokasi-turn-untuk-komunikasi>Dua Alokasi TURN untuk Komunikasi
<a class=anchor href=#dua-alokasi-turn-untuk-komunikasi>#</a></h4><p><img src=../images/03-two-turn-allocations.png alt="Two TURN allocations" title="Two TURN allocations"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Interactive Connectivity Establishment) adalah bagaimana WebRTC menghubungkan dua Agent. Didefinisikan dalam <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>, ini adalah teknologi lain yang sudah ada sebelum WebRTC! ICE adalah protokol untuk membangun konektivitas. Ini menentukan semua rute yang mungkin antara kedua <em>peer</em> dan kemudian memastikan Anda tetap terhubung.</p><p>Rute-rute ini dikenal sebagai <code>Candidate Pair</code>, yang merupakan pasangan alamat transpor lokal dan <em>remote</em>. Di sinilah STUN dan TURN ikut bermain dengan ICE. Alamat ini dapat berupa Alamat IP lokal Anda plus <em>port</em>, <code>pemetaan NAT</code>, atau <code>Relayed Transport Address</code>. Setiap sisi mengumpulkan semua alamat yang ingin mereka gunakan, menukarnya, dan kemudian mencoba untuk terhubung!</p><p>Dua ICE Agent berkomunikasi menggunakan paket ping ICE (atau secara resmi disebut pemeriksaan konektivitas) untuk membangun konektivitas. Setelah konektivitas terbentuk, mereka dapat mengirim data apa pun yang mereka inginkan. Ini akan seperti menggunakan <em>socket</em> normal. Pemeriksaan ini menggunakan protokol STUN.</p><h3 id=membuat-ice-agent>Membuat ICE Agent
<a class=anchor href=#membuat-ice-agent>#</a></h3><p>ICE Agent adalah <code>Controlling</code> atau <code>Controlled</code>. <code>Controlling</code> Agent adalah yang memutuskan <code>Candidate Pair</code> yang dipilih. Biasanya, <em>peer</em> yang mengirim <em>offer</em> adalah sisi <em>controlling</em>.</p><p>Setiap sisi harus memiliki <code>user fragment</code> dan <code>password</code>. Kedua nilai ini harus ditukar sebelum pemeriksaan konektivitas bahkan dapat dimulai. <code>user fragment</code> dikirim dalam teks biasa dan berguna untuk demuxing beberapa Sesi ICE.
<code>password</code> digunakan untuk menghasilkan atribut <code>MESSAGE-INTEGRITY</code>. Di akhir setiap paket STUN, ada atribut yang merupakan <em>hash</em> dari seluruh paket menggunakan <code>password</code> sebagai kunci. Ini digunakan untuk mengautentikasi paket dan memastikan itu tidak dirusak.</p><p>Untuk WebRTC, semua nilai ini didistribusikan melalui <code>Session Description</code> seperti dijelaskan di bab sebelumnya.</p><h3 id=pengumpulan-_candidate_>Pengumpulan <em>Candidate</em>
<a class=anchor href=#pengumpulan-_candidate_>#</a></h3><p>Kita sekarang perlu mengumpulkan semua alamat yang mungkin di mana kita dapat dijangkau. Alamat ini dikenal sebagai <em>candidate</em>.</p><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><p><em>Candidate Host</em> mendengarkan langsung pada antarmuka lokal. Ini dapat berupa UDP atau TCP.</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p><em>Candidate</em> mDNS mirip dengan <em>candidate host</em>, tetapi alamat IP-nya disamarkan. Alih-alih memberi tahu sisi lain tentang alamat IP Anda, Anda memberi mereka UUID sebagai <em>hostname</em>. Anda kemudian menyiapkan pendengar multicast, dan merespons jika ada yang meminta UUID yang Anda publikasikan.</p><p>Jika Anda berada di jaringan yang sama dengan <em>agent</em>, Anda dapat menemukan satu sama lain melalui Multicast. Jika Anda tidak berada di jaringan yang sama, Anda tidak akan dapat terhubung (kecuali administrator jaringan secara eksplisit mengonfigurasi jaringan untuk mengizinkan paket Multicast melewati).</p><p>Ini berguna untuk tujuan privasi. Pengguna dapat mengetahui alamat IP lokal Anda melalui WebRTC dengan <em>candidate Host</em> (tanpa bahkan mencoba terhubung kepada Anda), tetapi dengan <em>candidate</em> mDNS, sekarang mereka hanya mendapat UUID acak.</p><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><p><em>Candidate Server Reflexive</em> dihasilkan dengan melakukan <code>STUN Binding Request</code> ke STUN Server.</p><p>Ketika Anda mendapat <code>STUN Binding Response</code>, <code>XOR-MAPPED-ADDRESS</code> adalah <em>Candidate Server Reflexive</em> Anda.</p><h4 id=peer-reflexive>Peer Reflexive
<a class=anchor href=#peer-reflexive>#</a></h4><p><em>Candidate Peer Reflexive</em> dibuat ketika <em>peer remote</em> menerima <em>request</em> Anda dari alamat yang sebelumnya tidak diketahui oleh <em>peer</em>. Setelah menerima, <em>peer</em> melaporkan (memantulkan) alamat yang disebutkan kembali kepada Anda. <em>Peer</em> tahu bahwa <em>request</em> dikirim oleh Anda dan bukan orang lain karena ICE adalah protokol yang terautentikasi.</p><p>Ini umumnya terjadi ketika <code>Host Candidate</code> berkomunikasi dengan <code>Server Reflexive Candidate</code> yang berada di subnet yang berbeda, yang menghasilkan <code>pemetaan NAT</code> baru yang dibuat. Ingat kita mengatakan pemeriksaan konektivitas sebenarnya adalah paket STUN? Format respons STUN secara alami memungkinkan <em>peer</em> untuk melaporkan kembali alamat <em>peer-reflexive</em>.</p><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><p><em>Candidate Relay</em> dihasilkan dengan menggunakan TURN Server.</p><p>Setelah <em>handshake</em> awal dengan TURN Server, Anda diberi <code>RELAYED-ADDRESS</code>, ini adalah <em>Candidate Relay</em> Anda.</p><h3 id=pemeriksaan-konektivitas>Pemeriksaan Konektivitas
<a class=anchor href=#pemeriksaan-konektivitas>#</a></h3><p>Kita sekarang tahu <code>user fragment</code>, <code>password</code>, dan <em>candidate</em> dari <em>agent remote</em>. Kita sekarang dapat mencoba untuk terhubung! Setiap <em>candidate</em> dipasangkan satu sama lain. Jadi jika Anda memiliki 3 <em>candidate</em> di setiap sisi, Anda sekarang memiliki 9 pasangan <em>candidate</em>.</p><p>Secara visual terlihat seperti ini:</p><p><img src=../images/03-connectivity-checks.png alt="Connectivity checks" title="Connectivity checks"></p><h3 id=pemilihan-_candidate_>Pemilihan <em>Candidate</em>
<a class=anchor href=#pemilihan-_candidate_>#</a></h3><p>Controlling dan Controlled Agent keduanya mulai mengirim traffic pada setiap pasangan. Ini diperlukan jika satu Agent berada di belakang <code>Address Dependent Mapping</code>, ini akan menyebabkan <code>Peer Reflexive Candidate</code> dibuat.</p><p>Setiap <code>Candidate Pair</code> yang melihat traffic jaringan kemudian dipromosikan ke pasangan <code>Valid Candidate</code>. Controlling Agent kemudian mengambil satu pasangan <code>Valid Candidate</code> dan menominasikannya. Ini menjadi <code>Nominated Pair</code>. Controlling dan Controlled Agent kemudian mencoba satu putaran lagi komunikasi dua arah. Jika itu berhasil, <code>Nominated Pair</code> menjadi <code>Selected Candidate Pair</code>! Pasangan ini kemudian digunakan untuk sisa sesi.</p><h3 id=restart>Restart
<a class=anchor href=#restart>#</a></h3><p>Jika <code>Selected Candidate Pair</code> berhenti bekerja karena alasan apa pun (pemetaan NAT kedaluwarsa, TURN Server <em>crash</em>) ICE Agent akan masuk ke status <code>Failed</code>. Kedua <em>agent</em> dapat di-<em>restart</em> dan akan melakukan seluruh proses lagi.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#mengapa-webrtc-membutuhkan-subsistem-khusus-untuk-tersambung>Mengapa WebRTC membutuhkan subsistem khusus untuk tersambung?</a><ul><li><a href=#pengurangan-biaya-_bandwidth_>Pengurangan Biaya <em>Bandwidth</em></a></li><li><a href=#latensi-lebih-rendah>Latensi Lebih Rendah</a></li><li><a href=#komunikasi-e2e-yang-aman>Komunikasi E2E yang Aman</a></li></ul></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#kendala-jaringan-di-dunia-nyata>Kendala jaringan di dunia nyata</a><ul><li><a href=#tidak-dalam-jaringan-yang-sama>Tidak dalam jaringan yang sama</a></li><li><a href=#pembatasan-protokol>Pembatasan Protokol</a></li><li><a href=#aturan-_firewall_ids>Aturan <em>Firewall</em>/IDS</a></li></ul></li><li><a href=#pemetaan-nat>Pemetaan NAT</a><ul><li><a href=#membuat-pemetaan>Membuat pemetaan</a></li><li><a href=#perilaku-pembuatan-pemetaan>Perilaku Pembuatan Pemetaan</a></li><li><a href=#perilaku-penyaringan-pemetaan>Perilaku Penyaringan Pemetaan</a></li><li><a href=#penyegaran-pemetaan>Penyegaran Pemetaan</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#struktur-protokol>Struktur Protokol</a></li><li><a href=#membuat-pemetaan-nat>Membuat Pemetaan NAT</a></li><li><a href=#menentukan-tipe-nat>Menentukan Tipe NAT</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#siklus-hidup-turn>Siklus Hidup TURN</a></li><li><a href=#penggunaan-turn>Penggunaan TURN</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#membuat-ice-agent>Membuat ICE Agent</a></li><li><a href=#pengumpulan-_candidate_>Pengumpulan <em>Candidate</em></a></li><li><a href=#pemeriksaan-konektivitas>Pemeriksaan Konektivitas</a></li><li><a href=#pemilihan-_candidate_>Pemilihan <em>Candidate</em></a></li><li><a href=#restart>Restart</a></li></ul></li></ul></nav></div></aside></main></body></html>