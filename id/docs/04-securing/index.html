<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Securing # Keamanan apa yang dimiliki WebRTC? # Setiap koneksi WebRTC diautentikasi dan dienkripsi. Anda dapat yakin bahwa pihak ketiga tidak dapat melihat apa yang Anda kirim atau menyisipkan pesan palsu. Anda juga dapat yakin bahwa klien WebRTC yang membuat Session Description adalah yang Anda komunikasikan dengannya.
Sangat penting bahwa tidak ada yang merusak pesan-pesan tersebut. Tidak apa-apa jika pihak ketiga membaca Session Description saat transit. Namun, WebRTC tidak memiliki perlindungan terhadap modifikasinya."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/04-securing/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Securing"><meta property="og:description" content="Securing # Keamanan apa yang dimiliki WebRTC? # Setiap koneksi WebRTC diautentikasi dan dienkripsi. Anda dapat yakin bahwa pihak ketiga tidak dapat melihat apa yang Anda kirim atau menyisipkan pesan palsu. Anda juga dapat yakin bahwa klien WebRTC yang membuat Session Description adalah yang Anda komunikasikan dengannya.
Sangat penting bahwa tidak ada yang merusak pesan-pesan tersebut. Tidak apa-apa jika pihak ketiga membaca Session Description saat transit. Namun, WebRTC tidak memiliki perlindungan terhadap modifikasinya."><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Securing | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/04-securing/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/04-securing/ title=Защита><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/04-securing/ title=安全性><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/04-securing/ title=امنیت><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/04-securing/ title=Sécurisation><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/04-securing/ title=Seguridad><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/04-securing/ title=Güvenlik><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/04-securing/ title=보안><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/04-securing/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/04-securing/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/04-securing/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/04-securing/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/04-securing/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/04-securing/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/04-securing/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/>Connecting</a></li><li><a href=/id/docs/04-securing/ class=active>Securing</a></li><li><a href=/id/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/>Media Communication</a></li><li><a href=/id/docs/07-data-communication/>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Securing</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#keamanan-apa-yang-dimiliki-webrtc>Keamanan apa yang dimiliki WebRTC?</a></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#security-101>Security 101</a><ul><li><a href=#_plaintext_-dan-_ciphertext_><em>Plaintext</em> dan <em>Ciphertext</em></a></li><li><a href=#_cipher_><em>Cipher</em></a></li><li><a href=#fungsi-_hash_>Fungsi <em>Hash</em></a></li><li><a href=#kriptografi-_publicprivate-key_>Kriptografi <em>Public/Private Key</em></a></li><li><a href=#pertukaran-diffiehellman>Pertukaran Diffie–Hellman</a></li><li><a href=#fungsi-_pseudorandom_>Fungsi <em>Pseudorandom</em></a></li><li><a href=#fungsi-derivasi-kunci>Fungsi Derivasi Kunci</a></li><li><a href=#_nonce_><em>Nonce</em></a></li><li><a href=#_message-authentication-code_><em>Message Authentication Code</em></a></li><li><a href=#rotasi-kunci>Rotasi Kunci</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#format-paket>Format Paket</a></li><li><a href=#_handshake-state-machine_><em>Handshake State Machine</em></a></li><li><a href=#pembuatan-kunci>Pembuatan Kunci</a></li><li><a href=#bertukar-applicationdata>Bertukar ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#pembuatan-sesi>Pembuatan Sesi</a></li><li><a href=#bertukar-media>Bertukar Media</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=securing>Securing
<a class=anchor href=#securing>#</a></h1><h2 id=keamanan-apa-yang-dimiliki-webrtc>Keamanan apa yang dimiliki WebRTC?
<a class=anchor href=#keamanan-apa-yang-dimiliki-webrtc>#</a></h2><p>Setiap koneksi WebRTC diautentikasi dan dienkripsi. Anda dapat yakin bahwa pihak ketiga tidak dapat melihat apa yang Anda kirim atau menyisipkan pesan palsu. Anda juga dapat yakin bahwa klien WebRTC yang membuat Session Description adalah yang Anda komunikasikan dengannya.</p><p>Sangat penting bahwa tidak ada yang merusak pesan-pesan tersebut. Tidak apa-apa jika pihak ketiga membaca Session Description saat transit. Namun, WebRTC tidak memiliki perlindungan terhadap modifikasinya. Penyerang dapat melakukan serangan <em>man-in-the-middle</em> pada Anda dengan mengubah ICE Candidate dan memperbarui <em>Certificate Fingerprint</em>.</p><h2 id=bagaimana-cara-kerjanya>Bagaimana cara kerjanya?
<a class=anchor href=#bagaimana-cara-kerjanya>#</a></h2><p>WebRTC menggunakan dua protokol yang sudah ada sebelumnya, Datagram Transport Layer Security (<a href=https://tools.ietf.org/html/rfc6347>DTLS</a>) dan Secure Real-time Transport Protocol (<a href=https://tools.ietf.org/html/rfc3711>SRTP</a>).</p><p>DTLS memungkinkan Anda untuk menegosiasikan sesi dan kemudian bertukar data secara aman antara dua <em>peer</em>. Ini adalah saudara dari TLS, teknologi yang sama yang mendukung HTTPS, tetapi DTLS menggunakan UDP alih-alih TCP sebagai <em>transport layer</em>. Itu berarti protokol harus menangani pengiriman yang tidak andal. SRTP dirancang khusus untuk bertukar media secara aman. Ada beberapa optimisasi yang dapat kita lakukan dengan menggunakannya daripada DTLS.</p><p>DTLS digunakan terlebih dahulu. Ia melakukan <em>handshake</em> melalui koneksi yang disediakan oleh ICE. DTLS adalah protokol <em>client/server</em>, jadi satu sisi perlu memulai <em>handshake</em>. Peran <em>Client/Server</em> dipilih selama <em>signaling</em>. Selama <em>handshake</em> DTLS, kedua sisi menawarkan sertifikat.
Setelah <em>handshake</em> selesai, sertifikat ini dibandingkan dengan <em>hash</em> sertifikat di Session Description. Ini untuk memastikan bahwa <em>handshake</em> terjadi dengan klien WebRTC yang Anda harapkan. Koneksi DTLS kemudian tersedia untuk digunakan untuk komunikasi DataChannel.</p><p>Untuk membuat sesi SRTP kita menginisialisasinya menggunakan kunci yang dihasilkan oleh DTLS. SRTP tidak memiliki mekanisme <em>handshake</em>, jadi harus di-<em>bootstrap</em> dengan kunci eksternal. Setelah ini selesai, media dapat dipertukarkan yang dienkripsi menggunakan SRTP!</p><h2 id=security-101>Security 101
<a class=anchor href=#security-101>#</a></h2><p>Untuk memahami teknologi yang disajikan dalam bab ini, Anda perlu memahami istilah-istilah ini terlebih dahulu. Kriptografi adalah subjek yang rumit, jadi akan bermanfaat untuk berkonsultasi dengan sumber lain juga!</p><h3 id=_plaintext_-dan-_ciphertext_><em>Plaintext</em> dan <em>Ciphertext</em>
<a class=anchor href=#_plaintext_-dan-_ciphertext_>#</a></h3><p><em>Plaintext</em> adalah input ke <em>cipher</em>. <em>Ciphertext</em> adalah output dari <em>cipher</em>.</p><h3 id=_cipher_><em>Cipher</em>
<a class=anchor href=#_cipher_>#</a></h3><p><em>Cipher</em> adalah serangkaian langkah yang mengubah <em>plaintext</em> menjadi <em>ciphertext</em>. <em>Cipher</em> kemudian dapat dibalik, sehingga Anda dapat mengubah <em>ciphertext</em> Anda kembali ke <em>plaintext</em>. <em>Cipher</em> biasanya memiliki kunci untuk mengubah perilakunya. Istilah lain untuk ini adalah enkripsi dan dekripsi.</p><p><em>Cipher</em> sederhana adalah ROT13. Setiap huruf dipindahkan 13 karakter ke depan. Untuk membatalkan <em>cipher</em> Anda memindahkan 13 karakter ke belakang. <em>Plaintext</em> <code>HELLO</code> akan menjadi <em>ciphertext</em> <code>URYYB</code>. Dalam hal ini, <em>Cipher</em> adalah ROT, dan kuncinya adalah 13.</p><h3 id=fungsi-_hash_>Fungsi <em>Hash</em>
<a class=anchor href=#fungsi-_hash_>#</a></h3><p>Fungsi <em>hash</em> kriptografi adalah proses satu arah yang menghasilkan <em>digest</em>. Diberikan input, ia menghasilkan output yang sama setiap kali. Penting bahwa outputnya <em>tidak</em> dapat dibalik. Jika Anda memiliki output, Anda seharusnya tidak dapat menentukan inputnya. <em>Hashing</em> berguna ketika Anda ingin mengonfirmasi bahwa pesan tidak dirusak.</p><p>Fungsi <em>hash</em> sederhana (walaupun tentu tidak cocok untuk kriptografi nyata) adalah hanya mengambil setiap huruf lainnya. <code>HELLO</code> akan menjadi <code>HLO</code>. Anda tidak dapat mengasumsikan <code>HELLO</code> adalah inputnya, tetapi Anda dapat mengonfirmasi bahwa <code>HELLO</code> akan cocok dengan <em>digest hash</em>.</p><h3 id=kriptografi-_publicprivate-key_>Kriptografi <em>Public/Private Key</em>
<a class=anchor href=#kriptografi-_publicprivate-key_>#</a></h3><p>Kriptografi <em>Public/Private Key</em> menggambarkan jenis <em>cipher</em> yang digunakan DTLS dan SRTP. Dalam sistem ini, Anda memiliki dua kunci, kunci publik dan pribadi. Kunci publik untuk mengenkripsi pesan dan aman untuk dibagikan.
Kunci pribadi untuk mendekripsi, dan tidak boleh dibagikan. Ini adalah satu-satunya kunci yang dapat mendekripsi pesan yang dienkripsi dengan kunci publik.</p><h3 id=pertukaran-diffiehellman>Pertukaran Diffie–Hellman
<a class=anchor href=#pertukaran-diffiehellman>#</a></h3><p>Pertukaran Diffie–Hellman memungkinkan dua pengguna yang tidak pernah bertemu sebelumnya untuk membuat <em>shared secret</em> secara aman melalui internet. Pengguna <code>A</code> dapat mengirim rahasia ke Pengguna <code>B</code> tanpa khawatir tentang penyadapan. Ini bergantung pada kesulitan memecahkan masalah logaritma diskrit.
Anda tidak perlu sepenuhnya memahami bagaimana ini bekerja, tetapi ini membantu untuk mengetahui inilah yang membuat <em>handshake</em> DTLS mungkin.</p><p>Wikipedia memiliki contoh ini dalam tindakan <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>di sini</a>.</p><h3 id=fungsi-_pseudorandom_>Fungsi <em>Pseudorandom</em>
<a class=anchor href=#fungsi-_pseudorandom_>#</a></h3><p>Fungsi <em>Pseudorandom</em> (PRF) adalah fungsi yang telah ditentukan untuk menghasilkan nilai yang tampak acak. Ini mungkin mengambil beberapa input dan menghasilkan satu output.</p><h3 id=fungsi-derivasi-kunci>Fungsi Derivasi Kunci
<a class=anchor href=#fungsi-derivasi-kunci>#</a></h3><p>Derivasi Kunci adalah jenis Fungsi <em>Pseudorandom</em>. Derivasi Kunci adalah fungsi yang digunakan untuk membuat kunci lebih kuat. Satu pola umum adalah <em>key stretching</em>.</p><p>Katakanlah Anda diberi kunci yang berukuran 8 byte. Anda dapat menggunakan KDF untuk membuatnya lebih kuat.</p><h3 id=_nonce_><em>Nonce</em>
<a class=anchor href=#_nonce_>#</a></h3><p><em>Nonce</em> adalah input tambahan ke <em>cipher</em>. Ini digunakan sehingga Anda bisa mendapatkan output yang berbeda dari <em>cipher</em>, bahkan jika Anda mengenkripsi pesan yang sama beberapa kali.</p><p>Jika Anda mengenkripsi pesan yang sama 10 kali, <em>cipher</em> akan memberi Anda <em>ciphertext</em> yang sama 10 kali. Dengan menggunakan <em>nonce</em> Anda dapat mendapatkan output yang berbeda, sambil tetap menggunakan kunci yang sama. Penting Anda menggunakan <em>nonce</em> yang berbeda untuk setiap pesan! Jika tidak, itu meniadakan banyak nilainya.</p><h3 id=_message-authentication-code_><em>Message Authentication Code</em>
<a class=anchor href=#_message-authentication-code_>#</a></h3><p><em>Message Authentication Code</em> adalah <em>hash</em> yang ditempatkan di akhir pesan. MAC membuktikan bahwa pesan berasal dari pengguna yang Anda harapkan.</p><p>Jika Anda tidak menggunakan MAC, penyerang dapat menyisipkan pesan yang tidak valid. Setelah mendekripsi Anda hanya akan mendapatkan sampah karena mereka tidak tahu kuncinya.</p><h3 id=rotasi-kunci>Rotasi Kunci
<a class=anchor href=#rotasi-kunci>#</a></h3><p>Rotasi Kunci adalah praktik mengubah kunci Anda pada interval. Ini membuat kunci yang dicuri kurang berdampak. Jika kunci dicuri atau bocor, lebih sedikit data yang dapat didekripsi.</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS (Datagram Transport Layer Security) memungkinkan dua <em>peer</em> untuk membangun komunikasi yang aman tanpa konfigurasi yang sudah ada sebelumnya. Bahkan jika seseorang menguping percakapan, mereka tidak akan dapat mendekripsi pesan.</p><p>Untuk DTLS Client dan Server berkomunikasi, mereka perlu menyetujui <em>cipher</em> dan kunci. Mereka menentukan nilai-nilai ini dengan melakukan <em>handshake</em> DTLS. Selama <em>handshake</em>, pesan dalam <em>plaintext</em>.
Ketika DTLS Client/Server telah bertukar cukup detail untuk mulai mengenkripsi, ia mengirim <code>Change Cipher Spec</code>. Setelah pesan ini, setiap pesan berikutnya akan dienkripsi!</p><h3 id=format-paket>Format Paket
<a class=anchor href=#format-paket>#</a></h3><p>Setiap paket DTLS dimulai dengan <em>header</em>.</p><h4 id=content-type>Content Type
<a class=anchor href=#content-type>#</a></h4><p>Anda dapat mengharapkan tipe berikut:</p><ul><li><code>20</code> - Change Cipher Spec</li><li><code>22</code> - Handshake</li><li><code>23</code> - Application Data</li></ul><p><code>Handshake</code> digunakan untuk bertukar detail untuk memulai sesi. <code>Change Cipher Spec</code> digunakan untuk memberi tahu sisi lain bahwa semuanya akan dienkripsi. <code>Application Data</code> adalah pesan yang dienkripsi.</p><h4 id=version>Version
<a class=anchor href=#version>#</a></h4><p>Version dapat berupa <code>0x0000feff</code> (DTLS v1.0) atau <code>0x0000fefd</code> (DTLS v1.2) tidak ada v1.1.</p><h4 id=epoch>Epoch
<a class=anchor href=#epoch>#</a></h4><p>Epoch dimulai dari <code>0</code>, tetapi menjadi <code>1</code> setelah <code>Change Cipher Spec</code>. Pesan apa pun dengan epoch non-nol dienkripsi.</p><h4 id=sequence-number>Sequence Number
<a class=anchor href=#sequence-number>#</a></h4><p>Sequence Number digunakan untuk menjaga pesan tetap teratur. Setiap pesan meningkatkan Sequence Number. Ketika epoch bertambah, Sequence Number dimulai dari awal.</p><h4 id=length-dan-payload>Length dan Payload
<a class=anchor href=#length-dan-payload>#</a></h4><p>Payload adalah <code>Content Type</code> spesifik. Untuk <code>Application Data</code>, <code>Payload</code> adalah data yang dienkripsi. Untuk <code>Handshake</code> akan berbeda tergantung pada pesannya. Panjang adalah untuk seberapa besar <code>Payload</code>.</p><h3 id=_handshake-state-machine_><em>Handshake State Machine</em>
<a class=anchor href=#_handshake-state-machine_>#</a></h3><p>Selama <em>handshake</em>, Client/Server bertukar serangkaian pesan. Pesan-pesan ini dikelompokkan ke dalam <em>flight</em>. Setiap <em>flight</em> mungkin memiliki beberapa pesan di dalamnya (atau hanya satu).
<em>Flight</em> tidak lengkap sampai semua pesan dalam <em>flight</em> telah diterima. Kami akan menjelaskan tujuan setiap pesan lebih detail di bawah ini.</p><p><img src=../images/04-handshake.png alt=Handshake title=Handshake></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello adalah pesan awal yang dikirim oleh <em>client</em>. Ini berisi daftar atribut. Atribut ini memberi tahu <em>server</em> <em>cipher</em> dan fitur yang didukung <em>client</em>. Untuk WebRTC ini adalah bagaimana kita memilih SRTP Cipher juga. Ini juga berisi data acak yang akan digunakan untuk menghasilkan kunci untuk sesi.</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>HelloVerifyRequest dikirim oleh <em>server</em> ke <em>client</em>. Ini untuk memastikan bahwa <em>client</em> bermaksud mengirim permintaan. <em>Client</em> kemudian mengirim ulang ClientHello, tetapi dengan <em>token</em> yang disediakan dalam HelloVerifyRequest.</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello adalah respons oleh <em>server</em> untuk konfigurasi sesi ini. Ini berisi <em>cipher</em> apa yang akan digunakan ketika sesi ini selesai. Ini juga berisi data acak <em>server</em>.</p><h4 id=certificate>Certificate
<a class=anchor href=#certificate>#</a></h4><p>Certificate berisi sertifikat untuk Client atau Server. Ini digunakan untuk mengidentifikasi secara unik dengan siapa kita berkomunikasi. Setelah <em>handshake</em> selesai, kita akan memastikan sertifikat ini ketika di-<em>hash</em> cocok dengan <em>fingerprint</em> di <code>SessionDescription</code>.</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>Pesan ini digunakan untuk mengirimkan kunci publik. Saat startup, <em>client</em> dan <em>server</em> keduanya menghasilkan <em>keypair</em>. Setelah <em>handshake</em> nilai-nilai ini akan digunakan untuk menghasilkan <code>Pre-Master Secret</code>.</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>CertificateRequest dikirim oleh <em>server</em> yang memberi tahu <em>client</em> bahwa ia menginginkan sertifikat. <em>Server</em> dapat Meminta atau Mengharuskan sertifikat.</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone memberi tahu <em>client</em> bahwa <em>server</em> selesai dengan <em>handshake</em>.</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>CertificateVerify adalah bagaimana pengirim membuktikan bahwa ia memiliki kunci pribadi yang dikirim dalam pesan Certificate.</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec memberi tahu penerima bahwa segala sesuatu yang dikirim setelah pesan ini akan dienkripsi.</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished dienkripsi dan berisi <em>hash</em> dari semua pesan. Ini untuk menegaskan bahwa <em>handshake</em> tidak dirusak.</p><h3 id=pembuatan-kunci>Pembuatan Kunci
<a class=anchor href=#pembuatan-kunci>#</a></h3><p>Setelah <em>Handshake</em> selesai, Anda dapat mulai mengirim data terenkripsi. <em>Cipher</em> dipilih oleh <em>server</em> dan ada di ServerHello. Bagaimana kuncinya dipilih?</p><p>Pertama kita menghasilkan <code>Pre-Master Secret</code>. Untuk mendapatkan nilai ini, Diffie–Hellman digunakan pada kunci yang dipertukarkan oleh <code>ServerKeyExchange</code> dan <code>ClientKeyExchange</code>. Detailnya berbeda tergantung pada <em>Cipher</em> yang dipilih.</p><p>Selanjutnya <code>Master Secret</code> dihasilkan. Setiap versi DTLS memiliki <code>Pseudorandom function</code> yang ditentukan. Untuk DTLS 1.2 fungsi tersebut mengambil <code>Pre-Master Secret</code> dan nilai acak di <code>ClientHello</code> dan <code>ServerHello</code>.
Output dari menjalankan <code>Pseudorandom Function</code> adalah <code>Master Secret</code>. <code>Master Secret</code> adalah nilai yang digunakan untuk <em>Cipher</em>.</p><h3 id=bertukar-applicationdata>Bertukar ApplicationData
<a class=anchor href=#bertukar-applicationdata>#</a></h3><p>Kuda beban DTLS adalah <code>ApplicationData</code>. Sekarang kita memiliki <em>cipher</em> yang diinisialisasi, kita dapat mulai mengenkripsi dan mengirimkan nilai.</p><p>Pesan <code>ApplicationData</code> menggunakan <em>header</em> DTLS seperti yang dijelaskan sebelumnya. <code>Payload</code> diisi dengan <em>ciphertext</em>. Anda sekarang memiliki Sesi DTLS yang berfungsi dan dapat berkomunikasi dengan aman.</p><p>DTLS memiliki banyak fitur menarik lainnya seperti renegosiasi. Mereka tidak digunakan oleh WebRTC, jadi tidak akan dibahas di sini.</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP adalah protokol yang dirancang khusus untuk mengenkripsi paket RTP. Untuk memulai sesi SRTP Anda menentukan kunci dan <em>cipher</em> Anda. Tidak seperti DTLS ia tidak memiliki mekanisme <em>handshake</em>. Semua konfigurasi dan kunci dihasilkan selama <em>handshake</em> DTLS.</p><p>DTLS menyediakan API khusus untuk mengekspor kunci yang akan digunakan oleh proses lain. Ini didefinisikan dalam <a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>.</p><h3 id=pembuatan-sesi>Pembuatan Sesi
<a class=anchor href=#pembuatan-sesi>#</a></h3><p>SRTP mendefinisikan Key Derivation Function yang digunakan pada input. Ketika membuat Sesi SRTP, input dijalankan melalui ini untuk menghasilkan kunci kita untuk SRTP Cipher kita. Setelah ini Anda dapat melanjutkan untuk memproses media.</p><h3 id=bertukar-media>Bertukar Media
<a class=anchor href=#bertukar-media>#</a></h3><p>Setiap paket RTP memiliki SequenceNumber 16 bit. SequenceNumber ini digunakan untuk menjaga paket tetap teratur, seperti Primary Key. Selama panggilan ini akan berputar. SRTP melacaknya dan menyebutnya <em>rollover counter</em>.</p><p>Ketika mengenkripsi paket, SRTP menggunakan <em>rollover counter</em> dan <em>sequence number</em> sebagai <em>nonce</em>. Ini untuk memastikan bahwa bahkan jika Anda mengirim data yang sama dua kali, <em>ciphertext</em> akan berbeda. Ini penting untuk mencegah penyerang mengidentifikasi pola atau mencoba serangan <em>replay</em>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#keamanan-apa-yang-dimiliki-webrtc>Keamanan apa yang dimiliki WebRTC?</a></li><li><a href=#bagaimana-cara-kerjanya>Bagaimana cara kerjanya?</a></li><li><a href=#security-101>Security 101</a><ul><li><a href=#_plaintext_-dan-_ciphertext_><em>Plaintext</em> dan <em>Ciphertext</em></a></li><li><a href=#_cipher_><em>Cipher</em></a></li><li><a href=#fungsi-_hash_>Fungsi <em>Hash</em></a></li><li><a href=#kriptografi-_publicprivate-key_>Kriptografi <em>Public/Private Key</em></a></li><li><a href=#pertukaran-diffiehellman>Pertukaran Diffie–Hellman</a></li><li><a href=#fungsi-_pseudorandom_>Fungsi <em>Pseudorandom</em></a></li><li><a href=#fungsi-derivasi-kunci>Fungsi Derivasi Kunci</a></li><li><a href=#_nonce_><em>Nonce</em></a></li><li><a href=#_message-authentication-code_><em>Message Authentication Code</em></a></li><li><a href=#rotasi-kunci>Rotasi Kunci</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#format-paket>Format Paket</a></li><li><a href=#_handshake-state-machine_><em>Handshake State Machine</em></a></li><li><a href=#pembuatan-kunci>Pembuatan Kunci</a></li><li><a href=#bertukar-applicationdata>Bertukar ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#pembuatan-sesi>Pembuatan Sesi</a></li><li><a href=#bertukar-media>Bertukar Media</a></li></ul></li></ul></nav></div></aside></main></body></html>