<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Applied WebRTC # Sekarang setelah Anda mengetahui bagaimana WebRTC bekerja, saatnya untuk membangun dengannya! Bab ini mengeksplorasi apa yang orang bangun dengan WebRTC, dan bagaimana mereka membangunnya. Anda akan mempelajari semua hal menarik yang terjadi dengan WebRTC. Kekuatan WebRTC datang dengan biaya. Membangun layanan WebRTC tingkat produksi adalah menantang. Bab ini akan mencoba menjelaskan tantangan tersebut sebelum Anda menghadapinya.
Berdasarkan Kasus Penggunaan # Banyak yang berpikir WebRTC hanyalah teknologi untuk konferensi di peramban web."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/08-applied-webrtc/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Applied WebRTC"><meta property="og:description" content="Applied WebRTC # Sekarang setelah Anda mengetahui bagaimana WebRTC bekerja, saatnya untuk membangun dengannya! Bab ini mengeksplorasi apa yang orang bangun dengan WebRTC, dan bagaimana mereka membangunnya. Anda akan mempelajari semua hal menarik yang terjadi dengan WebRTC. Kekuatan WebRTC datang dengan biaya. Membangun layanan WebRTC tingkat produksi adalah menantang. Bab ini akan mencoba menjelaskan tantangan tersebut sebelum Anda menghadapinya.
Berdasarkan Kasus Penggunaan # Banyak yang berpikir WebRTC hanyalah teknologi untuk konferensi di peramban web."><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Applied WebRTC | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/08-applied-webrtc/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/08-applied-webrtc/ title="Applied WebRTC"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/08-applied-webrtc/ title="Hur WebRTC används"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/08-applied-webrtc/ title="Прикладной WebRTC"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/ title="WebRTC 应用场景"><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/08-applied-webrtc/ title=応用WebRTC><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/08-applied-webrtc/ title="اعمال کردن WebRTC"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/08-applied-webrtc/ title="WebRTC appliqué"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/08-applied-webrtc/ title="WebRTC Aplicado"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/08-applied-webrtc/ title="Uygulamalı WebRTC"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/08-applied-webrtc/ title="적용 WebRTC"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/08-applied-webrtc/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/08-applied-webrtc/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/08-applied-webrtc/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/08-applied-webrtc/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/08-applied-webrtc/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/08-applied-webrtc/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/08-applied-webrtc/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/08-applied-webrtc/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/08-applied-webrtc/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/>Connecting</a></li><li><a href=/id/docs/04-securing/>Securing</a></li><li><a href=/id/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/>Media Communication</a></li><li><a href=/id/docs/07-data-communication/>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/ class=active>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Applied WebRTC</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#berdasarkan-kasus-penggunaan>Berdasarkan Kasus Penggunaan</a><ul><li><a href=#conferencing>Conferencing</a></li><li><a href=#_broadcasting_><em>Broadcasting</em></a></li><li><a href=#_remote-access_><em>Remote Access</em></a></li><li><a href=#berbagi-file-dan-penghindaran-sensor>Berbagi File dan Penghindaran Sensor</a></li><li><a href=#internet-of-things>Internet of Things</a></li><li><a href=#_media-protocol-bridging_><em>Media Protocol Bridging</em></a></li><li><a href=#_data-protocol-bridging_><em>Data Protocol Bridging</em></a></li><li><a href=#teleoperation>Teleoperation</a></li><li><a href=#cdn-terdistribusi>CDN Terdistribusi</a></li></ul></li><li><a href=#topologi-webrtc>Topologi WebRTC</a><ul><li><a href=#_one-to-one_><em>One-To-One</em></a></li><li><a href=#_full-mesh_><em>Full Mesh</em></a></li><li><a href=#_hybrid-mesh_><em>Hybrid Mesh</em></a></li><li><a href=#_selective-forwarding-unit_><em>Selective Forwarding Unit</em></a></li><li><a href=#mcu>MCU</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=applied-webrtc>Applied WebRTC
<a class=anchor href=#applied-webrtc>#</a></h1><p>Sekarang setelah Anda mengetahui bagaimana WebRTC bekerja, saatnya untuk membangun dengannya! Bab ini mengeksplorasi apa yang orang
bangun dengan WebRTC, dan bagaimana mereka membangunnya. Anda akan mempelajari semua hal menarik yang terjadi
dengan WebRTC. Kekuatan WebRTC datang dengan biaya. Membangun layanan WebRTC tingkat produksi adalah
menantang. Bab ini akan mencoba menjelaskan tantangan tersebut sebelum Anda menghadapinya.</p><h2 id=berdasarkan-kasus-penggunaan>Berdasarkan Kasus Penggunaan
<a class=anchor href=#berdasarkan-kasus-penggunaan>#</a></h2><p>Banyak yang berpikir WebRTC hanyalah teknologi untuk konferensi di peramban web. Namun itu jauh lebih dari itu!
WebRTC digunakan dalam berbagai aplikasi. Kasus penggunaan baru muncul sepanjang waktu. Dalam bab ini kami akan mencantumkan beberapa yang umum dan bagaimana WebRTC merevolusi mereka.</p><h3 id=conferencing>Conferencing
<a class=anchor href=#conferencing>#</a></h3><p><em>Conferencing</em> adalah kasus penggunaan asli untuk WebRTC. Protokol ini berisi beberapa fitur yang diperlukan yang tidak ditawarkan protokol lain
di peramban. Anda bisa membangun sistem konferensi dengan WebSocket dan mungkin bekerja dalam kondisi optimal. Jika Anda ingin
sesuatu yang dapat digunakan dalam kondisi jaringan dunia nyata, WebRTC adalah pilihan terbaik.</p><p>WebRTC menyediakan <em>congestion control</em> dan <em>adaptive bitrate</em> untuk media. Seiring kondisi jaringan berubah, pengguna masih akan mendapatkan
pengalaman terbaik yang mungkin. <em>Developer</em> juga tidak perlu menulis kode tambahan untuk mengukur kondisi ini.</p><p>Peserta dapat mengirim dan menerima beberapa <em>stream</em>. Mereka juga dapat menambah dan menghapus <em>stream</em> tersebut kapan saja selama panggilan. <em>Codec</em> juga dinegosiasikan.
Semua fungsi ini disediakan oleh peramban, tidak ada kode khusus yang perlu ditulis oleh <em>developer</em>.</p><p><em>Conferencing</em> juga mendapat manfaat dari <em>data channel</em>. Pengguna dapat mengirim metadata atau berbagi dokumen. Anda dapat membuat beberapa <em>stream</em>
dan mengonfigurasinya jika Anda membutuhkan performa lebih daripada keandalan.</p><h3 id=_broadcasting_><em>Broadcasting</em>
<a class=anchor href=#_broadcasting_>#</a></h3><p>Banyak proyek baru mulai muncul di ruang siaran yang menggunakan WebRTC. Protokol ini menawarkan banyak hal baik untuk penerbit
dan konsumen media.</p><p>WebRTC yang berada di peramban memudahkan pengguna untuk menerbitkan video. Ini menghilangkan keharusan bagi pengguna untuk mengunduh klien baru.
Platform apa pun yang memiliki peramban web dapat menerbitkan video. Penerbit kemudian dapat mengirim beberapa <em>track</em> dan memodifikasi atau menghapusnya kapan saja. Ini adalah
peningkatan besar dibanding protokol lama yang hanya mengizinkan satu audio atau satu <em>track</em> video per koneksi.</p><p>WebRTC memberi <em>developer</em> kontrol yang lebih besar atas <em>trade-off</em> latensi versus kualitas. Jika lebih penting bahwa latensi tidak pernah melebihi
ambang batas tertentu, dan Anda bersedia mentolerir beberapa artefak dekoding. Anda dapat mengonfigurasi penonton untuk memutar media segera setelah
tiba. Dengan protokol lain yang berjalan melalui TCP, itu tidak semudah itu. Di peramban Anda dapat meminta data dan itu saja.</p><h3 id=_remote-access_><em>Remote Access</em>
<a class=anchor href=#_remote-access_>#</a></h3><p><em>Remote Access</em> adalah ketika Anda mengakses komputer lain dari jarak jauh melalui WebRTC. Anda bisa memiliki kendali penuh atas <em>host remote</em>, atau mungkin hanya
satu aplikasi. Ini bagus untuk menjalankan tugas yang mahal secara komputasi ketika perangkat keras lokal tidak dapat melakukannya. Seperti menjalankan video game baru, atau
perangkat lunak CAD. WebRTC mampu merevolusi ruang ini dalam tiga cara.</p><p>WebRTC dapat digunakan untuk mengakses <em>host</em> dari jarak jauh yang tidak dapat di-<em>route</em> secara global. Dengan NAT <em>Traversal</em> Anda dapat mengakses komputer yang hanya tersedia
melalui STUN. Ini bagus untuk keamanan dan privasi. Pengguna Anda tidak perlu merutekan video melalui <em>ingest</em>, atau &ldquo;jump box&rdquo;. NAT <em>Traversal</em> juga
membuat penerapan lebih mudah. Anda tidak perlu khawatir tentang <em>port forwarding</em> atau mengatur IP statis sebelumnya.</p><p><em>Data channel</em> juga sangat kuat dalam skenario ini. Mereka dapat dikonfigurasi sehingga hanya data terbaru yang diterima. Dengan TCP Anda menjalankan
risiko mengalami <em>Head-of-line blocking</em>. Klik mouse atau penekanan tombol lama bisa tiba terlambat, dan memblokir yang berikutnya agar tidak diterima.
<em>Data channel</em> WebRTC dirancang untuk menangani ini dan dapat dikonfigurasi untuk tidak mengirim ulang paket yang hilang. Anda juga dapat mengukur <em>backpressure</em> dan
memastikan bahwa Anda tidak mengirim lebih banyak data daripada yang didukung jaringan Anda.</p><p>WebRTC yang tersedia di peramban telah menjadi peningkatan kualitas hidup yang besar. Anda tidak perlu mengunduh klien propriet untuk memulai
sesi. Semakin banyak klien yang dilengkapi dengan WebRTC, Smart TV sekarang mendapatkan peramban web lengkap.</p><h3 id=berbagi-file-dan-penghindaran-sensor>Berbagi File dan Penghindaran Sensor
<a class=anchor href=#berbagi-file-dan-penghindaran-sensor>#</a></h3><p>Berbagi File dan Penghindaran Sensor adalah masalah yang sangat berbeda. Namun, WebRTC menyelesaikan masalah yang sama untuk keduanya. Ini membuat
keduanya mudah tersedia dan lebih sulit untuk diblokir.</p><p>Masalah pertama yang diselesaikan WebRTC adalah mendapatkan klien. Jika Anda ingin bergabung dengan jaringan berbagi file, Anda perlu mengunduh klien. Bahkan jika
jaringan terdistribusi, Anda masih perlu mendapatkan klien terlebih dahulu. Dalam jaringan yang dibatasi, unduhan sering diblokir. Bahkan jika Anda
dapat mengunduhnya, pengguna mungkin tidak dapat menginstal dan menjalankan klien. WebRTC tersedia di setiap peramban web yang membuatnya mudah tersedia.</p><p>Masalah kedua yang diselesaikan WebRTC adalah traffic Anda yang diblokir. Jika Anda menggunakan protokol yang hanya untuk berbagi file atau penghindaran sensor
lebih mudah untuk memblokirnya. Karena WebRTC adalah protokol tujuan umum, memblokirnya akan berdampak pada semua orang. Memblokir WebRTC mungkin mencegah
pengguna jaringan lain dari bergabung dengan panggilan konferensi.</p><h3 id=internet-of-things>Internet of Things
<a class=anchor href=#internet-of-things>#</a></h3><p>Internet of Things (IoT) mencakup beberapa kasus penggunaan yang berbeda. Bagi banyak orang ini berarti kamera keamanan yang terhubung ke jaringan. Menggunakan WebRTC Anda dapat melakukan <em>streaming</em> video ke <em>peer</em> WebRTC lain
seperti ponsel Anda atau peramban. Kasus penggunaan lainnya adalah memiliki perangkat yang terhubung dan bertukar data sensor. Anda dapat memiliki dua perangkat di LAN Anda
bertukar pembacaan iklim, kebisingan, atau cahaya.</p><p>WebRTC memiliki keuntungan privasi besar di sini dibandingkan protokol <em>stream</em> video lama. Karena WebRTC mendukung konektivitas P2P, kamera dapat mengirim video
langsung ke peramban Anda. Tidak ada alasan untuk video Anda dikirim ke <em>server</em> pihak ketiga. Bahkan ketika video dienkripsi, penyerang dapat membuat
asumsi dari metadata panggilan.</p><p>Interoperabilitas adalah keuntungan lain untuk ruang IoT. WebRTC tersedia dalam banyak bahasa berbeda; C#, C++, C, Go, Java, Python, Rust
dan TypeScript. Ini berarti Anda dapat menggunakan bahasa yang paling cocok untuk Anda. Anda juga tidak perlu beralih ke protokol atau format proprietary
untuk dapat menghubungkan klien Anda.</p><h3 id=_media-protocol-bridging_><em>Media Protocol Bridging</em>
<a class=anchor href=#_media-protocol-bridging_>#</a></h3><p>Anda memiliki perangkat keras dan perangkat lunak yang ada yang menghasilkan video, tetapi Anda belum dapat mengupgradenya. Mengharapkan pengguna untuk mengunduh klien proprietary
untuk menonton video itu membuat frustrasi. Jawabannya adalah menjalankan <em>bridge</em> WebRTC. <em>Bridge</em> menerjemahkan antara dua protokol sehingga pengguna dapat menggunakan
peramban dengan pengaturan lama Anda.</p><p>Banyak format yang di-<em>bridge</em> oleh <em>developer</em> menggunakan protokol yang sama dengan WebRTC. SIP umumnya diekspos melalui WebRTC dan memungkinkan pengguna untuk melakukan panggilan telepon
dari peramban mereka. RTSP digunakan di banyak kamera keamanan lama. Keduanya menggunakan protokol dasar yang sama (RTP dan SDP) sehingga murah secara komputasi
untuk dijalankan. <em>Bridge</em> hanya diperlukan untuk menambahkan atau menghapus hal-hal yang spesifik untuk WebRTC.</p><h3 id=_data-protocol-bridging_><em>Data Protocol Bridging</em>
<a class=anchor href=#_data-protocol-bridging_>#</a></h3><p>Peramban web hanya dapat berbicara dengan set protokol yang terbatas. Anda dapat menggunakan HTTP, WebSocket, WebRTC dan QUIC. Jika Anda ingin terhubung
ke hal lain, Anda perlu menggunakan <em>protocol bridge</em>. <em>Protocol bridge</em> adalah <em>server</em> yang mengonversi traffic asing menjadi sesuatu yang dapat diakses peramban.
Contoh populer adalah menggunakan SSH dari peramban Anda untuk mengakses <em>server</em>. <em>Data channel</em> WebRTC memiliki dua keuntungan dibanding kompetisi.</p><p><em>Data channel</em> WebRTC memungkinkan pengiriman tidak andal dan tidak terurut. Dalam kasus di mana latensi rendah kritis ini diperlukan. Anda tidak ingin data baru
diblokir oleh data lama, ini dikenal sebagai <em>head-of-line blocking</em>. Bayangkan Anda bermain game <em>First-person shooter</em> multipemain. Apakah Anda benar-benar peduli di mana
pemain berada dua detik yang lalu? Jika data itu tidak tiba tepat waktu, tidak masuk akal untuk terus mencoba mengirimnya. Pengiriman tidak andal dan tidak terurut memungkinkan
Anda menggunakan data segera setelah tiba.</p><p><em>Data channel</em> juga menyediakan <em>feedback pressure</em>. Ini memberi tahu Anda jika Anda mengirim data lebih cepat daripada yang dapat didukung koneksi Anda. Anda kemudian memiliki dua
pilihan ketika ini terjadi. <em>Data channel</em> dapat dikonfigurasi untuk <em>buffer</em> dan mengirimkan data terlambat, atau Anda dapat menjatuhkan data yang belum tiba
dalam <em>real-time</em>.</p><h3 id=teleoperation>Teleoperation
<a class=anchor href=#teleoperation>#</a></h3><p><em>Teleoperation</em> adalah tindakan mengendalikan perangkat dari jarak jauh melalui <em>data channel</em> WebRTC, dan mengirim video kembali melalui RTP. <em>Developer</em> mengemudikan mobil dari jarak jauh
melalui WebRTC hari ini! Ini digunakan untuk mengendalikan robot di lokasi konstruksi dan mengirim paket. Menggunakan WebRTC untuk masalah ini masuk akal karena dua alasan.</p><p>Keberadaan WebRTC di mana-mana memudahkan untuk memberikan kontrol kepada pengguna. Yang dibutuhkan pengguna hanyalah peramban web dan perangkat input. Peramban bahkan
mendukung pengambilan input dari <em>joystick</em> dan <em>gamepad</em>. WebRTC sepenuhnya menghilangkan kebutuhan untuk menginstal klien tambahan di perangkat pengguna.</p><h3 id=cdn-terdistribusi>CDN Terdistribusi
<a class=anchor href=#cdn-terdistribusi>#</a></h3><p>CDN terdistribusi adalah subset dari berbagi file. File yang didistribusikan dikonfigurasi oleh operator CDN sebagai gantinya. Ketika pengguna bergabung dengan jaringan CDN
mereka dapat mengunduh dan berbagi file yang diizinkan. Pengguna mendapat semua manfaat yang sama seperti berbagi file.</p><p>CDN ini bekerja dengan baik ketika Anda berada di kantor dengan konektivitas eksternal yang buruk, tetapi konektivitas LAN yang bagus. Anda dapat memiliki satu pengguna mengunduh video, dan
kemudian membagikannya dengan orang lain. Karena tidak semua orang mencoba mengambil file yang sama melalui jaringan eksternal, transfer akan selesai lebih cepat.</p><h2 id=topologi-webrtc>Topologi WebRTC
<a class=anchor href=#topologi-webrtc>#</a></h2><p>WebRTC adalah protokol untuk menghubungkan dua <em>agent</em>, jadi bagaimana <em>developer</em> menghubungkan ratusan orang sekaligus? Ada beberapa cara berbeda
yang dapat Anda lakukan, dan semuanya memiliki pro dan kontra. Solusi ini secara luas terbagi dalam dua kategori; <em>Peer-to-Peer</em> atau <em>Client/Server</em>. Fleksibilitas WebRTC
memungkinkan kita untuk membuat keduanya.</p><h3 id=_one-to-one_><em>One-To-One</em>
<a class=anchor href=#_one-to-one_>#</a></h3><p><em>One-to-One</em> adalah tipe koneksi pertama yang akan Anda gunakan dengan WebRTC. Anda menghubungkan dua klien WebRTC secara langsung dan mereka dapat mengirim media dan data dua arah.
Koneksi terlihat seperti ini.</p><p><img src=../images/08-one-to-one.png alt=One-to-One title=One-to-One></p><h3 id=_full-mesh_><em>Full Mesh</em>
<a class=anchor href=#_full-mesh_>#</a></h3><p><em>Full mesh</em> adalah jawabannya jika Anda ingin membangun panggilan konferensi atau game multipemain. Dalam topologi ini setiap pengguna membuat koneksi
dengan setiap pengguna lain secara langsung. Ini memungkinkan Anda membangun aplikasi Anda, tetapi datang dengan beberapa kekurangan.</p><p>Dalam topologi <em>Full Mesh</em> setiap pengguna terhubung langsung. Itu berarti Anda harus mengenkode dan mengunggah video secara independen untuk setiap anggota panggilan.
Kondisi jaringan antara setiap koneksi akan berbeda, jadi Anda tidak dapat menggunakan kembali video yang sama. Penanganan kesalahan juga sulit dalam
penerapan ini. Anda perlu mempertimbangkan dengan hati-hati apakah Anda telah kehilangan konektivitas lengkap, atau hanya konektivitas dengan satu <em>peer remote</em>.</p><p>Karena masalah ini, <em>Full Mesh</em> paling baik digunakan untuk grup kecil. Untuk apa pun yang lebih besar, topologi <em>client/server</em> adalah yang terbaik.</p><p><img src=../images/08-full-mesh.png alt="Full mesh" title="Full mesh"></p><h3 id=_hybrid-mesh_><em>Hybrid Mesh</em>
<a class=anchor href=#_hybrid-mesh_>#</a></h3><p><em>Hybrid Mesh</em> adalah alternatif untuk <em>Full Mesh</em> yang dapat meringankan beberapa masalah <em>Full Mesh</em>. Dalam <em>Hybrid Mesh</em> koneksi tidak dibuat
antara setiap pengguna. Sebaliknya, media direlai melalui <em>peer</em> di jaringan. Ini berarti bahwa pencipta media tidak perlu menggunakan sebanyak
<em>bandwidth</em> untuk mendistribusikan media.</p><p>Ini memiliki beberapa kekurangan. Dalam pengaturan ini, pencipta asli media tidak tahu kepada siapa videonya dikirim, atau apakah
tiba dengan sukses. Anda juga akan memiliki peningkatan latensi dengan setiap <em>hop</em> di jaringan <em>Hybrid Mesh</em> Anda.</p><p><img src=../images/08-hybrid-mesh.png alt="Hybrid mesh" title="Hybrid mesh"></p><h3 id=_selective-forwarding-unit_><em>Selective Forwarding Unit</em>
<a class=anchor href=#_selective-forwarding-unit_>#</a></h3><p>SFU (<em>Selective Forwarding Unit</em>) juga menyelesaikan masalah <em>Full Mesh</em>, tetapi dengan cara yang sama sekali berbeda. SFU mengimplementasikan topologi <em>client/server</em>, bukannya P2P.
Setiap <em>peer</em> WebRTC terhubung ke SFU dan mengunggah medianya. SFU kemudian meneruskan media ini ke setiap klien yang terhubung.</p><p>Dengan SFU setiap klien WebRTC hanya perlu mengenkode dan mengunggah video mereka sekali. Beban mendistribusikannya ke semua penonton ada pada SFU.
Konektivitas dengan SFU juga jauh lebih mudah daripada P2P. Anda dapat menjalankan SFU pada alamat yang dapat di-<em>route</em> secara global, membuatnya jauh lebih mudah bagi klien untuk terhubung.
Anda tidak perlu khawatir tentang <em>NAT Mapping</em>. Anda masih perlu memastikan SFU Anda tersedia melalui TCP (baik melalui ICE-TCP atau TURN).</p><p>Membangun SFU sederhana dapat dilakukan dalam satu akhir pekan. Membangun SFU yang baik yang dapat menangani semua jenis klien tidak pernah berakhir. Menyetel <em>Congestion Control</em>, <em>Error
Correction</em> dan Kinerja adalah tugas yang tidak pernah berakhir.</p><p><img src=../images/08-sfu.png alt="Selective Forwarding Unit" title="Selective Forwarding Unit"></p><h3 id=mcu>MCU
<a class=anchor href=#mcu>#</a></h3><p>MCU (<em>Multi-point Conferencing Unit</em>) adalah topologi <em>client/server</em> seperti SFU, tetapi menyusun <em>stream</em> output. Alih-alih mendistribusikan media keluar
yang tidak dimodifikasi, ia mengenkodekannya kembali sebagai satu <em>feed</em>.</p><p><img src=../images/08-mcu.png alt="Multi-point Conferencing Unit" title="Multi-point Conferencing Unit"></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/08-applied-webrtc.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#berdasarkan-kasus-penggunaan>Berdasarkan Kasus Penggunaan</a><ul><li><a href=#conferencing>Conferencing</a></li><li><a href=#_broadcasting_><em>Broadcasting</em></a></li><li><a href=#_remote-access_><em>Remote Access</em></a></li><li><a href=#berbagi-file-dan-penghindaran-sensor>Berbagi File dan Penghindaran Sensor</a></li><li><a href=#internet-of-things>Internet of Things</a></li><li><a href=#_media-protocol-bridging_><em>Media Protocol Bridging</em></a></li><li><a href=#_data-protocol-bridging_><em>Data Protocol Bridging</em></a></li><li><a href=#teleoperation>Teleoperation</a></li><li><a href=#cdn-terdistribusi>CDN Terdistribusi</a></li></ul></li><li><a href=#topologi-webrtc>Topologi WebRTC</a><ul><li><a href=#_one-to-one_><em>One-To-One</em></a></li><li><a href=#_full-mesh_><em>Full Mesh</em></a></li><li><a href=#_hybrid-mesh_><em>Hybrid Mesh</em></a></li><li><a href=#_selective-forwarding-unit_><em>Selective Forwarding Unit</em></a></li><li><a href=#mcu>MCU</a></li></ul></li></ul></nav></div></aside></main></body></html>