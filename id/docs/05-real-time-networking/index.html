<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Real-time Networking # Mengapa jaringan begitu penting dalam komunikasi Real-time? # Jaringan adalah faktor pembatas dalam komunikasi Real-time. Dalam dunia yang ideal kita akan memiliki bandwidth tak terbatas dan paket akan tiba secara instan. Namun ini tidak terjadi. Jaringan terbatas, dan kondisinya dapat berubah kapan saja. Mengukur dan mengamati kondisi jaringan juga merupakan masalah yang sulit. Anda bisa mendapatkan perilaku yang berbeda tergantung pada perangkat keras, perangkat lunak dan konfigurasinya."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/05-real-time-networking/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Real-time Networking"><meta property="og:description" content="Real-time Networking # Mengapa jaringan begitu penting dalam komunikasi Real-time? # Jaringan adalah faktor pembatas dalam komunikasi Real-time. Dalam dunia yang ideal kita akan memiliki bandwidth tak terbatas dan paket akan tiba secara instan. Namun ini tidak terjadi. Jaringan terbatas, dan kondisinya dapat berubah kapan saja. Mengukur dan mengamati kondisi jaringan juga merupakan masalah yang sulit. Anda bisa mendapatkan perilaku yang berbeda tergantung pada perangkat keras, perangkat lunak dan konfigurasinya."><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Real-time Networking | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/05-real-time-networking/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/05-real-time-networking/ title="Real-time Networking"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/05-real-time-networking/ title=Realtidsnätverk><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/05-real-time-networking/ title="Сетевое взаимодействие в реальном времени"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/05-real-time-networking/ title=搭建实时网络><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/05-real-time-networking/ title=リアルタイム・ネットワーキング><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/05-real-time-networking/ title="شبکه بی درنگ"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/05-real-time-networking/ title="Réseau en temps réel"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/05-real-time-networking/ title="Redes en Tiempo Real"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/05-real-time-networking/ title="Gerçek Zamanlı Ağ İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/05-real-time-networking/ title="실시간 네트워킹"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/05-real-time-networking/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/05-real-time-networking/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/05-real-time-networking/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/05-real-time-networking/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/05-real-time-networking/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/05-real-time-networking/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/05-real-time-networking/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/05-real-time-networking/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/05-real-time-networking/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/05-real-time-networking/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/>Connecting</a></li><li><a href=/id/docs/04-securing/>Securing</a></li><li><a href=/id/docs/05-real-time-networking/ class=active>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/>Media Communication</a></li><li><a href=/id/docs/07-data-communication/>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Real-time Networking</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#mengapa-jaringan-begitu-penting-dalam-komunikasi-_real-time_>Mengapa jaringan begitu penting dalam komunikasi <em>Real-time</em>?</a></li><li><a href=#apa-atribut-jaringan-yang-membuatnya-sulit>Apa atribut jaringan yang membuatnya sulit?</a><ul><li></li><li><a href=#_congestion_><em>Congestion</em></a></li><li><a href=#dinamis>Dinamis</a></li></ul></li><li><a href=#menyelesaikan-_packet-loss_>Menyelesaikan <em>Packet Loss</em></a><ul><li><a href=#_acknowledgments_><em>Acknowledgments</em></a></li><li><a href=#_selective-acknowledgments_><em>Selective Acknowledgments</em></a></li><li><a href=#_negative-acknowledgments_><em>Negative Acknowledgments</em></a></li><li><a href=#_forward-error-correction_><em>Forward Error Correction</em></a></li></ul></li><li><a href=#menyelesaikan-_jitter_>Menyelesaikan <em>Jitter</em></a><ul><li><a href=#operasi-jitterbuffer>Operasi JitterBuffer</a></li></ul></li><li><a href=#mendeteksi-_congestion_>Mendeteksi <em>Congestion</em></a></li><li><a href=#menyelesaikan-_congestion_>Menyelesaikan <em>Congestion</em></a><ul><li><a href=#mengirim-lebih-lambat>Mengirim Lebih Lambat</a></li><li><a href=#mengirim-lebih-sedikit>Mengirim Lebih Sedikit</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=real-time-networking>Real-time Networking
<a class=anchor href=#real-time-networking>#</a></h1><h2 id=mengapa-jaringan-begitu-penting-dalam-komunikasi-_real-time_>Mengapa jaringan begitu penting dalam komunikasi <em>Real-time</em>?
<a class=anchor href=#mengapa-jaringan-begitu-penting-dalam-komunikasi-_real-time_>#</a></h2><p>Jaringan adalah faktor pembatas dalam komunikasi <em>Real-time</em>. Dalam dunia yang ideal kita akan memiliki <em>bandwidth</em> tak terbatas
dan paket akan tiba secara instan. Namun ini tidak terjadi. Jaringan terbatas, dan kondisinya
dapat berubah kapan saja. Mengukur dan mengamati kondisi jaringan juga merupakan masalah yang sulit. Anda bisa mendapatkan perilaku yang berbeda
tergantung pada perangkat keras, perangkat lunak dan konfigurasinya.</p><p>Komunikasi <em>real-time</em> juga menghadirkan masalah yang tidak ada di sebagian besar domain lain. Untuk <em>developer</em> web, tidak fatal
jika situs web Anda lebih lambat di beberapa jaringan. Selama semua data tiba, pengguna senang. Dengan WebRTC, jika data Anda
terlambat, itu tidak berguna. Tidak ada yang peduli tentang apa yang dikatakan dalam panggilan konferensi 5 detik yang lalu. Jadi ketika mengembangkan sistem komunikasi <em>realtime</em>,
Anda harus membuat <em>trade-off</em>. Apa batas waktu saya, dan berapa banyak data yang dapat saya kirim?</p><p>Bab ini mencakup konsep yang berlaku untuk komunikasi data dan media. Pada bab selanjutnya kita akan melampaui
teorinya dan membahas bagaimana subsistem media dan data WebRTC menyelesaikan masalah ini.</p><h2 id=apa-atribut-jaringan-yang-membuatnya-sulit>Apa atribut jaringan yang membuatnya sulit?
<a class=anchor href=#apa-atribut-jaringan-yang-membuatnya-sulit>#</a></h2><p>Kode yang efektif bekerja di semua jaringan adalah rumit. Anda memiliki banyak faktor berbeda, dan mereka
semua dapat saling mempengaruhi secara halus. Ini adalah masalah paling umum yang akan dihadapi <em>developer</em>.</p><h4 id=_bandwidth_><em>Bandwidth</em>
<a class=anchor href=#_bandwidth_>#</a></h4><p><em>Bandwidth</em> adalah laju maksimum data yang dapat ditransfer melintasi jalur tertentu. Penting untuk diingat
ini juga bukan angka statis. <em>Bandwidth</em> akan berubah sepanjang rute seiring lebih banyak (atau lebih sedikit) orang menggunakannya.</p><h4 id=_transmission-time_-dan-_round-trip-time_><em>Transmission Time</em> dan <em>Round Trip Time</em>
<a class=anchor href=#_transmission-time_-dan-_round-trip-time_>#</a></h4><p><em>Transmission Time</em> adalah berapa lama waktu yang dibutuhkan paket untuk tiba di tujuannya. Seperti <em>Bandwidth</em> ini tidak konstan. <em>Transmission Time</em> dapat berfluktuasi kapan saja.</p><p><code>transmission_time = receive_time - send_time</code></p><p>Untuk menghitung <em>transmission time</em>, Anda memerlukan jam pada pengirim dan penerima yang disinkronkan dengan presisi milidetik.
Bahkan penyimpangan kecil akan menghasilkan pengukuran <em>transmission time</em> yang tidak dapat diandalkan.
Karena WebRTC beroperasi di lingkungan yang sangat heterogen, hampir mustahil untuk mengandalkan sinkronisasi waktu sempurna antara <em>host</em>.</p><p>Pengukuran <em>round-trip time</em> adalah solusi untuk sinkronisasi jam yang tidak sempurna.</p><p>Alih-alih beroperasi pada jam terdistribusi, <em>peer</em> WebRTC mengirim paket khusus dengan <em>timestamp</em>-nya sendiri <code>sendertime1</code>.
<em>Peer</em> yang bekerja sama menerima paket dan memantulkan <em>timestamp</em> kembali ke pengirim.
Setelah pengirim asli mendapat waktu yang dipantulkan, ia mengurangi <em>timestamp</em> <code>sendertime1</code> dari waktu saat ini <code>sendertime2</code>.
Delta waktu ini disebut &ldquo;<em>round-trip propagation delay</em>&rdquo; atau lebih umum <em>round-trip time</em>.</p><p><code>rtt = sendertime2 - sendertime1</code></p><p>Setengah dari <em>round trip time</em> dianggap sebagai perkiraan yang cukup baik dari <em>transmission time</em>.
Solusi ini tidak tanpa kekurangan.
Ini membuat asumsi bahwa dibutuhkan waktu yang sama untuk mengirim dan menerima paket.
Namun pada jaringan seluler, operasi pengiriman dan penerimaan mungkin tidak simetris waktu.
Anda mungkin telah memperhatikan bahwa kecepatan unggah pada ponsel Anda hampir selalu lebih rendah daripada kecepatan unduh.</p><p><code>transmission_time = rtt/2</code></p><p>Teknisnya pengukuran <em>round-trip time</em> dijelaskan lebih detail dalam <a href=../06-media-communication/#receiver-reports--sender-reports>bab RTCP Sender dan Receiver Reports</a>.</p><h4 id=_jitter_><em>Jitter</em>
<a class=anchor href=#_jitter_>#</a></h4><p><em>Jitter</em> adalah fakta bahwa <code>Transmission Time</code> dapat bervariasi untuk setiap paket. Paket Anda dapat ditunda, tetapi kemudian tiba dalam ledakan.</p><h4 id=_packet-loss_><em>Packet Loss</em>
<a class=anchor href=#_packet-loss_>#</a></h4><p><em>Packet Loss</em> adalah ketika pesan hilang dalam transmisi. Kehilangan bisa stabil, atau bisa datang dalam lonjakan.
Ini bisa karena jenis jaringan seperti satelit atau Wi-Fi. Atau bisa diperkenalkan oleh perangkat lunak di sepanjang jalan.</p><h4 id=_maximum-transmission-unit_><em>Maximum Transmission Unit</em>
<a class=anchor href=#_maximum-transmission-unit_>#</a></h4><p><em>Maximum Transmission Unit</em> adalah batas seberapa besar satu paket tunggal bisa. Jaringan tidak mengizinkan Anda mengirim
satu pesan raksasa. Pada level protokol, pesan mungkin harus dipecah menjadi beberapa paket yang lebih kecil.</p><p>MTU juga akan berbeda tergantung pada jalur jaringan apa yang Anda ambil. Anda dapat
menggunakan protokol seperti <a href=https://tools.ietf.org/html/rfc1191>Path MTU Discovery</a> untuk mengetahui ukuran paket terbesar yang dapat Anda kirim.</p><h3 id=_congestion_><em>Congestion</em>
<a class=anchor href=#_congestion_>#</a></h3><p><em>Congestion</em> adalah ketika batas jaringan telah tercapai. Ini biasanya karena Anda telah mencapai puncak
<em>bandwidth</em> yang dapat ditangani rute saat ini. Atau bisa operator yang memaksakan seperti batas per jam yang dikonfigurasi ISP Anda.</p><p><em>Congestion</em> menampakkan dirinya dalam banyak cara berbeda. Tidak ada perilaku standar. Dalam kebanyakan kasus ketika <em>congestion</em>
tercapai jaringan akan menjatuhkan paket berlebih. Dalam kasus lain jaringan akan <em>buffer</em>. Ini akan menyebabkan <em>Transmission Time</em>
untuk paket Anda meningkat. Anda juga dapat melihat lebih banyak <em>jitter</em> saat jaringan Anda menjadi padat. Ini adalah area yang berubah dengan cepat
dan algoritma baru untuk deteksi <em>congestion</em> masih ditulis.</p><h3 id=dinamis>Dinamis
<a class=anchor href=#dinamis>#</a></h3><p>Jaringan sangat dinamis dan kondisinya dapat berubah dengan cepat. Selama panggilan Anda dapat mengirim dan menerima ratusan ribu paket.
Paket-paket itu akan melakukan perjalanan melalui beberapa <em>hop</em>. <em>Hop</em> tersebut akan dibagikan oleh jutaan pengguna lain. Bahkan di jaringan lokal Anda, Anda dapat memiliki
film HD yang diunduh atau mungkin perangkat memutuskan untuk mengunduh pembaruan perangkat lunak.</p><p>Memiliki panggilan yang baik tidak sesederhana mengukur jaringan Anda saat startup. Anda perlu terus mengevaluasi. Anda juga perlu menangani semua perilaku berbeda
yang berasal dari banyak perangkat keras dan perangkat lunak jaringan.</p><h2 id=menyelesaikan-_packet-loss_>Menyelesaikan <em>Packet Loss</em>
<a class=anchor href=#menyelesaikan-_packet-loss_>#</a></h2><p>Menangani <em>packet loss</em> adalah masalah pertama untuk diselesaikan. Ada beberapa cara untuk menyelesaikannya, masing-masing dengan manfaatnya sendiri. Ini tergantung pada apa yang Anda kirim dan seberapa
toleran Anda terhadap latensi. Penting juga untuk dicatat bahwa tidak semua <em>packet loss</em> fatal. Kehilangan beberapa video mungkin bukan masalah, mata manusia mungkin bahkan tidak
mampu menganggapnya. Kehilangan pesan teks pengguna adalah fatal.</p><p>Katakanlah Anda mengirim 10 paket, dan paket 5 dan 6 hilang. Ini adalah cara Anda dapat menyelesaikannya.</p><h3 id=_acknowledgments_><em>Acknowledgments</em>
<a class=anchor href=#_acknowledgments_>#</a></h3><p><em>Acknowledgments</em> adalah ketika penerima memberi tahu pengirim setiap paket yang telah mereka terima. Pengirim menyadari <em>packet loss</em> ketika ia mendapat <em>acknowledgment</em>
untuk paket dua kali yang bukan final. Ketika pengirim mendapat <code>ACK</code> untuk paket 4 dua kali, ia tahu bahwa paket 5 belum terlihat.</p><h3 id=_selective-acknowledgments_><em>Selective Acknowledgments</em>
<a class=anchor href=#_selective-acknowledgments_>#</a></h3><p><em>Selective Acknowledgments</em> adalah peningkatan dari <em>Acknowledgments</em>. Penerima dapat mengirim <code>SACK</code> yang mengakui beberapa paket dan memberi tahu pengirim tentang kesenjangan.
Sekarang pengirim dapat mendapat <code>SACK</code> untuk paket 4 dan 7. Kemudian ia tahu ia perlu mengirim ulang paket 5 dan 6.</p><h3 id=_negative-acknowledgments_><em>Negative Acknowledgments</em>
<a class=anchor href=#_negative-acknowledgments_>#</a></h3><p><em>Negative Acknowledgments</em> menyelesaikan masalah dengan cara sebaliknya. Alih-alih memberi tahu pengirim apa yang telah diterimanya, penerima memberi tahu pengirim apa yang telah hilang. Dalam kasus kami <code>NACK</code>
akan dikirim untuk paket 5 dan 6. Pengirim hanya mengetahui paket yang ingin dikirim ulang oleh penerima.</p><h3 id=_forward-error-correction_><em>Forward Error Correction</em>
<a class=anchor href=#_forward-error-correction_>#</a></h3><p><em>Forward Error Correction</em> memperbaiki <em>packet loss</em> secara pre-emptif. Pengirim mengirim data redundan, yang berarti paket yang hilang tidak mempengaruhi <em>stream</em> akhir. Salah satu algoritma populer untuk
ini adalah koreksi kesalahan Reed–Solomon.</p><p>Ini mengurangi latensi/kompleksitas pengiriman dan penanganan <em>Acknowledgments</em>. <em>Forward Error Correction</em> adalah pemborosan <em>bandwidth</em> jika jaringan tempat Anda berada memiliki nol kehilangan.</p><h2 id=menyelesaikan-_jitter_>Menyelesaikan <em>Jitter</em>
<a class=anchor href=#menyelesaikan-_jitter_>#</a></h2><p><em>Jitter</em> hadir di sebagian besar jaringan. Bahkan di dalam LAN Anda memiliki banyak perangkat yang mengirim data pada tingkat yang berfluktuasi. Anda dapat dengan mudah mengamati <em>jitter</em> dengan melakukan ping perangkat lain dengan perintah <code>ping</code> dan memperhatikan fluktuasi dalam latensi <em>round-trip</em>.</p><p>Untuk menyelesaikan <em>jitter</em>, klien menggunakan JitterBuffer. JitterBuffer memastikan waktu pengiriman paket yang stabil. Kelemahannya adalah JitterBuffer menambahkan beberapa latensi ke paket yang tiba lebih awal.
Sisi baiknya adalah paket yang terlambat tidak menyebabkan <em>jitter</em>. Bayangkan bahwa selama panggilan, Anda melihat waktu kedatangan paket berikut:</p><pre tabindex=0><code>* time=1.46 ms
* time=1.93 ms
* time=1.57 ms
* time=1.55 ms
* time=1.54 ms
* time=1.72 ms
* time=1.45 ms
* time=1.73 ms
* time=1.80 ms
</code></pre><p>Dalam kasus ini, sekitar 1,8 ms akan menjadi pilihan yang baik. Paket yang tiba terlambat akan menggunakan jendela latensi kami. Paket yang tiba lebih awal akan ditunda sedikit dan dapat
mengisi jendela yang habis oleh paket yang terlambat. Ini berarti kita tidak lagi memiliki gagap dan memberikan tingkat pengiriman yang lancar untuk klien.</p><h3 id=operasi-jitterbuffer>Operasi JitterBuffer
<a class=anchor href=#operasi-jitterbuffer>#</a></h3><p><img src=../images/05-jitterbuffer.png alt=JitterBuffer title=JitterBuffer></p><p>Setiap paket ditambahkan ke <em>jitter buffer</em> segera setelah diterima.
Setelah ada cukup paket untuk merekonstruksi <em>frame</em>, paket yang membentuk <em>frame</em> dilepaskan dari <em>buffer</em> dan dikeluarkan untuk dekoding.
Decoder, pada gilirannya, mendekode dan menggambar <em>frame</em> video di layar pengguna.
Karena <em>jitter buffer</em> memiliki kapasitas terbatas, paket yang tetap di <em>buffer</em> terlalu lama akan dibuang.</p><p>Baca lebih lanjut tentang bagaimana <em>frame</em> video dikonversi menjadi paket RTP, dan mengapa rekonstruksi diperlukan <a href=../06-media-communication/#rtp>dalam bab komunikasi media</a>.</p><p><code>jitterBufferDelay</code> memberikan wawasan yang baik tentang kinerja jaringan Anda dan pengaruhnya pada kelancaran pemutaran.
Ini adalah bagian dari <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay>WebRTC statistics API</a> yang relevan dengan <em>stream</em> masuk penerima.
Penundaan mendefinisikan jumlah waktu <em>frame</em> video menghabiskan di <em>jitter buffer</em> sebelum dikeluarkan untuk dekoding.
Penundaan <em>jitter buffer</em> yang panjang berarti jaringan Anda sangat padat.</p><h2 id=mendeteksi-_congestion_>Mendeteksi <em>Congestion</em>
<a class=anchor href=#mendeteksi-_congestion_>#</a></h2><p>Sebelum kita dapat menyelesaikan <em>congestion</em>, kita perlu mendeteksinya. Untuk mendeteksinya kita menggunakan <em>congestion controller</em>. Ini adalah subjek yang rumit, dan masih berubah dengan cepat.
Algoritma baru masih diterbitkan dan diuji. Pada level tinggi mereka semua beroperasi sama. <em>Congestion controller</em> memberikan estimasi <em>bandwidth</em> yang diberikan beberapa input.
Ini beberapa input yang mungkin:</p><ul><li><strong>Packet Loss</strong> - Paket dijatuhkan saat jaringan menjadi padat.</li><li><strong>Jitter</strong> - Saat peralatan jaringan menjadi lebih kelebihan beban, antrian paket akan menyebabkan waktu menjadi tidak menentu.</li><li><strong>Round Trip Time</strong> - Paket membutuhkan waktu lebih lama untuk tiba ketika padat. Tidak seperti <em>jitter</em>, <em>Round Trip Time</em> terus meningkat.</li><li><strong>Explicit Congestion Notification</strong> - Jaringan yang lebih baru dapat menandai paket sebagai berisiko dijatuhkan untuk mengurangi <em>congestion</em>.</li></ul><p>Nilai-nilai ini perlu diukur terus-menerus selama panggilan. Pemanfaatan jaringan dapat meningkat atau menurun, sehingga <em>bandwidth</em> yang tersedia dapat terus berubah.</p><h2 id=menyelesaikan-_congestion_>Menyelesaikan <em>Congestion</em>
<a class=anchor href=#menyelesaikan-_congestion_>#</a></h2><p>Sekarang kita memiliki estimasi <em>bandwidth</em> kita perlu menyesuaikan apa yang kita kirim. Bagaimana kita menyesuaikan tergantung pada jenis data apa yang ingin kita kirim.</p><h3 id=mengirim-lebih-lambat>Mengirim Lebih Lambat
<a class=anchor href=#mengirim-lebih-lambat>#</a></h3><p>Membatasi kecepatan di mana Anda mengirim data adalah solusi pertama untuk mencegah <em>congestion</em>. <em>Congestion Controller</em> memberi Anda estimasi, dan itu adalah
tanggung jawab pengirim untuk membatasi laju.</p><p>Ini adalah metode yang digunakan untuk sebagian besar komunikasi data. Dengan protokol seperti TCP ini semua dilakukan oleh sistem operasi dan sepenuhnya transparan bagi pengguna dan <em>developer</em>.</p><h3 id=mengirim-lebih-sedikit>Mengirim Lebih Sedikit
<a class=anchor href=#mengirim-lebih-sedikit>#</a></h3><p>Dalam beberapa kasus kita dapat mengirim lebih sedikit informasi untuk memenuhi batas kita. Kita juga memiliki tenggat waktu keras untuk kedatangan data kita, jadi kita tidak bisa mengirim lebih lambat. Ini adalah kendala
yang dimiliki media <em>Real-time</em>.</p><p>Jika kita tidak memiliki cukup <em>bandwidth</em> yang tersedia, kita dapat menurunkan kualitas video yang kita kirim. Ini memerlukan <em>feedback loop</em> yang ketat antara <em>video encoder</em> dan <em>congestion controller</em> Anda.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/05-real-time-networking.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#mengapa-jaringan-begitu-penting-dalam-komunikasi-_real-time_>Mengapa jaringan begitu penting dalam komunikasi <em>Real-time</em>?</a></li><li><a href=#apa-atribut-jaringan-yang-membuatnya-sulit>Apa atribut jaringan yang membuatnya sulit?</a><ul><li></li><li><a href=#_congestion_><em>Congestion</em></a></li><li><a href=#dinamis>Dinamis</a></li></ul></li><li><a href=#menyelesaikan-_packet-loss_>Menyelesaikan <em>Packet Loss</em></a><ul><li><a href=#_acknowledgments_><em>Acknowledgments</em></a></li><li><a href=#_selective-acknowledgments_><em>Selective Acknowledgments</em></a></li><li><a href=#_negative-acknowledgments_><em>Negative Acknowledgments</em></a></li><li><a href=#_forward-error-correction_><em>Forward Error Correction</em></a></li></ul></li><li><a href=#menyelesaikan-_jitter_>Menyelesaikan <em>Jitter</em></a><ul><li><a href=#operasi-jitterbuffer>Operasi JitterBuffer</a></li></ul></li><li><a href=#mendeteksi-_congestion_>Mendeteksi <em>Congestion</em></a></li><li><a href=#menyelesaikan-_congestion_>Menyelesaikan <em>Congestion</em></a><ul><li><a href=#mengirim-lebih-lambat>Mengirim Lebih Lambat</a></li><li><a href=#mengirim-lebih-sedikit>Mengirim Lebih Sedikit</a></li></ul></li></ul></nav></div></aside></main></body></html>