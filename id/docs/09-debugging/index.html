<!doctype html><html lang=id dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Debugging # Debugging WebRTC bisa menjadi tugas yang menakutkan. Ada banyak bagian yang bergerak, dan semuanya bisa rusak secara independen. Jika Anda tidak hati-hati, Anda dapat kehilangan berminggu-minggu waktu melihat hal yang salah. Ketika Anda akhirnya menemukan bagian yang rusak, Anda perlu belajar sedikit untuk memahami mengapa.
Bab ini akan membawa Anda ke pola pikir untuk men-debug WebRTC. Ini akan menunjukkan kepada Anda cara memecah masalah. Setelah kami mengetahui masalahnya, kami akan memberikan tur singkat dari alat debugging yang populer."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/id/docs/09-debugging/"><meta property="og:site_name" content="WebRTC untuk yang Ingin Tahu"><meta property="og:title" content="Debugging"><meta property="og:description" content="Debugging # Debugging WebRTC bisa menjadi tugas yang menakutkan. Ada banyak bagian yang bergerak, dan semuanya bisa rusak secara independen. Jika Anda tidak hati-hati, Anda dapat kehilangan berminggu-minggu waktu melihat hal yang salah. Ketika Anda akhirnya menemukan bagian yang rusak, Anda perlu belajar sedikit untuk memahami mengapa.
Bab ini akan membawa Anda ke pola pikir untuk men-debug WebRTC. Ini akan menunjukkan kepada Anda cara memecah masalah. Setelah kami mengetahui masalahnya, kami akan memberikan tur singkat dari alat debugging yang populer."><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-06T08:29:59-05:00"><title>Debugging | WebRTC untuk yang Ingin Tahu</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/id/docs/09-debugging/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/09-debugging/ title=Felsökning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/09-debugging/ title=Отладка><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/09-debugging/ title=调试><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/09-debugging/ title=デバッグ><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/09-debugging/ title="اشکال زدایی"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/09-debugging/ title=Débogage><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/09-debugging/ title=Depuración><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/09-debugging/ title="Hata Ayıklama"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/09-debugging/ title=디버깅><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/id.search.min.5ca498a790b39aa7b82a2aeb7754b2c9af0c10e1e7c1bd5864545c99dd3a7244.js integrity="sha256-XKSYp5Czmqe4Kirrd1Syya8MEOHnwb1YZFRcmd06ckQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/id/><span>WebRTC untuk yang Ingin Tahu</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/09-debugging/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/09-debugging/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/09-debugging/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/09-debugging/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/09-debugging/>Français</a></li><li><a href=https://webrtcforthecurious.com/es/docs/09-debugging/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/09-debugging/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/09-debugging/>한국어</a></li></ul></li></ul><ul><li><a href=/id/docs/01-what-why-and-how/>Apa, Mengapa, dan Bagaimana</a></li><li><a href=/id/docs/02-signaling/>Signaling</a></li><li><a href=/id/docs/03-connecting/>Connecting</a></li><li><a href=/id/docs/04-securing/>Securing</a></li><li><a href=/id/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/id/docs/06-media-communication/>Media Communication</a></li><li><a href=/id/docs/07-data-communication/>Data Communication</a></li><li><a href=/id/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/id/docs/09-debugging/ class=active>Debugging</a></li><li><a href=/id/docs/10-history-of-webrtc/>History</a></li><li><a href=/id/docs/11-faq/>FAQ</a></li><li><a href=/id/docs/12-glossary/>Glossary</a></li><li><a href=/id/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Debugging</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#isolasi-masalah>Isolasi Masalah</a><ul><li><a href=#kegagalan-signaling>Kegagalan Signaling</a></li><li><a href=#kegagalan-jaringan>Kegagalan Jaringan</a></li><li><a href=#kegagalan-keamanan>Kegagalan Keamanan</a></li><li><a href=#kegagalan-media>Kegagalan Media</a></li><li><a href=#kegagalan-data>Kegagalan Data</a></li></ul></li><li><a href=#alat-perdagangan>Alat perdagangan</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>Wireshark</a></li><li><a href=#alat-peramban-webrtc>Alat peramban WebRTC</a></li></ul></li><li><a href=#latensi>Latensi</a><ul><li><a href=#pengukuran-latensi-_end-to-end_-manual>Pengukuran latensi <em>end-to-end</em> manual</a></li><li><a href=#pengukuran-latensi-_end-to-end_-otomatis>Pengukuran latensi <em>end-to-end</em> otomatis</a></li><li><a href=#tips-_debugging_-latensi>Tips <em>Debugging</em> Latensi</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=debugging>Debugging
<a class=anchor href=#debugging>#</a></h1><p><em>Debugging</em> WebRTC bisa menjadi tugas yang menakutkan. Ada banyak bagian yang bergerak, dan semuanya bisa rusak secara independen. Jika Anda tidak hati-hati, Anda dapat kehilangan berminggu-minggu waktu melihat hal yang salah. Ketika Anda akhirnya menemukan bagian yang rusak, Anda perlu belajar sedikit untuk memahami mengapa.</p><p>Bab ini akan membawa Anda ke pola pikir untuk men-<em>debug</em> WebRTC. Ini akan menunjukkan kepada Anda cara memecah masalah. Setelah kami mengetahui masalahnya, kami akan memberikan tur singkat dari alat <em>debugging</em> yang populer.</p><h2 id=isolasi-masalah>Isolasi Masalah
<a class=anchor href=#isolasi-masalah>#</a></h2><p>Saat men-<em>debug</em>, Anda perlu mengisolasi dari mana masalah berasal. Mulai dari awal&mldr;</p><h3 id=kegagalan-signaling>Kegagalan Signaling
<a class=anchor href=#kegagalan-signaling>#</a></h3><h3 id=kegagalan-jaringan>Kegagalan Jaringan
<a class=anchor href=#kegagalan-jaringan>#</a></h3><p>Uji <em>server</em> STUN Anda menggunakan netcat:</p><ol><li><p>Siapkan paket permintaan pengikatan <strong>20-byte</strong>:</p><pre tabindex=0><code>echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | hexdump -C
00000000  00 01 00 00 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54                                       |TEST|
00000014
</code></pre><p>Interpretasi:</p><ul><li><code>00 01</code> adalah tipe pesan.</li><li><code>00 00</code> adalah panjang bagian data.</li><li><code>21 12 a4 42</code> adalah <em>magic cookie</em>.</li><li>dan <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (Dekode ke ASCII: <code>TESTTESTTEST</code>) adalah <em>transaction ID</em> 12-byte.</li></ul></li><li><p>Kirim permintaan dan tunggu respons <strong>32 byte</strong>:</p><pre tabindex=0><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54 00 20 00 08  00 01 6f 32 7f 36 de 89  |TEST. ....o2.6..|
00000020
</code></pre><p>Interpretasi:</p><ul><li><code>01 01</code> adalah tipe pesan</li><li><code>00 0c</code> adalah panjang bagian data yang didekode menjadi 12 dalam desimal</li><li><code>21 12 a4 42</code> adalah <em>magic cookie</em></li><li>dan <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (Dekode ke ASCII: <code>TESTTESTTEST</code>) adalah <em>transaction ID</em> 12-byte.</li><li><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> adalah data 12-byte, interpretasi:<ul><li><code>00 20</code> adalah tipenya: <code>XOR-MAPPED-ADDRESS</code></li><li><code>00 08</code> adalah panjang bagian nilai yang didekode menjadi 8 dalam desimal</li><li><code>00 01 6f 32 7f 36 de 89</code> adalah nilai data, interpretasi:<ul><li><code>00 01</code> adalah tipe alamat (IPv4)</li><li><code>6f 32</code> adalah <em>port</em> yang di-<em>XOR-mapped</em></li><li><code>7f 36 de 89</code> adalah alamat IP yang di-<em>XOR-mapped</em></li></ul></li></ul></li></ul></li></ol><p>Mendekode bagian <em>XOR-mapped</em> merepotkan, tetapi kita dapat mengelabui <em>server stun</em> untuk melakukan <em>dummy XOR-mapping</em>, dengan memberikan <em>dummy magic cookie</em> (tidak valid) yang disetel ke <code>00 00 00 00</code>:</p><pre tabindex=0><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &#34;\x00\x01\x00\x00\x00\x00\x00\x00TESTTESTTEST&#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 00 00 00 00  54 45 53 54 54 45 53 54  |........TESTTEST|
00000010  54 45 53 54 00 01 00 08  00 01 4e 20 5e 24 7a cb  |TEST......N ^$z.|
00000020
</code></pre><p><em>XOR-ing</em> terhadap <em>dummy magic cookie</em> adalah idempoten, jadi <em>port</em> dan alamat akan jelas dalam respons. Ini tidak akan bekerja dalam semua situasi, karena beberapa <em>router</em> memanipulasi paket yang lewat, curang pada alamat IP. Jika kita melihat nilai data yang dikembalikan (delapan <em>byte</em> terakhir):</p><ul><li><code>00 01 4e 20 5e 24 7a cb</code> adalah nilai data, interpretasi:<ul><li><code>00 01</code> adalah tipe alamat (IPv4)</li><li><code>4e 20</code> adalah <em>port</em> yang di-<em>mapped</em>, yang didekode menjadi 20000 dalam desimal</li><li><code>5e 24 7a cb</code> adalah alamat IP, yang didekode menjadi <code>94.36.122.203</code> dalam notasi <em>dotted-decimal</em>.</li></ul></li></ul><h3 id=kegagalan-keamanan>Kegagalan Keamanan
<a class=anchor href=#kegagalan-keamanan>#</a></h3><h3 id=kegagalan-media>Kegagalan Media
<a class=anchor href=#kegagalan-media>#</a></h3><h3 id=kegagalan-data>Kegagalan Data
<a class=anchor href=#kegagalan-data>#</a></h3><h2 id=alat-perdagangan>Alat perdagangan
<a class=anchor href=#alat-perdagangan>#</a></h2><h3 id=netcat-nc>netcat (nc)
<a class=anchor href=#netcat-nc>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Netcat>netcat</a> adalah utilitas jaringan <em>command-line</em> untuk membaca dari dan menulis ke koneksi jaringan menggunakan TCP atau UDP. Ini biasanya tersedia sebagai perintah <code>nc</code>.</p><h3 id=tcpdump>tcpdump
<a class=anchor href=#tcpdump>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Tcpdump>tcpdump</a> adalah penganalisis paket jaringan data <em>command-line</em>.</p><p>Perintah umum:</p><ul><li><p>Tangkap paket UDP ke dan dari <em>port</em> 19302, cetak <em>hexdump</em> dari konten paket:</p><p><code>sudo tcpdump 'udp port 19302' -xx</code></p></li><li><p>Sama, tetapi simpan paket dalam file PCAP (<em>packet capture</em>) untuk inspeksi nanti:</p><p><code>sudo tcpdump 'udp port 19302' -w stun.pcap</code></p><p>File PCAP dapat dibuka dengan aplikasi Wireshark: <code>wireshark stun.pcap</code></p></li></ul><h3 id=wireshark>Wireshark
<a class=anchor href=#wireshark>#</a></h3><p><a href=https://www.wireshark.org>Wireshark</a> adalah penganalisis protokol jaringan yang banyak digunakan.</p><h3 id=alat-peramban-webrtc>Alat peramban WebRTC
<a class=anchor href=#alat-peramban-webrtc>#</a></h3><p>Peramban dilengkapi dengan alat bawaan yang dapat Anda gunakan untuk memeriksa koneksi yang Anda buat. Chrome memiliki <a href=chrome://webrtc-internals><code>chrome://webrtc-internals</code></a> dan <a href=chrome://webrtc-logs><code>chrome://webrtc-logs</code></a>. Firefox memiliki <a href=about:webrtc><code>about:webrtc</code></a>.</p><h2 id=latensi>Latensi
<a class=anchor href=#latensi>#</a></h2><p>Bagaimana Anda tahu Anda memiliki latensi tinggi? Anda mungkin telah memperhatikan bahwa video Anda tertinggal, tetapi apakah Anda tahu persis berapa banyak tertinggal?
Untuk dapat mengurangi latensi ini, Anda harus mulai dengan mengukurnya terlebih dahulu.</p><p>Latensi sejati seharusnya diukur <em>end-to-end</em>. Itu berarti tidak hanya latensi jalur jaringan antara pengirim dan penerima, tetapi latensi gabungan dari pengambilan kamera, pengkodean <em>frame</em>, transmisi, penerimaan, dekoding dan tampilan, serta kemungkinan antrian antara salah satu langkah ini.</p><p>Latensi <em>end-to-end</em> bukan jumlah sederhana dari latensi setiap komponen.</p><p>Meskipun Anda secara teoritis dapat mengukur latensi komponen dari <em>pipeline</em> transmisi video langsung secara terpisah dan kemudian menambahkannya bersama-sama, dalam praktiknya, setidaknya beberapa komponen akan tidak dapat diakses untuk instrumentasi, atau menghasilkan hasil yang sangat berbeda ketika diukur di luar <em>pipeline</em>.
Kedalaman antrian variabel antara tahap <em>pipeline</em>, topologi jaringan dan perubahan eksposur kamera hanyalah beberapa contoh komponen yang mempengaruhi latensi <em>end-to-end</em>.</p><p>Latensi intrinsik dari setiap komponen dalam sistem <em>live-streaming</em> Anda dapat berubah dan mempengaruhi komponen <em>downstream</em>.
Bahkan konten video yang ditangkap mempengaruhi latensi.
Misalnya, lebih banyak bit diperlukan untuk fitur frekuensi tinggi seperti cabang pohon, dibandingkan dengan langit biru yang jelas dengan frekuensi rendah.
Kamera dengan eksposur otomatis yang diaktifkan mungkin memakan waktu <em>jauh</em> lebih lama daripada 33 milidetik yang diharapkan untuk menangkap <em>frame</em>, bahkan jika ketika tingkat pengambilan disetel ke 30 <em>frame</em> per detik.
Transmisi melalui jaringan, terutama seluler, juga sangat dinamis karena permintaan yang berubah.
Lebih banyak pengguna memperkenalkan lebih banyak obrolan di udara.
Lokasi fisik Anda (zona sinyal rendah yang terkenal) dan beberapa faktor lain meningkatkan <em>packet loss</em> dan latensi.
Apa yang terjadi ketika Anda mengirim paket ke antarmuka jaringan, katakanlah adaptor WiFi atau modem LTE untuk pengiriman?
Jika tidak dapat segera dikirim, ia akan diantrekan pada antarmuka, semakin besar antrian semakin banyak latensi yang diperkenalkan antarmuka jaringan tersebut.</p><h3 id=pengukuran-latensi-_end-to-end_-manual>Pengukuran latensi <em>end-to-end</em> manual
<a class=anchor href=#pengukuran-latensi-_end-to-end_-manual>#</a></h3><p>Ketika kita berbicara tentang latensi <em>end-to-end</em>, yang kami maksud adalah waktu antara <em>event</em> terjadi dan diamati, artinya <em>frame</em> video muncul di layar.</p><pre tabindex=0><code>EndToEndLatency = T(observe) - T(happen)
</code></pre><p>Pendekatan naif adalah merekam waktu ketika <em>event</em> terjadi dan menguranginya dari waktu pengamatan.
Namun, karena presisi turun ke milidetik sinkronisasi waktu menjadi masalah.
Mencoba menyinkronkan jam di seluruh sistem terdistribusi sebagian besar sia-sia, bahkan kesalahan kecil dalam sinkronisasi waktu menghasilkan pengukuran latensi yang tidak dapat diandalkan.</p><p>Solusi sederhana untuk masalah sinkronisasi jam adalah menggunakan jam yang sama.
Tempatkan pengirim dan penerima dalam kerangka referensi yang sama.</p><p>Bayangkan Anda memiliki jam milidetik yang berdetak atau sumber <em>event</em> lainnya sebenarnya.
Anda ingin mengukur latensi dalam sistem yang melakukan <em>live stream</em> jam ke layar <em>remote</em> dengan mengarahkan kamera padanya.
Cara yang jelas untuk mengukur waktu antara <em>timer</em> milidetik berdetak (T<sub><code>happen</code></sub>) dan <em>frame</em> video jam muncul di layar (T<sub><code>observe</code></sub>) adalah sebagai berikut:</p><ul><li>Arahkan kamera Anda ke jam milidetik.</li><li>Kirim <em>frame</em> video ke penerima yang berada di lokasi fisik yang sama.</li><li>Ambil gambar (gunakan ponsel Anda) dari <em>timer</em> milidetik dan video yang diterima di layar.</li><li>Kurangi dua waktu.</li></ul><p>Itu adalah pengukuran latensi <em>end-to-end</em> yang paling benar untuk diri Anda sendiri.
Ini memperhitungkan semua latensi komponen (kamera, <em>encoder</em>, jaringan, <em>decoder</em>) dan tidak bergantung pada sinkronisasi jam apa pun.</p><p><img src=../images/09-diy-latency.png alt="DIY Latency" title="DIY Latency Measurement">.
<img src=../images/09-diy-latency-happen-observe.png alt="DIY Latency Example" title="DIY Latency Measurement Example">
Dalam foto di atas latensi <em>end-to-end</em> yang diukur adalah 101 milidetik. <em>Event</em> yang terjadi sekarang adalah 10:16:02.862, tetapi pengamat sistem <em>live-streaming</em> melihat 10:16:02.761.</p><h3 id=pengukuran-latensi-_end-to-end_-otomatis>Pengukuran latensi <em>end-to-end</em> otomatis
<a class=anchor href=#pengukuran-latensi-_end-to-end_-otomatis>#</a></h3><p>Pada saat penulisan (Mei 2021) standar WebRTC untuk penundaan <em>end-to-end</em> sedang aktif <a href=https://github.com/w3c/webrtc-stats/issues/537>dibahas</a>.
Firefox mengimplementasikan satu set API untuk membiarkan pengguna membuat pengukuran latensi otomatis di atas API WebRTC standar.
Namun dalam paragraf ini, kami membahas cara yang paling kompatibel untuk mengukur latensi secara otomatis.</p><p><img src=../images/09-ntp-latency.png alt="NTP Style Latency Measurement" title="NTP Style Latency Measurement"></p><p><em>Roundtrip time</em> dalam singkatnya: Saya mengirim Anda waktu saya <code>tR1</code>, ketika saya menerima kembali <code>tR1</code> saya pada waktu <code>tR2</code>, saya tahu <em>round trip time</em> adalah <code>tR2 - tR1</code>.</p><p>Diberikan saluran komunikasi antara pengirim dan penerima (misalnya <a href=https://webrtc.org/getting-started/data-channels>DataChannel</a>), penerima dapat memodelkan jam <em>monotonic</em> pengirim dengan mengikuti langkah-langkah di bawah ini:</p><ol><li>Pada waktu <code>tR1</code>, penerima mengirim pesan dengan <em>timestamp</em> jam <em>monotonic</em> lokalnya.</li><li>Ketika diterima di pengirim dengan waktu lokal <code>tS1</code>, pengirim merespons dengan salinan <code>tR1</code> serta <code>tS1</code> pengirim dan waktu <em>track video</em> pengirim <code>tSV1</code>.</li><li>Pada waktu <code>tR2</code> di sisi penerima, <em>round trip time</em> dihitung dengan mengurangi waktu pengiriman dan penerimaan pesan: <code>RTT = tR2 - tR1</code>.</li><li><em>Round trip time</em> <code>RTT</code> bersama dengan <em>timestamp</em> lokal pengirim <code>tS1</code> cukup untuk membuat estimasi jam <em>monotonic</em> pengirim. Waktu saat ini pada pengirim pada waktu <code>tR2</code> akan sama dengan <code>tS1</code> ditambah setengah dari <em>round trip time</em>.</li><li><em>Timestamp</em> jam lokal pengirim <code>tS1</code> dipasangkan dengan <em>timestamp track video</em> <code>tSV1</code> bersama dengan <em>round trip time</em> <code>RTT</code> karena itu cukup untuk menyinkronkan waktu <em>track video</em> penerima ke <em>track video</em> pengirim.</li></ol><p>Sekarang kita tahu berapa banyak waktu telah berlalu sejak waktu <em>frame video</em> pengirim yang dikenal terakhir <code>tSV1</code>, kita dapat memperkirakan latensi dengan mengurangi waktu <em>frame video</em> yang ditampilkan saat ini (<code>actual_video_time</code>) dari waktu yang diharapkan:</p><pre tabindex=0><code>expected_video_time = tSV1 + time_since(tSV1)
latency = expected_video_time - actual_video_time
</code></pre><p>Kelemahan metode ini adalah tidak termasuk latensi intrinsik kamera.
Sebagian besar sistem video menganggap <em>timestamp</em> pengambilan <em>frame</em> adalah waktu ketika <em>frame</em> dari kamera dikirim ke memori utama, yang akan beberapa saat setelah <em>event</em> yang direkam benar-benar terjadi.</p><h4 id=contoh-estimasi-latensi>Contoh estimasi latensi
<a class=anchor href=#contoh-estimasi-latensi>#</a></h4><p>Implementasi sampel membuka <em>data channel</em> <code>latency</code> pada penerima dan secara berkala mengirim <em>timestamp timer monotonic</em> penerima ke pengirim. Pengirim merespons kembali dengan pesan JSON dan penerima menghitung latensi berdasarkan pesan.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;received_time&#34;</span>: <span style=color:#ae81ff>64714</span>,       <span style=color:#75715e>// Timestamp dikirim oleh penerima, pengirim memantulkan timestamp. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;delay_since_received&#34;</span>: <span style=color:#ae81ff>46</span>,   <span style=color:#75715e>// Waktu yang berlalu sejak `received_time` terakhir diterima di pengirim.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;local_clock&#34;</span>: <span style=color:#ae81ff>1597366470336</span>, <span style=color:#75715e>// Waktu jam monotonic pengirim saat ini.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;track_times_msec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;myvideo_track1&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>13100</span>,        <span style=color:#75715e>// Timestamp RTP frame video (dalam milidetik).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>1597366470289</span> <span style=color:#75715e>// Timestamp jam monotonic frame video.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Buka <em>data channel</em> pada penerima:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>createDataChannel</span>(<span style=color:#e6db74>&#39;latency&#39;</span>);
</span></span></code></pre></div><p>Kirim waktu penerima <code>tR1</code> secara berkala. Contoh ini menggunakan 2 detik tanpa alasan tertentu:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>setInterval</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>tR1</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span></code></pre></div><p>Tangani pesan masuk dari penerima di pengirim:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Assuming event.data is a string like &#34;1234567&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span><span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>42000</span>; <span style=color:#75715e>// Current frame RTP timestamp converted to millisecond timescale.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tS1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1597366470289</span>; <span style=color:#75715e>// Current frame monotonic clock timestamp.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;received_time&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>tR1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;delay_since_received&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;local_clock&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>now</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;track_times_msec&#34;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;myvideo_track1&#34;</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>msg</span>));
</span></span></code></pre></div><p>Tangani pesan masuk dari pengirim dan cetak latensi yang diestimasi ke <code>console</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>fromSender</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;received_time&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;delay_since_received&#39;</span>]; <span style=color:#75715e>// How much time that has passed between the sender receiving and sending the response.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;local_clock&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>networkLatency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>networkLatency</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>VIDEO</span>.<span style=color:#a6e22e>requestVideoFrameCallback</span>((<span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>framemeta</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Estimate current time of the sender.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR2</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>] <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>entries</span>(<span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;track_times_msec&#39;</span>])[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tS1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>actualVideoTimeMsec</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>framemeta</span>.<span style=color:#a6e22e>rtpTimestamp</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>90</span>); <span style=color:#75715e>// Convert RTP timebase (90000) to millisecond timebase.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>latency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>actualVideoTimeMsec</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;latency&#39;</span>, <span style=color:#a6e22e>latency</span>, <span style=color:#e6db74>&#39;msec&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=waktu-video-aktual-di-peramban>Waktu video aktual di peramban
<a class=anchor href=#waktu-video-aktual-di-peramban>#</a></h4><blockquote><p><code>&lt;video>.requestVideoFrameCallback()</code> memungkinkan penulis web untuk diberi tahu ketika <em>frame</em> telah disajikan untuk komposisi.</p></blockquote><p>Sampai sangat baru-baru ini (Mei 2020), hampir tidak mungkin untuk mendapatkan <em>timestamp</em> dari <em>frame video</em> yang ditampilkan saat ini di peramban dengan andal. Metode solusi berdasarkan <code>video.currentTime</code> ada, tetapi tidak terlalu tepat.
Baik pengembang peramban Chrome dan Mozilla <a href=https://github.com/mozilla/standards-positions/issues/250>mendukung</a> pengenalan standar W3C baru, <a href=https://wicg.github.io/video-rvfc/><code>HTMLVideoElement.requestVideoFrameCallback()</code></a>, yang menambahkan <em>callback</em> API untuk mengakses waktu <em>frame video</em> saat ini.
Meskipun penambahan terdengar sepele, ini telah memungkinkan beberapa aplikasi media lanjutan di web yang memerlukan sinkronisasi audio dan video.
Khusus untuk WebRTC, <em>callback</em> akan menyertakan bidang <code>rtpTimestamp</code>, <em>timestamp</em> RTP yang terkait dengan <em>frame video</em> saat ini.
Ini harus ada untuk aplikasi WebRTC, tetapi tidak ada selain itu.</p><h3 id=tips-_debugging_-latensi>Tips <em>Debugging</em> Latensi
<a class=anchor href=#tips-_debugging_-latensi>#</a></h3><p>Karena <em>debugging</em> kemungkinan akan mempengaruhi latensi yang diukur, aturan umum adalah menyederhanakan pengaturan Anda ke yang terkecil yang mungkin yang masih dapat mereproduksi masalah.
Semakin banyak komponen yang dapat Anda hapus, semakin mudah untuk mencari tahu komponen mana yang menyebabkan masalah latensi.</p><h4 id=latensi-kamera>Latensi kamera
<a class=anchor href=#latensi-kamera>#</a></h4><p>Tergantung pada pengaturan kamera latensi kamera mungkin bervariasi.
Periksa pengaturan eksposur otomatis, fokus otomatis dan keseimbangan putih otomatis.
Semua fitur &ldquo;auto&rdquo; dari kamera web memerlukan waktu ekstra untuk menganalisis gambar yang ditangkap sebelum membuatnya tersedia untuk <em>stack</em> WebRTC.</p><p>Jika Anda di Linux, Anda dapat menggunakan alat <em>command line</em> <code>v4l2-ctl</code> untuk mengontrol pengaturan kamera:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Disable autofocus:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_auto<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Set focus to infinity:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_absolute<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Anda juga dapat menggunakan alat UI grafis <code>guvcview</code> untuk dengan cepat memeriksa dan men-<em>tweak</em> pengaturan kamera.</p><h4 id=latensi-_encoder_>Latensi <em>encoder</em>
<a class=anchor href=#latensi-_encoder_>#</a></h4><p>Sebagian besar <em>encoder</em> modern akan <em>buffer</em> beberapa <em>frame</em> sebelum mengeluarkan yang dikode.
Prioritas pertama mereka adalah keseimbangan antara kualitas gambar yang dihasilkan dan <em>bitrate</em>.
Pengkodean <em>multipass</em> adalah contoh ekstrem dari pengabaian latensi output <em>encoder</em>.
Selama <em>pass</em> pertama <em>encoder</em> mencerna seluruh video dan hanya setelah itu mulai mengeluarkan <em>frame</em>.</p><p>Namun, dengan penyetelan yang tepat orang telah mencapai latensi <em>sub-frame</em>.
Pastikan <em>encoder</em> Anda tidak menggunakan <em>reference frame</em> yang berlebihan atau bergantung pada <em>B-frame</em>.
Pengaturan penyetelan latensi setiap <em>codec</em> berbeda, tetapi untuk x264 kami merekomendasikan menggunakan <code>tune=zerolatency</code> dan <code>profile=baseline</code> untuk latensi output <em>frame</em> terendah.</p><h4 id=latensi-jaringan>Latensi jaringan
<a class=anchor href=#latensi-jaringan>#</a></h4><p>Latensi jaringan adalah salah satu yang dapat Anda lakukan paling sedikit, selain meningkatkan ke koneksi jaringan yang lebih baik.
Latensi jaringan sangat mirip dengan cuaca - Anda tidak dapat menghentikan hujan, tetapi Anda dapat memeriksa prakiraan dan membawa payung.
WebRTC mengukur kondisi jaringan dengan presisi milidetik.
Metrik penting adalah:</p><ul><li><em>Round-trip time</em>.</li><li><em>Packet loss</em> dan retransmisi paket.</li></ul><p><strong>Round-Trip Time</strong></p><p><em>Stack</em> WebRTC memiliki mekanisme pengukuran <em>round trip time</em> (RTT) jaringan bawaan <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime>mechanism</a>.
Perkiraan latensi yang cukup baik adalah setengah dari RTT. Ini mengasumsikan bahwa dibutuhkan waktu yang sama untuk mengirim dan menerima paket, yang tidak selalu terjadi.
RTT menetapkan batas bawah pada latensi <em>end-to-end</em>.
<em>Frame video</em> Anda tidak dapat mencapai penerima lebih cepat dari <code>RTT/2</code>, tidak peduli seberapa dioptimalkan <em>pipeline</em> kamera ke <em>encoder</em> Anda.</p><p>Mekanisme RTT bawaan didasarkan pada paket RTCP khusus yang disebut <em>sender/receiver reports</em>.
Pengirim mengirim pembacaan waktunya ke penerima, penerima pada gilirannya memantulkan <em>timestamp</em> yang sama ke pengirim.
Dengan demikian pengirim tahu berapa banyak waktu yang dibutuhkan paket untuk melakukan perjalanan ke penerima dan kembali.
Lihat bab <a href=../06-media-communication/#senderreceiver-reports>Sender/Receiver Reports</a> untuk lebih detail tentang pengukuran RTT.</p><p><strong>Packet loss dan retransmisi paket</strong></p><p>Baik RTP dan RTCP adalah protokol berdasarkan UDP, yang tidak memiliki jaminan pengurutan, pengiriman yang berhasil, atau non-duplikasi.
Semua hal di atas dapat dan memang terjadi dalam aplikasi WebRTC dunia nyata.
Implementasi <em>decoder</em> yang tidak canggih mengharapkan semua paket dari <em>frame</em> dikirim agar <em>decoder</em> berhasil merakit gambar.
Dalam kehadiran <em>packet loss</em> artefak dekoding mungkin muncul jika paket dari <a href=../06-media-communication/#inter-frame-types>P-frame</a> hilang.
Jika paket I-frame hilang maka semua <em>frame</em> dependen akan mendapatkan artefak berat atau tidak akan didekode sama sekali.
Kemungkinan besar ini akan membuat video &ldquo;membeku&rdquo; untuk sesaat.</p><p>Untuk menghindari (yah, setidaknya untuk mencoba menghindari) pembekuan video atau artefak dekoding, WebRTC menggunakan pesan pengakuan negatif (<a href=../06-media-communication/#negative-acknowledgment>NACK</a>).
Ketika penerima tidak mendapatkan paket RTP yang diharapkan, ia mengembalikan pesan NACK untuk memberi tahu pengirim untuk mengirim paket yang hilang lagi.
Penerima <em>menunggu</em> untuk retransmisi paket.
Retransmisi seperti itu menyebabkan peningkatan latensi.
Jumlah paket NACK yang dikirim dan diterima dicatat dalam bidang statistik bawaan WebRTC <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcoutboundrtpstreamstats-nackcount>outbound stream nackCount</a> dan <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-nackcount>inbound stream nackCount</a>.</p><p>Anda dapat melihat grafik bagus dari <code>nackCount</code> <em>inbound</em> dan <em>outbound</em> di <a href=#webrtc-browser-tools>halaman webrtc internals</a>.
Jika Anda melihat <code>nackCount</code> meningkat, itu berarti jaringan mengalami <em>packet loss</em> tinggi, dan <em>stack</em> WebRTC melakukan yang terbaik untuk membuat pengalaman video/audio yang mulus meskipun itu.</p><p>Ketika <em>packet loss</em> sangat tinggi sehingga <em>decoder</em> tidak dapat menghasilkan gambar, atau gambar dependen berikutnya seperti dalam kasus I-frame yang hilang sepenuhnya, semua P-frame masa depan tidak akan didekode.
Penerima akan mencoba mengurangi itu dengan mengirim pesan <em>Picture Loss Indication</em> khusus (<a href=../06-media-communication/#full-intra-frame-request-fir-and-picture-loss-indication-pli>PLI</a>).
Setelah pengirim menerima <code>PLI</code>, ia akan menghasilkan I-frame baru untuk membantu <em>decoder</em> penerima.
I-frame biasanya lebih besar dalam ukuran daripada P-frame. Ini meningkatkan jumlah paket yang perlu ditransmisikan.
Seperti dengan pesan NACK, penerima perlu menunggu I-frame baru, memperkenalkan latensi tambahan.</p><p>Perhatikan <code>pliCount</code> di <a href=#webrtc-browser-tools>halaman webrtc internals</a>. Jika meningkat, <em>tweak encoder</em> Anda untuk menghasilkan lebih sedikit paket atau aktifkan mode yang lebih tahan kesalahan.</p><h4 id=latensi-sisi-penerima>Latensi sisi penerima
<a class=anchor href=#latensi-sisi-penerima>#</a></h4><p>Latensi akan dipengaruhi oleh paket yang tiba tidak berurutan.
Jika paket setengah bawah gambar datang sebelum atas Anda harus menunggu atas sebelum dekoding.
Ini dijelaskan dalam bab <a href=../05-real-time-networking/#solving-jitter>Solving Jitter</a> dengan sangat detail.</p><p>Anda juga dapat merujuk ke metrik bawaan <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay>jitterBufferDelay</a> untuk melihat berapa lama <em>frame</em> ditahan di <em>buffer</em> penerimaan, menunggu semua paketnya sampai dilepaskan ke <em>decoder</em>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/8ba6ba8d2dd996d50b782ab76c9ebd1e81bf55cd title='Last modified by Claes Mogren | November 6, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>November 6, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/09-debugging.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#isolasi-masalah>Isolasi Masalah</a><ul><li><a href=#kegagalan-signaling>Kegagalan Signaling</a></li><li><a href=#kegagalan-jaringan>Kegagalan Jaringan</a></li><li><a href=#kegagalan-keamanan>Kegagalan Keamanan</a></li><li><a href=#kegagalan-media>Kegagalan Media</a></li><li><a href=#kegagalan-data>Kegagalan Data</a></li></ul></li><li><a href=#alat-perdagangan>Alat perdagangan</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>Wireshark</a></li><li><a href=#alat-peramban-webrtc>Alat peramban WebRTC</a></li></ul></li><li><a href=#latensi>Latensi</a><ul><li><a href=#pengukuran-latensi-_end-to-end_-manual>Pengukuran latensi <em>end-to-end</em> manual</a></li><li><a href=#pengukuran-latensi-_end-to-end_-otomatis>Pengukuran latensi <em>end-to-end</em> otomatis</a></li><li><a href=#tips-_debugging_-latensi>Tips <em>Debugging</em> Latensi</a></li></ul></li></ul></nav></div></aside></main></body></html>