<!doctype html><html lang=sv dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Varför behöver WebRTC ett särskilt delsystem för anslutning? #  De flesta applikationer som distribueras idag upprättar klient/serveranslutningar. En klient/serveranslutning kräver att servern har en känd och publik adress. En klient ansluter till en server, och servern svarar.
WebRTC använder inte en klient/server-modell utan skapar peer-to-peer (P2P) anslutningar. I en P2P-anslutning fördelas uppgiften att skapa en anslutning lika till båda parterna. Detta beror på att en publik nätverksadress (IP och port) är inget man kan förvänta sig i WebRTC, och den kan till och med ändras mitt under sessionen."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Anslutning"><meta property="og:description" content="Varför behöver WebRTC ett särskilt delsystem för anslutning? #  De flesta applikationer som distribueras idag upprättar klient/serveranslutningar. En klient/serveranslutning kräver att servern har en känd och publik adress. En klient ansluter till en server, och servern svarar.
WebRTC använder inte en klient/server-modell utan skapar peer-to-peer (P2P) anslutningar. I en P2P-anslutning fördelas uppgiften att skapa en anslutning lika till båda parterna. Detta beror på att en publik nätverksadress (IP och port) är inget man kan förvänta sig i WebRTC, och den kan till och med ändras mitt under sessionen."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/sv/docs/03-connecting/"><meta property="article:modified_time" content="2021-05-21T10:24:46-07:00"><meta property="og:site_name" content="WebRTC för nyfikna"><title>Anslutning | WebRTC för nyfikna</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/sv.search.min.5a54e22e099666a707a42b512c724899ef7f757b80c149d9d2e9ecc1ff0660d0.js integrity="sha256-WlTiLgmWZqcHpCtRLHJIme9/dXuAwUnZ0unswf8GYNA="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/sv><span>WebRTC för nyfikna</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Sök aria-label=Sök maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/>Vad, varför och hur</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/02-signaling/>Signalering</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/ class=active>Anslutning</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Säkerhet</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/05-real-time-networking/>Realtidsnätverk</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/06-media-communication/>Mediakommunikation</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/07-data-communication/>Datakommunikation</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Anslutning</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#reducerade-bandbreddskostnader>Reducerade bandbreddskostnader</a></li><li><a href=#lägre-latens>Lägre latens</a></li><li><a href=#säker-e2e-kommunikation>Säker E2E-kommunikation</a></li></ul></li><li><a href=#hur-fungerar-det>Hur fungerar det?</a></li><li><a href=#nätverksbegränsningar>Nätverksbegränsningar</a><ul><li><a href=#inte-i-samma-nätverk>Inte i samma nätverk</a></li><li><a href=#protokollbegränsningar>Protokollbegränsningar</a></li><li><a href=#brandväggids-regler>Brandvägg/IDS-regler</a></li></ul></li><li><a href=#nat-kartläggning>NAT-kartläggning</a><ul><li><a href=#skapa-en-nat-mappning>Skapa en NAT-mappning</a></li><li><a href=#olika-sorters-nat>Olika sorters NAT</a></li><li><a href=#mappning-av-filtreringsbeteenden>Mappning av filtreringsbeteenden</a></li><li><a href=#uppdatera-en-mappning>Uppdatera en mappning</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protokollstruktur>Protokollstruktur</a></li><li><a href=#skapa-en-nat-mappning-1>Skapa en NAT-mappning</a></li><li><a href=#bestämma-nat-typ>Bestämma NAT-typ</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-livscykel>TURN Livscykel</a></li><li><a href=#turn-användning>TURN Användning</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#skapa-en-ice-agent>Skapa en ICE-agent</a></li><li><a href=#kandidatsamling>Kandidatsamling</a></li><li><a href=#anslutningskontroller>Anslutningskontroller</a></li><li><a href=#kandidatval>Kandidatval</a></li><li><a href=#startar-om>Startar om</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=varför-behöver-webrtc-ett-särskilt-delsystem-för-anslutning>Varför behöver WebRTC ett särskilt delsystem för anslutning?
<a class=anchor href=#varf%c3%b6r-beh%c3%b6ver-webrtc-ett-s%c3%a4rskilt-delsystem-f%c3%b6r-anslutning>#</a></h1><p>De flesta applikationer som distribueras idag upprättar klient/serveranslutningar. En klient/serveranslutning kräver att servern har en känd och publik adress. En klient ansluter till en server, och servern svarar.</p><p>WebRTC använder inte en klient/server-modell utan skapar peer-to-peer (P2P) anslutningar. I en P2P-anslutning fördelas uppgiften att skapa en anslutning lika till båda parterna. Detta beror på att en publik nätverksadress (IP och port) är inget man kan förvänta sig i WebRTC, och den kan till och med ändras mitt under sessionen. WebRTC kommer att samla så mycket information som det går, och sedan göra allt den kan för sätta upp en dubbelriktad kommunikationsväg mellan två WebRTC-agenter.</p><p>Det kan dock vara svårt att skapa peer-to-peer-anslutning. Dessa agenter kan finnas i olika nätverk utan direkt anslutning. I situationer där direkt anslutning finns kan du fortfarande ha andra problem. I vissa fall talar dina klienter inte samma nätverksprotokoll (UDP &lt;-> TCP) eller kanske har olika IP-versioner (IPv4 &lt;-> IPv6).</p><p>Trots dessa svårigheter med att skapa en P2P-anslutning får du fördelar jämfört med traditionell klient/server-teknik på grund av följande funktioner WebRTC erbjuder.</p><h3 id=reducerade-bandbreddskostnader>Reducerade bandbreddskostnader
<a class=anchor href=#reducerade-bandbreddskostnader>#</a></h3><p>Eftersom mediekommunikation sker direkt mellan klienterna behöver du inte betala för eller drifta en egen server för att vidarebefordra media.</p><h3 id=lägre-latens>Lägre latens
<a class=anchor href=#l%c3%a4gre-latens>#</a></h3><p>Kommunikationen går snabbare när den är direkt! När en användare måste köra allt via din server gör det överföringarna långsammare.</p><h3 id=säker-e2e-kommunikation>Säker E2E-kommunikation
<a class=anchor href=#s%c3%a4ker-e2e-kommunikation>#</a></h3><p>Direkt kommunikation är säkrare. Eftersom användarnas trafik inte går via din server, behöver de inte ens lita på att du inte dekrypterar den.</p><h2 id=hur-fungerar-det>Hur fungerar det?
<a class=anchor href=#hur-fungerar-det>#</a></h2><p>Processen som beskrivs ovan kallas Interactive Connectivity Establishment (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>). Ytterligare ett protokoll som är äldre än WebRTC.</p><p>ICE är ett protokoll som försöker hitta det bästa sättet att kommunicera mellan två ICE-agenter. Varje ICE-agent publicerar hur den kan nås, dessa kallas kandidater. En kandidat är i huvudsak en nätverksadress för agenten som den tror att den andra klienten kan nå. ICE bestämmer sedan det bästa hopkopplingen av klienterna.</p><p>Den faktiska ICE-processen beskrivs mer detaljerat senare i detta kapitel. För att förstå varför ICE existerar är det bra att förstå vilket nätverksproblem vi behöver hantera.</p><h2 id=nätverksbegränsningar>Nätverksbegränsningar
<a class=anchor href=#n%c3%a4tverksbegr%c3%a4nsningar>#</a></h2><p>ICE handlar om att övervinna begränsningarna i dagens nätverk. Innan vi utforskar lösningen, låt oss prata om några vanliga problem.</p><h3 id=inte-i-samma-nätverk>Inte i samma nätverk
<a class=anchor href=#inte-i-samma-n%c3%a4tverk>#</a></h3><p>För det mesta kommer den andra WebRTC-agenten inte ens att vara i samma nätverk. Ett typiskt samtal är vanligtvis mellan två WebRTC-agenter i olika nätverk utan direktanslutning.</p><p>Nedan är en figur som visar två distinkta nätverk, anslutna via internet. I varje nätverk har du två parter.</p><p><img src=../../images/03-two-networks.png alt="Två nätverk" title="Två nätverk"></p><p>För parterna i samma nätverk är det mycket enkelt att ansluta. Kommunikation mellan <code>192.168.0.1 -> 192.168.0.2</code> är lätt att göra! Dessa två parter kan ansluta till varandra utan någon extern hjälp.</p><p>En värd som använder <code>Router B</code> har dock inget sätt att komma åt något bakom &ldquo;Router A&rdquo;. Hur kan den se skillnad på <code>191.168.0.1</code> bakom <code>Router A</code> och samma IP bakom <code>Router B</code>? De är privata IP-adresser! En värd som använder <code>Router B</code> kan skicka trafik direkt till <code>Router A</code>, men anropet slutar där. Hur vet <code>Router A</code> vilken värd den ska vidarebefordra meddelandet till?</p><h3 id=protokollbegränsningar>Protokollbegränsningar
<a class=anchor href=#protokollbegr%c3%a4nsningar>#</a></h3><p>Vissa nätverk tillåter inte UDP-trafik alls, eller kanske tillåter de inte TCP. Vissa nätverk kan ha en mycket låg MTU (Maximum Transmission Unit, storleken på varje paket). Det finns många variabler som nätverksadministratörer kan ändra som kan göra det svårt att kommunicera.</p><h3 id=brandväggids-regler>Brandvägg/IDS-regler
<a class=anchor href=#brandv%c3%a4ggids-regler>#</a></h3><p>En annan är &ldquo;Deep Packet Inspection&rdquo; och andra intelligenta filtreringar. Vissa nätverksadministratörer kommer att köra programvara som försöker bearbeta varje paket. Många gånger förstår inte denna programvara WebRTC, så den blockerar den eftersom den inte vet vad den ska göra, t.ex. behandlas WebRTC-paket som misstänkta UDP-paket när de kommer på en godtycklig port som inte är känd.</p><h2 id=nat-kartläggning>NAT-kartläggning
<a class=anchor href=#nat-kartl%c3%a4ggning>#</a></h2><p>NAT (Network Address Translation) är den magi som gör anslutningen av WebRTC möjlig. Så här tillåter WebRTC att två parter i helt olika subnät kommunicerar och behandlar problemet &ldquo;inte i samma nätverk&rdquo; ovan. Medan det skapar nya utmaningar, låt oss förklara hur NAT Mapping fungerar först.</p><p>Det använder inte ett relay, proxy eller server. Återigen har vi <code>Agent 1</code> och <code>Agent 2</code> och de finns i olika nätverk, men ändå flyter trafiken utan problem. Visualiserat ser det ut så här:</p><p><img src=../../images/03-nat-mapping.png alt="NAT mapping" title="NAT mapping"></p><p>För att få denna kommunikation att upprätta skapar du en översättning med hjälp av NAT. Agent 1 använder port 7000 för att upprätta en WebRTC-anslutning med Agent 2. Detta skapar en koppling från <code>192.168.0.1:7000</code> till <code>5.0.0.1:7000</code>. Detta gör det möjligt för Agent 2 att nå Agent 1 genom att skicka paket till <code>5.0.0.1:7000</code>. Att skapa en NAT-mappning som i det här exemplet är som en automatisk version av att forward:a en port i din router.</p><p>Nackdelen med NAT är att det inte finns något konsekvent sätt att göra det på (t.ex. vidarebefordran av en statisk port), och att beteendet är olika i olika nätverk. Internetleverantörer och hårdvarutillverkare kan göra det på olika sätt. I vissa fall kan nätverksadministratörer till och med inaktivera det.</p><p>Den goda nyheten är att hela beteendet är förstått och observerbart, så en ICE-agent kan bekräfta att den har satt upp NAT rätt och vet då alla inställningarna i mappningen.</p><p>Dokumentet som beskriver dessa beteenden är <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>.</p><h3 id=skapa-en-nat-mappning>Skapa en NAT-mappning
<a class=anchor href=#skapa-en-nat-mappning>#</a></h3><p>Att skapa en NAT-mappning är den enkla biten. När du skickar ett paket till en adress utanför ditt nätverk skapas en mappning! En NAT-mappning är bara en tillfällig offentlig IP och port som tilldelas av din NAT. Det utgående meddelandet kommer att skrivas om så att dess källadress ges av den nyligen mappade adressen. Om ett meddelande skickas tillbaka till den adressen, så dirigeras det automatiskt tillbaka till värden bakom den NAT:ade interna adressen. Detaljerna kring NAT är där det blir komplicerat.</p><h3 id=olika-sorters-nat>Olika sorters NAT
<a class=anchor href=#olika-sorters-nat>#</a></h3><p>En NAT tillhör en av tre olika kategorier:</p><h4 id=slutpunktoberoende-mappning-endpoint-independent>Slutpunktoberoende mappning (Endpoint-Independent)
<a class=anchor href=#slutpunktoberoende-mappning-endpoint-independent>#</a></h4><p>En mappning skapas för varje avsändare i NAT:at nätverk. Om du skickar två paket till två olika adresser kommer NAT-mappningen att återanvändas. Båda parterna utanför det lokala nätet skulle se samma avsändare IP och port. Om de svarar, skulle det skickas tillbaka till samma lokala lyssnare.</p><p>Detta är det bästa fallet. För att ett samtal ska fungera, MÅSTE åtminstone en av parterna vara av den här typen.</p><h4 id=adressberoende-mappning>Adressberoende mappning
<a class=anchor href=#adressberoende-mappning>#</a></h4><p>En ny mappning skapas varje gång du skickar ett paket till en ny adress. Om du skickar två paket till olika parter skapas två mappningar. Om du skickar två paket till samma part men till olika destinationsportar skapas INTE en ny mappning.</p><h4 id=adress--och-port-beroende-mappning>Adress- och port-beroende mappning
<a class=anchor href=#adress--och-port-beroende-mappning>#</a></h4><p>En ny mappning skapas om fjärr-IP:t eller porten är annorlunda. Om du skickar två paket till samma IP utanför det lokala nätet, men olika portar, skapas en ny mappning för varje.</p><h3 id=mappning-av-filtreringsbeteenden>Mappning av filtreringsbeteenden
<a class=anchor href=#mappning-av-filtreringsbeteenden>#</a></h3><p>Mappningsfiltrering handlar om reglerna kring vem som får använda mappningen. Det finns tre liknande klassificeringar:</p><h4 id=slutpunktsoberoende-filtrering>Slutpunktsoberoende filtrering
<a class=anchor href=#slutpunktsoberoende-filtrering>#</a></h4><p>Vem som helst kan använda mappningen. Du kan dela mappningen med flera andra parter och de kan alla skicka trafik till den.</p><h4 id=adressberoende-filtrering>Adressberoende filtrering
<a class=anchor href=#adressberoende-filtrering>#</a></h4><p>Endast värden som mappningen skapades för kan använda mappningen. Om du skickar ett paket till agent <code>A</code> kan det svara tillbaka med så många paket som det vill. Om agent <code>B</code> försöker skicka ett paket till den mappningen ignoreras det.</p><h4 id=adress--och-port-beroende-filtrering>Adress- och port-beroende filtrering
<a class=anchor href=#adress--och-port-beroende-filtrering>#</a></h4><p>Endast IP:t och porten för vilken mappningen skapades för kan använda den. Om du skickar ett paket till agent <code>A:5000</code> kan det svara tillbaka med så många paket som det vill. Om en agent <code>A:5001</code> försöker skicka ett paket till samma mappningen ignoreras paketet.</p><h3 id=uppdatera-en-mappning>Uppdatera en mappning
<a class=anchor href=#uppdatera-en-mappning>#</a></h3><p>Det rekommenderas att om en mappningen inte används på 5 minuter ska den förstöras. Detta är helt upp till ISP eller hårdvarutillverkaren.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (Session Traversal Utilities for NAT) är ett protokoll som skapades för att jobba med NATs. Det är ytterligare en teknik som skapats före WebRTC (och ICE!). Specifikationen hittar du i <a href=https://tools.ietf.org/html/rfc5389>RFC 5389</a>, som också definierar STUN-paketformatet. STUN-protokollet används också av ICE/TURN.</p><p>STUN är användbart eftersom det tillåter programmering av NAT mappning. Innan STUN kunde vi sätta upp ett NAT, men vi hade ingen aning om vilket IP och port det var! STUN ger dig inte bara möjligheten att skapa en NAT mappning, du får också detaljerna så att du kan dela dem med andra så att de kan skicka trafik till dig via den mappning du just skapade.</p><p>Låt oss börja med en grundläggande beskrivning av STUN. Senare kommer vi att utöka TURN- och ICE-användningen. För närvarande ska vi bara beskriva flödet för begäran / svar för att skapa en kartläggning. Sedan kommer vi att prata om hur man får detaljerna i den att dela med andra. Detta är processen som händer när du har en <code>stun:</code>-server i dina ICE-URL:er för en WebRTC PeerConnection. Kort sagt, STUN hjälper en server bakom ett NAT:at nätverk att lista ut vilken mappning som skapades genom att fråga en STUN-server utanför det lokala nätverket vad den kan se.</p><h3 id=protokollstruktur>Protokollstruktur
<a class=anchor href=#protokollstruktur>#</a></h3><p>Varje STUN-paket har följande format:</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-meddelande-typ>STUN Meddelande typ
<a class=anchor href=#stun-meddelande-typ>#</a></h4><p>Varje STUN-paket har en typ. Just nu bryr vi oss bara om följande två:</p><ul><li>Bindningsförfrågan - <code>0x0001</code></li><li>Bindningssvar - <code>0x0101</code></li></ul><p>För att skapa en NAT-mappning gör vi ett <code>Binding Request</code>. Sedan svarar servern med ett <code>Binding Response</code>.</p><h4 id=meddelandets-längd>Meddelandets längd
<a class=anchor href=#meddelandets-l%c3%a4ngd>#</a></h4><p>Hur långt avsnittet <code>Data</code> är. Detta avsnitt innehåller godtycklig data som definieras av <code>Message Type</code>.</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>Det fasta värdet <code>0x2112A442</code> i nätverksbyteordning (network byte order), det hjälper till att skilja STUN-trafik från andra protokoll.</p><h4 id=transaktions-id>Transaktions ID
<a class=anchor href=#transaktions-id>#</a></h4><p>En 96-bitars identifierare som unikt identifierar en begäran/svar. Detta hjälper dig att para ihop dina begäran och svar.</p><h4 id=data>Data
<a class=anchor href=#data>#</a></h4><p>Data kommer att innehålla en lista med STUN-attribut. Ett STUN-attribut har följande struktur:</p><pre><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Ett <code>STUN Binding Request</code> använder inga attribut. Det betyder att en <code>STUN Binding Request</code> endast innehåller en header.</p><p>En <code>STUN Binding Response</code> använder en <code>XOR-MAPPED-ADDRESS (0x0020)</code>. Detta attribut innehåller en IP och port. Detta är IP och port för den NAT-mappning som skapas!</p><h3 id=skapa-en-nat-mappning-1>Skapa en NAT-mappning
<a class=anchor href=#skapa-en-nat-mappning-1>#</a></h3><p>Att skapa en NAT-mappning med STUN kräver bara att skicka en begäran! Du skickar ett <code>STUN Binding Request</code> till STUN-servern. STUN-servern svarar sedan med en <code>STUN Binding Response</code>.
Denna <code>STUN Binding Response</code> kommer att innehålla en <code>Mapped Address</code>. Den &ldquo;mappade adressen&rdquo; är hur STUN-servern ser dig. Det är din &ldquo;NAT-mappning&rdquo;.
Den &ldquo;mappade adressen&rdquo; är vad du skulle dela om du vill att någon ska skicka paket till dig.</p><p>Din &ldquo;mappade adress&rdquo; kallas också för ditt &ldquo;publika IP&rdquo; eller ibland <code>Server Reflexive Candidate</code>.</p><h3 id=bestämma-nat-typ>Bestämma NAT-typ
<a class=anchor href=#best%c3%a4mma-nat-typ>#</a></h3><p>Tyvärr kan en &ldquo;mappad adress&rdquo; kanske ändå inte vara användbar. Om reglerna är &ldquo;adressberoende&rdquo; (<code>Address Dependent</code>) kan bara STUN-servern skicka trafik till dig. Om du delade adressen och en annan agent försöker skicka meddelanden kommer de att ignoreras. Detta gör det värdelöst för att kommunicera med andra. Du kanske tycker att fallet &ldquo;adressberoende&rdquo; faktiskt går att lösa om STUN-servern också kan vidarebefordra paket åt dig till din andra part! Detta leder oss till en annan teknik, TURN.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a> definierar en metod för att göra ett test för att lista ut din NAT-typ. Detta är användbart eftersom du kan veta i förväg om direktanslutning var möjlig.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (Traversal Using Relays around NAT) definieras i [RFC 5766] (<a href=https://tools.ietf.org/html/rfc5766>https://tools.ietf.org/html/rfc5766</a>) är lösningen när direktanslutning inte är möjlig. Det kan bero på att du har två NAT-typer som är oförenliga eller kanske inte kan tala samma protokoll! TURN kan också användas för sekretessändamål. Genom att köra all din kommunikation genom TURN döljer du klientens faktiska adress.</p><p>TURN använder en dedikerad server. Denna server fungerar som en proxy för en klient. Klienten ansluter till en TURN-server och skapar en allokering (<code>Allocation</code>). Genom att skapa en allokering får en klient en tillfällig IP/port/protokoll som kan användas för att skicka trafik tillbaka till klienten. Den här nya lyssnaren kallas en <code>Relayed Transport Address</code>. Tänk på det som en vidarebefordringsadress, du använder den så att andra kan skicka dig trafik via TURN! För varje klient du ger din <code>Relay Transport Address</code> till måste du skapa ett nytt &ldquo;tillstånd&rdquo; (<code>Permission</code>) för att tillåta kommunikation med dig.</p><p>När du skickar utgående trafik via TURN skickas den via din <code>Relayed Transport Address</code>. När en annan klient får trafik ser den ut att komma från TURN-servern.</p><h3 id=turn-livscykel>TURN Livscykel
<a class=anchor href=#turn-livscykel>#</a></h3><p>Följande är allt som en klient som vill skapa en TURN-allokering måste göra. Kommunikation med någon som använder TURN kräver inga ändringar. Den andra klienten får ett IP och en port, och de kommunicerar med den som vilken annan server som helst.</p><h4 id=tilldelningar-allocations>Tilldelningar (Allocations)
<a class=anchor href=#tilldelningar-allocations>#</a></h4><p>Tilldelningar är kärnan i TURN. En &ldquo;allokering&rdquo; är i grunden en &ldquo;TURN Session&rdquo;. För att skapa en TURN-allokering kommunicerar du med en TURN <code>Server Transport Address</code> (vanligtvis på port <code>3478</code>).</p><p>När du skapar en tilldelning måste du ange följande:</p><ul><li>Användarnamn/lösenord - För att skapa TURN-tilldelningar krävs autentisering</li><li>Allokeringstransport - Den &lsquo;vidarebefordrade transportadressen&rsquo; kan vara UDP eller TCP</li><li>Even-Port - Du kan begära sekventiella portar för flera tilldelningar, inte relevanta för WebRTC.</li></ul><p>Om begäran lyckades får du svar med TURN-servern med följande STUN-attribut i Data-sektionen:</p><ul><li><code>XOR-MAPPED-ADRESS</code> - <code>Mappad adress</code> för din <code>TURN Client</code>. När någon skickar data till &ldquo;Relayed Transport Address&rdquo;, vidarebefordras den till.</li><li><code>RELAYED-ADRESS</code> - Det här är adressen som du ger ut till andra klienter. Om någon skickar ett paket till den här adressen vidarebefordras det till TURN-klienten.</li><li><code>LIFETIME</code>- Hur länge tills denna TURN-fördelning tas bort. Du kan förlänga livslängden genom att skicka ett uppdaterings anrop (<code>Refresh</code>).</li></ul><h4 id=behörigheter>Behörigheter
<a class=anchor href=#beh%c3%b6righeter>#</a></h4><p>En klient kan inte skicka till din <code>Relayed Transport Address</code> förrän du skapar ett tillstånd för den. När du skapar en behörighet berättar du för TURN-servern att denna IP och Port får skicka inkommande trafik.</p><p>Klienten måste ge dig IP och port som den ser ut för TURN-servern. Det betyder att den ska skicka ett <code>STUN Binding Request</code> till TURN-servern. Ett vanligt felfall är att en klient skickar ett <code>STUN Binding Request</code> till en annan server. De kommer då att be dig skapa en behörighet för denna IP.</p><p>Låt oss säga att du vill skapa en behörighet (<code>permission</code>) för en klient bakom en &ldquo;adressberoende mappning&rdquo;. Om du genererar en &ldquo;mappad adress&rdquo; från en annan TURN-server kommer all inkommande trafik att ignoreras. Varje gång de kommunicerar med en annan klient genererar den en ny mappning. Behörigheterna löper ut efter 5 minuter om de inte uppdateras.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>Dessa två meddelanden är avsedda för TURN-klienten att skicka meddelanden till en klient.</p><p>SendIndication är ett fristående meddelande. Det innehåller den information du vill skicka, och vem du vill skicka den till. Detta är slösaktigt om du skickar många meddelanden till en annan klient. Om du skickar 1000 meddelanden kommer du att upprepa deras IP-adress 1000 gånger!</p><p>ChannelData låter dig skicka data, utan att upprepa IP-adressen. Du skapar en kanal med en IP och port. Du skickar sedan med ChannelId och IP och port fylls i på serversidan. Detta är bättre om du skickar många av meddelanden.</p><h4 id=refreshing>Refreshing
<a class=anchor href=#refreshing>#</a></h4><p>Allokeringar kommer att ta bort sig själva automatiskt. TURN-klienten måste uppdatera dem innan deras <code>LIFETIME</code> som ges när tilldelningen skapas går ut.</p><h3 id=turn-användning>TURN Användning
<a class=anchor href=#turn-anv%c3%a4ndning>#</a></h3><p>TURN Användningen finns i två former. Vanligtvis har du en part som fungerar som en &ldquo;TURN klient&rdquo; och den andra sidan kommunicerar direkt. I vissa fall kan du ha TURN-server på båda sidor, till exempel för att båda klienterna finns i nätverk som blockerar UDP, och därför sker anslutningen till respektive TURN-servrar via TCP.</p><p>Dessa figurer hjälper till att illustrera hur det skulle se ut.</p><h4 id=en-turn-allokering-för-kommunikation>En TURN allokering för kommunikation
<a class=anchor href=#en-turn-allokering-f%c3%b6r-kommunikation>#</a></h4><p><img src=../../images/03-one-turn-allocation.png alt="En TURN allokering" title="En TURN allokering"></p><h4 id=två-turn-allokeringar-för-kommunikation>Två TURN allokeringar för kommunikation
<a class=anchor href=#tv%c3%a5-turn-allokeringar-f%c3%b6r-kommunikation>#</a></h4><p><img src=../../images/03-two-turn-allocations.png alt="Två TURN allokeringar" title="Två TURN allokeringar"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Interactive Connectivity Establishment) är tekniken WebRTC använder för att ansluta två klienter med varandra. Definierad i <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>, detta är ytterligare en standard som är återanvänd i WebRTC. ICE är ett protokoll för att sätta upp av anslutningar. Det hittar alla möjliga rutter (routes) mellan de två klienterna och säkerställer att de kan kommunicera med varandra.</p><p>Dessa rutter är kända som <code>Candidate Pairs</code>, vilket är en anslutning mellan en lokal och en extern adress. Det är här STUN och TURN används tillsammans med ICE. Dessa adresser kan vara din lokala IP-adress plus en port, &ldquo;NAT-mappning&rdquo; eller en <code>Relayed Transport Address</code>. Båda klienterna listar alla adresser de vill använda, skickar över dem och försöker sedan ansluta.</p><p>Två ICE-agenter kommunicerar med hjälp av ICE-ping-paket (<code>connectivity checks</code>) för att sätta upp en anslutning. När anslutningen har upprättats kan de skicka vilken data de vill. Det blir som att använda en normal socket. Dessa kontroller använder STUN-protokollet.</p><h3 id=skapa-en-ice-agent>Skapa en ICE-agent
<a class=anchor href=#skapa-en-ice-agent>#</a></h3><p>En ICE-agent är antingen <code>Controlling</code> eller <code>Controlled</code>. Den &ldquo;kontrollerande&rdquo; agenten är den som bestämmer vilken kandidat (<code>Candidate Pair</code>) som ska användas. Vanligtvis är den klient som skickar erbjudandet den kontrollerande sidan.</p><p>Varje klient måste ha ett &ldquo;användarfragment&rdquo; (<code>user fragment</code>) och ett &ldquo;lösenord&rdquo; (<code>password</code>). Dessa två värden måste utbytas innan anslutningskontroller kan göras. &ldquo;Användarfragmentet&rdquo; skickas i klartext och är användbart för att separera (demuxing) flera ICE-sessioner.
Lösenordet används för att generera attributet <code>MESSAGE-INTEGRITY</code>. I slutet av varje STUN-paket finns det ett attribut som är en hash för hela paketet med &ldquo;lösenordet&rdquo; som en nyckel. Detta används för att autentisera paketet och se till att det inte har blivit manipulerat.</p><p>För WebRTC skickas alla dessa värden via &ldquo;sessionsbeskrivningen&rdquo; som beskrevs i förra kapitlet.</p><h3 id=kandidatsamling>Kandidatsamling
<a class=anchor href=#kandidatsamling>#</a></h3><p>Vi måste nu samla alla möjliga adresser vi kan nås på. Dessa adresser kallas kandidater. Dessa kandidater skickas också via &ldquo;sessionsbeskrivningen&rdquo;.</p><h4 id=klient>Klient
<a class=anchor href=#klient>#</a></h4><p>En klientkandidat lyssnar direkt på ett lokalt nätverksinterface, antingen via UDP eller TCP.</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>En mDNS-kandidat liknar en klientkandidat, men IP-adressen är dold. Istället för att informera den andra sidan om din IP-adress, ger du dem ett UUID som värdnamn. Du ställer istället upp en multicast-lyssnare och svarar om någon frågar efter det UUID som du publicerat.</p><p>Om du är i samma nätverk som agenten kan du hitta varandra via multicast. Om du inte är i samma nätverk kommer du inte att kunna ansluta (om inte nätverksadministratören uttryckligen konfigurerat nätverket så att multicast-paket kan passera).</p><p>Detta är användbart för sekretessändamål. En användare kan ta reda på din lokala IP-adress via WebRTC med en klientkandidat (utan att ens försöka ansluta till dig), men med en mDNS-kandidat får de nu bara ett slumpmässigt UUID.</p><h4 id=serverreflexiv-kandidat>Serverreflexiv kandidat
<a class=anchor href=#serverreflexiv-kandidat>#</a></h4><p>En serverreflexiv kandidat genereras genom att göra ett <code>STUN Binding Request</code> till en STUN-server.</p><p>När du får en <code>STUN Binding Response</code>, är <code>XOR-MAPPED-ADDRESS</code> din serverreflexiva kandidat.</p><h4 id=peer-reflexive>Peer Reflexive
<a class=anchor href=#peer-reflexive>#</a></h4><p>En Peer Reflexive-kandidat är när du får en inkommande begäran från en adress som du inte känner till. Eftersom ICE är ett autentiserat protokoll vet du att trafiken är giltig. Detta betyder bara att den andra klienten försöker kommunicera med dig från en extern adress den ännu inte känner till.</p><p>Detta händer ofta när en &ldquo;klientkandidat&rdquo; kommunicerar med en &ldquo;serverreflexiv kandidat&rdquo;. En ny &ldquo;NAT-mappning&rdquo; skapades eftersom du kommunicerar utanför ditt subnät. Kommer du ihåg att vi sa att anslutningskontrollerna faktiskt är STUN-paket? Formatet för STUN-svar tillåter naturligtvis en peer att rapportera tillbaka den peer-reflexiva adressen.</p><h4 id=relä-relay>Relä (Relay)
<a class=anchor href=#rel%c3%a4-relay>#</a></h4><p>En reläkandidat genereras med hjälp av en TURN-server.</p><p>Efter den första handskakningen med TURN-servern får du en <code>RELAYED-ADDRESS</code>, detta är din reläkandidat.</p><h3 id=anslutningskontroller>Anslutningskontroller
<a class=anchor href=#anslutningskontroller>#</a></h3><p>Vi känner nu till den andra klientens &ldquo;användarfragment&rdquo;, &ldquo;lösenord&rdquo; och kandidater. Vi kan nu försöka ansluta! Alla kandidater matchas med varandra, så om du har 3 kandidater på varje sida har du nu 9 kandidatpar.</p><p>Visuellt ser det ut så här:</p><p><img src=../../images/03-connectivity-checks.png alt=Anslutningskontroller title=Anslutningskontroller></p><h3 id=kandidatval>Kandidatval
<a class=anchor href=#kandidatval>#</a></h3><p>Den kontrollerande och kontrollerade agenten skickar a trafik över varje par. Detta behövs om en agent står bakom en &ldquo;adressberoende mappning&rdquo; (<code>Address Dependent Mapping</code>). Detta kommer att skapa en ny &ldquo;peer reflexive kandidat&rdquo;.</p><p>Varje &ldquo;kandidatpar&rdquo; som lyckades skicka nätverkstrafik befordras till ett &ldquo;giltigt kandidatpar&rdquo;. Den kontrollerande agenten nominerar sedan ett giltigt kandidatpart. Detta blir det &ldquo;nominerade paret&rdquo;. Den kontrollerande och kontrollerade agenten försöker sedan ytterligare en runda dubbelriktad kommunikation. Om det lyckas blir det &ldquo;nominerade paret&rdquo; det &ldquo;utvalda kandidatparet&rdquo; (<code>Selected Candidate Pair</code>)! Detta par används sedan under resten av sessionen.</p><h3 id=startar-om>Startar om
<a class=anchor href=#startar-om>#</a></h3><p>Om ditt <code>Selected Candidate Pair</code> slutar fungera av någon anledning (NAT-mappning upphör att gälla, TURN-server kraschar) kommer ICE-agenten att få status <code>Failed</code>. Båda agenterna kan startas om och kommer att göra hela processen om igen.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/03-connecting/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li class=active><a href=https://webrtcforthecurious.com/sv/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/1a70667159cd5b163978675a035fe32eadacca0b title="Senast modifierad av Claes Mogren | May 21, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 21, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.sv/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Redigera denna sida</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#reducerade-bandbreddskostnader>Reducerade bandbreddskostnader</a></li><li><a href=#lägre-latens>Lägre latens</a></li><li><a href=#säker-e2e-kommunikation>Säker E2E-kommunikation</a></li></ul></li><li><a href=#hur-fungerar-det>Hur fungerar det?</a></li><li><a href=#nätverksbegränsningar>Nätverksbegränsningar</a><ul><li><a href=#inte-i-samma-nätverk>Inte i samma nätverk</a></li><li><a href=#protokollbegränsningar>Protokollbegränsningar</a></li><li><a href=#brandväggids-regler>Brandvägg/IDS-regler</a></li></ul></li><li><a href=#nat-kartläggning>NAT-kartläggning</a><ul><li><a href=#skapa-en-nat-mappning>Skapa en NAT-mappning</a></li><li><a href=#olika-sorters-nat>Olika sorters NAT</a></li><li><a href=#mappning-av-filtreringsbeteenden>Mappning av filtreringsbeteenden</a></li><li><a href=#uppdatera-en-mappning>Uppdatera en mappning</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protokollstruktur>Protokollstruktur</a></li><li><a href=#skapa-en-nat-mappning-1>Skapa en NAT-mappning</a></li><li><a href=#bestämma-nat-typ>Bestämma NAT-typ</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-livscykel>TURN Livscykel</a></li><li><a href=#turn-användning>TURN Användning</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#skapa-en-ice-agent>Skapa en ICE-agent</a></li><li><a href=#kandidatsamling>Kandidatsamling</a></li><li><a href=#anslutningskontroller>Anslutningskontroller</a></li><li><a href=#kandidatval>Kandidatval</a></li><li><a href=#startar-om>Startar om</a></li></ul></li></ul></nav></div></aside></main></body></html>