<!doctype html><html lang=sv dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Vad, varför och hur # Vad är WebRTC? # WebRTC, förkortning för Web Real-Time Communication, är både ett API och ett protokoll. WebRTC-protokollet är en uppsättning regler som två WebRTC-agenter använder för att sätta upp en säker tvåvägs realtidskommunikation. WebRTC API:et tillåter sedan utvecklare att använda WebRTC-protokollet. WebRTC API:et är endast specificerat för JavaScript.
Ett liknande förhållande skulle vara det mellan HTTP och Fetch API:et. WebRTC protokollet skulle vara HTTP, och WebRTC API:et motsvarar Fetch API:et."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/"><meta property="og:site_name" content="WebRTC för nyfikna"><meta property="og:title" content="Vad, varför och hur"><meta property="og:description" content="Vad, varför och hur # Vad är WebRTC? # WebRTC, förkortning för Web Real-Time Communication, är både ett API och ett protokoll. WebRTC-protokollet är en uppsättning regler som två WebRTC-agenter använder för att sätta upp en säker tvåvägs realtidskommunikation. WebRTC API:et tillåter sedan utvecklare att använda WebRTC-protokollet. WebRTC API:et är endast specificerat för JavaScript.
Ett liknande förhållande skulle vara det mellan HTTP och Fetch API:et. WebRTC protokollet skulle vara HTTP, och WebRTC API:et motsvarar Fetch API:et."><meta property="og:locale" content="sv"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-10-19T21:06:32-04:00"><title>Vad, varför och hur | WebRTC för nyfikna</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/ title="Что, Зачем и как ?"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/ title="Quoi, Pourquoi et Comment"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ title="Apa, Mengapa, dan Bagaimana"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ title="¿Qué, Por qué y Cómo?"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/sv.search.min.fd90457d4862486103b93b93064dd29dc3b4c5b2333733016b4209da43dcc99b.js integrity="sha256-/ZBFfUhiSGEDuTuTBk3SncO0xbIzNzMBa0IJ2kPcyZs=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/sv/><span>WebRTC för nyfikna</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Sök aria-label=Sök maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/>Русский</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/>Español</a></li></ul></li></ul><ul><li><a href=/sv/docs/01-what-why-and-how/ class=active>Vad, varför och hur</a></li><li><a href=/sv/docs/02-signaling/>Signalering</a></li><li><a href=/sv/docs/03-connecting/>Anslutning</a></li><li><a href=/sv/docs/04-securing/>Säkerhet</a></li><li><a href=/sv/docs/05-real-time-networking/>Realtidsnätverk</a></li><li><a href=/sv/docs/06-media-communication/>Mediakommunikation</a></li><li><a href=/sv/docs/07-data-communication/>Datakommunikation</a></li><li><a href=/sv/docs/08-applied-webrtc/>Hur WebRTC används</a></li><li><a href=/sv/docs/09-debugging/>Felsökning</a></li><li><a href=/sv/docs/10-history-of-webrtc/>Historia</a></li><li><a href=/sv/docs/11-faq/>FAQ</a></li><li><a href=/sv/docs/12-glossary/>Ordlista</a></li><li><a href=/sv/docs/13-reference/>Referenser</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Vad, varför och hur</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#vad-är-webrtc>Vad är WebRTC?</a></li><li><a href=#varför-ska-jag-lära-mig-webrtc>Varför ska jag lära mig WebRTC?</a></li><li><a href=#webrtc-protokollet-är-en-samling-av-andra-tekniker>WebRTC Protokollet är en samling av andra tekniker</a><ul><li><a href=#signalering-hur-parter-hittar-varandra-i-webrtc>Signalering: Hur parter hittar varandra i WebRTC</a></li><li><a href=#anslutning-och-nat-traversal-med-stunturn>Anslutning och NAT Traversal med STUN/TURN</a></li><li><a href=#säkra-transportskiktet-med-dtls-och-srtp>Säkra transportskiktet med DTLS och SRTP</a></li><li><a href=#kommunicera-med-parter-via-rtp-och-sctp>Kommunicera med parter via RTP och SCTP</a></li></ul></li><li><a href=#webrtc-en-samling-protokoll>WebRTC, en samling protokoll</a></li><li><a href=#hur-fungerar-apiet-webrtc>Hur fungerar API:et WebRTC</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=vad-varför-och-hur>Vad, varför och hur
<a class=anchor href=#vad-varf%c3%b6r-och-hur>#</a></h1><h2 id=vad-är-webrtc>Vad är WebRTC?
<a class=anchor href=#vad-%c3%a4r-webrtc>#</a></h2><p>WebRTC, förkortning för Web Real-Time Communication, är både ett API och ett protokoll. WebRTC-protokollet är en uppsättning regler som två WebRTC-agenter använder för att sätta upp en säker tvåvägs realtidskommunikation. WebRTC API:et tillåter sedan utvecklare att använda WebRTC-protokollet. WebRTC API:et är endast specificerat för JavaScript.</p><p>Ett liknande förhållande skulle vara det mellan HTTP och Fetch API:et. WebRTC protokollet skulle vara HTTP, och WebRTC API:et motsvarar Fetch API:et.</p><p>WebRTC-protokollet finns tillgängligt i andra API:er och språk än JavaScript. Du kan också hitta servrar och domänspecifika verktyg för WebRTC. Alla dessa implementationer använder WebRTC-protokollet så att de kan kommunicera med varandra.</p><p>WebRTC-protokollet upprätthålls i IETF i arbetsgruppen <a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a>. WebRTC API:et är dokumenterat i W3C som <a href=https://www.w3.org/TR/webrtc/>webrtc</a>.</p><h2 id=varför-ska-jag-lära-mig-webrtc>Varför ska jag lära mig WebRTC?
<a class=anchor href=#varf%c3%b6r-ska-jag-l%c3%a4ra-mig-webrtc>#</a></h2><p>Det här är en lista på några saker som WebRTC kommer att ge dig:</p><ul><li>Öppen standard</li><li>Flera implementeringar</li><li>Fungerar direkt i webbläsare</li><li>Obligatorisk kryptering</li><li>NAT Traversal</li><li>Byggt på beprövad, befintlig, teknik</li><li>Trängselkontroll</li><li>Latens som kan mätas i bråkdelar av en sekund</li></ul><p>Listan är inte komplett, bara exempel på saker som är bra att känna till. Oroa dig inte om du inte känner till alla dessa termer ännu, den här boken kommer att lära dig dem på vägen.</p><h2 id=webrtc-protokollet-är-en-samling-av-andra-tekniker>WebRTC Protokollet är en samling av andra tekniker
<a class=anchor href=#webrtc-protokollet-%c3%a4r-en-samling-av-andra-tekniker>#</a></h2><p>Detta är ett ämne som kan ta en hel bok att förklara, men till att börja med delar vi upp det i fyra steg.</p><ol><li>Signalering</li><li>Anslutning</li><li>Säkerhet</li><li>Kommunikation</li></ol><p>Dessa fyra steg sker alltid i den här ordningen. Varje steg måste vara helt klart, utan problem, innan nästa steg kan påbörjas.</p><p>En intressant sak med WebRTC är att varje steg faktiskt består av många andra protokoll! WebRTC är en samling av många befintliga tekniker. I den meningen är WebRTC egentligen bara en kombination av beprövad teknik som har funnits sedan början av 2000-talet och inte något helt nytt.</p><p>Vi kommer att gå igenom alla dessa steg i detalj senare, men det är bra att först förstå dem på en hög nivå. Eftersom de är beroende av varandra kommer det att hjälpa dig när vi senare förklarar syftet med vart och ett av dessa steg.</p><h3 id=signalering-hur-parter-hittar-varandra-i-webrtc>Signalering: Hur parter hittar varandra i WebRTC
<a class=anchor href=#signalering-hur-parter-hittar-varandra-i-webrtc>#</a></h3><p>När en WebRTC-agent startar har den ingen aning om vem den ska kommunicera med och vad de ska kommunicera om. Signalering löser problemet! Signalering används för att starta samtalet så att två WebRTC-agenter kan börja kommunicera.</p><p>Signalering använder ett befintligt protokoll SDP (Session Description Protocol). SDP är ett enkelt textbaserat protokoll. Varje SDP-meddelande består av nyckel/värdepar och innehåller en lista med &ldquo;media sections&rdquo;. SDP:n som de två WebRTC agenterna utbyter innehåller detaljer som:</p><ul><li>IP-adresser och portar som agenten kan nås på (kandidater).</li><li>Hur många ljud- och videospår agenten vill skicka.</li><li>Vilka ljud- och video-kodek som varje agent stöder.</li><li>Värden som används vid anslutning (<code>uFrag</code>/<code>uPwd</code>).</li><li>Värden som används vid säkringen (certifikatfingeravtryck).</li></ul><p>Observera att signalering vanligtvis sker i en separat kanal (out-of-band); applikationer använder i allmänhet inte WebRTC för att skicka signalmeddelanden. Vilken arkitektur som helst som är lämplig för att skicka meddelanden kan användas för att vidarebefordra SDP:erna mellan de anslutande parterna. Många applikationer använder sin befintliga infrastruktur (som REST-API:er, WebSocket-anslutningar eller autentiserande proxys) för att på enklaste sätt utbyta SDP:er mellan rätt klienter.</p><h3 id=anslutning-och-nat-traversal-med-stunturn>Anslutning och NAT Traversal med STUN/TURN
<a class=anchor href=#anslutning-och-nat-traversal-med-stunturn>#</a></h3><p>När de två WebRTC-agenterna utbytt SDP:er har de nu tillräckligt med detaljer för att försöka ansluta till varandra. För att göra det använder WebRTC en annan etablerad teknik som kallas ICE (Interactive Connectivity Establishment).</p><p>ICE är ett protokoll som skapades före WebRTC och. ICE används för att upprätta en anslutning mellan två agenter. Dessa agenter kan vara i samma nätverk eller på andra sidan världen.</p><p>ICE är används för att skapa en direktanslutning utan att gå via en central server. Den verkliga magin här är &ldquo;NAT Traversal&rdquo; och STUN/TURN-servrar. Dessa två begrepp, som vi kommer att utforska djupare senare, är allt du behöver för att kommunicera med en ICE-agent i ett annat sub-nät.</p><p>När de två agenterna väl har anslutits går WebRTC vidare till nästa steg; att upprätta en krypterad kommunikationskanal för att utbyta ljud, video och data.</p><h3 id=säkra-transportskiktet-med-dtls-och-srtp>Säkra transportskiktet med DTLS och SRTP
<a class=anchor href=#s%c3%a4kra-transportskiktet-med-dtls-och-srtp>#</a></h3><p>Nu när vi har dubbelriktad kommunikation (via ICE) måste vi sätta upp en säker kommunikationskanal. Detta görs genom två andra protokoll som också är äldre än WebRTC; DTLS (Datagram Transport Layer Security) och SRTP (Secure Real-time Transport Protocol). Det första protokollet, DTLS är helt enkelt TLS över UDP. (TLS är det kryptografiska protokollet som används för att säkra kommunikation via HTTPS). Det andra protokollet, SRTP, används för att kryptera RTP (Real-time Protocol) data paket.</p><p>Först ansluter WebRTC genom att göra en DTLS-handskakning över anslutningen som upprättats av ICE. Till skillnad från HTTPS använder WebRTC inte en centraliserad Certificate Authority för certifikatet. Istället verifierar WebRTC bara att certifikatet som utbyts via DTLS matchar. Denna DTLS-anslutning används sedan för DataChannel-meddelanden.</p><p>WebRTC använder sedan ett annat protokoll för ljud- och video-överföring som heter RTP. Vi skyddar våra RTP-paket med SRTP. Vi initierar vår SRTP-session genom att extrahera nycklarna från den förhandlade DTLS-sessionen.</p><p>Vi kommer att gå igenom varför medieöverföring har ett eget protokoll i ett senare kapitel, men just nu räcker det att veta add de hanteras separat.</p><p>Nu är vi klara! Vi har nu satt upp dubbelriktad och säker kommunikation. Om du har en stabil anslutning mellan dina WebRTC-agenter är det här all komplexitet du behöver. Tyvärr har den verkliga världen andra problem som paketförlust och brist på bandbredd. Nästa avsnitt handlar om hur vi hanterar dem.</p><h3 id=kommunicera-med-parter-via-rtp-och-sctp>Kommunicera med parter via RTP och SCTP
<a class=anchor href=#kommunicera-med-parter-via-rtp-och-sctp>#</a></h3><p>Nu när vi har nu två WebRTC-agenter med säker dubbelriktad uppkoppling, låt oss börja kommunicera! Återigen använder vi två befintliga protokoll: RTP (Real-time Transport Protocol) och SCTP (Stream Control Transmission Protocol). Vi använder RTP för att utbyta media krypterat med SRTP och vi använder SCTP för att skicka och ta emot DataChannel-meddelanden krypterade med DTLS.</p><p>RTP är ganska minimalt, men ger oss allt vi behöver för att implementera realtidsströmning. Det viktiga är att RTP ger utvecklaren flexibilitet, så att de kan hantera latens, förlust och trängsel som de vill. Vi kommer att gå igenom detta i detalj i mediekapitlet.</p><p>Det slutliga protokollet i stacken är SCTP. SCTP tillåter många leveransalternativ för meddelanden. Du kan till exempel välja att ha opålitlig leverans utan ordning, så att du kan få den latens som behövs för realtidssystem.</p><h2 id=webrtc-en-samling-protokoll>WebRTC, en samling protokoll
<a class=anchor href=#webrtc-en-samling-protokoll>#</a></h2><p>WebRTC löser väldigt många problem åt oss. Först kan detta verka väldigt ambitiöst, men det smarta med WebRTCs är att man inte försökte lösa allt själva. Istället återanvände man många befintliga tekniker för enskilda ändamål och kombinerade dem till ett paket som är lättare att använda.</p><p>Detta gör att vi kan undersöka och lära oss om varje del individuellt, utan att bli överväldigade. Ett bra sätt att visualisera det hela är att en &ldquo;WebRTC Agent&rdquo; egentligen bara är en samordnare av många olika protokoll.</p><p><img src=../../images/01-webrtc-agent.png alt="WebRTC Agent" title="WebRTC Agent"></p><h2 id=hur-fungerar-apiet-webrtc>Hur fungerar API:et WebRTC
<a class=anchor href=#hur-fungerar-apiet-webrtc>#</a></h2><p>Det här avsnittet visar hur JavaScript API:et kopplas till protokollet. Detta är inte tänkt som ett omfattande demo av WebRTC API:et, utan mer för att skapa en mental modell för hur det hela hänger ihop.
Om du inte känner till någon av dem är det ok. Det här kan vara ett roligt avsnitt att återvända till när du lär dig mer!</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p><code>RTCPeerConnection</code> är den högsta nivån av en &ldquo;WebRTC Session&rdquo;. Den innehåller alla ovan nämnda protokoll. Delsystemen är alla allokerade men ingenting händer ännu.</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code> skapar en ny RTP-ström. En slumpmässig synkroniseringskälla (SSRC) kommer att genereras för denna ström. Den här strömmen kommer sedan att finnas i Sessionsbeskrivningen som genereras av <code>createOffer</code> inuti en media-sektion. Varje samtal till <code>addTrack</code> skapar en ny SSRC och media-sektion.</p><p>Omedelbart efter att en SRTP-session har upprättats kommer dessa mediepaket att skickas via ICE efter att ha krypterats med SRTP.</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p><code>createDataChannel</code> skapar en ny SCTP-ström om det inte finns någon SCTP-koppling. Som standard är SCTP inte aktiverat men startas bara när en sida begär en datakanal.</p><p>Omedelbart efter att en DTLS-session har upprättats kommer SCTP-föreningen att skicka paket via ICE och krypteras med DTLS.</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code> genererar en sessionsbeskrivning (Session Description) av det lokala tillståndet som ska delas med den andra parten.</p><p>Handlingen att anropa <code>createOffer</code> förändrar ingenting för den lokala parten.</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code> gör alla begärda ändringar. <code>addTrack</code>, <code>createDataChannel</code> och liknande anrop är alla tillfälliga tills detta anrop görs. <code>setLocalDescription</code> anropas med det värde som genereras av <code>createOffer</code>.</p><p>Vanligtvis, efter det här anropet, kommer du att skicka erbjudandet till den andra parten, och de kommer att kalla <code>setRemoteDescription</code> med den.</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p><code>setRemoteDescription</code> är hur vi informerar den lokala agenten om andra kandidaters tillstånd. Så här görs signalering med JavaScript API:et.</p><p>När <code>setRemoteDescription</code> har anropats på båda sidor har WebRTC agenterna tillräckligt med information för att börja kommunicera direkt part-till-part (P2P)!</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code> tillåter en WebRTC-agent att lägga till fler ICE-kandidater på när som helst. Detta API skickar ICE-kandidaten direkt in i ICE-delsystemet och har ingen annan effekt på själva WebRTC-anslutningen.</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code> är ett återanrop som avfyras när ett RTP-paket tas emot från den andra parten. De inkommande paketen skulle ha deklarerats i Sessionsbeskrivningen som skickades till <code>setRemoteDescription</code>.</p><p>WebRTC använder SSRC för att hitta rätt <code>MediaStream</code> och <code>MediaStreamTrack</code>, och avfyrar återanropet med dessa detaljer fyllda.</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code> är en återanrop som avfyras för att visa tillståndet hos ICE-agenten. När du har fått en nätverksanslutning eller när du kopplas bort så får du det här meddelandet.</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code> är en kombination av ICE agenten och DTLS agentens tillstånd. Du kan lyssna på detta meddelande för att få veta när uppsättningen av både ICE och DTLS har slutförts.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/4a018295aa5e2a3dc14acf11f9f1c7a7a73983d6 title='Senast modifierad av Claes Mogren | oktober 20, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>oktober 20, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Redigera denna sida</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#vad-är-webrtc>Vad är WebRTC?</a></li><li><a href=#varför-ska-jag-lära-mig-webrtc>Varför ska jag lära mig WebRTC?</a></li><li><a href=#webrtc-protokollet-är-en-samling-av-andra-tekniker>WebRTC Protokollet är en samling av andra tekniker</a><ul><li><a href=#signalering-hur-parter-hittar-varandra-i-webrtc>Signalering: Hur parter hittar varandra i WebRTC</a></li><li><a href=#anslutning-och-nat-traversal-med-stunturn>Anslutning och NAT Traversal med STUN/TURN</a></li><li><a href=#säkra-transportskiktet-med-dtls-och-srtp>Säkra transportskiktet med DTLS och SRTP</a></li><li><a href=#kommunicera-med-parter-via-rtp-och-sctp>Kommunicera med parter via RTP och SCTP</a></li></ul></li><li><a href=#webrtc-en-samling-protokoll>WebRTC, en samling protokoll</a></li><li><a href=#hur-fungerar-apiet-webrtc>Hur fungerar API:et WebRTC</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>