<!doctype html><html lang=sv dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Felsökning # Felsökning av WebRTC kan vara en trixig uppgift. Det finns många rörliga delar, och de kan alla gå sönder oberoende av varandra. Om du inte är försiktig kan du förlora veckor på att kolla på fel saker. När du äntligen hittar den del som är trasig måste du lära dig mer för att förstå varför.
Detta kapitel kommer att få dig att tänka på rätt sätt för att felsöka WebRTC."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/sv/docs/09-debugging/"><meta property="og:site_name" content="WebRTC för nyfikna"><meta property="og:title" content="Felsökning"><meta property="og:description" content="Felsökning # Felsökning av WebRTC kan vara en trixig uppgift. Det finns många rörliga delar, och de kan alla gå sönder oberoende av varandra. Om du inte är försiktig kan du förlora veckor på att kolla på fel saker. När du äntligen hittar den del som är trasig måste du lära dig mer för att förstå varför.
Detta kapitel kommer att få dig att tänka på rätt sätt för att felsöka WebRTC."><meta property="og:locale" content="sv"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-02-25T10:09:59+08:00"><title>Felsökning | WebRTC för nyfikna</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/sv/docs/09-debugging/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/09-debugging/ title=调试><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/09-debugging/ title=デバッグ><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/09-debugging/ title="اشکال زدایی"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/09-debugging/ title="Hata Ayıklama"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/09-debugging/ title=디버깅><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/sv.search.min.fd90457d4862486103b93b93064dd29dc3b4c5b2333733016b4209da43dcc99b.js integrity="sha256-/ZBFfUhiSGEDuTuTBk3SncO0xbIzNzMBa0IJ2kPcyZs=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/sv/><span>WebRTC för nyfikna</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Sök aria-label=Sök maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/09-debugging/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/09-debugging/>Русский</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/09-debugging/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/09-debugging/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/09-debugging/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/09-debugging/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/09-debugging/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/09-debugging/>한국어</a></li></ul></li></ul><ul><li><a href=/sv/docs/01-what-why-and-how/>Vad, varför och hur</a></li><li><a href=/sv/docs/02-signaling/>Signalering</a></li><li><a href=/sv/docs/03-connecting/>Anslutning</a></li><li><a href=/sv/docs/04-securing/>Säkerhet</a></li><li><a href=/sv/docs/05-real-time-networking/>Realtidsnätverk</a></li><li><a href=/sv/docs/06-media-communication/>Mediakommunikation</a></li><li><a href=/sv/docs/07-data-communication/>Datakommunikation</a></li><li><a href=/sv/docs/08-applied-webrtc/>Hur WebRTC används</a></li><li><a href=/sv/docs/09-debugging/ class=active>Felsökning</a></li><li><a href=/sv/docs/10-history-of-webrtc/>Historia</a></li><li><a href=/sv/docs/11-faq/>FAQ</a></li><li><a href=/sv/docs/12-glossary/>Ordlista</a></li><li><a href=/sv/docs/13-reference/>Referenser</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Felsökning</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#isolera-problemet>Isolera problemet</a><ul><li><a href=#signalfel>Signalfel</a></li><li><a href=#nätverksfel>Nätverksfel</a></li><li><a href=#säkerhetsfel>Säkerhetsfel</a></li><li><a href=#mediefel>Mediefel</a></li><li><a href=#datafel>Datafel</a></li></ul></li><li><a href=#praktiska-verktyg>Praktiska verktyg</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>wireshark</a></li><li><a href=#webrtc-internals>webrtc-internals</a></li></ul></li><li><a href=#latens>Latens</a><ul><li><a href=#manuell-mätning-från-start-till-slut>Manuell mätning från start till slut</a></li><li><a href=#automatisk-start-till-slut-mätning>Automatisk start-till-slut-mätning</a></li><li><a href=#tips-för-att-felsöka-latensproblem>Tips för att felsöka latensproblem</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=felsökning>Felsökning
<a class=anchor href=#fels%c3%b6kning>#</a></h1><p>Felsökning av WebRTC kan vara en trixig uppgift. Det finns många rörliga delar, och de kan alla gå sönder oberoende av varandra. Om du inte är försiktig kan du förlora veckor på att kolla på fel saker. När du äntligen hittar den del som är trasig måste du lära dig mer för att förstå varför.</p><p>Detta kapitel kommer att få dig att tänka på rätt sätt för att felsöka WebRTC. Det kommer att visa dig hur du bryter ner problemet. När vi känner till problemet ger vi en snabb översikt av de mest populära felsökningsverktygen.</p><h2 id=isolera-problemet>Isolera problemet
<a class=anchor href=#isolera-problemet>#</a></h2><p>När du felsöker måste du isolera var problemet kommer ifrån. Börja från början av&mldr;</p><h3 id=signalfel>Signalfel
<a class=anchor href=#signalfel>#</a></h3><p>TODO!</p><h3 id=nätverksfel>Nätverksfel
<a class=anchor href=#n%c3%a4tverksfel>#</a></h3><p>Testa din STUN-server med netcat:</p><ol><li><p>Förbered ett <strong>20-byte</strong> bindningsförfråganspaket:</p><pre tabindex=0><code>echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | hexdump -C
00000000  00 01 00 00 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54                                       |TEST|
00000014
</code></pre><p>Förklaring:</p><ul><li><code>00 01</code> är meddelandetypen.</li><li><code>00 00</code> är längden på datan.</li><li><code>21 12 a4 42</code> är den magiska kakan.</li><li>och <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (I ASCII: <code>TESTTESTTEST</code>) är ett 12-byte långt transaktions-ID.</li></ul></li><li><p>Skicka meddelandet och vänta på det <strong>32 byte</strong> stora svaret:</p><pre tabindex=0><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54 00 20 00 08  00 01 6f 32 7f 36 de 89  |TEST. ....o2.6..|
00000020
</code></pre><p>Förklaring:</p><ul><li><code>01 01</code> är meddelandetypen.</li><li><code>00 0c</code> är längden på datan, i det hör fallet 12 i decimaltal.</li><li><code>21 12 a4 42</code> är den magiska kakan.</li><li>och <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (I ASCII: <code>TESTTESTTEST</code>) är ett 12-bitars transaktions-ID</li><li><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> de 12-bitarna med data, som översatt blir:<ul><li><code>00 20</code> är typen: <code>XOR-MAPPED-ADDRESS</code>.</li><li><code>00 08</code> är längden på värdet, i det här fallet 8 bytes</li><li><code>00 01 6f 32 7f 36 de 89</code> är själva värdet, som översatt blir:<ul><li><code>00 01</code> adresstyp (IPv4)</li><li><code>6f 32</code> den XOR-mappade porten</li><li><code>7f 36 de 89</code> den XOR-mappede IP-adressen</li></ul></li></ul></li></ul></li></ol><p>Avkodning av det XOR-mappade avsnittet är lite krångligt, men vi kan lura stun-servern att utföra en dummy-XOR-mappning genom att skicka en (ogiltig) dummy-magisk cookie inställd på <code>00 00 00 00</code>:</p><pre tabindex=0><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &#34;\x00\x01\x00\x00\x00\x00\x00\x00TESTTESTTEST&#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 00 00 00 00  54 45 53 54 54 45 53 54  |........TESTTEST|
00000010  54 45 53 54 00 01 00 08  00 01 4e 20 5e 24 7a cb  |TEST......N ^$z.|
00000020
</code></pre><p>XOR på en magiska kakan med bara nollor ändrar inget, så porten och adressen kommer att vara i klartext i svaret. Detta fungerar inte alltid, eftersom vissa routrar manipulerar de passerande paketen, fusk på IP-adressen. Om vi tittar på det returnerade värdet (senaste åtta byten):</p><ul><li><code>00 01 4e 20 5e 24 7a cb</code> data värdet, som översatt blir:<ul><li><code>00 01</code> adresstyp (IPv4)</li><li><code>4e 20</code> portwn, i det hör fallet 20000 i decimal tal.</li><li><code>5e 24 7a cb</code> är IP adressen, <code>94.36.122.203</code> i mer lättläst form.</li></ul></li></ul><h3 id=säkerhetsfel>Säkerhetsfel
<a class=anchor href=#s%c3%a4kerhetsfel>#</a></h3><h3 id=mediefel>Mediefel
<a class=anchor href=#mediefel>#</a></h3><h3 id=datafel>Datafel
<a class=anchor href=#datafel>#</a></h3><h2 id=praktiska-verktyg>Praktiska verktyg
<a class=anchor href=#praktiska-verktyg>#</a></h2><h3 id=netcat-nc>netcat (nc)
<a class=anchor href=#netcat-nc>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Netcat>netcat</a> är ett nätverksverktyg för kommandoraden som kan läsa och skriva till nätverksanslutningar via TCP eller UDP. Det är vanligtvis tillgängligt som kommandot <code>nc</code>.</p><h3 id=tcpdump>tcpdump
<a class=anchor href=#tcpdump>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Tcpdump>tcpdump</a> är ett datanätverkspaketanalysverktyg för kommandoraden.</p><p>Vanliga kommandon:</p><ul><li><p>Fånga UDP-paket till och från port 19302, skriv ut en hexdump av paketinnehållet:</p><p><code>sudo tcpdump 'udp port 19302' -xx</code></p></li><li><p>Samma, men spara istället paketen i en PCAP-fil (packet capture) för senare inspektion:</p><p><code>sudo tcpdump 'udp port 19302' -w stun.pcap</code></p><p>PCAP-filen kan öppnas med Wireshark-applikationen: <code>wireshark stun.pcap</code></p></li></ul><h3 id=wireshark>wireshark
<a class=anchor href=#wireshark>#</a></h3><h3 id=webrtc-internals>webrtc-internals
<a class=anchor href=#webrtc-internals>#</a></h3><p>Chrome har en inbyggd WebRTC-statistiksida som du hittar på <a href=chrome://webrtc-internals>chrome://webrtc-internals</a>.</p><h2 id=latens>Latens
<a class=anchor href=#latens>#</a></h2><p>Hur vet du om du har hög latens? Du kanske har märkt att din video släpar efter, men vet du exakt hur mycket efter den är?
För att kunna minska latensen måste du börja med att mäta den först.</p><p>Sann latens ska mätas hela vägen. Det betyder inte bara latensen för nätverket mellan avsändaren och mottagaren, utan den kombinerade latensen för kamera, kodande av video, överföring, mottagning, avkodning och visning, samt eventuell a köer mellan dessa steg.</p><p>Total latens kan inte beräknas som en summa av latensen för varje komponent.</p><p>Även om du teoretiskt kan mäta latensen för alla komponenter i en live videoöverföring separat och sedan lägga hop dem, i praktiken kommer åtminstone vissa komponenter antingen att vara oåtkomliga för instrumentering eller ge ett helt annat resultat när de mäts utanför överföringen.
Olika buffrings-effekter mellan steg i video pipelinen, nätverkstopologi och automatiska kamera justeringar är bara några exempel på komponenter som påverkar den faktiska latensen.</p><p>Den inneboende latensen för varje komponent i ditt livesändningssystem kan förändras och påverka nedströms komponenter.
Även innehållet i den inspelade videon påverkar latensen.
Till exempel krävs många fler bitar för komplexa bilder såsom trädgrenar, jämfört med en klarblå himmel som innehåller mycket mindre information.
En kamera med automatisk exponering aktiverad kan ta <em>mycket</em> längre tid än de förväntade 33 millisekunderna för att ta en bild, även om inspelningshastigheten är inställd på 30 bilder per sekund.
Överföring över nätverket, särskilt mobila nät, ändras också ofta på grund av förändrad efterfrågan och kapacitet.
Fler användare introducerar mer störningar i luften.
Din fysiska plats (områden med dålig täckning) och flera andra faktorer ökar paketförlust och latens.
Vad händer när du skickar ett paket till ett nätverksinterface, till exempel en WiFi-adapter eller ett LTE-modem?
Om paketet inte kan skickas omedelbart köas det upp, ju längre kö desto mer latens introducerar ett sådant nätverksinterface.</p><h3 id=manuell-mätning-från-start-till-slut>Manuell mätning från start till slut
<a class=anchor href=#manuell-m%c3%a4tning-fr%c3%a5n-start-till-slut>#</a></h3><p>När vi pratar om start-till-slut-latens menar vi tiden mellan en händelse som inträffar och när den observeras, det vill säga att bilden visas på skärmen.</p><pre tabindex=0><code>EndToEndLatency = T(observe) - T(happen)
</code></pre><p>Ett naivt tillvägagångssätt är att mäta tiden när en viss händelse sker och subtrahera den från tiden vid när man kan se videon av händelsen.
Men när precisionen är nere på millisekunder blir tidssynkronisering ett problem.
Att försöka synkronisera klockor över distribuerade system är oftast meningslöst, även ett litet fel i tidssynkronisering ger opålitliga mätningar.</p><p>En enkel lösning på klocksynkroniseringsproblemet är att använda samma klocka, att
placera sändare och mottagare i samma referensram.</p><p>Tänk dig att du verkligen har en tickande millisekund-klocka eller någon annan händelsekälla.
Du vill mäta latens i ett system som live streamar klockan till en skärm genom att peka en kamera mot den.
Ett uppenbart sätt att mäta tiden mellan att millisekundtimern tickar (T<sub><code>happen</code></sub>) och klockans bild visas på skärmen (T<sub><code>observe</code></sub>) är följande:</p><ul><li>Rikta kameran mot klockan.</li><li>Skicka videon till en mottagare som är på samma fysiska plats.</li><li>Ta en bild (använd din telefon) av klockan och den mottagna videon på skärmen.</li><li>Subtrahera två gånger.</li></ul><p>Det är den mest riktiga mätningen för start-till-slut-latens.
Den innehåller alla komponenters latens (kamera, kodek, nätverk, avkodare) och är inte beroende av någon klocksynkronisering.</p><p><img src=../../images/09-diy-latency.png alt="DIY Latency" title="DIY Latency Measurement">.
<img src=../../images/09-diy-latency-happen-observe.png alt="DIY Latency Example" title="DIY Latency Measurement Example">
På bilden ovan är uppmätta start-till-slut-latensen 101 ms. Tiden som syns just nu är 10:16:02.862, men observatören av live-streaming-systemet ser 10:16:02.761.</p><h3 id=automatisk-start-till-slut-mätning>Automatisk start-till-slut-mätning
<a class=anchor href=#automatisk-start-till-slut-m%c3%a4tning>#</a></h3><p>I skrivande stund (maj 2021) <a href=https://github.com/w3c/webrtc-stats/issues/537>diskuteras</a> WebRTC-standarden för start-till-slut-latens aktivt.
Firefox implementerade en uppsättning API:er för att låta användare skapa automatisk latensmätning över standard WebRTC API:et.
Men i det här kapitlet diskuterar vi det mest kompatibla sättet att automatiskt mäta latens.</p><p><img src=../images/09-ntp-latency.png alt="NTP Style Latency Measurement" title="NTP Style Latency Measurement"></p><p>Tur-och-returtid i ett nötskal: Jag skickar dig min tid <code>tR1</code>, när jag får tillbaka min <code>tR1</code> vid tiden <code>tR2</code> vet jag att tur-och-returtiden är <code>tR2 - tR1</code>.</p><p>Tänk dig att du har en kommunikationskanal mellan sändare och mottagare (t.ex. en <a href=https://webrtc.org/getting-started/data-channels>DataChannel</a>. Då kan mottagaren modellera avsändarens monotona klocka genom att följa nedanstående steg:</p><ol><li>Vid tidpunkten <code>tR1</code> skickar mottagaren ett meddelande med sin lokala klocktid.</li><li>När den tas emot av sändaren med lokal tid <code>tS1</code>, svarar sändaren med en kopia av <code>tR1</code> samt sändarens <code>tS1</code> och sändarens video-tid <code>tSV1</code>.</li><li>Vid tidpunkten <code>tR2</code> hos mottagaren beräknas tur-och-retur-tiden genom att subtrahera meddelandets sändnings- och mottagningstider: <code>RTT = tR2 - tR1</code>.</li><li>Tur-och-retur-tid (<code>RTT</code>) tillsammans med avsändarens lokala tid <code>tS1</code> är tillräckligt för att göra en uppskattning av avsändarens monotona klocka. Den aktuella tiden hos avsändaren vid tiden <code>tR2</code> bör vara lika med <code>tS1</code> plus hälften av tur-och-retur-tiden.</li><li>Avsändarens lokala klocka <code>tS1</code> tillsammans med videospårets tidsstämpel <code>tSV1</code> och tur-och-retur-tiden <code>RTT</code> räcker därför för att synkronisera mottagarens video med avsändarens video.</li></ol><p>Nu när vi vet hur mycket tid som har gått sedan senaste video-bilden (<code>tSV1</code>), kan vi göra en ungefärlig uppskattning av latensen genom att dra bort klockstämpeln hos video-bilden som visas just nu från den uppskattade tiden:</p><pre tabindex=0><code>expected_video_time = tSV1 + time_since(tSV1)
latency = expected_video_time - actual_video_time
</code></pre><p>Metodens nackdel är att den inte inkluderar själva kamerans latens.
De flesta videosystem anser att tidsstämpeln för bildtagning är den tid då kameran skickat bilden till minnet, vilket kommer att vara några ögonblick efter att själva kamera sensorn tog emot bilden.</p><h4 id=exempel-på-latensuppskattning>Exempel på latensuppskattning
<a class=anchor href=#exempel-p%c3%a5-latensuppskattning>#</a></h4><p>I exemplet nedan öppnas en datakanal kallad <code>latency</code> hos mottagaren, som periodiskt skickar tidsstämplar till sändaren. Sändaren svarar tillbaka med ett JSON-meddelande.
Mottagaren beräknar latensen baserat på det meddelandet.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;received_time&#34;</span>: <span style=color:#ae81ff>64714</span>,       <span style=color:#75715e>// Timestamp sent by receiver, sender reflects the timestamp. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;delay_since_received&#34;</span>: <span style=color:#ae81ff>46</span>,   <span style=color:#75715e>// Time elapsed since last `received_time` received on sender.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;local_clock&#34;</span>: <span style=color:#ae81ff>1597366470336</span>, <span style=color:#75715e>// The sender&#39;s current monotonic clock time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;track_times_msec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;myvideo_track1&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>13100</span>,        <span style=color:#75715e>// Video frame RTP timestamp (in milliseconds).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>1597366470289</span> <span style=color:#75715e>// Video frame monotonic clock timestamp.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Öppna en data-kanal hos mottagaren:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>createDataChannel</span>(<span style=color:#e6db74>&#39;latency&#39;</span>);
</span></span></code></pre></div><p>Skicka mottagarens tid <code>tR1</code> med jämna mellanrum. Valet av 2 sekunder har ingen specifik betydelse:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>setInterval</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>tR1</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span></code></pre></div><p>Hantera inkommande meddelanden från mottagaren hos sändaren:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Assuming event.data is a string like &#34;1234567&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span><span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>42000</span>; <span style=color:#75715e>// Current frame RTP timestamp converted to millisecond timescale.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tS1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1597366470289</span>; <span style=color:#75715e>// Current frame monotonic clock timestamp.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;received_time&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>tR1</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;delay_since_received&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;local_clock&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>now</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;track_times_msec&#34;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;myvideo_track1&#34;</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>msg</span>));
</span></span></code></pre></div><p>Hantera inkommande meddelande från sändaren och visa den beräknade latensen i konsolen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>fromSender</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;received_time&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;delay_since_received&#39;</span>]; <span style=color:#75715e>// How much time that has passed between the sender receiving and sending the response.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;local_clock&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>networkLatency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>networkLatency</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>VIDEO</span>.<span style=color:#a6e22e>requestVideoFrameCallback</span>((<span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>framemeta</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Estimate current time of the sender.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR2</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>] <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>entries</span>(<span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;track_times_msec&#39;</span>])[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tS1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>actualVideoTimeMsec</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>framemeta</span>.<span style=color:#a6e22e>rtpTimestamp</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>90</span>); <span style=color:#75715e>// Convert RTP timebase (90000) to millisecond timebase.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>latency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>actualVideoTimeMsec</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;latency&#39;</span>, <span style=color:#a6e22e>latency</span>, <span style=color:#e6db74>&#39;msec&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=actual-video-time-in-browser>Actual video time in browser
<a class=anchor href=#actual-video-time-in-browser>#</a></h4><blockquote><p><code>&lt;video>.requestVideoFrameCallback()</code> tillåter webbutvecklare att få ett meddelande när en bild har är tillgänglig att visas.</p></blockquote><p>Fram till mycket nyligen (maj 2020), var det nästan omöjligt att på ett tillförlitligt sätt få en tidsstämpel för den visade bilden i en webbläsare. Lösningar baserade på <code>video.currentTime</code> fanns, men de var inte särskilt exakta.
Utvecklare från både Chrome och Mozilla <a href=https://github.com/mozilla/standards-positions/issues/250>stödde</a> införandet av en ny W3C-standard, <a href=https://wicg.github.io/video-rvfc/><code>HTMLVideoElement.requestVideoFrameCallback()</code></a>, som lägger till ett nytt API för att komma åt den aktuella bildens tidsstämpel.
Även om tillägget låter trivialt, har det möjliggjort flera avancerade medieapplikationer via nätet som kräver ljud- och videosynkronisering.
För WebRTC inkluderar API:et fältet <code>rtpTimestamp</code> i meddelandet, RTP-tidsstämpeln associerad med den aktuella bilden.
Detta fält finns bara för WebRTC-applikationer, annars saknas det.</p><h3 id=tips-för-att-felsöka-latensproblem>Tips för att felsöka latensproblem
<a class=anchor href=#tips-f%c3%b6r-att-fels%c3%b6ka-latensproblem>#</a></h3><p>Eftersom felsökning sannolikt kommer att påverka den uppmätta latensen är den allmänna regeln att förenkla dit system till minsta möjliga som fortfarande kan reproducera problemet.
Ju fler komponenter du kan ta bort, desto lättare blir det att ta reda på vilken komponent som orsakar latensproblemet.</p><h4 id=kameralatens>Kameralatens
<a class=anchor href=#kameralatens>#</a></h4><p>Beroende på kamerainställningar kan kamerans latens variera.
Kontrollera inställningar för automatisk exponering, autofokus och automatisk vitbalans.
Alla &ldquo;auto&rdquo;-funktionerna på webbkameror tar lite extra tid för att analysera den tagna bilden innan den är tillgänglig för WebRTC-stacken.</p><p>Om du kör Linux kan du använda kommandoradsverktyget <code>v4l2-ctl</code> för att ändra kamerainställningarna:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Stäng av autofocus:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_auto<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Sätt fokus till max:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_absolute<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Du kan också använda det grafiska verktyget <code>guvcview</code> för att kontrollera och justera kamerainställningarna.</p><h4 id=kodarens-latens>Kodarens latens
<a class=anchor href=#kodarens-latens>#</a></h4><p>De flesta moderna kodare kommer att buffra ett antal bilder innan de kodas.
Deras högsta prioritet är att hitta en balans mellan kvaliteten på den producerade bilden och hur mycket data varje bild använder (bitrate).
Multipass-kodning är ett extremt exempel där kodaren helt bortser från latensen.
Under det första passet tar den in hela videon och först därefter börjar utmatning av bilder.</p><p>Men med rätt inställningar är det möjligt att nå latens lägre än den önskade bildfrekvensen.
Se till att din kodare inte använder för många I-bilder eller förlitar dig på B-bilder.
Varje codecs inställningar för latensinställning är olika, men för x264 rekommenderar vi att du använder <code>tune=zerolatency</code> och <code>profile=baseline</code> för få så låg latens som möjligt.</p><h4 id=nätverksfördröjning>Nätverksfördröjning
<a class=anchor href=#n%c3%a4tverksf%c3%b6rdr%c3%b6jning>#</a></h4><p>Nätverksfördröjningar är nog det kan göra minst åt, förutom att uppgradera till en bättre internetanslutning.
Nätverksfördröjningar är ungefär som vädret - du kan inte stoppa regnet, men du kan kolla prognosen och ta med ett paraply.
WebRTC mäter nätverksförhållanden med millisekundprecision.
Viktiga mätvärden är:</p><ul><li>Tur-och-returtid</li><li>Paketförlust och omskickande av paket.</li></ul><p><strong>Tur-och-returtid</strong></p><p>WebRTC-stacken har en inbyggd <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime>nätverksmätningsmekanism</a> för tur-och-returtid.
En tillräckligt bra uppskattning av latens är hälften av RTT. Det förutsätter att det tar samma tid att skicka och ta emot ett paket, vilket inte alltid är fallet.
Tur-och-returtid sätter den lägre gränsen för start-till-slut-latens.
Dina bilder når inte mottagaren snabbare än <code>RTT/2</code>, oavsett hur snabbt din kamera skickar bilder till kodaren.</p><p>Den inbyggda RTT-mekanismen är baserad på speciella RTCP-paket som kallas avsändar-/mottagarrapporter.
Avsändaren skickar sin tidsavläsning till mottagaren, mottagaren återspeglar i sin tur samma tidsstämpel till avsändaren.
Därmed vet avsändaren hur mycket tid det tog för paketet att skickas till mottagaren och tillbaka.
Se kapitlet <a href=../06-media-communication/#senderreceiver-reports>Avsändar-/mottagarrapporter</a> för mer information om RTT-mätning.</p><p><strong>Paketförlust och omskickande av paket</strong></p><p>Både RTP och RTCP är protokoll baserade på UDP som inte har någon garanti för varken ordning, leverans eller duplicering.
Allt ovanstående fall dyker upp när du använder WebRTC-applikationer.
En osofistikerad avkodarimplementering förväntar sig att alla paket i en bild ska levereras för att avkodaren ska sätta ihop bilden igen.
Vid paketförlust kan avkodningsartefakter uppstå om paket med en <a href=../06-media-communication/#inter-frame-types>P-bild</a> går förlorade.
Om en I-bild-paket tappas får alla följande bilder antingen grava artefakter, eller kommer inte att avkodas och visas alls.
Mest troligt kommer detta att få videon att &ldquo;frysa&rdquo; för ett ögonblick.</p><p>För att undvika (åtminstone försöka undvika) att videon fryser eller är full av avkodningsartefakter använder WebRTC negativa bekräftelsemeddelanden (<a href=../06-media-communication/#negative-acknowledgment>NACK</a>).
När mottagaren inte får ett förväntat RTP-paket returnerar det ett NACK-meddelande för att be avsändaren att skicka det saknade paketet igen.
Mottagaren <em>väntar</em> på omskickandet av paketet.
Sådana omskickningar orsakar givetvis ökad latens.
Antalet skickade och mottagna NACK-paket registreras i WebRTCs inbyggda statistikfält <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcoutboundrtpstreamstats-nackcount>outbound stream nackCount</a> och <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-nackcount>inbound stream nackCount</a>.</p><p>Du kan se fina diagram över inkommande och utgående <code>nackCount</code> på <a href=#webrtc-internals>webrtc internals sidan</a>.
Om du ser att <code>nackCount</code> ökar, betyder det att nätverket upplever höga paketförluster, och WebRTC-stacken gör sitt bästa för att skapa en smidig video och ljudupplevelse trots det.</p><p>När paketförlusten är så hög att avkodaren inte kan producera en bild eller efterföljande beroende bilder, som i fallet med en helt förlorad I-bild, kommer alla framtida P-bilder inte att avkodas.
Mottagaren kommer att försöka mildra det genom att skicka ett speciellt bildförlustindikationsmeddelande (Picture Loss Indication message, <a href=../06-media-communication/#full-intra-frame-request-fir-and-picture-loss-indication-pli>PLI</a>).
När sändaren får ett <code>PLI</code> meddelande kommer den att skicka en ny I-bild för att hjälpa mottagarens avkodare.
I-bilder är normalt större än P-bilder, så det ökar mängden data som behöver sändas.
Precis som med NACK-meddelanden måste mottagaren vänta på den nya I-bilden vilket ökar latensen ytterligare.</p><p>Kolla efter <code>pliCount</code> på <a href=#webrtc-internals>webrtc internals sidan</a>. Om den ökar, justera din kodare så att den skickar mindre data, eller producerar paket med mer redundans.</p><h4 id=latens-på-mottagarsidan>Latens på mottagarsidan
<a class=anchor href=#latens-p%c3%a5-mottagarsidan>#</a></h4><p>Latens kommer att påverkas av paket som kommer fram i fel ordning.
Om den nedre halvan av en bild kommer före toppen måste du vänta på toppen innan du kan avkoda den.
Detta förklaras mer noggrant i kapitlet <a href=../05-real-time-networking/#solving-jitter>Solving Jitter</a>.</p><p>Du kan också hänvisa till det inbyggda <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay>jitterBufferDelay</a> mätningen för att se hur länge en bild hölls i mottagningsbufferten i väntan på alla paket, innan den skickades vidare till avkodaren.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/4917936e291137a624c77f0aa8794a4b24f81d73 title='Senast modifierad av Pang | februari 25, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>februari 25, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/09-debugging.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Redigera denna sida</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#isolera-problemet>Isolera problemet</a><ul><li><a href=#signalfel>Signalfel</a></li><li><a href=#nätverksfel>Nätverksfel</a></li><li><a href=#säkerhetsfel>Säkerhetsfel</a></li><li><a href=#mediefel>Mediefel</a></li><li><a href=#datafel>Datafel</a></li></ul></li><li><a href=#praktiska-verktyg>Praktiska verktyg</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>wireshark</a></li><li><a href=#webrtc-internals>webrtc-internals</a></li></ul></li><li><a href=#latens>Latens</a><ul><li><a href=#manuell-mätning-från-start-till-slut>Manuell mätning från start till slut</a></li><li><a href=#automatisk-start-till-slut-mätning>Automatisk start-till-slut-mätning</a></li><li><a href=#tips-för-att-felsöka-latensproblem>Tips för att felsöka latensproblem</a></li></ul></li></ul></nav></div></aside></main></body></html>