<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.119.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="What, Why and How # What is WebRTC? # WebRTC, short for Web Real-Time Communication, is both an API and a Protocol. The WebRTC protocol is a set of rules for two WebRTC agents to negotiate bi-directional secure real-time communication. The WebRTC API then allows developers to use the WebRTC protocol. The WebRTC API is specified only for JavaScript.
A similar relationship would be the one between HTTP and the Fetch API."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="What, Why and How"><meta property="og:description" content="What, Why and How # What is WebRTC? # WebRTC, short for Web Real-Time Communication, is both an API and a Protocol. The WebRTC protocol is a set of rules for two WebRTC agents to negotiate bi-directional secure real-time communication. The WebRTC API then allows developers to use the WebRTC protocol. The WebRTC API is specified only for JavaScript.
A similar relationship would be the one between HTTP and the Fetch API."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/01-what-why-and-how/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-05-31T16:36:50-04:00"><title>What, Why and How | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ title="Vad, varför och hur"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/ title="Что, Зачем и как ?"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/ title="Quoi, Pourquoi et Comment"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ title="Apa, Mengapa, dan Bagaimana"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ title="¿Qué, Por qué y Cómo?"><link rel=stylesheet href=/book.min.e935e20bd0d469378cb482f0958edf258c731a4f895dccd55799c6fbc8043f23.css integrity="sha256-6TXiC9DUaTeMtILwlY7fJYxzGk+JXczVV5nG+8gEPyM="><script defer src=/en.search.min.10cb999fc66fcb108b163a87fb347e8d157f0ec3688ef8f8cb687fe3613108c2.js integrity="sha256-EMuZn8ZvyxCLFjqH+zR+jRV/DsNojvj4y2h/42ExCMI="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ class=active>What, Why and How</a></li><li><a href=https://webrtcforthecurious.com/docs/02-signaling/>Signaling</a></li><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>Connecting</a></li><li><a href=https://webrtcforthecurious.com/docs/04-securing/>Securing</a></li><li><a href=https://webrtcforthecurious.com/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/>Media Communication</a></li><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>Data Communication</a></li><li><a href=https://webrtcforthecurious.com/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=https://webrtcforthecurious.com/docs/09-debugging/>Debugging</a></li><li><a href=https://webrtcforthecurious.com/docs/10-history-of-webrtc/>History</a></li><li><a href=https://webrtcforthecurious.com/docs/11-faq/>FAQ</a></li><li><a href=https://webrtcforthecurious.com/docs/12-glossary/>Glossary</a></li><li><a href=https://webrtcforthecurious.com/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>What, Why and How</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-is-webrtc>What is WebRTC?</a></li><li><a href=#why-should-i-learn-webrtc>Why should I learn WebRTC?</a></li><li><a href=#the-webrtc-protocol-is-a-collection-of-other-technologies>The WebRTC Protocol is a collection of other technologies</a><ul><li><a href=#signaling-how-peers-find-each-other-in-webrtc>Signaling: How peers find each other in WebRTC</a></li><li><a href=#connecting-and-nat-traversal-with-stunturn>Connecting and NAT Traversal with STUN/TURN</a></li><li><a href=#securing-the-transport-layer-with-dtls-and-srtp>Securing the transport layer with DTLS and SRTP</a></li><li><a href=#communicating-with-peers-via-rtp-and-sctp>Communicating with peers via RTP and SCTP</a></li></ul></li><li><a href=#webrtc-a-collection-of-protocols>WebRTC, a collection of protocols</a></li><li><a href=#how-does-the-webrtc-api-work>How does the WebRTC API work?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=what-why-and-how>What, Why and How
<a class=anchor href=#what-why-and-how>#</a></h1><h2 id=what-is-webrtc>What is WebRTC?
<a class=anchor href=#what-is-webrtc>#</a></h2><p>WebRTC, short for Web Real-Time Communication, is both an API and a Protocol. The WebRTC protocol is a set of rules for two WebRTC agents to negotiate bi-directional secure real-time communication. The WebRTC API then allows developers to use the WebRTC protocol. The WebRTC API is specified only for JavaScript.</p><p>A similar relationship would be the one between HTTP and the Fetch API. WebRTC the protocol would be HTTP, and WebRTC the API would be the Fetch API.</p><p>The WebRTC protocol is available in other APIs and languages besides JavaScript. You can find servers and domain-specific tools as well for WebRTC. All of these implementations use the WebRTC protocol so that they can interact with each other.</p><p>The WebRTC protocol is maintained in the IETF in the <a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a> working group. The WebRTC API is documented in the W3C as <a href=https://www.w3.org/TR/webrtc/>webrtc</a>.</p><h2 id=why-should-i-learn-webrtc>Why should I learn WebRTC?
<a class=anchor href=#why-should-i-learn-webrtc>#</a></h2><p>These are some of the things that WebRTC will give you:</p><ul><li>Open standard</li><li>Multiple implementations</li><li>Available in browsers</li><li>Mandatory encryption</li><li>NAT Traversal</li><li>Repurposed existing technology</li><li>Congestion control</li><li>Sub-second latency</li></ul><p>This list is not exhaustive, just an example of some of the things you may appreciate during your journey. Don&rsquo;t worry if you don&rsquo;t know all these terms yet, this book will teach them to you along the way.</p><h2 id=the-webrtc-protocol-is-a-collection-of-other-technologies>The WebRTC Protocol is a collection of other technologies
<a class=anchor href=#the-webrtc-protocol-is-a-collection-of-other-technologies>#</a></h2><p>The WebRTC Protocol is an immense topic that would take an entire book to explain. However, to start off we break it into four steps.</p><ol><li>Signaling</li><li>Connecting</li><li>Securing</li><li>Communicating</li></ol><p>These steps are sequential, which means the prior step must be 100% successful for the subsequent step to begin.</p><p>One peculiar fact about WebRTC is that each step is actually made up of many other protocols! To make WebRTC, we stitch together many existing technologies. In that sense, you can think of WebRTC as being more a combination and configuration of well-understood tech dating back to the early 2000s than as a brand-new process in its own right.</p><p>Each of these steps has dedicated chapters, but it is helpful to understand them at a high level first. Since they depend on each other, it will help when explaining further the purpose of each of these steps.</p><h3 id=signaling-how-peers-find-each-other-in-webrtc>Signaling: How peers find each other in WebRTC
<a class=anchor href=#signaling-how-peers-find-each-other-in-webrtc>#</a></h3><p>When a WebRTC Agent starts, it has no idea who it is going to communicate with or what they are going to communicate about. The <em>Signaling</em> step solves this issue! Signaling is used to bootstrap the call, allowing two independent WebRTC agents to start communicating.</p><p>Signaling uses an existing, plain-text protocol called SDP (Session Description Protocol). Each SDP message is made up of key/value pairs and contains a list of &ldquo;media sections&rdquo;. The SDP that the two WebRTC agents exchange contains details like:</p><ul><li>The IPs and Ports that the agent is reachable on (candidates).</li><li>The number of audio and video tracks the agent wishes to send.</li><li>The audio and video codecs each agent supports.</li><li>The values used while connecting (<code>uFrag</code>/<code>uPwd</code>).</li><li>The values used while securing (certificate fingerprint).</li></ul><p>It is important to note that signaling typically happens &ldquo;out-of-band&rdquo;, which means applications generally don&rsquo;t use WebRTC itself to exchange signaling messages. Any architecture suitable for sending messages can relay the SDPs between the connecting peers, and many applications will simply use their existing infrastructure (e.g. REST endpoints, WebSocket connections, or authentication proxies) to facilitate trading of SDPs between the proper clients.</p><h3 id=connecting-and-nat-traversal-with-stunturn>Connecting and NAT Traversal with STUN/TURN
<a class=anchor href=#connecting-and-nat-traversal-with-stunturn>#</a></h3><p>Once two WebRTC agents have exchanged SDPs, they have enough information to attempt to connect to each other. To make this connection happen, WebRTC uses another established technology called ICE (Interactive Connectivity Establishment).</p><p>ICE is a protocol that pre-dates WebRTC and allows the establishment of a direct connection between two agents without a central server. These two agents could be on the same network or on the other side of the world.</p><p>ICE enables direct connection, but the real magic of the connecting process involves a concept called &lsquo;NAT Traversal&rsquo; and the use of STUN/TURN Servers. These two concepts, which we will explore in more depth later, are all you need to communicate with an ICE Agent in another subnet.</p><p>When the two agents have successfully established an ICE connection, WebRTC moves on to the next step; establishing an encrypted transport for sharing audio, video, and data between them.</p><h3 id=securing-the-transport-layer-with-dtls-and-srtp>Securing the transport layer with DTLS and SRTP
<a class=anchor href=#securing-the-transport-layer-with-dtls-and-srtp>#</a></h3><p>Now that we have bi-directional communication (via ICE), we need to make our communication secure! This is done through two more protocols that also pre-date WebRTC; DTLS (Datagram Transport Layer Security) and SRTP (Secure Real-Time Transport Protocol). The first protocol, DTLS, is simply TLS over UDP (TLS is the cryptographic protocol used to secure communication over HTTPS). The second protocol, SRTP, is used to ensure encryption of RTP (Real-time Transport Protocol) data packets.</p><p>First, WebRTC connects by doing a DTLS handshake over the connection established by ICE. Unlike HTTPS, WebRTC doesn&rsquo;t use a central authority for certificates. It simply asserts that the certificate exchanged via DTLS matches the fingerprint shared via signaling. This DTLS connection is then used for DataChannel messages.</p><p>Next, WebRTC uses the RTP protocol, secured using SRTP, for audio/video transmission. We initialize our SRTP session by extracting the keys from the negotiated DTLS session.</p><p>We will discuss why media and data transmission have their own protocols in a later chapter, but for now it is enough to know that they are handled separately.</p><p>Now we are done! We have successfully established bi-directional and secure communication. If you have a stable connection between your WebRTC agents, this is all the complexity you need. In the next section, we will discuss how WebRTC deals with the unfortunate real world problems of packet loss and bandwidth limits.</p><h3 id=communicating-with-peers-via-rtp-and-sctp>Communicating with peers via RTP and SCTP
<a class=anchor href=#communicating-with-peers-via-rtp-and-sctp>#</a></h3><p>Now that we have two WebRTC agents connected and secure, bi-directional communication established, let&rsquo;s start communicating! Again, WebRTC will use two pre-existing protocols: RTP (Real-time Transport Protocol), and SCTP (Stream Control Transmission Protocol). We use RTP to exchange media encrypted with SRTP, and we use SCTP to send and receive DataChannel messages encrypted with DTLS.</p><p>RTP is quite a minimal protocol, but it provides the necessary tools to implement real-time streaming. The most important thing about RTP is that it gives flexibility to the developer, allowing them to handle latency, package loss, and congestion as they please. We will discuss this further in the media chapter.</p><p>The final protocol in the stack is SCTP. The important thing about SCTP is that you can turn off reliable and in order message delivery (among many different options). This allows developers to ensure the necessary latency for real-time systems.</p><h2 id=webrtc-a-collection-of-protocols>WebRTC, a collection of protocols
<a class=anchor href=#webrtc-a-collection-of-protocols>#</a></h2><p>WebRTC solves a lot of problems. At first glance the technology may seem over-engineered, but the genius of WebRTC is its humility. It wasn&rsquo;t created under the assumption that it could solve everything better. Instead, it embraced many existing single purpose technologies and brought them together into a streamlined, widely applicable bundle.</p><p>This allows us to examine and learn each part individually without being overwhelmed. A good way to visualize it is a &lsquo;WebRTC Agent&rsquo; is really just an orchestrator of many different protocols.</p><p><img src=../images/01-webrtc-agent.png alt="WebRTC Agent" title="WebRTC Agent Diagram"></p><h2 id=how-does-the-webrtc-api-work>How does the WebRTC API work?
<a class=anchor href=#how-does-the-webrtc-api-work>#</a></h2><p>This section outlines how the WebRTC JavaScript API maps to the WebRTC protocol described above. It isn&rsquo;t meant as an extensive demo of the WebRTC API, but more to create a mental model of how everything ties together.
If you aren&rsquo;t familiar with either the protocol or the API, don&rsquo;t worry. This could be a fun section to return to as you learn more!</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p>The <code>RTCPeerConnection</code> is the top-level &ldquo;WebRTC Session&rdquo;. It contains all the protocols mentioned above. The subsystems are all allocated but nothing happens yet.</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code> creates a new RTP stream. A random Synchronization Source (SSRC) will be generated for this stream. This stream will then be inside the Session Description generated by <code>createOffer</code> inside a media section. Each call to <code>addTrack</code> will create a new SSRC and media section.</p><p>Immediately after an SRTP Session is established, these media packets will start being encrypted using SRTP and sent via ICE.</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p><code>createDataChannel</code> creates a new SCTP stream if no SCTP association exists. SCTP is not enabled by default. It is only started when one side requests a data channel.</p><p>Immediately after a DTLS Session is established, the SCTP association will start sending packets encrypted with DTLS via ICE.</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code> generates a Session Description of the local state to be shared with the remote peer.</p><p>The act of calling <code>createOffer</code> doesn&rsquo;t change anything for the local peer.</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code> commits any requested changes. The calls <code>addTrack</code>, <code>createDataChannel</code>, and similar calls are temporary until this call. <code>setLocalDescription</code> is called with the value generated by <code>createOffer</code>.</p><p>Usually, after this call, you will send the offer to the remote peer, who will use it to call <code>setRemoteDescription</code>.</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p><code>setRemoteDescription</code> is how we inform the local agent about the state of the remote candidates. This is how the act of &lsquo;Signaling&rsquo; is done with the JavaScript API.</p><p>When <code>setRemoteDescription</code> has been called on both sides, the WebRTC agents now have enough info to start communicating Peer-To-Peer (P2P)!</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code> allows a WebRTC agent to add more remote ICE Candidates at any time. This API sends the ICE Candidate right into the ICE subsystem and has no other effect on the greater WebRTC connection.</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code> is a callback fired when an RTP packet is received from the remote peer. The incoming packets would have been declared in the Session Description that was passed to <code>setRemoteDescription</code>.</p><p>WebRTC uses the SSRC and looks up the associated <code>MediaStream</code> and <code>MediaStreamTrack</code>, and fires this callback with these details populated.</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code> is a callback that is fired which reflects a change in the state of an ICE agent. When you have a change in network connectivity this is how you are notified.</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code> is a combination of ICE agent and DTLS agent state. You can watch this to be notified when ICE and DTLS have both completed successfully.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li class=active><a href=https://webrtcforthecurious.com/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Español</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/058a8ae3294591394c2fe73c1cf9818e7ae94eb5 title='Last modified by Charlie Blevins | May 31, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 31, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-is-webrtc>What is WebRTC?</a></li><li><a href=#why-should-i-learn-webrtc>Why should I learn WebRTC?</a></li><li><a href=#the-webrtc-protocol-is-a-collection-of-other-technologies>The WebRTC Protocol is a collection of other technologies</a><ul><li><a href=#signaling-how-peers-find-each-other-in-webrtc>Signaling: How peers find each other in WebRTC</a></li><li><a href=#connecting-and-nat-traversal-with-stunturn>Connecting and NAT Traversal with STUN/TURN</a></li><li><a href=#securing-the-transport-layer-with-dtls-and-srtp>Securing the transport layer with DTLS and SRTP</a></li><li><a href=#communicating-with-peers-via-rtp-and-sctp>Communicating with peers via RTP and SCTP</a></li></ul></li><li><a href=#webrtc-a-collection-of-protocols>WebRTC, a collection of protocols</a></li><li><a href=#how-does-the-webrtc-api-work>How does the WebRTC API work?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>