<!doctype html><html lang=tr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hata Ayıklama # WebRTC hata ayıklama göz korkutucu bir görev olabilir. Çok sayıda hareketli parça vardır ve hepsi bağımsız olarak bozulabilir. Dikkatli olmazsanız, yanlış şeylere bakarak haftalar kaybedebilirsiniz. Sonunda bozuk olan kısmı bulduğunuzda, nedenini anlamak için biraz öğrenmeniz gerekecek.
Bu bölüm sizi WebRTC hata ayıklama zihniyetine sokacaktır. Size problemi nasıl parçalara ayıracağınızı gösterecektir. Problemi öğrendikten sonra, popüler hata ayıklama araçlarının hızlı bir turunu vereceğiz.
Problemi İzole Edin # Hata ayıklama yaparken, sorunun nereden geldiğini izole etmeniz gerekir."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/tr/docs/09-debugging/"><meta property="og:site_name" content="WebRTC Meraklıları İçin"><meta property="og:title" content="Hata Ayıklama"><meta property="og:description" content="Hata Ayıklama # WebRTC hata ayıklama göz korkutucu bir görev olabilir. Çok sayıda hareketli parça vardır ve hepsi bağımsız olarak bozulabilir. Dikkatli olmazsanız, yanlış şeylere bakarak haftalar kaybedebilirsiniz. Sonunda bozuk olan kısmı bulduğunuzda, nedenini anlamak için biraz öğrenmeniz gerekecek.
Bu bölüm sizi WebRTC hata ayıklama zihniyetine sokacaktır. Size problemi nasıl parçalara ayıracağınızı gösterecektir. Problemi öğrendikten sonra, popüler hata ayıklama araçlarının hızlı bir turunu vereceğiz.
Problemi İzole Edin # Hata ayıklama yaparken, sorunun nereden geldiğini izole etmeniz gerekir."><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-07-16T20:46:44+03:00"><title>Hata Ayıklama | WebRTC Meraklıları İçin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/tr/docs/09-debugging/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/09-debugging/ title=Felsökning><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/09-debugging/ title=调试><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/09-debugging/ title=デバッグ><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/09-debugging/ title="اشکال زدایی"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/09-debugging/ title=디버깅><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/tr.search.min.0e513a3507f051bf655d831577c7dbbf888331f24101f7ab2d356e175710b4d8.js integrity="sha256-DlE6NQfwUb9lXYMVd8fbv4iDMfJBAferLTVuF1cQtNg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/tr/><span>WebRTC Meraklıları İçin</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Arama aria-label=Arama maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Türkçe</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/09-debugging/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/09-debugging/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/09-debugging/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/09-debugging/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/09-debugging/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/09-debugging/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/09-debugging/>Español</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/09-debugging/>한국어</a></li></ul></li></ul><ul><li><a href=/tr/docs/01-what-why-and-how/>Ne, Neden ve Nasıl</a></li><li><a href=/tr/docs/02-signaling/>Sinyalleşme</a></li><li><a href=/tr/docs/03-connecting/>Bağlanma</a></li><li><a href=/tr/docs/04-securing/>Güvenlik</a></li><li><a href=/tr/docs/05-real-time-networking/>Gerçek Zamanlı Ağ İletişimi</a></li><li><a href=/tr/docs/06-media-communication/>Medya İletişimi</a></li><li><a href=/tr/docs/07-data-communication/>Veri İletişimi</a></li><li><a href=/tr/docs/08-applied-webrtc/>Uygulamalı WebRTC</a></li><li><a href=/tr/docs/09-debugging/ class=active>Hata Ayıklama</a></li><li><a href=/tr/docs/10-history-of-webrtc/>Tarihçe</a></li><li><a href=/tr/docs/11-faq/>SSS</a></li><li><a href=/tr/docs/12-glossary/>Sözlük</a></li><li><a href=/tr/docs/13-reference/>Referans</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Hata Ayıklama</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#problemi-izole-edin>Problemi İzole Edin</a><ul><li><a href=#sinyalleşme-hatası>Sinyalleşme Hatası</a></li><li><a href=#ağ-hatası>Ağ Hatası</a></li><li><a href=#güvenlik-hatası>Güvenlik Hatası</a></li><li><a href=#medya-hatası>Medya Hatası</a></li><li><a href=#veri-hatası>Veri Hatası</a></li></ul></li><li><a href=#mesleğin-araçları>Mesleğin Araçları</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>Wireshark</a></li><li><a href=#webrtc-tarayıcı-araçları>WebRTC tarayıcı araçları</a></li></ul></li><li><a href=#gecikme>Gecikme</a><ul><li><a href=#manuel-uçtan-uca-gecikme-ölçümü>Manuel uçtan uca gecikme ölçümü</a></li><li><a href=#otomatik-uçtan-uca-gecikme-ölçümü>Otomatik uçtan uca gecikme ölçümü</a></li><li><a href=#gecikme-hata-ayıklama-ipuçları>Gecikme Hata Ayıklama İpuçları</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=hata-ayıklama>Hata Ayıklama
<a class=anchor href=#hata-ay%c4%b1klama>#</a></h1><p>WebRTC hata ayıklama göz korkutucu bir görev olabilir. Çok sayıda hareketli parça vardır ve hepsi bağımsız olarak bozulabilir. Dikkatli olmazsanız, yanlış şeylere bakarak haftalar kaybedebilirsiniz. Sonunda bozuk olan kısmı bulduğunuzda, nedenini anlamak için biraz öğrenmeniz gerekecek.</p><p>Bu bölüm sizi WebRTC hata ayıklama zihniyetine sokacaktır. Size problemi nasıl parçalara ayıracağınızı gösterecektir. Problemi öğrendikten sonra, popüler hata ayıklama araçlarının hızlı bir turunu vereceğiz.</p><h2 id=problemi-izole-edin>Problemi İzole Edin
<a class=anchor href=#problemi-izole-edin>#</a></h2><p>Hata ayıklama yaparken, sorunun nereden geldiğini izole etmeniz gerekir. Başlangıçtan başlayın&mldr;</p><h3 id=sinyalleşme-hatası>Sinyalleşme Hatası
<a class=anchor href=#sinyalle%c5%9fme-hatas%c4%b1>#</a></h3><h3 id=ağ-hatası>Ağ Hatası
<a class=anchor href=#a%c4%9f-hatas%c4%b1>#</a></h3><p>STUN sunucunuzu netcat kullanarak test edin:</p><ol><li><p><strong>20-byte</strong> bağlama istek paketini hazırlayın:</p><pre tabindex=0><code>echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | hexdump -C
00000000  00 01 00 00 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54                                       |TEST|
00000014
</code></pre><p>Yorumlama:</p><ul><li><code>00 01</code> mesaj türüdür.</li><li><code>00 00</code> veri bölümünün uzunluğudur.</li><li><code>21 12 a4 42</code> sihirli çerezdır.</li><li>ve <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (ASCII&rsquo;ye dekod edildiğinde: <code>TESTTESTTEST</code>) 12-byte işlem ID&rsquo;sidir.</li></ul></li><li><p>İsteği gönderin ve <strong>32 byte</strong> yanıtı bekleyin:</p><pre tabindex=0><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 21 12 a4 42  54 45 53 54 54 45 53 54  |....!..BTESTTEST|
00000010  54 45 53 54 00 20 00 08  00 01 6f 32 7f 36 de 89  |TEST. ....o2.6..|
00000020
</code></pre><p>Yorumlama:</p><ul><li><code>01 01</code> mesaj türüdür</li><li><code>00 0c</code> veri bölümünün uzunluğudur (ondalık olarak 12&rsquo;ye dekod edilir)</li><li><code>21 12 a4 42</code> sihirli çerezdır</li><li>ve <code>54 45 53 54 54 45 53 54 54 45 53 54</code> (ASCII&rsquo;ye dekod edildiğinde: <code>TESTTESTTEST</code>) 12-byte işlem ID&rsquo;sidir.</li><li><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> 12-byte veridir, yorumlama:<ul><li><code>00 20</code> tür: <code>XOR-MAPPED-ADDRESS</code></li><li><code>00 08</code> değer bölümünün uzunluğudur (ondalık olarak 8&rsquo;e dekod edilir)</li><li><code>00 01 6f 32 7f 36 de 89</code> veri değeridir, yorumlama:<ul><li><code>00 01</code> adres türüdür (IPv4)</li><li><code>6f 32</code> XOR-eşlenen porttur</li><li><code>7f 36 de 89</code> XOR-eşlenen IP adresidir</li></ul></li></ul></li></ul></li></ol><p>XOR-eşlenen bölümü dekod etmek zahmetlidir, ancak <code>00 00 00 00</code>&lsquo;a ayarlanmış (geçersiz) sahte sihirli çerez sağlayarak stun sunucusunu sahte XOR-eşleme gerçekleştirmesi için kandırabiliriz:</p><pre tabindex=0><code>stunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne &#34;\x00\x01\x00\x00\x00\x00\x00\x00TESTTESTTEST&#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C
00000000  01 01 00 0c 00 00 00 00  54 45 53 54 54 45 53 54  |........TESTTEST|
00000010  54 45 53 54 00 01 00 08  00 01 4e 20 5e 24 7a cb  |TEST......N ^$z.|
00000020
</code></pre><p>Sahte sihirli çereze karşı XOR yapmak idempotanttır, bu yüzden port ve adres yanıtta açık olacaktır. Bu tüm durumlarda çalışmayacaktır, çünkü bazı router&rsquo;lar geçen paketleri manipüle eder, IP adresinde hile yapar. Döndürülen veri değerine (son sekiz byte) bakarsak:</p><ul><li><code>00 01 4e 20 5e 24 7a cb</code> veri değeridir, yorumlama:<ul><li><code>00 01</code> adres türüdür (IPv4)</li><li><code>4e 20</code> eşlenen porttur (ondalık olarak 20000&rsquo;e dekod edilir)</li><li><code>5e 24 7a cb</code> IP adresidir (noktalı ondalık notasyonda <code>94.36.122.203</code>&lsquo;e dekod edilir).</li></ul></li></ul><h3 id=güvenlik-hatası>Güvenlik Hatası
<a class=anchor href=#g%c3%bcvenlik-hatas%c4%b1>#</a></h3><h3 id=medya-hatası>Medya Hatası
<a class=anchor href=#medya-hatas%c4%b1>#</a></h3><h3 id=veri-hatası>Veri Hatası
<a class=anchor href=#veri-hatas%c4%b1>#</a></h3><h2 id=mesleğin-araçları>Mesleğin Araçları
<a class=anchor href=#mesle%c4%9fin-ara%c3%a7lar%c4%b1>#</a></h2><h3 id=netcat-nc>netcat (nc)
<a class=anchor href=#netcat-nc>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Netcat>netcat</a>, TCP veya UDP kullanan ağ bağlantılarından okuma ve yazma için komut satırı ağ yardımcı programıdır. Genellikle <code>nc</code> komutu olarak mevcuttur.</p><h3 id=tcpdump>tcpdump
<a class=anchor href=#tcpdump>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Tcpdump>tcpdump</a> komut satırı veri ağı paket analizörüdür.</p><p>Yaygın komutlar:</p><ul><li><p>Port 19302&rsquo;ye gelen ve giden UDP paketlerini yakalayın, paket içeriğinin hexdump&rsquo;ını yazdırın:</p><p><code>sudo tcpdump 'udp port 19302' -xx</code></p></li><li><p>Aynısı, ancak paketleri daha sonra inceleme için PCAP (paket yakalama) dosyasına kaydedin:</p><p><code>sudo tcpdump 'udp port 19302' -w stun.pcap</code></p><p>PCAP dosyası Wireshark uygulamasıyla açılabilir: <code>wireshark stun.pcap</code></p></li></ul><h3 id=wireshark>Wireshark
<a class=anchor href=#wireshark>#</a></h3><p><a href=https://www.wireshark.org>Wireshark</a> yaygın olarak kullanılan ağ protokol analizörüdür.</p><h3 id=webrtc-tarayıcı-araçları>WebRTC tarayıcı araçları
<a class=anchor href=#webrtc-taray%c4%b1c%c4%b1-ara%c3%a7lar%c4%b1>#</a></h3><p>Tarayıcılar kurduğunuz bağlantıları incelemek için kullanabileceğiniz yerleşik araçlarla gelir. Chrome&rsquo;da <a href=chrome://webrtc-internals><code>chrome://webrtc-internals</code></a> ve <a href=chrome://webrtc-logs><code>chrome://webrtc-logs</code></a> vardır. Firefox&rsquo;ta <a href=about:webrtc><code>about:webrtc</code></a> vardır.</p><h2 id=gecikme>Gecikme
<a class=anchor href=#gecikme>#</a></h2><p>Yüksek gecikmeniz olduğunu nasıl bilirsiniz? Videonuzun gecikmeli olduğunu fark etmiş olabilirsiniz, ancak tam olarak ne kadar geciktiğini biliyor musunuz?
Bu gecikmeyi azaltabilmek için önce onu ölçerek başlamanız gerekir.</p><p>Gerçek gecikme uçtan uca ölçülmesi beklenir. Bu, sadece gönderen ve alıcı arasındaki ağ yolunun gecikmesi değil, kamera yakalama, çerçeve kodlama, iletim, alma, dekodlama ve görüntüleme ile bu adımlardan herhangi biri arasında olası kuyruklama gecikmesinin birleşik gecikmesi anlamına gelir.</p><p>Uçtan uca gecikme, her bileşenin gecikmelerinin basit toplamı değildir.</p><p>Teorik olarak canlı video iletim hattının bileşenlerinin gecikmesini ayrı ayrı ölçüp sonra bunları toplayabilseniz de, pratikte en azından bazı bileşenler ya enstrümantasyon için erişilemez olacak ya da hat dışında ölçüldüğünde önemli ölçüde farklı sonuçlar üretecektir.
Hat aşamaları arasındaki değişken kuyruk derinlikleri, ağ topolojisi ve kamera pozlama değişiklikleri uçtan uca gecikmeyi etkileyen bileşenlerin sadece birkaç örneğidir.</p><p>Canlı yayın sisteminizde her bileşenin içsel gecikmesi değişebilir ve aşağı akış bileşenlerini etkileyebilir.
Yakalanan videonun içeriği bile gecikmeyi etkiler.
Örneğin, ağaç dalları gibi yüksek frekans özellikler için, açık mavi gökyüzü gibi düşük frekanslıya kıyasla çok daha fazla bit gerekir.
Otomatik pozlama açık olan kamera, yakalama hızı saniyede 30 kareye ayarlanmış olsa bile bir kareyi yakalamak için beklenen 33 milisaniyeden <em>çok</em> daha uzun sürebilir.
Ağ üzerinden iletim, özellikle hücresel, değişen talep nedeniyle çok dinamiktir.
Daha fazla kullanıcı havada daha fazla konuşma getirir.
Fiziksel konumunuz (kötü şöhretli düşük sinyal bölgeleri) ve diğer birçok faktör paket kaybını ve gecikmeyi artırır.
Teslimat için bir ağ arayüzüne, diyelim WiFi adaptörü veya LTE modeme paket gönderdiğinizde ne olur?
Hemen teslim edilemezse arayüzde kuyruğa alınır, kuyruk ne kadar büyükse böyle ağ arayüzü o kadar gecikme getirir.</p><h3 id=manuel-uçtan-uca-gecikme-ölçümü>Manuel uçtan uca gecikme ölçümü
<a class=anchor href=#manuel-u%c3%a7tan-uca-gecikme-%c3%b6l%c3%a7%c3%bcm%c3%bc>#</a></h3><p>Uçtan uca gecikmeden bahsettiğimizde, bir olayın gerçekleşmesi ile gözlemlenmesi arasındaki zamanı kastediyoruz, yani video karelerinin ekranda görünmesi.</p><pre tabindex=0><code>UctanUcaGecikme = T(gözlemle) - T(gerçekleş)
</code></pre><p>Naif yaklaşım, bir olayın gerçekleştiği zamanı kaydetmek ve bunu gözlem zamanından çıkarmaktır.
Ancak, hassasiyet milisaniyelere düştüğünde zaman senkronizasyonu sorun haline gelir.
Dağıtık sistemlerde saatleri senkronize etmeye çalışmak çoğunlukla boşunadır, zaman senkronizasyonundaki küçük bir hata bile güvenilmez gecikme ölçümü üretir.</p><p>Saat senkronizasyon sorunları için basit bir geçici çözüm aynı saati kullanmaktır.
Gönderen ve alıcıyı aynı referans çerçevesine koyun.</p><p>Milisaniyelik tikan bir saatiniz veya gerçekten başka herhangi bir olay kaynağınız olduğunu hayal edin.
Saati kameraya doğrultarak uzak ekrana canlı yayın yapan sistemde gecikmeyi ölçmek istiyorsunuz.
Milisaniye zamanlayıcısının tiklemesi (T<sub><code>gerçekleş</code></sub>) ile saatin video karelerinin ekranda görünmesi (T<sub><code>gözlemle</code></sub>) arasındaki zamanı ölçmenin açık yolu şudur:</p><ul><li>Kameranızı milisaniyelik saate doğrultun.</li><li>Video karelerini aynı fiziksel konumda olan alıcıya gönderin.</li><li>Milisaniyelik zamanlayıcının ve ekranda alınan videonun fotoğrafını çekin (telefonunuzu kullanın).</li><li>İki zamanı çıkarın.</li></ul><p>Bu en gerçek uçtan uca gecikme ölçümüdür.
Tüm bileşen gecikmelerini (kamera, kodlayıcı, ağ, dekoder) hesaba katar ve herhangi bir saat senkronizasyonuna dayanmaz.</p><p><img src=../images/09-diy-latency.png alt="DIY Latency" title="DIY Latency Measurement">.
<img src=../images/09-diy-latency-happen-observe.png alt="DIY Latency Example" title="DIY Latency Measurement Example"></p><p>Yukarıdaki fotoğrafta ölçülen uçtan uca gecikme 101 msn&rsquo;dir. Şu anda gerçekleşen olay 10:16:02.862, ancak canlı yayın sistemi gözlemcisi 10:16:02.761&rsquo;i görüyor.</p><h3 id=otomatik-uçtan-uca-gecikme-ölçümü>Otomatik uçtan uca gecikme ölçümü
<a class=anchor href=#otomatik-u%c3%a7tan-uca-gecikme-%c3%b6l%c3%a7%c3%bcm%c3%bc>#</a></h3><p>Bu yazının yazıldığı tarih itibariyle (Mayıs 2021) uçtan uca gecikme için WebRTC standardı aktif olarak <a href=https://github.com/w3c/webrtc-stats/issues/537>tartışılmaktadır</a>.
Firefox, kullanıcıların standart WebRTC API&rsquo;lerinin üstünde otomatik gecikme ölçümü oluşturmalarına izin veren bir dizi API uyguladı.
Ancak bu paragrafta, gecikmeyi otomatik olarak ölçmenin en uyumlu yolunu tartışıyoruz.</p><p><img src=../images/09-ntp-latency.png alt="NTP Style Latency Measurement" title="NTP Style Latency Measurement"></p><p>Gidiş-dönüş süresi özetle: Size zamanımı <code>tR1</code> gönderiyorum, <code>tR1</code>&lsquo;imi <code>tR2</code> zamanında geri aldığımda, gidiş-dönüş süresinin <code>tR2 - tR1</code> olduğunu biliyorum.</p><p>Gönderen ve alıcı arasında bir iletişim kanalı verildiğinde (örneğin <a href=https://webrtc.org/getting-started/data-channels>DataChannel</a>), alıcı aşağıdaki adımları izleyerek gönderenin monotonik saatini modelleyebilir:</p><ol><li><code>tR1</code> zamanında, alıcı yerel monotonik saat zaman damgası ile bir mesaj gönderir.</li><li>Yerel zaman <code>tS1</code> ile gönderene ulaştığında, gönderen <code>tR1</code>&lsquo;in kopyası ile birlikte gönderenin <code>tS1</code>&lsquo;i ve gönderenin video track zamanı <code>tSV1</code>&lsquo;i ile yanıt verir.</li><li>Alıcı tarafta <code>tR2</code> zamanında, gidiş-dönüş süresi mesajın gönderme ve alma zamanları çıkarılarak hesaplanır: <code>RTT = tR2 - tR1</code>.</li><li>Gidiş-dönüş süresi <code>RTT</code> ile gönderen yerel zaman damgası <code>tS1</code> birlikte gönderenin monotonik saatinin tahmini oluşturmak için yeterlidir. <code>tR2</code> zamanında gönderendeki mevcut zaman <code>tS1</code> artı gidiş-dönüş süresinin yarısına eşit olur.</li><li>Gönderenin yerel saat zaman damgası <code>tS1</code>&lsquo;in video track zaman damgası <code>tSV1</code> ile eşleştirilmesi ve gidiş-dönüş süresi <code>RTT</code> ile birlikte alıcı video track zamanını gönderen video track&rsquo;e senkronize etmek için yeterlidir.</li></ol><p>Şimdi son bilinen gönderen video karesi zamanından <code>tSV1</code>&lsquo;den ne kadar zaman geçtiğini bildiğimize göre, şu anda görüntülenen video karesinin zamanını (<code>actual_video_time</code>) beklenen zamandan çıkararak gecikmeyi yaklaşık olarak hesaplayabiliriz:</p><pre tabindex=0><code>expected_video_time = tSV1 + time_since(tSV1)
latency = expected_video_time - actual_video_time
</code></pre><p>Bu yöntemin dezavantajı kameranın içsel gecikmesini içermemesidir.
Çoğu video sistemi kare yakalama zaman damgasını kameradan kareyi ana belleğe teslim etme zamanı olarak kabul eder, bu kayıt edilen olayın gerçekten gerçekleşmesinden birkaç an sonra olacaktır.</p><h4 id=örnek-gecikme-tahmini>Örnek gecikme tahmini
<a class=anchor href=#%c3%b6rnek-gecikme-tahmini>#</a></h4><p>Örnek uygulama alıcıda bir <code>latency</code> veri kanalı açar ve periyodik olarak alıcının monotonik zamanlayıcı zaman damgalarını gönderene gönderir. Gönderen JSON mesajı ile geri yanıt verir ve alıcı mesaja dayalı gecikmeyi hesaplar.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;received_time&#34;</span>: <span style=color:#ae81ff>64714</span>, <span style=color:#75715e>// Alıcı tarafından gönderilen zaman damgası, gönderen zaman damgasını yansıtır.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>&#34;delay_since_received&#34;</span>: <span style=color:#ae81ff>46</span>, <span style=color:#75715e>// Gönderici üzerinde son `received_time` alındığından beri geçen zaman.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>&#34;local_clock&#34;</span>: <span style=color:#ae81ff>1597366470336</span>, <span style=color:#75715e>// Gönderenin mevcut monotonik saat zamanı.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>&#34;track_times_msec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;myvideo_track1&#34;</span>: [
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>13100</span>, <span style=color:#75715e>// Video karesi RTP zaman damgası (milisaniye cinsinden).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#ae81ff>1597366470289</span> <span style=color:#75715e>// Video karesi monotonik saat zaman damgası.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Alıcıda veri kanalını açın:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>createDataChannel</span>(<span style=color:#e6db74>&#34;latency&#34;</span>);
</span></span></code></pre></div><p>Alıcının zamanını <code>tR1</code> periyodik olarak gönderin. Bu örnek özel bir nedeni olmadan 2 saniye kullanır:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>setInterval</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>tR1</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span></code></pre></div><p>Gönderici üzerinde alıcıdan gelen mesajı işleyin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// event.data&#39;nın &#34;1234567&#34; gibi bir string olduğunu varsayarak.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span><span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>42000</span>; <span style=color:#75715e>// Mevcut kare RTP zaman damgası milisaniye zaman ölçeğine dönüştürülmüş.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tS1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1597366470289</span>; <span style=color:#75715e>// Mevcut kare monotonik saat zaman damgası.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>received_time</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>tR1</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>delay_since_received</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>local_clock</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>now</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>track_times_msec</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>myvideo_track1</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>],
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>msg</span>));
</span></span></code></pre></div><p>Gönderenden gelen mesajı işleyin ve tahmini gecikmeyi <code>console</code>&lsquo;a yazdırın:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>fromSender</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#34;received_time&#34;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#34;delay_since_received&#34;</span>]; <span style=color:#75715e>// Gönderenin alma ve yanıt gönderme arasında geçen zaman.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#34;local_clock&#34;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>networkLatency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>networkLatency</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>VIDEO</span>.<span style=color:#a6e22e>requestVideoFrameCallback</span>((<span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>framemeta</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Gönderenin mevcut zamanını tahmin edin.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR2</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>] <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>entries</span>(<span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#34;track_times_msec&#34;</span>])[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tS1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>actualVideoTimeMsec</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>framemeta</span>.<span style=color:#a6e22e>rtpTimestamp</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>90</span>); <span style=color:#75715e>// RTP timebase&#39;ini (90000) milisaniye timebase&#39;ine dönüştür.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>latency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>actualVideoTimeMsec</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;latency&#34;</span>, <span style=color:#a6e22e>latency</span>, <span style=color:#e6db74>&#34;msec&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=tarayıcıda-gerçek-video-zamanı>Tarayıcıda gerçek video zamanı
<a class=anchor href=#taray%c4%b1c%c4%b1da-ger%c3%a7ek-video-zaman%c4%b1>#</a></h4><blockquote><p><code>&lt;video>.requestVideoFrameCallback()</code> web yazarlarının kompozisyon için bir kare sunulduğunda bilgilendirilmelerine izin verir.</p></blockquote><p>Çok yakın zamana kadar (Mayıs 2020), tarayıcılarda şu anda görüntülenen video karesinin zaman damgasını güvenilir şekilde almak neredeyse imkansızdı. <code>video.currentTime</code> tabanlı geçici çözüm yöntemleri vardı, ancak özellikle hassas değildi.
Hem Chrome hem de Mozilla tarayıcı geliştiricileri mevcut video kare zamanına erişim için API callback&rsquo;i ekleyen yeni W3C standardı <a href=https://wicg.github.io/video-rvfc/><code>HTMLVideoElement.requestVideoFrameCallback()</code></a>&rsquo;nin tanıtımını <a href=https://github.com/mozilla/standards-positions/issues/250>desteklediler</a>.
Ekleme basit gelir, ancak web üzerinde ses ve video senkronizasyonu gerektiren birden fazla gelişmiş medya uygulamasını etkinleştirmiştir.
Özellikle WebRTC için callback, mevcut video karesi ile ilişkili RTP zaman damgası olan <code>rtpTimestamp</code> alanını içerecektir.
Bu WebRTC uygulamaları için mevcut olmalı, aksi takdirde mevcut olmamalıdır.</p><h3 id=gecikme-hata-ayıklama-ipuçları>Gecikme Hata Ayıklama İpuçları
<a class=anchor href=#gecikme-hata-ay%c4%b1klama-ipu%c3%a7lar%c4%b1>#</a></h3><p>Hata ayıklama muhtemelen ölçülen gecikmeyi etkileyeceği için, genel kural kurulumunuzu sorunu hala yeniden üretebilecek en küçük olasılığa basitleştirmektir.
Ne kadar çok bileşeni kaldırabilirseniz, hangi bileşenin gecikme problemine neden olduğunu anlamak o kadar kolay olacaktır.</p><h4 id=kamera-gecikmesi>Kamera gecikmesi
<a class=anchor href=#kamera-gecikmesi>#</a></h4><p>Kamera ayarlarına bağlı olarak kamera gecikmesi değişebilir.
Otomatik pozlama, otomatik odaklama ve otomatik beyaz denge ayarlarını kontrol edin.
Web kameralarının tüm &ldquo;otomatik&rdquo; özellikleri, yakalanan görüntüyü WebRTC yığınına kullanılabilir hale getirmeden önce analiz etmek için ekstra zaman alır.</p><p>Linux&rsquo;taysanız, kamera ayarlarını kontrol etmek için <code>v4l2-ctl</code> komut satırı aracını kullanabilirsiniz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Otomatik odaklamayı devre dışı bırakın:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_auto<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Odağı sonsuzluğa ayarlayın:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_absolute<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Kamera ayarlarını hızla kontrol etmek ve ayarlamak için <code>guvcview</code> grafik UI aracını da kullanabilirsiniz.</p><h4 id=kodlayıcı-gecikmesi>Kodlayıcı gecikmesi
<a class=anchor href=#kodlay%c4%b1c%c4%b1-gecikmesi>#</a></h4><p>Çoğu modern kodlayıcı kodlanmış bir tane çıkarmadan önce bazı kareleri tamponlayacaktır.
Öncelikleri üretilen resmin kalitesi ve bitrate arasında bir denge kurmaktır.
Çok geçişli kodlama, kodlayıcının çıkış gecikmesini umursamamasının aşırı örneğidir.
İlk geçiş sırasında kodlayıcı tüm videoyu alır ve ancak ondan sonra kareleri çıkarmaya başlar.</p><p>Ancak, uygun ayarlama ile insanlar alt-kare gecikmelerine ulaştılar.
Kodlayıcınızın aşırı referans kareleri kullanmadığından veya B-karelerine dayanmadığından emin olun.
Her codec&rsquo;in gecikme ayarlama ayarları farklıdır, ancak x264 için en düşük kare çıkış gecikmesi için <code>tune=zerolatency</code> ve <code>profile=baseline</code> kullanmanızı öneririz.</p><h4 id=ağ-gecikmesi>Ağ gecikmesi
<a class=anchor href=#a%c4%9f-gecikmesi>#</a></h4><p>Ağ gecikmesi, daha iyi ağ bağlantısına yükseltmek dışında tartışmalı olarak en az yapabileceğiniz şeydir.
Ağ gecikmesi hava durumu gibidir - yağmuru durduramazsınız, ancak hava durumunu kontrol edip şemsiye alabilirsiniz.
WebRTC ağ koşullarını milisaniye hassasiyetle ölçer.
Önemli metrikler:</p><ul><li>Gidiş-dönüş süresi.</li><li>Paket kaybı ve paket yeniden iletimleri.</li></ul><p><strong>Gidiş-Dönüş Süresi</strong></p><p>WebRTC yığınının yerleşik ağ gidiş dönüş süresi (RTT) ölçüm <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime>mekanizması</a> vardır.
Gecikmenin yeterince iyi yaklaşımı RTT&rsquo;nin yarısıdır. Paket gönderme ve alma süresinin aynı olduğunu varsayar, ki bu her zaman böyle değildir.
RTT uçtan uca gecikmenin alt sınırını belirler.
Video kareleriniz kamera-kodlayıcı hattınız ne kadar optimize olursa olsun alıcıya <code>RTT/2</code>&lsquo;den daha hızlı ulaşamaz.</p><p>Yerleşik RTT mekanizması gönderen/alıcı raporları adlı özel RTCP paketlerine dayanır.
Gönderen zaman okumasını alıcıya gönderir, alıcı aynı zaman damgasını gönderene yansıtır.
Böylece gönderen paketin alıcıya gidip geri dönmesi için ne kadar zaman aldığını bilir.
RTT ölçümünün daha fazla detayı için <a href=../06-media-communication/#senderreceiver-reports>Sender/Receiver Reports</a> bölümüne bakın.</p><p><strong>Paket kaybı ve paket yeniden iletimleri</strong></p><p>Hem RTP hem de RTCP, sıralama, başarılı teslimat veya tekrarlama garantisi olmayan UDP tabanlı protokollerdir.
Yukarıdakilerin hepsi gerçek dünya WebRTC uygulamalarında olabilir ve olur.
Sofistike olmayan dekoder uygulaması dekoderin görüntüyü başarıyla yeniden birleştirebilmesi için bir karenin tüm paketlerinin teslim edilmesini bekler.
Paket kaybı varlığında <a href=../06-media-communication/#inter-frame-types>P-frame</a> paketleri kaybolursa dekodlama artefaktları görünebilir.
I-frame paketleri kaybolursa tüm bağımlı kareler ya ağır artefaktlar alacak ya da hiç dekod edilmeyeceklerdir.
Büyük olasılıkla bu videonun bir an için &ldquo;donmasına&rdquo; neden olacaktır.</p><p>Video donmasını veya dekodlama artefaktlarını önlemek için (en azından önlemeye çalışmak için), WebRTC olumsuz onay mesajları (<a href=../06-media-communication/#negative-acknowledgment>NACK</a>) kullanır.
Alıcı beklenen RTP paketini almadığında, gönderene eksik paketi tekrar göndermesini söylemek için NACK mesajı döndürür.
Alıcı paketin yeniden iletimini <em>bekler</em>.
Bu tür yeniden iletimler artan gecikmeye neden olur.
Gönderilen ve alınan NACK paketlerinin sayısı WebRTC&rsquo;nin yerleşik istatistik alanlarında <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcoutboundrtpstreamstats-nackcount>outbound stream nackCount</a> ve <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-nackcount>inbound stream nackCount</a> kaydedilir.</p><p><a href=#webrtc-browser-tools>webrtc internals sayfasında</a> gelen ve giden <code>nackCount</code>&lsquo;un güzel grafiklerini görebilirsiniz.
<code>nackCount</code>&lsquo;un arttığını görüyorsanız, ağın yüksek paket kaybı yaşadığı ve WebRTC yığının buna rağmen düzgün video/ses deneyimi oluşturmak için elinden geleni yaptığı anlamına gelir.</p><p>Paket kaybı o kadar yüksek ki dekoder görüntü üretemiyor veya tamamen kayıp I-frame durumunda olduğu gibi sonraki bağımlı görüntüleri üretemiyor, gelecekteki tüm P-frameler dekod edilmeyecek.
Alıcı özel Picture Loss Indication mesajı (<a href=../06-media-communication/#full-intra-frame-request-fir-and-picture-loss-indication-pli>PLI</a>) göndererek bunu hafifletmeye çalışacaktır.
Gönderen <code>PLI</code> aldığında, alıcının dekoderine yardımcı olmak için yeni I-frame üretecektir.
I-frameler normalde P-framelerden boyut olarak daha büyüktür. Bu iletilmesi gereken paket sayısını artırır.
NACK mesajları gibi, alıcının yeni I-frame&rsquo;i beklemesi gerekecek, ek gecikme getirecektir.</p><p><a href=#webrtc-browser-tools>webrtc internals sayfasında</a> <code>pliCount</code>&lsquo;u izleyin. Artıyorsa, kodlayıcınızı daha az paket üretecek şekilde ayarlayın veya daha hata dirençli modu etkinleştirin.</p><h4 id=alıcı-tarafı-gecikmesi>Alıcı tarafı gecikmesi
<a class=anchor href=#al%c4%b1c%c4%b1-taraf%c4%b1-gecikmesi>#</a></h4><p>Gecikme, sıra dışı gelen paketlerden etkilenecektir.
Görüntü paketinin alt yarısı üstten önce gelirse dekodlamadan önce üstü beklemeniz gerekir.
Bu <a href=../05-real-time-networking/#solving-jitter>Solving Jitter</a> bölümünde büyük detayda açıklanmıştır.</p><p>Bir karenin dekodere serbest bırakılmadan önce tüm paketlerini beklerken alma tamponunda ne kadar süre tutulduğunu görmek için yerleşik <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay>jitterBufferDelay</a> metriğine de başvurabilirsiniz.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/30cec2bd1fa8fc839dca83e8a73daa7afd98de9e title='Son düzenleyen fatihsen-dev | Temmuz 16, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>Temmuz 16, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/09-debugging.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Bu sayfayı düzenle</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#problemi-izole-edin>Problemi İzole Edin</a><ul><li><a href=#sinyalleşme-hatası>Sinyalleşme Hatası</a></li><li><a href=#ağ-hatası>Ağ Hatası</a></li><li><a href=#güvenlik-hatası>Güvenlik Hatası</a></li><li><a href=#medya-hatası>Medya Hatası</a></li><li><a href=#veri-hatası>Veri Hatası</a></li></ul></li><li><a href=#mesleğin-araçları>Mesleğin Araçları</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>Wireshark</a></li><li><a href=#webrtc-tarayıcı-araçları>WebRTC tarayıcı araçları</a></li></ul></li><li><a href=#gecikme>Gecikme</a><ul><li><a href=#manuel-uçtan-uca-gecikme-ölçümü>Manuel uçtan uca gecikme ölçümü</a></li><li><a href=#otomatik-uçtan-uca-gecikme-ölçümü>Otomatik uçtan uca gecikme ölçümü</a></li><li><a href=#gecikme-hata-ayıklama-ipuçları>Gecikme Hata Ayıklama İpuçları</a></li></ul></li></ul></nav></div></aside></main></body></html>