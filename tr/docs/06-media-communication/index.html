<!doctype html><html lang=tr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Medya İletişimi # WebRTC&rsquo;nin medya iletişiminden ne elde ederim? # WebRTC size sınırsız miktarda ses ve video akışı gönderip almanıza izin verir. Bu akışları bir çağrı sırasında istediğiniz zaman ekleyip çıkarabilirsiniz. Bu akışların hepsi bağımsız olabilir veya birlikte paketlenmiş olabilir! Masaüstünüzün video beslemesini gönderebilir ve ardından web kameranızdan ses ve video ekleyebilirsiniz.
WebRTC protokolü codec agnostiktir. Alttaki aktarım her şeyi destekler, henüz var olmayan şeyleri bile! Ancak, iletişim kurduğunuz WebRTC Ajanı bunu kabul etmek için gerekli araçlara sahip olmayabilir."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/tr/docs/06-media-communication/"><meta property="og:site_name" content="WebRTC Meraklıları İçin"><meta property="og:title" content="Medya İletişimi"><meta property="og:description" content="Medya İletişimi # WebRTC’nin medya iletişiminden ne elde ederim? # WebRTC size sınırsız miktarda ses ve video akışı gönderip almanıza izin verir. Bu akışları bir çağrı sırasında istediğiniz zaman ekleyip çıkarabilirsiniz. Bu akışların hepsi bağımsız olabilir veya birlikte paketlenmiş olabilir! Masaüstünüzün video beslemesini gönderebilir ve ardından web kameranızdan ses ve video ekleyebilirsiniz.
WebRTC protokolü codec agnostiktir. Alttaki aktarım her şeyi destekler, henüz var olmayan şeyleri bile! Ancak, iletişim kurduğunuz WebRTC Ajanı bunu kabul etmek için gerekli araçlara sahip olmayabilir."><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-07-16T20:46:44+03:00"><title>Medya İletişimi | WebRTC Meraklıları İçin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/tr/docs/06-media-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/06-media-communication/ title=Mediakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/06-media-communication/ title=Медиа-коммуникация><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/06-media-communication/ title=媒体通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/06-media-communication/ title=メディア・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/06-media-communication/ title="ارتباط رسانه ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/06-media-communication/ title="Comunicación de Medios"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/06-media-communication/ title="미디어 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/tr.search.min.0e513a3507f051bf655d831577c7dbbf888331f24101f7ab2d356e175710b4d8.js integrity="sha256-DlE6NQfwUb9lXYMVd8fbv4iDMfJBAferLTVuF1cQtNg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/tr/><span>WebRTC Meraklıları İçin</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Arama aria-label=Arama maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Türkçe</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/06-media-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/06-media-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/06-media-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/06-media-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/06-media-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/06-media-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/06-media-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/06-media-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/tr/docs/01-what-why-and-how/>Ne, Neden ve Nasıl</a></li><li><a href=/tr/docs/02-signaling/>Sinyalleşme</a></li><li><a href=/tr/docs/03-connecting/>Bağlanma</a></li><li><a href=/tr/docs/04-securing/>Güvenlik</a></li><li><a href=/tr/docs/05-real-time-networking/>Gerçek Zamanlı Ağ İletişimi</a></li><li><a href=/tr/docs/06-media-communication/ class=active>Medya İletişimi</a></li><li><a href=/tr/docs/07-data-communication/>Veri İletişimi</a></li><li><a href=/tr/docs/08-applied-webrtc/>Uygulamalı WebRTC</a></li><li><a href=/tr/docs/09-debugging/>Hata Ayıklama</a></li><li><a href=/tr/docs/10-history-of-webrtc/>Tarihçe</a></li><li><a href=/tr/docs/11-faq/>SSS</a></li><li><a href=/tr/docs/12-glossary/>Sözlük</a></li><li><a href=/tr/docs/13-reference/>Referans</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Medya İletişimi</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtcnin-medya-iletişiminden-ne-elde-ederim>WebRTC&rsquo;nin medya iletişiminden ne elde ederim?</a></li><li><a href=#nasıl-çalışır>Nasıl çalışır?</a></li><li><a href=#gecikme-vs-kalite>Gecikme vs Kalite</a><ul><li><a href=#gerçek-dünya-sınırlamaları>Gerçek Dünya Sınırlamaları</a></li><li><a href=#video-karmaşıktır>Video Karmaşıktır</a></li></ul></li><li><a href=#video-101>Video 101</a><ul><li><a href=#kayıplı-ve-kayıpsız-sıkıştırma>Kayıplı ve Kayıpsız sıkıştırma</a></li><li><a href=#çerçeve-içi-ve-çerçeveler-arası-sıkıştırma>Çerçeve içi ve çerçeveler arası sıkıştırma</a></li><li><a href=#çerçeve-arası-türler>Çerçeve arası türler</a></li><li><a href=#video-hassastır>Video hassastır</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#paket-formatı>Paket Formatı</a></li><li><a href=#uzantılar>Uzantılar</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#paket-formatı-1>Paket Formatı</a></li><li><a href=#full-intra-frame-request-fir-ve-picture-loss-indication-pli>Full INTRA-frame Request (FIR) ve Picture Loss Indication (PLI)</a></li><li><a href=#negative-acknowledgment>Negative Acknowledgment</a></li><li><a href=#sender-ve-receiver-reports>Sender ve Receiver Reports</a></li></ul></li><li><a href=#rtprtcp-nasıl-birlikte-sorunları-çözer>RTP/RTCP nasıl birlikte sorunları çözer</a><ul><li><a href=#forward-error-correction>Forward Error Correction</a></li><li><a href=#adaptive-bitrate-ve-bandwidth-estimation>Adaptive Bitrate ve Bandwidth Estimation</a></li></ul></li><li><a href=#ağ-durumunu-tanımlama-ve-iletişim>Ağ Durumunu Tanımlama ve İletişim</a><ul><li><a href=#receiver-reports--sender-reports>Receiver Reports / Sender Reports</a></li><li><a href=#tmmbr-tmmbn-remb-ve-twcc-gcc-ile-eşleştirilmiş>TMMBR, TMMBN, REMB ve TWCC, GCC ile eşleştirilmiş</a></li></ul></li><li><a href=#bant-genişliği-tahmini-alternatifleri>Bant Genişliği Tahmini Alternatifleri</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=medya-iletişimi>Medya İletişimi
<a class=anchor href=#medya-ileti%c5%9fimi>#</a></h1><h2 id=webrtcnin-medya-iletişiminden-ne-elde-ederim>WebRTC&rsquo;nin medya iletişiminden ne elde ederim?
<a class=anchor href=#webrtcnin-medya-ileti%c5%9fiminden-ne-elde-ederim>#</a></h2><p>WebRTC size sınırsız miktarda ses ve video akışı gönderip almanıza izin verir. Bu akışları bir çağrı sırasında istediğiniz zaman ekleyip çıkarabilirsiniz. Bu akışların hepsi bağımsız olabilir veya birlikte paketlenmiş olabilir! Masaüstünüzün video beslemesini gönderebilir ve ardından web kameranızdan ses ve video ekleyebilirsiniz.</p><p>WebRTC protokolü codec agnostiktir. Alttaki aktarım her şeyi destekler, henüz var olmayan şeyleri bile! Ancak, iletişim kurduğunuz WebRTC Ajanı bunu kabul etmek için gerekli araçlara sahip olmayabilir.</p><p>WebRTC ayrıca dinamik ağ koşullarını ele almak için tasarlanmıştır. Bir çağrı sırasında bant genişliğiniz artabilir veya azalabilir. Belki aniden çok fazla paket kaybı yaşarsınız. Protokol tüm bunları ele almak için tasarlanmıştır. WebRTC ağ koşullarına yanıt verir ve mevcut kaynaklarla size mümkün olan en iyi deneyimi sunmaya çalışır.</p><h2 id=nasıl-çalışır>Nasıl çalışır?
<a class=anchor href=#nas%c4%b1l-%c3%a7al%c4%b1%c5%9f%c4%b1r>#</a></h2><p>WebRTC önceden var olan iki protokol kullanır: RTP ve RTCP, her ikisi de <a href=https://tools.ietf.org/html/rfc1889>RFC 1889</a>&lsquo;da tanımlanmıştır.</p><p>RTP (Gerçek zamanlı Aktarım Protokolü), medyayı taşıyan protokoldür. Videonun gerçek zamanlı teslimatına izin verecek şekilde tasarlanmıştır. Gecikme veya güvenilirlik etrafında herhangi bir kural koymazken, bunları uygulamak için araçları verir. RTP size akışlar verir, böylece tek bir bağlantı üzerinden birden fazla medya beslemesi çalıştırabilirsiniz. Ayrıca bir medya pipeline&rsquo;ını beslemek için ihtiyacınız olan zamanlama ve sıralama bilgilerini de verir.</p><p>RTCP (RTP Kontrol Protokolü), çağrı hakkındaki meta verileri ileten protokoldür. Format çok esnektir ve istediğiniz meta verileri eklemenize izin verir. Bu, çağrı hakkındaki istatistikleri iletmek için kullanılır. Ayrıca paket kaybını ele almak ve tıkanıklık kontrolü uygulamak için de kullanılır. Değişen ağ koşullarına yanıt vermek için gerekli çift yönlü iletişimi sağlar.</p><h2 id=gecikme-vs-kalite>Gecikme vs Kalite
<a class=anchor href=#gecikme-vs-kalite>#</a></h2><p>Gerçek zamanlı medya, gecikme ve kalite arasında ödünleşimler yapmakla ilgilidir. Tolere etmeye istekli olduğunuz gecikme ne kadar fazlaysa, o kadar yüksek kaliteli video bekleyebilirsiniz.</p><h3 id=gerçek-dünya-sınırlamaları>Gerçek Dünya Sınırlamaları
<a class=anchor href=#ger%c3%a7ek-d%c3%bcnya-s%c4%b1n%c4%b1rlamalar%c4%b1>#</a></h3><p>Bu kısıtlamaların hepsi gerçek dünyanın sınırlamaları nedeniyle oluşur. Bunların hepsi üstesinden gelmeniz gereken ağınızın özellikleridir.</p><h3 id=video-karmaşıktır>Video Karmaşıktır
<a class=anchor href=#video-karma%c5%9f%c4%b1kt%c4%b1r>#</a></h3><p>Video taşımak kolay değildir. 30 dakikalık sıkıştırılmamış 720 8-bit video depolamak için yaklaşık 110 GB&rsquo;a ihtiyacınız var. Bu rakamlarla 4 kişilik konferans görüşmesi gerçekleşmeyecektir. Daha küçük hale getirmenin bir yoluna ihtiyacımız var ve cevap video sıkıştırmadır. Yine de bunun dezavantajları yok değildir.</p><h2 id=video-101>Video 101
<a class=anchor href=#video-101>#</a></h2><p>Video sıkıştırmayı derinlemesine ele almayacağız, ancak RTP&rsquo;nin neden bu şekilde tasarlandığını anlamak için yeterli kadarını ele alacağız. Video sıkıştırma, videoyu aynı videoyu temsil etmek için daha az bit gerektiren yeni bir formata kodlar.</p><h3 id=kayıplı-ve-kayıpsız-sıkıştırma>Kayıplı ve Kayıpsız sıkıştırma
<a class=anchor href=#kay%c4%b1pl%c4%b1-ve-kay%c4%b1ps%c4%b1z-s%c4%b1k%c4%b1%c5%9ft%c4%b1rma>#</a></h3><p>Videoyu kayıpsız (hiçbir bilgi kaybolmaz) veya kayıplı (bilgi kaybolabilir) olacak şekilde kodlayabilirsiniz. Kayıpsız kodlama bir eşe daha fazla veri gönderilmesini gerektirdiği için, daha yüksek gecikmeli akış ve daha fazla düşürülen paket oluşturduğu için, video kalitesi o kadar iyi olmasa da RTP tipik olarak kayıplı sıkıştırma kullanır.</p><h3 id=çerçeve-içi-ve-çerçeveler-arası-sıkıştırma>Çerçeve içi ve çerçeveler arası sıkıştırma
<a class=anchor href=#%c3%a7er%c3%a7eve-i%c3%a7i-ve-%c3%a7er%c3%a7eveler-aras%c4%b1-s%c4%b1k%c4%b1%c5%9ft%c4%b1rma>#</a></h3><p>Video sıkıştırma iki türde gelir. İlki çerçeve içidir. Çerçeve içi sıkıştırma, tek bir video çerçevesini tanımlamak için kullanılan bitleri azaltır. Aynı teknikler JPEG sıkıştırma yöntemi gibi durağan resimleri sıkıştırmak için kullanılır.</p><p>İkinci tür çerçeveler arası sıkıştırmadır. Video birçok resimden oluştuğu için aynı bilgiyi iki kez göndermemenin yollarını ararız.</p><h3 id=çerçeve-arası-türler>Çerçeve arası türler
<a class=anchor href=#%c3%a7er%c3%a7eve-aras%c4%b1-t%c3%bcrler>#</a></h3><p>Üç çerçeve türü vardır:</p><ul><li><strong>I-Frame</strong> - Tam bir resim, başka bir şey olmadan decode edilebilir.</li><li><strong>P-Frame</strong> - Kısmi bir resim, sadece önceki resimden değişiklikleri içerir.</li><li><strong>B-Frame</strong> - Kısmi bir resim, önceki ve gelecek resimlerin bir modifikasyonudur.</li></ul><p>Aşağıda üç çerçeve türünün görselleştirmesi verilmiştir.</p><p><img src=../images/06-frame-types.png alt="Frame types" title="Frame types"></p><h3 id=video-hassastır>Video hassastır
<a class=anchor href=#video-hassast%c4%b1r>#</a></h3><p>Video sıkıştırma inanılmaz derecede durumludur, bu da internet üzerinden aktarımını zorlaştırır. Bir I-Frame&rsquo;in bir parçasını kaybederseniz ne olur? P-Frame neyi değiştireceğini nasıl biliyor? Video sıkıştırma daha karmaşık hale geldikçe, bu daha da büyük bir sorun haline geliyor. Neyse ki RTP ve RTCP&rsquo;nin çözümü var.</p><h2 id=rtp>RTP
<a class=anchor href=#rtp>#</a></h2><h3 id=paket-formatı>Paket Formatı
<a class=anchor href=#paket-format%c4%b1>#</a></h3><p>Her RTP paketi aşağıdaki yapıya sahiptir:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v>Version (V)
<a class=anchor href=#version-v>#</a></h4><p><code>Version</code> her zaman <code>2</code>&lsquo;dir.</p><h4 id=padding-p>Padding (P)
<a class=anchor href=#padding-p>#</a></h4><p><code>Padding</code>, payload&rsquo;ın padding&rsquo;i olup olmadığını kontrol eden bir boolean&rsquo;dır.</p><p>Payload&rsquo;ın son byte&rsquo;ı kaç padding byte&rsquo;ının eklendiğini içerir.</p><h4 id=extension-x>Extension (X)
<a class=anchor href=#extension-x>#</a></h4><p>Ayarlanırsa, RTP başlığının uzantıları olacaktır. Bu aşağıda daha ayrıntılı olarak açıklanmaktadır.</p><h4 id=csrc-count-cc>CSRC count (CC)
<a class=anchor href=#csrc-count-cc>#</a></h4><p><code>SSRC</code>&lsquo;den sonra ve payload&rsquo;dan önce gelen <code>CSRC</code> tanımlayıcılarının miktarı.</p><h4 id=marker-m>Marker (M)
<a class=anchor href=#marker-m>#</a></h4><p>İşaretleyici bit önceden belirlenmiş bir anlama sahip değildir ve kullanıcının istediği şekilde kullanılabilir.</p><p>Bazı durumlarda kullanıcı konuşurken ayarlanır. Ayrıca yaygın olarak bir anahtar çerçeveyi işaretlemek için kullanılır.</p><h4 id=payload-type-pt>Payload Type (PT)
<a class=anchor href=#payload-type-pt>#</a></h4><p><code>Payload Type</code>, bu paket tarafından taşınan codec&rsquo;in benzersiz tanımlayıcısıdır.</p><p>WebRTC için <code>Payload Type</code> dinamiktir. Bir çağrıdaki VP8 diğerinden farklı olabilir. Çağrıdaki teklif veren, <code>Session Description</code>&lsquo;da <code>Payload Types</code>&lsquo;ın codec&rsquo;lere eşlemesini belirler.</p><h4 id=sequence-number>Sequence Number
<a class=anchor href=#sequence-number>#</a></h4><p><code>Sequence Number</code>, bir akıştaki paketleri sıralamak için kullanılır. Her paket gönderildiğinde <code>Sequence Number</code> bir artırılır.</p><p>RTP, kayıplı ağlar üzerinde yararlı olacak şekilde tasarlanmıştır. Bu, alıcıya paketlerin ne zaman kaybolduğunu tespit etme yolu verir.</p><h4 id=timestamp>Timestamp
<a class=anchor href=#timestamp>#</a></h4><p>Bu paket için örnekleme anı. Bu küresel bir saat değildir, medya akışında ne kadar zaman geçtiğidir. Birkaç RTP paketi, örneğin hepsi aynı video çerçevesinin parçasıysa aynı zaman damgasına sahip olabilir.</p><h4 id=synchronization-source-ssrc>Synchronization Source (SSRC)
<a class=anchor href=#synchronization-source-ssrc>#</a></h4><p><code>SSRC</code>, bu akış için benzersiz tanımlayıcıdır. Bu, tek bir RTP akışı üzerinden birden fazla medya akışı çalıştırmanıza olanak tanır.</p><h4 id=contributing-source-csrc>Contributing Source (CSRC)
<a class=anchor href=#contributing-source-csrc>#</a></h4><p>Bu pakete hangi <code>SSRC</code>&lsquo;lerin katkıda bulunduğunu ileten bir liste.</p><p>Bu yaygın olarak konuşma göstergeleri için kullanılır. Diyelim ki sunucu tarafında birden fazla ses beslemesini tek bir RTP akışında birleştirdiniz. Daha sonra bu alanı &ldquo;Bu anda Giriş akışı A ve C konuşuyordu&rdquo; demek için kullanabilirsiniz.</p><h4 id=payload>Payload
<a class=anchor href=#payload>#</a></h4><p>Gerçek payload verisi. Padding bayrağı ayarlanmışsa, kaç padding byte&rsquo;ının eklendiğinin sayısıyla sonlanabilir.</p><h3 id=uzantılar>Uzantılar
<a class=anchor href=#uzant%c4%b1lar>#</a></h3><h2 id=rtcp>RTCP
<a class=anchor href=#rtcp>#</a></h2><h3 id=paket-formatı-1>Paket Formatı
<a class=anchor href=#paket-format%c4%b1-1>#</a></h3><p>Her RTCP paketi aşağıdaki yapıya sahiptir:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |       PT      |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v-1>Version (V)
<a class=anchor href=#version-v-1>#</a></h4><p><code>Version</code> her zaman <code>2</code>&lsquo;dir.</p><h4 id=padding-p-1>Padding (P)
<a class=anchor href=#padding-p-1>#</a></h4><p><code>Padding</code>, payload&rsquo;ın padding&rsquo;i olup olmadığını kontrol eden bir boolean&rsquo;dır.</p><p>Payload&rsquo;ın son byte&rsquo;ı kaç padding byte&rsquo;ının eklendiğini içerir.</p><h4 id=reception-report-count-rc>Reception Report Count (RC)
<a class=anchor href=#reception-report-count-rc>#</a></h4><p>Bu paketteki raporların sayısı. Tek bir RTCP paketi birden fazla olay içerebilir.</p><h4 id=packet-type-pt>Packet Type (PT)
<a class=anchor href=#packet-type-pt>#</a></h4><p>Bu RTCP Paketinin ne tür olduğunun benzersiz tanımlayıcısı. Bir WebRTC Ajanının tüm bu türleri desteklemesi gerekmez ve Ajanlar arasındaki destek farklı olabilir. Yaygın olarak görebilecekleriniz şunlardır:</p><ul><li><code>192</code> - Full INTRA-frame Request (<code>FIR</code>)</li><li><code>193</code> - Negative ACKnowledgements (<code>NACK</code>)</li><li><code>200</code> - Sender Report</li><li><code>201</code> - Receiver Report</li><li><code>205</code> - Generic RTP Feedback</li><li><code>206</code> - Payload Specific Feedback</li></ul><p>Bu paket türlerinin önemi aşağıda daha ayrıntılı olarak açıklanacaktır.</p><h3 id=full-intra-frame-request-fir-ve-picture-loss-indication-pli>Full INTRA-frame Request (FIR) ve Picture Loss Indication (PLI)
<a class=anchor href=#full-intra-frame-request-fir-ve-picture-loss-indication-pli>#</a></h3><p>Hem <code>FIR</code> hem de <code>PLI</code> mesajları benzer bir amaca hizmet eder. Bu mesajlar gönderenden tam bir anahtar çerçeve ister.
<code>PLI</code>, kısmi çerçeveler decoder&rsquo;a verildiğinde ancak bunları decode edemediğinde kullanılır.
Bu, çok fazla paket kaybınız olması veya belki decoder&rsquo;ın çökmesi nedeniyle olabilir.</p><p><a href=https://tools.ietf.org/html/rfc5104#section-4.3.1.2>RFC 5104</a>&rsquo;e göre, paketler veya çerçeveler kaybolduğunda <code>FIR</code> kullanılmamalıdır. Bu <code>PLI</code>&lsquo;nin işidir. <code>FIR</code>, paket kaybı dışındaki nedenlerle bir anahtar çerçeve ister - örneğin yeni bir üye video konferansına girdiğinde. Video akışını decode etmeye başlamak için tam bir anahtar çerçeveye ihtiyaçları vardır, decoder anahtar çerçeve gelene kadar çerçeveleri atıyor olacaktır.</p><p>Alıcının bağlandıktan hemen sonra tam bir anahtar çerçeve istemesi iyi bir fikirdir, bu bağlanma ile kullanıcının ekranında görüntü çıkması arasındaki gecikmeyi minimize eder.</p><p><code>PLI</code> paketleri Payload Specific Feedback mesajlarının bir parçasıdır.</p><p>Pratikte, hem <code>PLI</code> hem de <code>FIR</code> paketlerini işleyebilen yazılım her iki durumda da aynı şekilde davranacaktır. Encoder&rsquo;a yeni bir tam anahtar çerçeve üretmesi için sinyal gönderecektir.</p><h3 id=negative-acknowledgment>Negative Acknowledgment
<a class=anchor href=#negative-acknowledgment>#</a></h3><p>Bir <code>NACK</code>, gönderenin tek bir RTP paketini yeniden iletmesini ister. Bu genellikle bir RTP paketinin kaybolması nedeniyle olur, ancak geç kaldığı için de olabilir.</p><p><code>NACK</code>&lsquo;ler, tüm çerçevenin tekrar gönderilmesini istemekten çok daha bant genişliği açısından verimlidir. RTP paketleri çok küçük parçalara böldüğü için, gerçekten sadece küçük eksik bir parça istiyorsunuz. Alıcı SSRC ve Sequence Number ile bir RTCP mesajı oluşturur. Gönderen bu RTP paketini yeniden göndermek için mevcut değilse, mesajı görmezden gelir.</p><h3 id=sender-ve-receiver-reports>Sender ve Receiver Reports
<a class=anchor href=#sender-ve-receiver-reports>#</a></h3><p>Bu raporlar ajanlar arasında istatistik göndermek için kullanılır. Bu, gerçekten alınan paket miktarını ve jitter&rsquo;ı iletir.</p><p>Raporlar tanılama ve tıkanıklık kontrolü için kullanılabilir.</p><h2 id=rtprtcp-nasıl-birlikte-sorunları-çözer>RTP/RTCP nasıl birlikte sorunları çözer
<a class=anchor href=#rtprtcp-nas%c4%b1l-birlikte-sorunlar%c4%b1-%c3%a7%c3%b6zer>#</a></h2><p>RTP ve RTCP daha sonra ağların neden olduğu tüm sorunları çözmek için birlikte çalışır. Bu teknikler hala sürekli değişiyor!</p><h3 id=forward-error-correction>Forward Error Correction
<a class=anchor href=#forward-error-correction>#</a></h3><p>FEC olarak da bilinir. Paket kaybıyla başa çıkmanın başka bir yöntemi. FEC, istenmeden bile aynı veriyi birden fazla kez göndermenizdir. Bu RTP seviyesinde veya codec ile daha da alt seviyede yapılır.</p><p>Bir çağrı için paket kaybı sabitiyse, FEC, NACK&rsquo;ten çok daha düşük gecikmeli bir çözümdür. İstemek ve sonra eksik paketi yeniden iletmek zorunda kalmanın gidiş-dönüş süresi NACK&rsquo;ler için önemli olabilir.</p><h3 id=adaptive-bitrate-ve-bandwidth-estimation>Adaptive Bitrate ve Bandwidth Estimation
<a class=anchor href=#adaptive-bitrate-ve-bandwidth-estimation>#</a></h3><p><a href=../05-real-time-networking/>Real-time networking</a> bölümünde tartışıldığı gibi, ağlar öngörülemez ve güvenilmezdir. Bant genişliği kullanılabilirliği bir oturum boyunca birden fazla kez değişebilir.
Mevcut bant genişliğinin bir saniye içinde dramatik olarak (büyüklük mertebeleri) değiştiğini görmek nadir değildir.</p><p>Ana fikir, tahmin edilen, mevcut ve gelecekteki mevcut ağ bant genişliğine dayalı olarak kodlama bitrate&rsquo;ini ayarlamaktır.
Bu, mümkün olan en iyi kalitede video ve ses sinyalinin iletilmesini ve ağ tıkanıklığı nedeniyle bağlantının düşmemesini sağlar.
Ağ davranışını modelleyen ve tahmin etmeye çalışan buluşsal yöntemler Bandwidth estimation olarak bilinir.</p><p>Bunun çok fazla nüansı vardır, bu yüzden daha ayrıntılı olarak inceleyelim.</p><h2 id=ağ-durumunu-tanımlama-ve-iletişim>Ağ Durumunu Tanımlama ve İletişim
<a class=anchor href=#a%c4%9f-durumunu-tan%c4%b1mlama-ve-ileti%c5%9fim>#</a></h2><p>RTP/RTCP her türlü farklı ağ üzerinde çalışır ve sonuç olarak, bazı iletişimin gönderenden alıcıya giderken düşürülmesi yaygındır. UDP üzerine kurulduğu için, paket yeniden iletimi için yerleşik bir mekanizma yoktur, tıkanıklık kontrolünü ele almak şöyle dursun.</p><p>Kullanıcılara en iyi deneyimi sağlamak için WebRTC, ağ yolu hakkındaki nitelikleri tahmin etmeli ve bu niteliklerin zaman içinde nasıl değiştiğine uyum sağlamalıdır. İzlenmesi gereken temel özellikler şunlardır: mevcut bant genişliği (her yönde, simetrik olmayabilir), gidiş-dönüş süresi ve jitter (gidiş-dönüş süresindeki dalgalanmalar). Paket kaybını hesaba katması ve ağ koşulları değiştikçe bu özelliklerdeki değişiklikleri iletmesi gerekir.</p><p>Bu protokoller için iki temel amaç vardır:</p><ol><li>Ağ tarafından desteklenen mevcut bant genişliğini (her yönde) tahmin etmek.</li><li>Gönderen ve alıcı arasında ağ özelliklerini iletmek.</li></ol><p>RTP/RTCP&rsquo;nin bu sorunu ele almak için üç farklı yaklaşımı vardır. Hepsinin artıları ve eksileri vardır ve genellikle her nesil öncekilerine göre gelişmiştir. Hangi uygulamayı kullanacağınız öncelikle istemcileriniz için mevcut yazılım yığınına ve uygulamanızı oluşturmak için mevcut kütüphanelere bağlı olacaktır.</p><h3 id=receiver-reports--sender-reports>Receiver Reports / Sender Reports
<a class=anchor href=#receiver-reports--sender-reports>#</a></h3><p>İlk uygulama, Receiver Reports çifti ve tamamlayıcısı Sender Reports&rsquo;tır. Bu RTCP mesajları <a href=https://tools.ietf.org/html/rfc3550#section-6.4>RFC 3550</a>&lsquo;de tanımlanmıştır ve uç noktalar arasında ağ durumunu iletmekten sorumludur. Receiver Reports, ağ hakkındaki nitelikleri (paket kaybı, gidiş-dönüş süresi ve jitter dahil) iletmeye odaklanır ve bu raporlara dayalı olarak mevcut bant genişliğini tahmin etmekten sorumlu diğer algoritmalarla eşleşir.</p><p>Sender ve Receiver raporları (SR ve RR) birlikte ağ kalitesinin bir resmini çizer. Her SSRC için bir programda gönderilirler ve mevcut bant genişliğini tahmin ederken kullanılan girdilerdir. Bu tahminler, aşağıdaki alanları içeren RR verilerini aldıktan sonra gönderen tarafından yapılır:</p><ul><li><strong>Fraction Lost</strong> - Son Receiver Report&rsquo;tan bu yana paketlerin yüzde kaçı kayboldu.</li><li><strong>Cumulative Number of Packets Lost</strong> - Tüm çağrı boyunca kaç paket kayboldu.</li><li><strong>Extended Highest Sequence Number Received</strong> - Alınan son Sequence Number neydi ve kaç kez döndü.</li><li><strong>Interarrival Jitter</strong> - Tüm çağrı için rolling Jitter.</li><li><strong>Last Sender Report Timestamp</strong> - Gönderendeki son bilinen zaman, gidiş-dönüş süresi hesaplaması için kullanılır.</li></ul><p>SR ve RR, gidiş-dönüş süresini hesaplamak için birlikte çalışır.</p><p>Gönderen SR&rsquo;de yerel zamanını <code>sendertime1</code>&lsquo;i içerir. Alıcı bir SR paketi aldığında, RR&rsquo;yi geri gönderir. Diğer şeylerin yanı sıra, RR gönderenden az önce alınan <code>sendertime1</code>&lsquo;i içerir.
SR&rsquo;yi alma ve RR&rsquo;yi gönderme arasında bir gecikme olacaktır. Bu nedenle, RR ayrıca bir &ldquo;son gönderen raporundan bu yana gecikme&rdquo; zamanını - <code>DLSR</code>&lsquo;yi de içerir. <code>DLSR</code>, gidiş-dönüş süresini ayarlamak için kullanılır.</p><p>İşlemde daha sonra gidiş-dönüş süresi tahminini yapmak için kullanılır. Gönderen RR&rsquo;yi aldığında, mevcut zaman <code>sendertime2</code>&lsquo;den <code>sendertime1</code> ve <code>DLSR</code>&lsquo;yi çıkarır. Bu zaman deltası gidiş-dönüş yayılma gecikmesi veya gidiş-dönüş süresi olarak adlandırılır.</p><p><code>rtt = sendertime2 - sendertime1 - DLSR</code></p><p>Gidiş-dönüş süresi sade İngilizcede:</p><ul><li>Size saatimin mevcut okumasını içeren bir mesaj gönderirim, diyelim ki 16:20, 42 saniye ve 420 milisaniye.</li><li>Siz de bu aynı zaman damgasını bana geri gönderirsiniz.</li><li>Ayrıca mesajımı okumaktan mesajı geri göndermeye kadar geçen zamanı da dahil edersiniz, diyelim ki 5 milisaniye.</li><li>Zamanı geri aldığımda, saate tekrar bakarım.</li><li>Şimdi saatim 16:20, 42 saniye 690 milisaniye diyor.</li><li>Bu, size ulaşıp bana geri dönmek için 265 milisaniye (690 - 420 - 5) aldığı anlamına gelir.</li><li>Dolayısıyla, gidiş-dönüş süresi 265 milisaniyedir.</li></ul><p><img src=../images/06-rtt.png alt="Round-trip time" title="Round-trip time"></p><h3 id=tmmbr-tmmbn-remb-ve-twcc-gcc-ile-eşleştirilmiş>TMMBR, TMMBN, REMB ve TWCC, GCC ile eşleştirilmiş
<a class=anchor href=#tmmbr-tmmbn-remb-ve-twcc-gcc-ile-e%c5%9fle%c5%9ftirilmi%c5%9f>#</a></h3><h4 id=google-congestion-control-gcc>Google Congestion Control (GCC)
<a class=anchor href=#google-congestion-control-gcc>#</a></h4><p>Google Congestion Control (GCC) algoritması (<a href=https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>draft-ietf-rmcat-gcc-02</a>&lsquo;de özetlenmiştir) bant genişliği tahmininin zorluğunu ele alır. İlişkili iletişim gereksinimlerini kolaylaştırmak için çeşitli diğer protokollerle eşleşir. Sonuç olarak, alıcı tarafında (TMMBR/TMMBN veya REMB ile çalıştırıldığında) veya gönderen tarafında (TWCC ile çalıştırıldığında) çalışmaya çok uygundur.</p><p>Mevcut bant genişliği tahminlerine ulaşmak için GCC, iki temel metrik olarak paket kaybına ve çerçeve varış zamanındaki dalgalanmalara odaklanır. Bu metrikleri iki bağlantılı kontrolör üzerinden çalıştırır: kayıp-tabanlı kontrolör ve gecikme-tabanlı kontrolör.</p><p>GCC&rsquo;nin ilk bileşeni olan kayıp-tabanlı kontrolör basittir:</p><ul><li>Paket kaybı %10&rsquo;un üzerindeyse, bant genişliği tahmini azaltılır.</li><li>Paket kaybı %2-10 arasındaysa, bant genişliği tahmini aynı kalır.</li><li>Paket kaybı %2&rsquo;nin altındaysa, bant genişliği tahmini artırılır.</li></ul><p>Paket kaybı ölçümleri sık sık alınır. Eşleştirilmiş iletişim protokolüne bağlı olarak, paket kaybı ya açıkça iletilir (TWCC&rsquo;de olduğu gibi) ya da çıkarılır (TMMBR/TMMBN ve REMB&rsquo;de olduğu gibi). Bu yüzdeler yaklaşık bir saniye civarındaki zaman pencereleri üzerinde değerlendirilir.</p><p>Gecikme-tabanlı kontrolör, kayıp-tabanlı kontrolörle işbirliği yapar ve paket varış zamanındaki varyasyonlara bakar. Bu gecikme-tabanlı kontrolör, ağ bağlantılarının ne zaman giderek daha tıkanık hale geldiğini belirlemeyi amaçlar ve paket kaybı oluşmadan önce bile bant genişliği tahminlerini azaltabilir. Teori, yol boyunca en meşgul ağ arayüzünün, arayüz tamponlarının içindeki kapasitesi bitene kadar paketleri sıraya koymaya devam edeceğidir. Bu arayüz gönderebileceğinden daha fazla trafik almaya devam ederse, tampon alanına sığdıramadığı tüm paketleri düşmeye zorlanacaktır. Bu tür paket kaybı, düşük gecikmeli/gerçek zamanlı iletişim için özellikle yıkıcıdır, ancak aynı zamanda bu bağlantı üzerindeki tüm iletişim için verimi de bozabilir ve ideal olarak kaçınılmalıdır. Bu nedenle, GCC, paket kaybı gerçekten gerçekleşmeden <em>önce</em> ağ bağlantılarının giderek büyüyen kuyruk derinlikleri olup olmadığını anlamaya çalışır. Zaman içinde artan sıralama gecikmelerini gözlemlerse bant genişliği kullanımını azaltacaktır.</p><p>Bunu başarmak için GCC, gidiş-dönüş süresindeki ince artışları ölçerek kuyruk derinliğindeki artışları çıkarmaya çalışır. Çerçevelerin &ldquo;varış-arası zamanını&rdquo; kaydeder, <code>t(i) - t(i-1)</code>: iki paket grubunun (genellikle ardışık video çerçeveleri) varış zamanındaki fark. Bu paket grupları sıklıkla düzenli zaman aralıklarında ayrılır (örneğin, 24 fps bir video için her 1/24 saniyede bir). Sonuç olarak, varış-arası zamanı ölçmek, ilk paket grubunun (yani çerçevenin) başlangıcı ile bir sonrakinin ilk çerçevesi arasındaki zaman farkını kaydetmek kadar basittir.</p><p>Aşağıdaki diyagramda, medyan paketler arası gecikme artışı +20 msn&rsquo;dir, ağ tıkanıklığının açık bir göstergesidir.</p><p><img src=../images/06-twcc.png alt="TWCC with delay" title="TWCC with delay"></p><p>Varış-arası zaman zaman içinde artıyorsa, bu bağlayan ağ arayüzlerinde artan kuyruk derinliğinin kanıtı olarak kabul edilir ve ağ tıkanıklığı olarak değerlendirilir. (Not: GCC, çerçeve byte boyutlarındaki dalgalanmalar için bu ölçümleri kontrol edecek kadar akıllıdır.) GCC, gecikme ölçümlerini bir <a href=https://en.wikipedia.org/wiki/Kalman_filter>Kalman filtresini</a> kullanarak rafine eder ve tıkanıklığı işaretlemeden önce ağ gidiş-dönüş sürelerinin (ve varyasyonlarının) birçok ölçümünü alır. GCC&rsquo;nin Kalman filtresini doğrusal regresyonun yerini alacak şekilde düşünebilirsiniz: jitter zamanlama ölçümlerine gürültü eklediğinde bile doğru tahminler yapmaya yardımcı olur. Tıkanıklığı işaretledikten sonra, GCC mevcut bitrate&rsquo;i azaltacaktır. Alternatif olarak, sabit ağ koşulları altında, daha yüksek yük değerlerini test etmek için bant genişliği tahminlerini yavaşça artırabilir.</p><h4 id=tmmbr-tmmbn-ve-remb>TMMBR, TMMBN ve REMB
<a class=anchor href=#tmmbr-tmmbn-ve-remb>#</a></h4><p>TMMBR/TMMBN ve REMB için, alıcı taraf önce mevcut gelen bant genişliğini tahmin eder (GCC gibi bir protokol kullanarak) ve ardından bu bant genişliği tahminlerini uzak gönderenlere iletir. Paket kaybı veya ağ tıkanıklığı hakkındaki diğer nitelikler hakkında ayrıntı alışverişi yapmaları gerekmez çünkü alıcı tarafında çalışmak onların varış-arası zamanı ve paket kaybını doğrudan ölçmelerine olanak tanır. Bunun yerine, TMMBR, TMMBN ve REMB sadece bant genişliği tahminlerinin kendilerini alışverişi yapar:</p><ul><li><strong>Temporary Maximum Media Stream Bit Rate Request</strong> - Tek bir SSRC için istenen bitrate&rsquo;in mantissa/üssü.</li><li><strong>Temporary Maximum Media Stream Bit Rate Notification</strong> - Bir TMMBR&rsquo;nin alındığını bildiren mesaj.</li><li><strong>Receiver Estimated Maximum Bitrate</strong> - Tüm oturum için istenen bitrate&rsquo;in mantissa/üssü.</li></ul><p>TMMBR ve TMMBN önce geldi ve <a href=https://tools.ietf.org/html/rfc5104>RFC 5104</a>&rsquo;te tanımlandı. REMB daha sonra geldi, <a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-remb-03>draft-alvestrand-rmcat-remb</a>&lsquo;de bir taslak sunuldu, ancak hiçbir zaman standartlaştırılmadı.</p><p>REMB kullanan örnek bir oturum aşağıdaki gibi davranabilir:</p><p><img src=../images/06-remb.png alt=REMB title=REMB></p><p>Bu yöntem kağıt üzerinde harika çalışır. Gönderen alıcıdan tahmin alır, encoder bitrate&rsquo;ini alınan değere ayarlar. Tada! Ağ koşullarına uyum sağladık.</p><p>Ancak pratikte, REMB yaklaşımının birden fazla dezavantajı vardır.</p><p>Encoder verimsizliği birincisidir. Encoder için bir bitrate ayarladığınızda, mutlaka istediğiniz tam bitrate&rsquo;i çıkarmayacaktır. Kodlama, encoder ayarlarına ve kodlanan çerçeveye bağlı olarak daha fazla veya daha az bit çıkarabilir.</p><p>Örneğin, x264 encoder&rsquo;ını <code>tune=zerolatency</code> ile kullanmak belirtilen hedef bitrate&rsquo;ten önemli ölçüde sapabilir. İşte olası bir senaryo:</p><ul><li>Diyelim ki bitrate&rsquo;i 1000 kbps&rsquo;ye ayarlayarak başlıyoruz.</li><li>Encoder sadece 700 kbps çıkarıyor, çünkü kodlamak için yeterli yüksek frekans özelliği yok. (AKA - &ldquo;duvara bakmak&rdquo;.)</li><li>Ayrıca alıcının 700 kbps videoyu sıfır paket kaybıyla aldığını hayal edelim. Daha sonra gelen bitrate&rsquo;i %8 artırmak için REMB kuralı 1&rsquo;i uygular.</li><li>Alıcı gönderene 756 kbps önerisi (700 kbps * 1.08) ile bir REMB paketi gönderir.</li><li>Gönderen encoder bitrate&rsquo;ini 756 kbps&rsquo;ye ayarlar.</li><li>Encoder daha da düşük bir bitrate çıkarır.</li><li>Bu süreç kendini tekrar etmeye devam eder ve bitrate&rsquo;i mutlak minimuma düşürür.</li></ul><p>Bunun nasıl ağır encoder parametre ayarlamasına neden olacağını ve harika bir bağlantıda bile izlenemez videoyla kullanıcıları şaşırtacağını görebilirsiniz.</p><h4 id=transport-wide-congestion-control>Transport Wide Congestion Control
<a class=anchor href=#transport-wide-congestion-control>#</a></h4><p>Transport Wide Congestion Control, RTCP ağ durumu iletişimindeki en son gelişmedir. <a href=https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01>draft-holmer-rmcat-transport-wide-cc-extensions-01</a>&lsquo;de tanımlanmıştır, ancak aynı zamanda hiçbir zaman standartlaştırılmamıştır.</p><p>TWCC oldukça basit bir prensip kullanır:</p><p><img src=../images/06-twcc-idea.png alt=TWCC title=TWCC></p><p>REMB ile alıcı, gönderen tarafa mevcut indirme bitrate&rsquo;ini bildirir. Çıkarılan paket kaybı hakkında kesin ölçümler ve sadece kendisinin sahip olduğu paketler arası varış zamanı hakkında veri kullanır.</p><p>TWCC, SR/RR ve REMB protokol nesilleri arasında neredeyse hibrit bir yaklaşımdır. Bant genişliği tahminlerini gönderen tarafa geri getirir (SR/RR&rsquo;ye benzer), ancak bant genişliği tahmin tekniği REMB nesline daha çok benzer.</p><p>TWCC ile alıcı, gönderene her paketin varış zamanını bildirir. Bu, gönderenin paketler arası varış gecikme varyasyonunu ölçmesi ve ses/video beslemesine katkıda bulunamayacak kadar düşürülen veya geç gelen paketleri tanımlaması için yeterli bilgidir. Bu veriler sık sık alışverişi edildiğinde, gönderen değişen ağ koşullarına hızla uyum sağlayabilir ve GCC gibi bir algoritma kullanarak çıkış bant genişliğini değiştirebilir.</p><p>Gönderen gönderilen paketleri, sıra numaralarını, boyutlarını ve zaman damgalarını takip eder. Gönderen alıcıdan RTCP mesajları aldığında, gönderme paketler arası gecikmelerini alma gecikmeleriyle karşılaştırır. Alma gecikmeleri artıyorsa, ağ tıkanıklığını işaret eder ve gönderen düzeltici önlemler almalıdır.</p><p>Gönderene ham veri sağlayarak, TWCC gerçek zamanlı ağ koşullarına mükemmel bir görünüm sağlar:</p><ul><li>Bireysel kayıp paketlere kadar neredeyse anında paket kaybı davranışı</li><li>Doğru gönderme bitrate&rsquo;i</li><li>Doğru alma bitrate&rsquo;i</li><li>Jitter ölçümü</li><li>Gönderme ve alma paket gecikmeleri arasındaki farklar</li><li>Ağın patlamalı veya sabit bant genişliği teslimatını nasıl tolere ettiğinin açıklaması</li></ul><p>TWCC&rsquo;nin en önemli katkılarından biri, WebRTC geliştiricilerine sağladığı esnekliktir. Tıkanıklık kontrol algoritmasını gönderen tarafa konsolide ederek, yaygın olarak kullanılabilen ve zaman içinde minimal geliştirmeler gerektiren basit istemci koduna olanak tanır. Karmaşık tıkanıklık kontrol algoritmaları daha sonra doğrudan kontrol ettikleri donanımda (Bölüm 8&rsquo;de tartışılan Selective Forwarding Unit gibi) daha hızlı bir şekilde yinelenebilir. Tarayıcılar ve mobil cihazlar söz konusu olduğunda, bu, bu istemcilerin standartlaştırma veya tarayıcı güncellemelerini beklemek zorunda kalmadan (yaygın olarak kullanılabilir olması oldukça uzun sürebilir) algoritma geliştirmelerinden faydalanabileceği anlamına gelir.</p><h2 id=bant-genişliği-tahmini-alternatifleri>Bant Genişliği Tahmini Alternatifleri
<a class=anchor href=#bant-geni%c5%9fli%c4%9fi-tahmini-alternatifleri>#</a></h2><p>En çok dağıtılan uygulama, <a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-congestion-02>draft-alvestrand-rmcat-congestion</a>&lsquo;da tanımlanan &ldquo;Gerçek Zamanlı İletişim için Google Tıkanıklık Kontrol Algoritması"dır.</p><p>GCC&rsquo;ye birkaç alternatif vardır, örneğin <a href=https://tools.ietf.org/html/draft-zhu-rmcat-nada-04>NADA: Gerçek Zamanlı Medya için Birleşik Tıkanıklık Kontrol Şeması</a> ve <a href=https://tools.ietf.org/html/draft-johansson-rmcat-scream-cc-05>SCReAM - Multimedya için Kendi Kendine Saatli Hız Adaptasyonu</a>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/30cec2bd1fa8fc839dca83e8a73daa7afd98de9e title='Son düzenleyen fatihsen-dev | Temmuz 16, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>Temmuz 16, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/06-media-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Bu sayfayı düzenle</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtcnin-medya-iletişiminden-ne-elde-ederim>WebRTC&rsquo;nin medya iletişiminden ne elde ederim?</a></li><li><a href=#nasıl-çalışır>Nasıl çalışır?</a></li><li><a href=#gecikme-vs-kalite>Gecikme vs Kalite</a><ul><li><a href=#gerçek-dünya-sınırlamaları>Gerçek Dünya Sınırlamaları</a></li><li><a href=#video-karmaşıktır>Video Karmaşıktır</a></li></ul></li><li><a href=#video-101>Video 101</a><ul><li><a href=#kayıplı-ve-kayıpsız-sıkıştırma>Kayıplı ve Kayıpsız sıkıştırma</a></li><li><a href=#çerçeve-içi-ve-çerçeveler-arası-sıkıştırma>Çerçeve içi ve çerçeveler arası sıkıştırma</a></li><li><a href=#çerçeve-arası-türler>Çerçeve arası türler</a></li><li><a href=#video-hassastır>Video hassastır</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#paket-formatı>Paket Formatı</a></li><li><a href=#uzantılar>Uzantılar</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#paket-formatı-1>Paket Formatı</a></li><li><a href=#full-intra-frame-request-fir-ve-picture-loss-indication-pli>Full INTRA-frame Request (FIR) ve Picture Loss Indication (PLI)</a></li><li><a href=#negative-acknowledgment>Negative Acknowledgment</a></li><li><a href=#sender-ve-receiver-reports>Sender ve Receiver Reports</a></li></ul></li><li><a href=#rtprtcp-nasıl-birlikte-sorunları-çözer>RTP/RTCP nasıl birlikte sorunları çözer</a><ul><li><a href=#forward-error-correction>Forward Error Correction</a></li><li><a href=#adaptive-bitrate-ve-bandwidth-estimation>Adaptive Bitrate ve Bandwidth Estimation</a></li></ul></li><li><a href=#ağ-durumunu-tanımlama-ve-iletişim>Ağ Durumunu Tanımlama ve İletişim</a><ul><li><a href=#receiver-reports--sender-reports>Receiver Reports / Sender Reports</a></li><li><a href=#tmmbr-tmmbn-remb-ve-twcc-gcc-ile-eşleştirilmiş>TMMBR, TMMBN, REMB ve TWCC, GCC ile eşleştirilmiş</a></li></ul></li><li><a href=#bant-genişliği-tahmini-alternatifleri>Bant Genişliği Tahmini Alternatifleri</a></li></ul></nav></div></aside></main></body></html>