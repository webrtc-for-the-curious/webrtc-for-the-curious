<!doctype html><html lang=tr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Ne, Neden ve Nasıl # WebRTC Nedir? # WebRTC, Web Real-Time Communication&rsquo;ın kısaltması olarak hem bir API hem de bir Protokoldür. WebRTC protokolü, iki WebRTC aracısının çift yönlü güvenli gerçek zamanlı iletişim müzakere etmesi için bir dizi kuraldan oluşur. WebRTC API&rsquo;si ise geliştiricilerin WebRTC protokolünü kullanmasına olanak tanır. WebRTC API&rsquo;si yalnızca JavaScript için belirtilmiştir.
Benzer bir ilişki HTTP ve Fetch API arasındaki ilişki olacaktır. WebRTC protokolü HTTP olurken, WebRTC API&rsquo;si Fetch API olur."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/"><meta property="og:site_name" content="WebRTC Meraklıları İçin"><meta property="og:title" content="Ne, Neden ve Nasıl"><meta property="og:description" content="Ne, Neden ve Nasıl # WebRTC Nedir? # WebRTC, Web Real-Time Communication’ın kısaltması olarak hem bir API hem de bir Protokoldür. WebRTC protokolü, iki WebRTC aracısının çift yönlü güvenli gerçek zamanlı iletişim müzakere etmesi için bir dizi kuraldan oluşur. WebRTC API’si ise geliştiricilerin WebRTC protokolünü kullanmasına olanak tanır. WebRTC API’si yalnızca JavaScript için belirtilmiştir.
Benzer bir ilişki HTTP ve Fetch API arasındaki ilişki olacaktır. WebRTC protokolü HTTP olurken, WebRTC API’si Fetch API olur."><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-07-16T20:46:44+03:00"><title>Ne, Neden ve Nasıl | WebRTC Meraklıları İçin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ title="Vad, varför och hur"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/ title="Что, Зачем и Как"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/ title="Quoi, Pourquoi et Comment"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ title="Apa, Mengapa, dan Bagaimana"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ title="¿Qué, Por qué y Cómo?"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/ title="무엇, 왜, 어떻게?"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/tr.search.min.0e513a3507f051bf655d831577c7dbbf888331f24101f7ab2d356e175710b4d8.js integrity="sha256-DlE6NQfwUb9lXYMVd8fbv4iDMfJBAferLTVuF1cQtNg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/tr/><span>WebRTC Meraklıları İçin</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Arama aria-label=Arama maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Türkçe</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/>Español</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/>한국어</a></li></ul></li></ul><ul><li><a href=/tr/docs/01-what-why-and-how/ class=active>Ne, Neden ve Nasıl</a></li><li><a href=/tr/docs/02-signaling/>Sinyalleşme</a></li><li><a href=/tr/docs/03-connecting/>Bağlanma</a></li><li><a href=/tr/docs/04-securing/>Güvenlik</a></li><li><a href=/tr/docs/05-real-time-networking/>Gerçek Zamanlı Ağ İletişimi</a></li><li><a href=/tr/docs/06-media-communication/>Medya İletişimi</a></li><li><a href=/tr/docs/07-data-communication/>Veri İletişimi</a></li><li><a href=/tr/docs/08-applied-webrtc/>Uygulamalı WebRTC</a></li><li><a href=/tr/docs/09-debugging/>Hata Ayıklama</a></li><li><a href=/tr/docs/10-history-of-webrtc/>Tarihçe</a></li><li><a href=/tr/docs/11-faq/>SSS</a></li><li><a href=/tr/docs/12-glossary/>Sözlük</a></li><li><a href=/tr/docs/13-reference/>Referans</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Ne, Neden ve Nasıl</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc-nedir>WebRTC Nedir?</a></li><li><a href=#neden-webrtc-öğrenmeliyim>Neden WebRTC öğrenmeliyim?</a></li><li><a href=#webrtc-protokolü-diğer-teknolojilerin-bir-koleksiyonudur>WebRTC Protokolü diğer teknolojilerin bir koleksiyonudur</a><ul><li><a href=#sinyalleme-webrtcde-eşler-birbirlerini-nasıl-bulur>Sinyalleme: WebRTC&rsquo;de eşler birbirlerini nasıl bulur</a></li><li><a href=#stunturn-ile-bağlanma-ve-nat-geçişi>STUN/TURN ile Bağlanma ve NAT Geçişi</a></li><li><a href=#dtls-ve-srtp-ile-aktarım-katmanını-güvenlik-altına-alma>DTLS ve SRTP ile aktarım katmanını güvenlik altına alma</a></li><li><a href=#rtp-ve-sctp-aracılığıyla-eşlerle-iletişim>RTP ve SCTP aracılığıyla eşlerle iletişim</a></li></ul></li><li><a href=#webrtc-protokollerin-bir-koleksiyonu>WebRTC, protokollerin bir koleksiyonu</a></li><li><a href=#webrtc-apisi-nasıl-çalışır>WebRTC API&rsquo;si nasıl çalışır?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ne-neden-ve-nasıl>Ne, Neden ve Nasıl
<a class=anchor href=#ne-neden-ve-nas%c4%b1l>#</a></h1><h2 id=webrtc-nedir>WebRTC Nedir?
<a class=anchor href=#webrtc-nedir>#</a></h2><p>WebRTC, Web Real-Time Communication&rsquo;ın kısaltması olarak hem bir API hem de bir Protokoldür. WebRTC protokolü, iki WebRTC aracısının çift yönlü güvenli gerçek zamanlı iletişim müzakere etmesi için bir dizi kuraldan oluşur. WebRTC API&rsquo;si ise geliştiricilerin WebRTC protokolünü kullanmasına olanak tanır. WebRTC API&rsquo;si yalnızca JavaScript için belirtilmiştir.</p><p>Benzer bir ilişki HTTP ve Fetch API arasındaki ilişki olacaktır. WebRTC protokolü HTTP olurken, WebRTC API&rsquo;si Fetch API olur.</p><p>WebRTC protokolü JavaScript dışında diğer API&rsquo;ler ve dillerde de mevcuttur. WebRTC için sunucular ve domain-spesifik araçlar da bulabilirsiniz. Tüm bu uygulamalar WebRTC protokolünü kullanır böylece birbirleriyle etkileşim kurabilirler.</p><p>WebRTC protokolü IETF&rsquo;de <a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a> çalışma grubunda sürdürülmektedir. WebRTC API&rsquo;si ise W3C&rsquo;de <a href=https://www.w3.org/TR/webrtc/>webrtc</a> olarak belgelendirilmiştir.</p><h2 id=neden-webrtc-öğrenmeliyim>Neden WebRTC öğrenmeliyim?
<a class=anchor href=#neden-webrtc-%c3%b6%c4%9frenmeliyim>#</a></h2><p>WebRTC&rsquo;nin size vereceği şeyler şunlardır:</p><ul><li>Açık standart</li><li>Çoklu uygulamalar</li><li>Tarayıcılarda mevcut</li><li>Zorunlu şifreleme</li><li>NAT Geçişi</li><li>Mevcut teknolojinin yeniden kullanımı</li><li>Tıkanıklık kontrolü</li><li>Saniyenin altında gecikme</li></ul><p>Bu liste kapsamlı değil, yolculuğunuz sırasında takdir edebileceğiniz şeylerin sadece bir örneği. Henüz tüm bu terimleri bilmiyorsanız endişelenmeyin, bu kitap bunları yol boyunca size öğretecek.</p><h2 id=webrtc-protokolü-diğer-teknolojilerin-bir-koleksiyonudur>WebRTC Protokolü diğer teknolojilerin bir koleksiyonudur
<a class=anchor href=#webrtc-protokol%c3%bc-di%c4%9fer-teknolojilerin-bir-koleksiyonudur>#</a></h2><p>WebRTC Protokolü, açıklamak için tam bir kitap gerektirecek muazzam bir konudur. Ancak başlangıç olarak onu dört adıma ayırıyoruz.</p><ol><li>Sinyalleme</li><li>Bağlanma</li><li>Güvenlik</li><li>İletişim</li></ol><p>Bu adımlar sıralıdır, yani önceki adımın sonraki adımın başlaması için %100 başarılı olması gerekir.</p><p>WebRTC hakkındaki garip bir gerçek, her adımın aslında birçok başka protokolden oluşmasıdır! WebRTC yapmak için birçok mevcut teknolojiyi bir araya getiriyoruz. Bu anlamda WebRTC&rsquo;yi, kendi başına yepyeni bir süreç olmaktan ziyade 2000&rsquo;li yılların başlarına dayanan iyi anlaşılmış teknolojilerin bir kombinasyonu ve konfigürasyonu olarak düşünebilirsiniz.</p><p>Bu adımların her birinin özel bölümleri vardır, ancak önce bunları yüksek düzeyde anlamak yararlıdır. Birbirlerine bağımlı oldukları için, bu adımların her birinin amacını daha fazla açıklarken yardımcı olacaktır.</p><h3 id=sinyalleme-webrtcde-eşler-birbirlerini-nasıl-bulur>Sinyalleme: WebRTC&rsquo;de eşler birbirlerini nasıl bulur
<a class=anchor href=#sinyalleme-webrtcde-e%c5%9fler-birbirlerini-nas%c4%b1l-bulur>#</a></h3><p>Bir WebRTC Aracısı başladığında, kimle iletişim kuracağı veya ne hakkında iletişim kuracağı hakkında hiçbir fikri yoktur. <em>Sinyalleme</em> adımı bu sorunu çözer! Sinyalleme, çağrıyı başlatmak için kullanılır ve iki bağımsız WebRTC aracısının iletişim kurmaya başlamasına olanak tanır.</p><p>Sinyalleme, SDP (Session Description Protocol) adı verilen mevcut, düz metin bir protokol kullanır. Her SDP mesajı anahtar/değer çiftlerinden oluşur ve &ldquo;medya bölümleri&rdquo; listesi içerir. İki WebRTC aracısının değiş tokuş ettiği SDP şu gibi detayları içerir:</p><ul><li>Aracının ulaşılabilir olduğu IP&rsquo;ler ve Portlar (adaylar).</li><li>Aracının göndermek istediği ses ve video parça sayısı.</li><li>Her aracının desteklediği ses ve video codec&rsquo;leri.</li><li>Bağlanırken kullanılan değerler (<code>uFrag</code>/<code>uPwd</code>).</li><li>Güvenlik sağlanırken kullanılan değerler (sertifika parmak izi).</li></ul><p>Sinyallemenin tipik olarak &ldquo;bant dışı&rdquo; gerçekleştiğini not etmek çok önemlidir, bu da uygulamaların genellikle sinyalleme mesajlarını değiş tokuş etmek için WebRTC&rsquo;nin kendisini kullanmadığı anlamına gelir. İki taraf arasında bir WebRTC bağlantısı başlatmadan önce başka bir iletişim kanalına ihtiyaç vardır. Kullanılan kanal türü WebRTC&rsquo;nin endişesi değildir. Mesaj göndermek için uygun herhangi bir mimari, bağlanan eşler arasında SDP&rsquo;leri aktarabilir ve birçok uygulama, uygun istemciler arasında SDP&rsquo;lerin değiş tokuşunu kolaylaştırmak için mevcut altyapılarını (örneğin REST uç noktaları, WebSocket bağlantıları veya kimlik doğrulama proxy&rsquo;leri) basitçe kullanacaktır.</p><h3 id=stunturn-ile-bağlanma-ve-nat-geçişi>STUN/TURN ile Bağlanma ve NAT Geçişi
<a class=anchor href=#stunturn-ile-ba%c4%9flanma-ve-nat-ge%c3%a7i%c5%9fi>#</a></h3><p>İki WebRTC aracısı SDP&rsquo;leri değiş tokuş ettikten sonra, birbirlerine bağlanmaya çalışmak için yeterli bilgiye sahip olurlar. Bu bağlantıyı gerçekleştirmek için WebRTC, ICE (Interactive Connectivity Establishment) adı verilen başka bir yerleşik teknolojiyi kullanır.</p><p>ICE, WebRTC&rsquo;den önce var olan ve merkezi bir sunucu olmadan iki aracı arasında doğrudan bağlantı kurulmasına olanak tanıyan bir protokoldür. Bu iki aracı aynı ağda veya dünyanın diğer ucunda olabilir.</p><p>ICE doğrudan bağlantı sağlar, ancak bağlanma sürecinin gerçek büyüsü &lsquo;NAT Geçişi&rsquo; kavramını ve STUN/TURN Sunucularının kullanımını içerir. Daha sonra derinlemesine keşfedeceğimiz bu iki kavram, başka bir alt ağdaki ICE Aracısı ile iletişim kurmak için ihtiyacınız olan her şeydir.</p><p>İki aracı başarıyla bir ICE bağlantısı kurduğunda, WebRTC bir sonraki adıma geçer; aralarında ses, video ve veri paylaşımı için şifrelenmiş bir aktarım katmanı kurmak.</p><h3 id=dtls-ve-srtp-ile-aktarım-katmanını-güvenlik-altına-alma>DTLS ve SRTP ile aktarım katmanını güvenlik altına alma
<a class=anchor href=#dtls-ve-srtp-ile-aktar%c4%b1m-katman%c4%b1n%c4%b1-g%c3%bcvenlik-alt%c4%b1na-alma>#</a></h3><p>Artık çift yönlü iletişimimiz (ICE aracılığıyla) olduğuna göre, iletişimimizi güvenli hale getirmemiz gerekiyor! Bu, yine WebRTC&rsquo;den önce var olan iki protokol daha aracılığıyla yapılır; DTLS (Datagram Transport Layer Security) ve SRTP (Secure Real-Time Transport Protocol). İlk protokol olan DTLS, basitçe UDP üzerinden TLS&rsquo;dir (TLS, HTTPS üzerinden iletişimi güvenli hale getirmek için kullanılan kriptografik protokoldür). İkinci protokol olan SRTP, RTP (Real-time Transport Protocol) veri paketlerinin şifrelenmesini sağlamak için kullanılır.</p><p>İlk olarak, WebRTC, ICE tarafından kurulan bağlantı üzerinden bir DTLS el sıkışması yaparak bağlanır. HTTPS&rsquo;den farklı olarak, WebRTC sertifikalar için merkezi bir otorite kullanmaz. Sadece DTLS aracılığıyla değiş tokuş edilen sertifikanın, sinyalleme yoluyla paylaşılan parmak iziyle eşleştiğini doğrular. Bu DTLS bağlantısı daha sonra DataChannel mesajları için kullanılır.</p><p>Ardından, WebRTC ses/video iletimi için SRTP kullanarak güvenli hale getirilmiş RTP protokolünü kullanır. SRTP oturumumuzu, müzakere edilen DTLS oturumundan anahtarları çıkararak başlatırız.</p><p>Medya ve veri iletiminin neden kendi protokollerine sahip olduğunu daha sonraki bir bölümde tartışacağız, ancak şimdilik bunların ayrı ayrı ele alındığını bilmek yeterlidir.</p><p>Şimdi bittik! Başarılı bir şekilde çift yönlü ve güvenli iletişim kurduk. WebRTC aracılarınız arasında kararlı bir bağlantınız varsa, ihtiyacınız olan tüm karmaşıklık budur. Bir sonraki bölümde, WebRTC&rsquo;nin talihsiz gerçek dünya problemleri olan paket kaybı ve bant genişliği sınırları ile nasıl başa çıktığını tartışacağız.</p><h3 id=rtp-ve-sctp-aracılığıyla-eşlerle-iletişim>RTP ve SCTP aracılığıyla eşlerle iletişim
<a class=anchor href=#rtp-ve-sctp-arac%c4%b1l%c4%b1%c4%9f%c4%b1yla-e%c5%9flerle-ileti%c5%9fim>#</a></h3><p>Artık iki WebRTC aracımız bağlandı ve güvenli, çift yönlü iletişim kuruldu, hadi iletişim kurmaya başlayalım! Yine, WebRTC iki önceden var olan protokol kullanacak: RTP (Real-time Transport Protocol) ve SCTP (Stream Control Transmission Protocol). SRTP ile şifrelenmiş medyayı değiş tokuş etmek için RTP kullanır ve DTLS ile şifrelenmiş DataChannel mesajlarını göndermek ve almak için SCTP kullanırız.</p><p>RTP oldukça minimal bir protokoldür, ancak gerçek zamanlı akış uygulamak için gerekli araçları sağlar. RTP hakkında en önemli şey, geliştiriciye esneklik sağlamasıdır ve gecikme, paket kaybı ve tıkanıklığı istedikleri gibi ele almalarına olanak tanır. Bunu medya bölümünde daha ayrıntılı tartışacağız.</p><p>Yığındaki son protokol SCTP&rsquo;dir. SCTP hakkında önemli olan şey, güvenilir ve sıralı mesaj teslimini (birçok farklı seçenek arasında) kapatabilmenizdir. Bu, geliştiricilerin gerçek zamanlı sistemler için gerekli gecikmeyi sağlamalarına olanak tanır.</p><h2 id=webrtc-protokollerin-bir-koleksiyonu>WebRTC, protokollerin bir koleksiyonu
<a class=anchor href=#webrtc-protokollerin-bir-koleksiyonu>#</a></h2><p>WebRTC bir sürü problemi çözer. İlk bakışta teknoloji aşırı mühendislik edilmiş görünebilir, ancak WebRTC&rsquo;nin dehası onun alçakgönüllülüğündedir. Her şeyi daha iyi çözebileceği varsayımı altında yaratılmamıştır. Bunun yerine, birçok mevcut tek amaçlı teknolojiyi kucaklamış ve bunları akıcı, yaygın olarak uygulanabilir bir pakete getirmiştir.</p><p>Bu, her parçayı bunalmadan ayrı ayrı incelememize ve öğrenmemize olanak tanır. Bunu görselleştirmenin iyi bir yolu, bir &lsquo;WebRTC Aracısı&rsquo;nın gerçekten birçok farklı protokolün sadece bir orkestratörü olduğudur.</p><p><img src=../images/01-webrtc-agent.png alt="WebRTC Agent" title="WebRTC Agent Diyagramı"></p><h2 id=webrtc-apisi-nasıl-çalışır>WebRTC API&rsquo;si nasıl çalışır?
<a class=anchor href=#webrtc-apisi-nas%c4%b1l-%c3%a7al%c4%b1%c5%9f%c4%b1r>#</a></h2><p>Bu bölüm, WebRTC JavaScript API&rsquo;sinin yukarıda açıklanan WebRTC protokolüne nasıl eşlendiğini özetler. WebRTC API&rsquo;sinin kapsamlı bir demosu olması amaçlanmamıştır, daha çok her şeyin nasıl bir araya geldiğini gösteren zihinsel bir model oluşturmak içindir.
Protokol veya API&rsquo;ye aşina değilseniz endişelenmeyin. Bu, daha fazla öğrendikçe geri dönmek için eğlenceli bir bölüm olabilir!</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p><code>RTCPeerConnection</code>, üst düzey &ldquo;WebRTC Oturumu"dur. Yukarıda bahsedilen tüm protokolleri içerir. Alt sistemlerin hepsi tahsis edilir ancak henüz hiçbir şey olmaz.</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code> yeni bir RTP akışı oluşturur. Bu akış için rastgele bir Synchronization Source (SSRC) oluşturulacaktır. Bu akış daha sonra <code>createOffer</code> tarafından oluşturulan Session Description içinde bir medya bölümü içinde yer alacaktır. Her <code>addTrack</code> çağrısı yeni bir SSRC ve medya bölümü oluşturacaktır.</p><p>Bir SRTP Oturumu kurulur kurulmaz, bu medya paketleri SRTP kullanılarak şifrelenmeye başlar ve ICE aracılığıyla gönderilir.</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p><code>createDataChannel</code>, SCTP ilişkisi yoksa yeni bir SCTP akışı oluşturur. SCTP varsayılan olarak etkin değildir. Yalnızca bir taraf veri kanalı talep ettiğinde başlatılır.</p><p>Bir DTLS Oturumu kurulur kurulmaz, SCTP ilişkisi DTLS ile şifrelenmiş paketleri ICE aracılığıyla göndermeye başlayacaktır.</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code>, uzak eşle paylaşılacak yerel durumun bir Session Description&rsquo;ını oluşturur.</p><p><code>createOffer</code> çağrısı yerel eş için hiçbir şeyi değiştirmez.</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code>, talep edilen değişiklikleri onaylar. <code>addTrack</code>, <code>createDataChannel</code> ve benzer çağrılar bu çağrıya kadar geçicidir. <code>setLocalDescription</code>, <code>createOffer</code> tarafından oluşturulan değerle çağrılır.</p><p>Genellikle bu çağrıdan sonra, teklifi uzak eşe göndereceksiniz, o da bunu <code>setRemoteDescription</code> çağırmak için kullanacaktır.</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p><code>setRemoteDescription</code>, yerel aracıyı uzak adayların durumu hakkında nasıl bilgilendirdiğimizdir. &lsquo;Sinyalleme&rsquo; eylemi JavaScript API&rsquo;si ile bu şekilde yapılır.</p><p>Her iki tarafta da <code>setRemoteDescription</code> çağrıldığında, WebRTC aracıları artık Eşten-Eşe (P2P) iletişim kurmaya başlamak için yeterli bilgiye sahiptir!</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code>, bir WebRTC aracısının herhangi bir zamanda daha fazla uzak ICE Adayı eklemesine olanak tanır. Bu API, ICE Adayını doğrudan ICE alt sistemine gönderir ve daha büyük WebRTC bağlantısı üzerinde başka bir etkisi yoktur.</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code>, uzak eşten bir RTP paketi alındığında tetiklenen bir callback&rsquo;tir. Gelen paketler, <code>setRemoteDescription</code>&lsquo;a geçirilen Session Description&rsquo;da beyan edilmiş olacaktır.</p><p>WebRTC, SSRC&rsquo;yi kullanır ve ilişkili <code>MediaStream</code> ve <code>MediaStreamTrack</code>&lsquo;i arar ve bu detaylarla doldurulmuş bu callback&rsquo;i tetikler.</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code>, ICE aracısının durumundaki değişikliği yansıtan bir callback&rsquo;tir. Ağ bağlantısında bir değişiklik olduğunda bu şekilde bilgilendirilirsiniz.</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code>, ICE aracısı ve DTLS aracısı durumunun bir kombinasyonudur. ICE ve DTLS&rsquo;nin her ikisi de başarıyla tamamlandığında bilgilendirilmek için bunu izleyebilirsiniz.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/30cec2bd1fa8fc839dca83e8a73daa7afd98de9e title='Son düzenleyen fatihsen-dev | Temmuz 16, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>Temmuz 16, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Bu sayfayı düzenle</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc-nedir>WebRTC Nedir?</a></li><li><a href=#neden-webrtc-öğrenmeliyim>Neden WebRTC öğrenmeliyim?</a></li><li><a href=#webrtc-protokolü-diğer-teknolojilerin-bir-koleksiyonudur>WebRTC Protokolü diğer teknolojilerin bir koleksiyonudur</a><ul><li><a href=#sinyalleme-webrtcde-eşler-birbirlerini-nasıl-bulur>Sinyalleme: WebRTC&rsquo;de eşler birbirlerini nasıl bulur</a></li><li><a href=#stunturn-ile-bağlanma-ve-nat-geçişi>STUN/TURN ile Bağlanma ve NAT Geçişi</a></li><li><a href=#dtls-ve-srtp-ile-aktarım-katmanını-güvenlik-altına-alma>DTLS ve SRTP ile aktarım katmanını güvenlik altına alma</a></li><li><a href=#rtp-ve-sctp-aracılığıyla-eşlerle-iletişim>RTP ve SCTP aracılığıyla eşlerle iletişim</a></li></ul></li><li><a href=#webrtc-protokollerin-bir-koleksiyonu>WebRTC, protokollerin bir koleksiyonu</a></li><li><a href=#webrtc-apisi-nasıl-çalışır>WebRTC API&rsquo;si nasıl çalışır?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>