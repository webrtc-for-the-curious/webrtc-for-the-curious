<!doctype html><html lang=tr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Bağlanma # WebRTC neden bağlanma için özel bir alt sisteme ihtiyaç duyar? # Bugün dağıtılan çoğu uygulama istemci/sunucu bağlantıları kurar. Bir istemci/sunucu bağlantısı, sunucunun kararlı, iyi bilinen bir aktarım adresine sahip olmasını gerektirir. Bir istemci sunucuyla iletişime geçer ve sunucu yanıt verir.
WebRTC bir istemci/sunucu modeli kullanmaz, eşten-eşe (P2P) bağlantılar kurar. P2P bağlantısında, bağlantı oluşturma görevi her iki eşe eşit olarak dağıtılır. Bunun nedeni, WebRTC&rsquo;de bir aktarım adresinin (IP ve port) varsayılamayacak olması ve hatta oturum sırasında değişebilmesidir."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/tr/docs/03-connecting/"><meta property="og:site_name" content="WebRTC Meraklıları İçin"><meta property="og:title" content="Bağlanma"><meta property="og:description" content="Bağlanma # WebRTC neden bağlanma için özel bir alt sisteme ihtiyaç duyar? # Bugün dağıtılan çoğu uygulama istemci/sunucu bağlantıları kurar. Bir istemci/sunucu bağlantısı, sunucunun kararlı, iyi bilinen bir aktarım adresine sahip olmasını gerektirir. Bir istemci sunucuyla iletişime geçer ve sunucu yanıt verir.
WebRTC bir istemci/sunucu modeli kullanmaz, eşten-eşe (P2P) bağlantılar kurar. P2P bağlantısında, bağlantı oluşturma görevi her iki eşe eşit olarak dağıtılır. Bunun nedeni, WebRTC’de bir aktarım adresinin (IP ve port) varsayılamayacak olması ve hatta oturum sırasında değişebilmesidir."><meta property="og:locale" content="tr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-07-16T20:46:44+03:00"><title>Bağlanma | WebRTC Meraklıları İçin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/tr/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/tr.search.min.0e513a3507f051bf655d831577c7dbbf888331f24101f7ab2d356e175710b4d8.js integrity="sha256-DlE6NQfwUb9lXYMVd8fbv4iDMfJBAferLTVuF1cQtNg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/tr/><span>WebRTC Meraklıları İçin</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Arama aria-label=Arama maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Türkçe</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/tr/docs/01-what-why-and-how/>Ne, Neden ve Nasıl</a></li><li><a href=/tr/docs/02-signaling/>Sinyalleşme</a></li><li><a href=/tr/docs/03-connecting/ class=active>Bağlanma</a></li><li><a href=/tr/docs/04-securing/>Güvenlik</a></li><li><a href=/tr/docs/05-real-time-networking/>Gerçek Zamanlı Ağ İletişimi</a></li><li><a href=/tr/docs/06-media-communication/>Medya İletişimi</a></li><li><a href=/tr/docs/07-data-communication/>Veri İletişimi</a></li><li><a href=/tr/docs/08-applied-webrtc/>Uygulamalı WebRTC</a></li><li><a href=/tr/docs/09-debugging/>Hata Ayıklama</a></li><li><a href=/tr/docs/10-history-of-webrtc/>Tarihçe</a></li><li><a href=/tr/docs/11-faq/>SSS</a></li><li><a href=/tr/docs/12-glossary/>Sözlük</a></li><li><a href=/tr/docs/13-reference/>Referans</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Bağlanma</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc-neden-bağlanma-için-özel-bir-alt-sisteme-ihtiyaç-duyar>WebRTC neden bağlanma için özel bir alt sisteme ihtiyaç duyar?</a><ul><li><a href=#azaltılmış-bant-genişliği-maliyetleri>Azaltılmış Bant Genişliği Maliyetleri</a></li><li><a href=#daha-düşük-gecikme>Daha Düşük Gecikme</a></li><li><a href=#güvenli-uçtan-uca-iletişim>Güvenli Uçtan Uca İletişim</a></li></ul></li><li><a href=#nasıl-çalışır>Nasıl çalışır?</a></li><li><a href=#gerçek-dünya-ağ-kısıtlamaları>Gerçek dünya ağ kısıtlamaları</a><ul><li><a href=#aynı-ağda-değil>Aynı ağda değil</a></li><li><a href=#protokol-kısıtlamaları>Protokol Kısıtlamaları</a></li><li><a href=#firewallids-kuralları>Firewall/IDS Kuralları</a></li></ul></li><li><a href=#nat-mapping>NAT Mapping</a><ul><li><a href=#eşleme-oluşturma>Eşleme Oluşturma</a></li><li><a href=#eşleme-oluşturma-davranışları>Eşleme Oluşturma Davranışları</a></li><li><a href=#eşleme-filtreleme-davranışları>Eşleme Filtreleme Davranışları</a></li><li><a href=#eşleme-yenileme>Eşleme Yenileme</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protokol-yapısı>Protokol Yapısı</a></li><li><a href=#nat-eşlemesi-oluşturma>NAT Eşlemesi Oluşturma</a></li><li><a href=#nat-türünü-belirleme>NAT Türünü Belirleme</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-yaşam-döngüsü>TURN Yaşam Döngüsü</a></li><li><a href=#turn-kullanımı>TURN Kullanımı</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#ice-ajanı-oluşturma>ICE Ajanı Oluşturma</a></li><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li><li><a href=#restarts>Restarts</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=bağlanma>Bağlanma
<a class=anchor href=#ba%c4%9flanma>#</a></h1><h2 id=webrtc-neden-bağlanma-için-özel-bir-alt-sisteme-ihtiyaç-duyar>WebRTC neden bağlanma için özel bir alt sisteme ihtiyaç duyar?
<a class=anchor href=#webrtc-neden-ba%c4%9flanma-i%c3%a7in-%c3%b6zel-bir-alt-sisteme-ihtiya%c3%a7-duyar>#</a></h2><p>Bugün dağıtılan çoğu uygulama istemci/sunucu bağlantıları kurar. Bir istemci/sunucu bağlantısı, sunucunun kararlı, iyi bilinen bir aktarım adresine sahip olmasını gerektirir. Bir istemci sunucuyla iletişime geçer ve sunucu yanıt verir.</p><p>WebRTC bir istemci/sunucu modeli kullanmaz, eşten-eşe (P2P) bağlantılar kurar. P2P bağlantısında, bağlantı oluşturma görevi her iki eşe eşit olarak dağıtılır. Bunun nedeni, WebRTC&rsquo;de bir aktarım adresinin (IP ve port) varsayılamayacak olması ve hatta oturum sırasında değişebilmesidir. WebRTC tüm toplayabileceği bilgileri toplayacak ve iki WebRTC Ajanı arasında çift yönlü iletişim sağlamak için büyük çaba gösterecektir.</p><p>Ancak eşten-eşe bağlantı kurmak zor olabilir. Bu ajanlar doğrudan bağlantısı olmayan farklı ağlarda olabilir. Doğrudan bağlantının mevcut olduğu durumlarda bile başka sorunlarınız olabilir. Bazı durumlarda, istemcileriniz aynı ağ protokollerini konuşmaz (UDP &lt;-> TCP) veya belki farklı IP Sürümleri (IPv4 &lt;-> IPv6) kullanır.</p><p>P2P bağlantı kurmada bu zorluklara rağmen, WebRTC&rsquo;nin sunduğu aşağıdaki özellikler nedeniyle geleneksel İstemci/Sunucu teknolojisine göre avantajlar elde edersiniz.</p><h3 id=azaltılmış-bant-genişliği-maliyetleri>Azaltılmış Bant Genişliği Maliyetleri
<a class=anchor href=#azalt%c4%b1lm%c4%b1%c5%9f-bant-geni%c5%9fli%c4%9fi-maliyetleri>#</a></h3><p>Medya iletişimi doğrudan eşler arasında gerçekleştiği için medyayı aktarmak için ayrı bir sunucu için ödeme yapmanız veya barındırmanız gerekmez.</p><h3 id=daha-düşük-gecikme>Daha Düşük Gecikme
<a class=anchor href=#daha-d%c3%bc%c5%9f%c3%bck-gecikme>#</a></h3><p>İletişim doğrudan olduğunda daha hızlıdır! Bir kullanıcı her şeyi sunucunuzdan geçirmek zorunda kaldığında, aktarımları yavaşlatır.</p><h3 id=güvenli-uçtan-uca-iletişim>Güvenli Uçtan Uca İletişim
<a class=anchor href=#g%c3%bcvenli-u%c3%a7tan-uca-ileti%c5%9fim>#</a></h3><p>Doğrudan İletişim daha güvenlidir. Kullanıcılar verileri sunucunuzdan yönlendirmediği için, şifresini çözmeyeceğinize güvenmeleri bile gerekmez.</p><h2 id=nasıl-çalışır>Nasıl çalışır?
<a class=anchor href=#nas%c4%b1l-%c3%a7al%c4%b1%c5%9f%c4%b1r>#</a></h2><p>Yukarıda açıklanan işleme Etkileşimli Bağlantı Kurma (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>) denir. WebRTC&rsquo;den önce var olan başka bir protokol.</p><p>ICE, iki ICE Ajanı arasında iletişim kurmanın en iyi yolunu bulmaya çalışan bir protokoldür. Her ICE Ajanı ulaşılabilir olduğu yolları yayınlar, bunlar adaylar olarak bilinir. Bir aday, esasen ajanın diğer eşin ulaşabileceğine inandığı aktarım adresidir. ICE daha sonra adayların en iyi eşleşmesini belirler.</p><p>Gerçek ICE süreci bu bölümün ilerleyen kısımlarında daha ayrıntılı olarak açıklanmıştır. ICE&rsquo;nin neden var olduğunu anlamak için, hangi ağ davranışlarını aştığımızı anlamak yararlıdır.</p><h2 id=gerçek-dünya-ağ-kısıtlamaları>Gerçek dünya ağ kısıtlamaları
<a class=anchor href=#ger%c3%a7ek-d%c3%bcnya-a%c4%9f-k%c4%b1s%c4%b1tlamalar%c4%b1>#</a></h2><p>ICE tamamen gerçek dünya ağlarının kısıtlamalarını aşmakla ilgilidir. Çözümü keşfetmeden önce, gerçek problemleri konuşalım.</p><h3 id=aynı-ağda-değil>Aynı ağda değil
<a class=anchor href=#ayn%c4%b1-a%c4%9fda-de%c4%9fil>#</a></h3><p>Çoğu zaman diğer WebRTC Ajanı aynı ağda bile olmayacaktır. Tipik bir çağrı genellikle doğrudan bağlantısı olmayan farklı ağlardaki iki WebRTC Ajanı arasındadır.</p><p>Aşağıda genel internet üzerinden bağlanan iki farklı ağın grafiği bulunmaktadır. Her ağda iki host bulunmaktadır.</p><p>Aynı ağdaki hostlar için bağlantı kurmak çok kolaydır. <code>192.168.0.1 -> 192.168.0.2</code> arasındaki iletişim kolay yapılabilir! Bu iki host herhangi bir dış yardım olmadan birbirine bağlanabilir.</p><p>Ancak, <code>Router B</code> kullanan bir host&rsquo;un <code>Router A</code>&lsquo;nın arkasındaki hiçbir şeye doğrudan erişim yolu yoktur. <code>Router A</code>&lsquo;nın arkasındaki <code>192.168.0.1</code> ile <code>Router B</code>&lsquo;nin arkasındaki aynı IP arasındaki farkı nasıl anlarsınız? Bunlar özel IP&rsquo;lerdir! <code>Router B</code> kullanan bir host doğrudan <code>Router A</code>&lsquo;ya trafik gönderebilir, ancak istek orada sonlanır. <code>Router A</code> mesajı hangi host&rsquo;a yönlendirmesi gerektiğini nasıl bilir?</p><h3 id=protokol-kısıtlamaları>Protokol Kısıtlamaları
<a class=anchor href=#protokol-k%c4%b1s%c4%b1tlamalar%c4%b1>#</a></h3><p>Bazı ağlar UDP trafiğine hiç izin vermez, belki de TCP&rsquo;ye izin vermezler. Bazı ağlarda çok düşük MTU (Maksimum İletim Birimi) olabilir. Ağ yöneticilerinin değiştirebileceği ve iletişimi zorlaştırabilecek birçok değişken vardır.</p><h3 id=firewallids-kuralları>Firewall/IDS Kuralları
<a class=anchor href=#firewallids-kurallar%c4%b1>#</a></h3><p>Bir diğeri &ldquo;Derin Paket İncelemesi&rdquo; ve diğer akıllı filtrelemelerdir. Bazı ağ yöneticileri her paketi işlemeye çalışan yazılım çalıştırır. Çoğu zaman bu yazılım WebRTC&rsquo;yi anlamaz, bu yüzden ne yapacağını bilmediği için onu bloklar, örneğin WebRTC paketlerini beyaz listede olmayan rastgele bir port üzerindeki şüpheli UDP paketleri olarak değerlendirir.</p><h2 id=nat-mapping>NAT Mapping
<a class=anchor href=#nat-mapping>#</a></h2><p>NAT (Ağ Adresi Çevirisi) eşlemesi WebRTC&rsquo;nin bağlantısını mümkün kılan sihirdir. WebRTC&rsquo;nin tamamen farklı alt ağlardaki iki eşin iletişim kurmasına nasıl izin verdiği, yukarıdaki &ldquo;aynı ağda değil&rdquo; problemini ele aldığı budur. Yeni zorluklar yaratsa da, NAT eşlemesinin ilk etapta nasıl çalıştığını açıklayalım.</p><p>Relay, proxy veya sunucu kullanmaz. Yine <code>Ajan 1</code> ve <code>Ajan 2</code>&lsquo;miz var ve farklı ağlardalar. Ancak, trafik tamamen akıyor. Görselleştirildiğinde şöyle görünür:</p><p><img src=../images/03-nat-mapping.png alt="NAT mapping" title="NAT mapping"></p><p>Bu iletişimi gerçekleştirmek için bir NAT eşlemesi kurarsınız. Ajan 1, Ajan 2 ile WebRTC bağlantısı kurmak için port 7000&rsquo;i kullanır. Bu, <code>192.168.0.1:7000</code>&lsquo;i <code>5.0.0.1:7000</code>&lsquo;e bağlama oluşturur. Bu daha sonra Ajan 2&rsquo;nin <code>5.0.0.1:7000</code>&lsquo;e paketler göndererek Ajan 1&rsquo;e ulaşmasına izin verir. Bu örnekteki gibi NAT eşlemesi oluşturmak, router&rsquo;ınızda port yönlendirme yapmanın otomatik versiyonu gibidir.</p><p>NAT eşlemesinin dezavantajı, tek bir eşleme formu olmaması (örneğin statik port yönlendirme) ve davranışın ağlar arasında tutarsız olmasıdır. ISP&rsquo;ler ve donanım üreticileri bunu farklı şekillerde yapabilir. Bazı durumlarda, ağ yöneticileri bunu devre dışı bile bırakabilir.</p><p>İyi haber, davranış aralığının tam olarak anlaşılması ve gözlemlenebilir olmasıdır, bu yüzden bir ICE Ajanı bir NAT eşlemesi oluşturduğunu ve eşlemenin özelliklerini doğrulayabilir.</p><p>Bu davranışları açıklayan belge <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>&lsquo;dir.</p><h3 id=eşleme-oluşturma>Eşleme Oluşturma
<a class=anchor href=#e%c5%9fleme-olu%c5%9fturma>#</a></h3><p>Eşleme oluşturmak en kolay kısımdır. Ağınızın dışındaki bir adrese paket gönderdiğinizde, bir eşleme oluşturulur! NAT eşlemesi, NAT&rsquo;ınız tarafından tahsis edilen sadece geçici bir genel IP ve port&rsquo;tur. Giden mesaj, kaynak adresinin yeni eşleme adresi tarafından verilmesi için yeniden yazılacaktır. Eşlemeye bir mesaj gönderilirse, onu oluşturan NAT içindeki host&rsquo;a otomatik olarak geri yönlendirilecektir. Eşlemeler etrafındaki ayrıntılar karmaşık hale geldiği yerdir.</p><h3 id=eşleme-oluşturma-davranışları>Eşleme Oluşturma Davranışları
<a class=anchor href=#e%c5%9fleme-olu%c5%9fturma-davran%c4%b1%c5%9flar%c4%b1>#</a></h3><p>Eşleme oluşturma üç farklı kategoriye ayrılır:</p><h4 id=endpoint-independent-mapping>Endpoint-Independent Mapping
<a class=anchor href=#endpoint-independent-mapping>#</a></h4><p>NAT içindeki her gönderen için bir eşleme oluşturulur. İki farklı uzak adrese iki paket gönderirseniz, NAT eşlemesi yeniden kullanılacaktır. Her iki uzak host da aynı kaynak IP ve port&rsquo;u görecektir. Uzak hostlar yanıt verirlerse, aynı yerel dinleyiciye geri gönderilecektir.</p><p>Bu en iyi durum senaryosudur. Bir çağrının çalışması için en az bir tarafın bu türde olması GEREKİR.</p><h4 id=address-dependent-mapping>Address Dependent Mapping
<a class=anchor href=#address-dependent-mapping>#</a></h4><p>Yeni bir adrese paket gönderdiğiniz her seferde yeni bir eşleme oluşturulur. İki farklı host&rsquo;a iki paket gönderirseniz, iki eşleme oluşturulacaktır. Aynı uzak host&rsquo;a ancak farklı hedef portlara iki paket gönderirseniz, yeni bir eşleme oluşturulmayacaktır.</p><h4 id=address-and-port-dependent-mapping>Address and Port Dependent Mapping
<a class=anchor href=#address-and-port-dependent-mapping>#</a></h4><p>Uzak IP veya port farklıysa yeni bir eşleme oluşturulur. Aynı uzak host&rsquo;a ancak farklı hedef portlara iki paket gönderirseniz, yeni bir eşleme oluşturulacaktır.</p><h3 id=eşleme-filtreleme-davranışları>Eşleme Filtreleme Davranışları
<a class=anchor href=#e%c5%9fleme-filtreleme-davran%c4%b1%c5%9flar%c4%b1>#</a></h3><p>Eşleme filtreleme, eşlemeyi kimlerin kullanmasına izin verildiği etrafındaki kurallardır. Benzer üç sınıflandırmaya ayrılırlar:</p><h4 id=endpoint-independent-filtering>Endpoint-Independent Filtering
<a class=anchor href=#endpoint-independent-filtering>#</a></h4><p>Herkes eşlemeyi kullanabilir. Eşlemeyi birden fazla diğer eşle paylaşabilirsiniz ve hepsi ona trafik gönderebilir.</p><h4 id=address-dependent-filtering>Address Dependent Filtering
<a class=anchor href=#address-dependent-filtering>#</a></h4><p>Sadece eşlemenin oluşturulduğu host eşlemeyi kullanabilir. <code>A</code> host&rsquo;una bir paket gönderirseniz sadece aynı host&rsquo;tan yanıt alabilirsiniz. <code>B</code> host&rsquo;u o eşlemeye paket göndermeye çalışırsa, görmezden gelinecektir.</p><h4 id=address-and-port-dependent-filtering>Address and Port Dependent Filtering
<a class=anchor href=#address-and-port-dependent-filtering>#</a></h4><p>Sadece eşlemenin oluşturulduğu host ve port o eşlemeyi kullanabilir. <code>A:5000</code>&lsquo;e bir paket gönderirseniz sadece aynı host ve port&rsquo;tan yanıt alabilirsiniz. <code>A:5001</code> o eşlemeye paket göndermeye çalışırsa, görmezden gelinecektir.</p><h3 id=eşleme-yenileme>Eşleme Yenileme
<a class=anchor href=#e%c5%9fleme-yenileme>#</a></h3><p>Bir eşleme 5 dakika kullanılmazsa yok edilmesi önerilir. Bu tamamen ISP veya donanım üreticisine bağlıdır.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (NAT için Oturum Geçiş Yardımcı Programları) sadece NAT&rsquo;larla çalışmak için oluşturulmuş bir protokoldür. Bu, WebRTC&rsquo;den (ve ICE&rsquo;den!) önce var olan başka bir teknolojidir. <a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a> tarafından tanımlanır, bu aynı zamanda STUN paket yapısını da tanımlar. STUN protokolü ayrıca ICE/TURN tarafından da kullanılır.</p><p>STUN, NAT Eşlemelerinin programatik olarak oluşturulmasına izin verdiği için yararlıdır. STUN&rsquo;dan önce, bir NAT eşlemesi oluşturabiliyorduk, ancak bunun IP ve port&rsquo;unun ne olduğu hakkında hiçbir fikrimiz yoktu! STUN size sadece eşleme oluşturma yeteneği vermekle kalmaz, aynı zamanda başkalarıyla paylaşabilmeniz için ayrıntıları da verir, böylece az önce oluşturduğunuz eşleme aracılığıyla size trafik geri gönderebilirler.</p><p>STUN&rsquo;un temel bir açıklamasıyla başlayalım. Daha sonra, TURN ve ICE kullanımını genişleteceğiz. Şimdilik, sadece eşleme oluşturmak için İstek/Yanıt akışını açıklayacağız. Sonra başkalarıyla paylaşmak için ayrıntılarını nasıl alacağımızı konuşacağız. Bu, WebRTC PeerConnection için ICE URL&rsquo;lerinizde bir <code>stun:</code> sunucunuz olduğunda gerçekleşen işlemdir. Özetle, STUN bir NAT arkasındaki endpoint&rsquo;in NAT dışındaki bir STUN sunucusundan gözlemlediğini rapor etmesini isteyerek hangi eşlemenin oluşturulduğunu anlamasına yardımcı olur.</p><h3 id=protokol-yapısı>Protokol Yapısı
<a class=anchor href=#protokol-yap%c4%b1s%c4%b1>#</a></h3><p>Her STUN paketi aşağıdaki yapıya sahiptir:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-message-type>STUN Message Type
<a class=anchor href=#stun-message-type>#</a></h4><p>Her STUN paketinin bir türü vardır. Şimdilik, sadece aşağıdakilerle ilgileniyoruz:</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><p>NAT eşlemesi oluşturmak için bir <code>Binding Request</code> yaparız. Sonra sunucu <code>Binding Response</code> ile yanıt verir.</p><h4 id=message-length>Message Length
<a class=anchor href=#message-length>#</a></h4><p>Bu, <code>Data</code> bölümünün ne kadar uzun olduğudur. Bu bölüm <code>Message Type</code> tarafından tanımlanan rastgele veriler içerir.</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>Ağ byte sırasında sabit değer <code>0x2112A442</code>, STUN trafiğini diğer protokollerden ayırt etmeye yardımcı olur.</p><h4 id=transaction-id>Transaction ID
<a class=anchor href=#transaction-id>#</a></h4><p>Bir istek/yanıtı benzersiz şekilde tanımlayan 96-bit tanımlayıcı. Bu, isteklerinizi ve yanıtlarınızı eşleştirmenize yardımcı olur.</p><h4 id=data>Data
<a class=anchor href=#data>#</a></h4><p>Data bir STUN öznitelikleri listesi içerecektir. Bir STUN Özniteliği aşağıdaki yapıya sahiptir:</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><code>STUN Binding Request</code> hiçbir öznitelik kullanmaz. Bu, <code>STUN Binding Request</code>&lsquo;in sadece başlığı içerdiği anlamına gelir.</p><p><code>STUN Binding Response</code> bir <code>XOR-MAPPED-ADDRESS (0x0020)</code> kullanır. Bu öznitelik bir IP ve port içerir. Bu, oluşturulan NAT eşlemesinin IP ve port&rsquo;udur!</p><h3 id=nat-eşlemesi-oluşturma>NAT Eşlemesi Oluşturma
<a class=anchor href=#nat-e%c5%9flemesi-olu%c5%9fturma>#</a></h3><p>STUN kullanarak NAT eşlemesi oluşturmak sadece bir istek göndermeyi gerektirir! STUN Sunucusuna bir <code>STUN Binding Request</code> gönderirsiniz. STUN Sunucusu daha sonra <code>STUN Binding Response</code> ile yanıt verir.
Bu <code>STUN Binding Response</code> <code>Mapped Address</code> içerecektir. <code>Mapped Address</code>, STUN Sunucusunun sizi nasıl gördüğüdür ve sizin <code>NAT eşlemenizdir</code>.
<code>Mapped Address</code>, birinin size paketler göndermesini istiyorsanız paylaşacağınız şeydir.</p><p>İnsanlar <code>Mapped Address</code>&lsquo;i aynı zamanda sizin <code>Public IP</code>&lsquo;niz veya <code>Server Reflexive Candidate</code>&lsquo;ınız olarak da adlandırırlar.</p><h3 id=nat-türünü-belirleme>NAT Türünü Belirleme
<a class=anchor href=#nat-t%c3%bcr%c3%bcn%c3%bc-belirleme>#</a></h3><p>Ne yazık ki, <code>Mapped Address</code> tüm durumlarda yararlı olmayabilir. <code>Address Dependent</code> ise, sadece STUN sunucusu size geri trafik gönderebilir. Bunu paylaştıysanız ve başka bir eş mesaj göndermeye çalıştıysa, düşürüleceklerdir. Bu, başkalarıyla iletişim kurmak için işe yaramaz hale getirir. <code>Address Dependent</code> durumunun aslında çözülebilir olduğunu görebilirsiniz, eğer STUN sunucusunu çalıştıran host aynı zamanda sizin için paketleri eşe yönlendirebiliyorsa! Bu bizi aşağıda TURN kullanarak çözüme götürür.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a> NAT Türünüzü belirlemek için bir test çalıştırma yöntemi tanımlar. Bu yararlıdır çünkü doğrudan bağlantının mümkün olup olmadığını önceden bilirsiniz.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (NAT etrafında Relay&rsquo;ler Kullanarak Geçiş) <a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a>&lsquo;da tanımlanır ve doğrudan bağlantının mümkün olmadığı durumlarda çözümdür. Bu, uyumsuz iki NAT Türünüz olması veya belki aynı protokolü konuşamıyor olmanız nedeniyle olabilir! TURN ayrıca gizlilik amaçları için de kullanılabilir. Tüm iletişiminizi TURN üzerinden çalıştırarak istemcinin gerçek adresini gizlersiniz.</p><p>TURN özel bir sunucu kullanır. Bu sunucu bir istemci için proxy görevi görür. İstemci bir TURN Sunucusuna bağlanır ve bir <code>Allocation</code> oluşturur. Allocation oluşturarak, istemci istemciye geri trafik göndermek için kullanılabilecek geçici bir IP/Port/Protokol alır. Bu yeni dinleyici <code>Relayed Transport Address</code> olarak bilinir. Bunu yönlendirme adresi olarak düşünün, başkalarının TURN üzerinden size trafik gönderebilmesi için bunu dağıtırsınız! <code>Relay Transport Address</code>&lsquo;i verdiğiniz her eş için, sizinle iletişime izin vermek için yeni bir <code>Permission</code> oluşturmalısınız.</p><p>TURN üzerinden giden trafiği gönderdiğinizde, <code>Relayed Transport Address</code> üzerinden gönderilir. Uzak bir eş trafik aldığında, TURN Sunucusundan geldiğini görür.</p><h3 id=turn-yaşam-döngüsü>TURN Yaşam Döngüsü
<a class=anchor href=#turn-ya%c5%9fam-d%c3%b6ng%c3%bcs%c3%bc>#</a></h3><p>Aşağıda TURN allocation oluşturmak isteyen bir istemcinin yapması gereken her şey bulunmaktadır. TURN kullanan biriyle iletişim kurmak hiçbir değişiklik gerektirmez. Diğer eş bir IP ve port alır ve herhangi bir diğer host gibi onunla iletişim kurar.</p><h4 id=allocations>Allocations
<a class=anchor href=#allocations>#</a></h4><p>Allocation&rsquo;lar TURN&rsquo;ün kalbindedir. Bir <code>allocation</code> temel olarak bir &ldquo;TURN Oturumu"dur. TURN allocation oluşturmak için TURN <code>Server Transport Address</code> (genellikle port <code>3478</code>) ile iletişim kurarsınız.</p><p>Allocation oluştururken, aşağıdakileri sağlamanız gerekir:</p><ul><li>Kullanıcı Adı/Şifre - TURN allocation&rsquo;ları oluşturmak kimlik doğrulaması gerektirir.</li><li>Allocation Transport - Sunucu (<code>Relayed Transport Address</code>) ve eşler arasındaki aktarım protokolü, UDP veya TCP olabilir.</li><li>Even-Port - Birden fazla allocation için ardışık portlar isteyebilirsiniz, WebRTC için ilgili değil.</li></ul><p>İstek başarılı olursa, Data bölümünde aşağıdaki STUN Öznitelikleri ile TURN Sunucusundan bir yanıt alırsınız:</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>TURN Client</code>&lsquo;ın <code>Mapped Address</code>&lsquo;i. Birisi <code>Relayed Transport Address</code>&lsquo;e veri gönderdiğinde, buraya yönlendirilir.</li><li><code>RELAYED-ADDRESS</code> - Bu, diğer istemcilere verdiğiniz adrestir. Birisi bu adrese bir paket gönderirse, TURN istemcisine aktarılır.</li><li><code>LIFETIME</code> - Bu TURN Allocation&rsquo;ın ne kadar süre sonra yok edildiği. <code>Refresh</code> isteği göndererek yaşam süresini uzatabilirsiniz.</li></ul><h4 id=permissions>Permissions
<a class=anchor href=#permissions>#</a></h4><p>Uzak bir host, onlar için bir permission oluşturana kadar <code>Relayed Transport Address</code>&lsquo;inize gönderemez. Permission oluşturduğunuzda, TURN sunucusuna bu IP ve port&rsquo;un gelen trafiği göndermeye izinli olduğunu söylüyorsunuz.</p><p>Uzak host&rsquo;un size TURN sunucusuna göründüğü şekliyle IP ve port&rsquo;u vermesi gerekir. Bu, TURN Sunucusuna bir <code>STUN Binding Request</code> göndermesi gerektiği anlamına gelir. Yaygın bir hata durumu, uzak host&rsquo;un farklı bir sunucuya <code>STUN Binding Request</code> göndermesidir. Daha sonra sizden bu IP için permission oluşturmanızı isteyeceklerdir.</p><p>Diyelim ki <code>Address Dependent Mapping</code> arkasındaki bir host için permission oluşturmak istiyorsunuz. Farklı bir TURN sunucusundan <code>Mapped Address</code> üretirseniz, tüm gelen trafik düşürülecektir. Farklı bir host ile her iletişim kurduklarında yeni bir eşleme oluşturur. Permission&rsquo;lar yenilenmezlerse 5 dakika sonra sona erer.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>Bu iki mesaj TURN Client&rsquo;ın uzak bir eşe mesaj göndermesi içindir.</p><p>SendIndication bağımsız bir mesajdır. İçinde göndermek istediğiniz veri ve kime göndermek istediğiniz vardır. Uzak bir eşe çok sayıda mesaj gönderiyorsanız bu savurgan olur. 1.000 mesaj gönderirseniz IP Adreslerini 1.000 kez tekrar edeceksiniz!</p><p>ChannelData veri göndermenize izin verir, ancak IP Adresini tekrar etmez. Bir IP ve port ile Channel oluşturursunuz. Daha sonra ChannelId ile gönderirsiniz ve IP ve port sunucu tarafında doldurulacaktır. Çok sayıda mesaj gönderiyorsanız bu daha iyi seçimdir.</p><h4 id=refreshing>Refreshing
<a class=anchor href=#refreshing>#</a></h4><p>Allocation&rsquo;lar kendilerini otomatik olarak yok ederler. TURN Client bunları allocation oluştururken verilen <code>LIFETIME</code>&lsquo;dan daha önce yenilemelidir.</p><h3 id=turn-kullanımı>TURN Kullanımı
<a class=anchor href=#turn-kullan%c4%b1m%c4%b1>#</a></h3><p>TURN Kullanımı iki formda var olur. Genellikle, bir eşiniz &ldquo;TURN Client&rdquo; görevi görür ve diğer taraf doğrudan iletişim kurar. Bazı durumlarda her iki tarafta da TURN kullanımınız olabilir, örneğin her iki istemci de UDP&rsquo;yi bloke eden ağlarda olduğu ve bu nedenle ilgili TURN sunucularına bağlantı TCP üzerinden gerçekleştiği için.</p><p>Bu diyagramlar bunun nasıl görüneceğini açıklamaya yardımcı olur.</p><h4 id=iletişim-için-bir-turn-allocation>İletişim için Bir TURN Allocation
<a class=anchor href=#ileti%c5%9fim-i%c3%a7in-bir-turn-allocation>#</a></h4><p><img src=../images/03-one-turn-allocation.png alt="One TURN allocation" title="One TURN allocation"></p><h4 id=iletişim-için-iki-turn-allocation>İletişim için İki TURN Allocation
<a class=anchor href=#ileti%c5%9fim-i%c3%a7in-iki-turn-allocation>#</a></h4><p><img src=../images/03-two-turn-allocations.png alt="Two TURN allocations" title="Two TURN allocations"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Etkileşimli Bağlantı Kurma) WebRTC&rsquo;nin iki Ajanı nasıl bağladığıdır. <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>&rsquo;te tanımlanır, bu WebRTC&rsquo;den önce var olan başka bir teknolojidir! ICE bağlantı kurmak için bir protokoldür. İki eş arasındaki tüm olası yolları belirler ve sonra bağlı kaldığınızı garanti eder.</p><p>Bu yollar <code>Candidate Pairs</code> olarak bilinir, bu yerel ve uzak aktarım adresinin eşleştirilmesidir. STUN ve TURN&rsquo;ün ICE ile devreye girdiği yer burasıdır. Bu adresler yerel IP Adresiniz artı port, <code>NAT mapping</code> veya <code>Relayed Transport Address</code> olabilir. Her taraf kullanmak istedikleri tüm adresleri toplar, bunları değiş tokuş eder ve sonra bağlanmaya çalışır!</p><p>İki ICE Ajanı bağlantı kurmak için ICE ping paketleri (veya resmi olarak connectivity checks adı verilen) kullanarak iletişim kurar. Bağlantı kurulduktan sonra, istedikleri herhangi bir veriyi gönderebilirler. Normal socket kullanmak gibi olacaktır. Bu kontroller STUN protokolünü kullanır.</p><h3 id=ice-ajanı-oluşturma>ICE Ajanı Oluşturma
<a class=anchor href=#ice-ajan%c4%b1-olu%c5%9fturma>#</a></h3><p>Bir ICE Ajanı ya <code>Controlling</code> ya da <code>Controlled</code>&lsquo;dır. <code>Controlling</code> Ajanı seçilen <code>Candidate Pair</code>&lsquo;i belirleyen ajandır. Genellikle, teklifi gönderen eş controlling taraftır.</p><p>Her tarafın bir <code>user fragment</code> ve <code>password</code>&lsquo;ü olmalıdır. Bu iki değer connectivity check&rsquo;ler başlamadan önce değiş tokuş edilmelidir. <code>user fragment</code> düz metin olarak gönderilir ve birden fazla ICE Oturumunu demux etmek için yararlıdır.
<code>password</code> bir <code>MESSAGE-INTEGRITY</code> özniteliği oluşturmak için kullanılır. Her STUN paketinin sonunda, <code>password</code>&lsquo;ü anahtar olarak kullanan tüm paketin hash&rsquo;i olan bir öznitelik vardır. Bu paketi doğrulamak ve kurcalanmadığından emin olmak için kullanılır.</p><p>WebRTC için, tüm bu değerler önceki bölümde açıklandığı gibi <code>Session Description</code> aracılığıyla dağıtılır.</p><h3 id=candidate-gathering>Candidate Gathering
<a class=anchor href=#candidate-gathering>#</a></h3><p>Şimdi ulaşılabilir olduğumuz tüm olası adresleri toplamamız gerekiyor. Bu adresler candidate olarak bilinir.</p><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><p>Host candidate doğrudan yerel arayüzde dinler. Bu UDP veya TCP olabilir.</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>mDNS candidate host candidate&rsquo;e benzer, ancak IP adresi gizlenir. Diğer tarafa IP adresinizi bildirmek yerine, hostname olarak onlara bir UUID verirsiniz. Daha sonra multicast dinleyici kurarsınız ve yayınladığınız UUID&rsquo;yi isteyen olursa yanıt verirsiniz.</p><p>Ajan ile aynı ağdaysanız, Multicast aracılığıyla birbirinizi bulabilirsiniz. Aynı ağda değilseniz, bağlanamayacaksınız (ağ yöneticisi ağı Multicast paketlerinin geçişine izin verecek şekilde açıkça yapılandırmadıkça).</p><p>Bu gizlilik amacıyla yararlıdır. Bir kullanıcı Host candidate ile WebRTC aracılığıyla yerel IP adresinizi öğrenebilir (size bağlanmaya çalışmadan bile), ancak mDNS candidate ile şimdi sadece rastgele bir UUID alırlar.</p><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><p>Server Reflexive candidate, STUN Sunucusuna <code>STUN Binding Request</code> yaparak oluşturulur.</p><p><code>STUN Binding Response</code> aldığınızda, <code>XOR-MAPPED-ADDRESS</code> sizin Server Reflexive Candidate&rsquo;ınızdır.</p><h4 id=peer-reflexive>Peer Reflexive
<a class=anchor href=#peer-reflexive>#</a></h4><p>Peer Reflexive candidate, uzak eş isteğinizi daha önce eşe bilinmeyen bir adresten aldığında oluşturulur. Alındığında, eş söz konusu adresi size geri bildirir (yansıtır). Eş isteğin sizin tarafınızdan gönderildiğini ve başka biri tarafından gönderilmediğini bilir çünkü ICE kimlik doğrulamalı bir protokoldür.</p><p>Bu yaygın olarak bir <code>Host Candidate</code>&lsquo;in farklı alt ağda olan <code>Server Reflexive Candidate</code> ile iletişim kurması durumunda gerçekleşir ve bu yeni bir <code>NAT mapping</code> oluşturulmasına neden olur. Connectivity check&rsquo;lerin aslında STUN paketleri olduğunu söylediğimizi hatırlayın? STUN yanıtının formatı doğal olarak eşin peer-reflexive adresi geri bildirmesine izin verir.</p><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><p>Relay Candidate, TURN Sunucusu kullanarak oluşturulur.</p><p>TURN Sunucusu ile ilk handshake&rsquo;den sonra size bir <code>RELAYED-ADDRESS</code> verilir, bu sizin Relay Candidate&rsquo;ınızdır.</p><h3 id=connectivity-checks>Connectivity Checks
<a class=anchor href=#connectivity-checks>#</a></h3><p>Şimdi uzak ajanın <code>user fragment</code>, <code>password</code> ve candidate&rsquo;larını biliyoruz. Artık bağlanmaya çalışabiliriz! Her candidate birbiriyle eşleştirilir. Her tarafta 3 candidate&rsquo;ınız varsa, şimdi 9 candidate çiftiniz vardır.</p><p>Görsel olarak şöyle görünür:</p><p><img src=../images/03-connectivity-checks.png alt="Connectivity checks" title="Connectivity checks"></p><h3 id=candidate-selection>Candidate Selection
<a class=anchor href=#candidate-selection>#</a></h3><p>Controlling ve Controlled Agent&rsquo;lar her çift üzerinde trafik göndermeye başlar. Bu, bir Ajanın <code>Address Dependent Mapping</code> arkasında olması durumunda gereklidir, bu <code>Peer Reflexive Candidate</code> oluşturulmasına neden olacaktır.</p><p>Ağ trafiği gören her <code>Candidate Pair</code> daha sonra <code>Valid Candidate</code> çiftine terfi edilir. Controlling Agent daha sonra bir <code>Valid Candidate</code> çiftini alır ve onu aday gösterir. Bu <code>Nominated Pair</code> olur. Controlling ve Controlled Agent daha sonra bir tur daha çift yönlü iletişim denemeye çalışır. Bu başarılı olursa, <code>Nominated Pair</code> <code>Selected Candidate Pair</code> olur! Bu çift daha sonra oturumun geri kalanı için kullanılır.</p><h3 id=restarts>Restarts
<a class=anchor href=#restarts>#</a></h3><p><code>Selected Candidate Pair</code> herhangi bir nedenle çalışmayı durdurursa (NAT mapping süresi dolar, TURN Sunucusu çöker) ICE Ajanı <code>Failed</code> durumuna geçer. Her iki ajan da yeniden başlatılabilir ve tüm süreci baştan yapacaktır.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/30cec2bd1fa8fc839dca83e8a73daa7afd98de9e title='Son düzenleyen fatihsen-dev | Temmuz 16, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>Temmuz 16, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Bu sayfayı düzenle</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc-neden-bağlanma-için-özel-bir-alt-sisteme-ihtiyaç-duyar>WebRTC neden bağlanma için özel bir alt sisteme ihtiyaç duyar?</a><ul><li><a href=#azaltılmış-bant-genişliği-maliyetleri>Azaltılmış Bant Genişliği Maliyetleri</a></li><li><a href=#daha-düşük-gecikme>Daha Düşük Gecikme</a></li><li><a href=#güvenli-uçtan-uca-iletişim>Güvenli Uçtan Uca İletişim</a></li></ul></li><li><a href=#nasıl-çalışır>Nasıl çalışır?</a></li><li><a href=#gerçek-dünya-ağ-kısıtlamaları>Gerçek dünya ağ kısıtlamaları</a><ul><li><a href=#aynı-ağda-değil>Aynı ağda değil</a></li><li><a href=#protokol-kısıtlamaları>Protokol Kısıtlamaları</a></li><li><a href=#firewallids-kuralları>Firewall/IDS Kuralları</a></li></ul></li><li><a href=#nat-mapping>NAT Mapping</a><ul><li><a href=#eşleme-oluşturma>Eşleme Oluşturma</a></li><li><a href=#eşleme-oluşturma-davranışları>Eşleme Oluşturma Davranışları</a></li><li><a href=#eşleme-filtreleme-davranışları>Eşleme Filtreleme Davranışları</a></li><li><a href=#eşleme-yenileme>Eşleme Yenileme</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protokol-yapısı>Protokol Yapısı</a></li><li><a href=#nat-eşlemesi-oluşturma>NAT Eşlemesi Oluşturma</a></li><li><a href=#nat-türünü-belirleme>NAT Türünü Belirleme</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-yaşam-döngüsü>TURN Yaşam Döngüsü</a></li><li><a href=#turn-kullanımı>TURN Kullanımı</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#ice-ajanı-oluşturma>ICE Ajanı Oluşturma</a></li><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li><li><a href=#restarts>Restarts</a></li></ul></li></ul></nav></div></aside></main></body></html>