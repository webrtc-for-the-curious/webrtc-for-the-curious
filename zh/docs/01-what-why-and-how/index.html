<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="是什么，为什么，如何使用 #  WebRTC是什么？ #  WebRTC是Web实时通信（Real-Time Communication）的缩写，它既是API也是协议。WebRTC协议是两个WebRTC Agent协商双向安全实时通信的一组规则。开发人员可以通过WebRTC API使用WebRTC协议。目前WebRTC API仅有JavaScript版本。
可以用HTTP和Fetch API之间的关系作为类比。WebRTC协议就是HTTP，而WebRTC API就是Fetch API。
除了JavaScript语言，WebRTC协议也可以在其他API和语言中使用。你还可以找到WebRTC的服务器和特定领域的工具。所有这些实现都使用WebRTC协议，以便它们可以彼此交互。
WebRTC协议由IETF工作组在rtcweb中维护。WebRTC API的W3C文档在webrtc。
为什么我应该学习WebRTC？ #  下面这些是WebRTC可以带给你的东西。这并不是一份详尽的清单，只是列举一些你在学习中可能感兴趣的点。如果你还不了解所有这些术语，请不要担心，本书将陆续将这些概念教给你。
 开放标准 多种实现 在浏览器中可用 强制加密 NAT穿透 复用现有技术 拥塞控制 亚秒级延迟  WebRTC协议是一组其他技术的集合体 #  这个主题需要整本书来解释。但是，首先，我们将其分为四个步骤。
 信令（Signaling） 连接（Connecting） 安全加密（Securing） 通信（Communicating）  这四个步骤依次发生。上一个步骤必须100％成功，随后的步骤才能开始。
关于WebRTC的一个特殊事实是，每个步骤实际上都是由许多其他协议组成的！为了让WebRTC工作起来，我们将许多现有技术结合在一起。从这个意义上讲，WebRTC更像是2000年代早期以来就已经存在的一些易于理解的技术的组合和配置。
每个步骤都有专门的章节，但是首先从较高的层次上理解它们会有所帮助。由于它们彼此依赖，因此理解这些在进一步解释每个步骤的目的时会有所帮助。
信令：peer如何在WebRTC中找到彼此 #  当WebRTC Agent启动时，它不知道与谁通信以及他们将要通信的内容。信令解决了这个问题！信令用于引导呼叫，以便两个WebRTC Agent可以开始通信。
信令使用一种现有的协议SDP（会话描述协议）。SDP是一种纯文本协议。每个SDP消息均由键/值对组成，并包含“media sections（媒体部分）”列表。两个WebRTC Agent交换的SDP所包含一些详细信息，如：
 Agent可供外部访问的（候选的）IP和端口。 Agent希望发送多少路音频和视频流。 Agent支持哪些音频和视频编解码器。 连接时需要用到的值（uFrag/uPwd）。 加密传输时需要用到的值（证书指纹）。  注意，信令通常发生在“out-of-band”。也就是说，应用通常不使用WebRTC本身来交换信令消息。在连接的peer中，任何适合发送消息的架构均可被用于传递SDP信息，许多应用程序都使用其现有的基础设施（例如REST端点，WebSocket连接或身份验证代理）来解决适当客户端之间的SDP传递问题。
使用STUN/TURN进行连接和NAT穿透 #  现在，两个WebRTC Agent知道足够的详细信息以尝试相互连接。接下来，WebRTC将使用另一种成熟的技术，称为ICE。
ICE（交互式连接建立）是WebRTC前现有的协议。ICE允许在两个Agent之间建立连接。这些Agent可以在同一网络上，也可以在世界的另一端。ICE是无需中央服务器即可建立直接连接的解决方案。
这里真正的魔法是“ NAT穿透”和STUN/TURN服务器。这两个概念是与另一个子网中的ICE Agent进行通信所需的全部。稍后我们将深入探讨这些主题。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="是什么，为什么，如何使用"><meta property="og:description" content="是什么，为什么，如何使用 #  WebRTC是什么？ #  WebRTC是Web实时通信（Real-Time Communication）的缩写，它既是API也是协议。WebRTC协议是两个WebRTC Agent协商双向安全实时通信的一组规则。开发人员可以通过WebRTC API使用WebRTC协议。目前WebRTC API仅有JavaScript版本。
可以用HTTP和Fetch API之间的关系作为类比。WebRTC协议就是HTTP，而WebRTC API就是Fetch API。
除了JavaScript语言，WebRTC协议也可以在其他API和语言中使用。你还可以找到WebRTC的服务器和特定领域的工具。所有这些实现都使用WebRTC协议，以便它们可以彼此交互。
WebRTC协议由IETF工作组在rtcweb中维护。WebRTC API的W3C文档在webrtc。
为什么我应该学习WebRTC？ #  下面这些是WebRTC可以带给你的东西。这并不是一份详尽的清单，只是列举一些你在学习中可能感兴趣的点。如果你还不了解所有这些术语，请不要担心，本书将陆续将这些概念教给你。
 开放标准 多种实现 在浏览器中可用 强制加密 NAT穿透 复用现有技术 拥塞控制 亚秒级延迟  WebRTC协议是一组其他技术的集合体 #  这个主题需要整本书来解释。但是，首先，我们将其分为四个步骤。
 信令（Signaling） 连接（Connecting） 安全加密（Securing） 通信（Communicating）  这四个步骤依次发生。上一个步骤必须100％成功，随后的步骤才能开始。
关于WebRTC的一个特殊事实是，每个步骤实际上都是由许多其他协议组成的！为了让WebRTC工作起来，我们将许多现有技术结合在一起。从这个意义上讲，WebRTC更像是2000年代早期以来就已经存在的一些易于理解的技术的组合和配置。
每个步骤都有专门的章节，但是首先从较高的层次上理解它们会有所帮助。由于它们彼此依赖，因此理解这些在进一步解释每个步骤的目的时会有所帮助。
信令：peer如何在WebRTC中找到彼此 #  当WebRTC Agent启动时，它不知道与谁通信以及他们将要通信的内容。信令解决了这个问题！信令用于引导呼叫，以便两个WebRTC Agent可以开始通信。
信令使用一种现有的协议SDP（会话描述协议）。SDP是一种纯文本协议。每个SDP消息均由键/值对组成，并包含“media sections（媒体部分）”列表。两个WebRTC Agent交换的SDP所包含一些详细信息，如：
 Agent可供外部访问的（候选的）IP和端口。 Agent希望发送多少路音频和视频流。 Agent支持哪些音频和视频编解码器。 连接时需要用到的值（uFrag/uPwd）。 加密传输时需要用到的值（证书指纹）。  注意，信令通常发生在“out-of-band”。也就是说，应用通常不使用WebRTC本身来交换信令消息。在连接的peer中，任何适合发送消息的架构均可被用于传递SDP信息，许多应用程序都使用其现有的基础设施（例如REST端点，WebSocket连接或身份验证代理）来解决适当客户端之间的SDP传递问题。
使用STUN/TURN进行连接和NAT穿透 #  现在，两个WebRTC Agent知道足够的详细信息以尝试相互连接。接下来，WebRTC将使用另一种成熟的技术，称为ICE。
ICE（交互式连接建立）是WebRTC前现有的协议。ICE允许在两个Agent之间建立连接。这些Agent可以在同一网络上，也可以在世界的另一端。ICE是无需中央服务器即可建立直接连接的解决方案。
这里真正的魔法是“ NAT穿透”和STUN/TURN服务器。这两个概念是与另一个子网中的ICE Agent进行通信所需的全部。稍后我们将深入探讨这些主题。"><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/"><meta property="article:modified_time" content="2022-03-07T23:33:20+08:00"><meta property="og:site_name" content="给好奇者的WebRTC"><title>是什么，为什么，如何使用 | 给好奇者的WebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ title="Vad, varför och hur"><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/zh.search.min.a9a4dfa67a85363fe72bc452d7a6b11bf767abfbf54ab9e9133afdb4befdc8fd.js integrity="sha256-qaTfpnqFNj/nK8RS16axG/dnq/v1SrnpEzr9tL79yP0="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/zh><span>给好奇者的WebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ class=active>是什么，为什么，如何使用</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/02-signaling/>信令</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>连接</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>安全性</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/05-real-time-networking/>搭建实时网络</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>媒体通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>数据通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/>WebRTC应用场景</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>调试</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/11-faq/>常见问题</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/12-glossary/>Glossary</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>是什么，为什么，如何使用</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc是什么>WebRTC是什么？</a></li><li><a href=#为什么我应该学习webrtc>为什么我应该学习WebRTC？</a></li><li><a href=#webrtc协议是一组其他技术的集合体>WebRTC协议是一组其他技术的集合体</a><ul><li><a href=#信令peer如何在webrtc中找到彼此>信令：peer如何在WebRTC中找到彼此</a></li><li><a href=#使用stunturn进行连接和nat穿透>使用STUN/TURN进行连接和NAT穿透</a></li><li><a href=#使用dtls和srtp加密传输层>使用DTLS和SRTP加密传输层</a></li><li><a href=#通过rtp和sctp进行点对点通信>通过RTP和SCTP进行点对点通信</a></li></ul></li><li><a href=#webrtc是一系列协议的集合>WebRTC是一系列协议的集合</a></li><li><a href=#webrtcapi如何工作>WebRTC（API）如何工作</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=是什么为什么如何使用>是什么，为什么，如何使用
<a class=anchor href=#%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8>#</a></h1><h2 id=webrtc是什么>WebRTC是什么？
<a class=anchor href=#webrtc%e6%98%af%e4%bb%80%e4%b9%88>#</a></h2><p>WebRTC是Web实时通信（Real-Time Communication）的缩写，它既是API也是协议。WebRTC协议是两个WebRTC Agent协商双向安全实时通信的一组规则。开发人员可以通过WebRTC API使用WebRTC协议。目前WebRTC API仅有JavaScript版本。</p><p>可以用HTTP和Fetch API之间的关系作为类比。WebRTC协议就是HTTP，而WebRTC API就是Fetch API。</p><p>除了JavaScript语言，WebRTC协议也可以在其他API和语言中使用。你还可以找到WebRTC的服务器和特定领域的工具。所有这些实现都使用WebRTC协议，以便它们可以彼此交互。</p><p>WebRTC协议由IETF工作组在<a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a>中维护。WebRTC API的W3C文档在<a href=https://www.w3.org/TR/webrtc/>webrtc</a>。</p><h2 id=为什么我应该学习webrtc>为什么我应该学习WebRTC？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e5%ba%94%e8%af%a5%e5%ad%a6%e4%b9%a0webrtc>#</a></h2><p>下面这些是WebRTC可以带给你的东西。这并不是一份详尽的清单，只是列举一些你在学习中可能感兴趣的点。如果你还不了解所有这些术语，请不要担心，本书将陆续将这些概念教给你。</p><ul><li>开放标准</li><li>多种实现</li><li>在浏览器中可用</li><li>强制加密</li><li>NAT穿透</li><li>复用现有技术</li><li>拥塞控制</li><li>亚秒级延迟</li></ul><h2 id=webrtc协议是一组其他技术的集合体>WebRTC协议是一组其他技术的集合体
<a class=anchor href=#webrtc%e5%8d%8f%e8%ae%ae%e6%98%af%e4%b8%80%e7%bb%84%e5%85%b6%e4%bb%96%e6%8a%80%e6%9c%af%e7%9a%84%e9%9b%86%e5%90%88%e4%bd%93>#</a></h2><p>这个主题需要整本书来解释。但是，首先，我们将其分为四个步骤。</p><ul><li>信令（Signaling）</li><li>连接（Connecting）</li><li>安全加密（Securing）</li><li>通信（Communicating）</li></ul><p>这四个步骤依次发生。上一个步骤必须100％成功，随后的步骤才能开始。</p><p>关于WebRTC的一个特殊事实是，每个步骤实际上都是由许多其他协议组成的！为了让WebRTC工作起来，我们将许多现有技术结合在一起。从这个意义上讲，WebRTC更像是2000年代早期以来就已经存在的一些易于理解的技术的组合和配置。</p><p>每个步骤都有专门的章节，但是首先从较高的层次上理解它们会有所帮助。由于它们彼此依赖，因此理解这些在进一步解释每个步骤的目的时会有所帮助。</p><h3 id=信令peer如何在webrtc中找到彼此>信令：peer如何在WebRTC中找到彼此
<a class=anchor href=#%e4%bf%a1%e4%bb%a4peer%e5%a6%82%e4%bd%95%e5%9c%a8webrtc%e4%b8%ad%e6%89%be%e5%88%b0%e5%bd%bc%e6%ad%a4>#</a></h3><p>当WebRTC Agent启动时，它不知道与谁通信以及他们将要通信的内容。信令解决了这个问题！信令用于引导呼叫，以便两个WebRTC Agent可以开始通信。</p><p>信令使用一种现有的协议SDP（会话描述协议）。SDP是一种纯文本协议。每个SDP消息均由键/值对组成，并包含“media sections（媒体部分）”列表。两个WebRTC Agent交换的SDP所包含一些详细信息，如：</p><ul><li>Agent可供外部访问的（候选的）IP和端口。</li><li>Agent希望发送多少路音频和视频流。</li><li>Agent支持哪些音频和视频编解码器。</li><li>连接时需要用到的值（<code>uFrag</code>/<code>uPwd</code>）。</li><li>加密传输时需要用到的值（证书指纹）。</li></ul><p>注意，信令通常发生在“out-of-band”。也就是说，应用通常不使用WebRTC本身来交换信令消息。在连接的peer中，任何适合发送消息的架构均可被用于传递SDP信息，许多应用程序都使用其现有的基础设施（例如REST端点，WebSocket连接或身份验证代理）来解决适当客户端之间的SDP传递问题。</p><h3 id=使用stunturn进行连接和nat穿透>使用STUN/TURN进行连接和NAT穿透
<a class=anchor href=#%e4%bd%bf%e7%94%a8stunturn%e8%bf%9b%e8%a1%8c%e8%bf%9e%e6%8e%a5%e5%92%8cnat%e7%a9%bf%e9%80%8f>#</a></h3><p>现在，两个WebRTC Agent知道足够的详细信息以尝试相互连接。接下来，WebRTC将使用另一种成熟的技术，称为ICE。</p><p>ICE（交互式连接建立）是WebRTC前现有的协议。ICE允许在两个Agent之间建立连接。这些Agent可以在同一网络上，也可以在世界的另一端。ICE是无需中央服务器即可建立直接连接的解决方案。</p><p>这里真正的魔法是“ NAT穿透”和STUN/TURN服务器。这两个概念是与另一个子网中的ICE Agent进行通信所需的全部。稍后我们将深入探讨这些主题。</p><p>ICE成功连接后，WebRTC就会继续建立加密传输。加密传输用于音频，视频和数据。</p><h3 id=使用dtls和srtp加密传输层>使用DTLS和SRTP加密传输层
<a class=anchor href=#%e4%bd%bf%e7%94%a8dtls%e5%92%8csrtp%e5%8a%a0%e5%af%86%e4%bc%a0%e8%be%93%e5%b1%82>#</a></h3><p>现在我们有了双向通信（基于ICE），我们需要建立安全的通信。这是基于WebRTC前已有的两种协议完成的。第一个协议是DTLS（数据报传输层安全性），即基于UDP的TLS。TLS是一个加密协议，用于保护基于HTTPS的安全通信。第二种协议是SRTP（安全实时传输协议）。</p><p>首先，WebRTC通过在ICE建立的连接上进行DTLS握手来进行连接。与HTTPS不同，WebRTC不使用中央授权来颁发证书。相反，WebRTC只是判断通过DTLS交换的证书是否与通过信令共享的签名相符。然后，此DTLS连接可以被用于传输DataChannel消息。</p><p>接下来，WebRTC使用RTP协议进行音频/视频的传输。我们使用SRTP来保护我们的RTP数据包。我们从协商的DTLS会话中提取密钥，用来初始化SRTP会话。在后续章节中，我们会讨论为什么媒体传输需要有它自己的协议。</p><p>现在我们完成了！你现在可以进行安全的双向通信。如果你的WebRTC Agent之间具有稳定的连接，以上这些就是你可能需要解决的所有复杂问题了。不幸的是，现实世界中存在数据包丢失和带宽限制等问题，下一节我们会介绍如何处理这些问题。</p><h3 id=通过rtp和sctp进行点对点通信>通过RTP和SCTP进行点对点通信
<a class=anchor href=#%e9%80%9a%e8%bf%87rtp%e5%92%8csctp%e8%bf%9b%e8%a1%8c%e7%82%b9%e5%af%b9%e7%82%b9%e9%80%9a%e4%bf%a1>#</a></h3><p>现在，我们有了两个具有安全的双向通信功能的WebRTC Agent。让我们开始通信！跟前面一样，我们使用两个现有的协议：RTP（实时传输协议）和SCTP（流控制传输协议）。我们使用RTP来交换用SRTP加密过的媒体数据，使用SCTP发送和接收那些用DTLS加密过的DataChannel消息。</p><p>RTP很轻量，但是提供了实现实时流式传输所需的功能。最重要的是，RTP为开发人员提供了灵活性，因此他们可以根据需要来处理延迟，丢失和拥塞。我们将在媒体章节中对此进行进一步讨论。</p><p>协议栈中的最后一个协议是SCTP。SCTP支持许多不同的消息传送选项。你可以根据需要开启不可靠传输，无序传输等选项，以便获得实时系统所需的低延迟。</p><h2 id=webrtc是一系列协议的集合>WebRTC是一系列协议的集合
<a class=anchor href=#webrtc%e6%98%af%e4%b8%80%e7%b3%bb%e5%88%97%e5%8d%8f%e8%ae%ae%e7%9a%84%e9%9b%86%e5%90%88>#</a></h2><p>WebRTC解决了许多问题。初看起来，这似乎是过度设计的。实际上，WebRTC非常克制。它并未认为它可以更好的解决所有问题。相反，它采纳了许多现有的解决某个特定问题的技术，然后将它们有机地结合起来。</p><p>这使得我们可以独立的检查和学习每个部分，而不会毫无头绪。实际上，从另一个角度去看“ WebRTC Agent”，它只是许多不同协议的协调器。</p><p><img src=../../images/01-webrtc-agent.png alt="WebRTC Agent" title="WebRTC Agent图示"></p><h2 id=webrtcapi如何工作>WebRTC（API）如何工作
<a class=anchor href=#webrtcapi%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c>#</a></h2><p>本部分显示JavaScript API是如何跟协议相对应的。这不是一个WebRTC API的详细演示，更多的是为了创建一个思维模型，展现各个模块是如何串联起来的。如果你对各个模块都还不熟悉，那也不要紧。当你了解更多信息时，再回头看看这一部分，可能会很有趣！</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p><code>RTCPeerConnection</code>是最顶层的"WebRTC会话&rdquo;。它包含上述所有协议。调用后，所有子系统都会被创建，但是此时什么都还没有发生。</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code>创建一个新的RTP流。会为这个RTP流生成一个随机的SSRC（Synchronization Source/同步源）。在后续<code>createOffer</code>生成会话描述中，这个RTP流会被放入一个media section。每次调用<code>addTrack</code>都会创建一个新的SSRC和一个对应的media section。</p><p>在建立SRTP会话后，这些媒体数据包将被SRTP加密，然后立即通过ICE开始发送。</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p>当没有SCTP关联(SCTP Association)存在时，<code>createDataChannel</code>将创建一个新的SCTP流。默认情况下，SCTP是不启用的，只有在一方请求数据通道时才启动。</p><p>在DTLS会话建立之后，SCTP关联将立即通过ICE发送数据包，并使用DTLS加密。</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code>生成会话描述，里面是需要与远端Peer分享的本地信息。</p><p>调用<code>createOffer</code>的行为对于本地Peer没有任何改变。</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code>提交所有请求的更改。 <code>addTrack</code> <code>createDataChannel</code>和其他类似的调用都是临时的(调用<code>setLocalDescription</code>后生效)。 调用<code>setLocalDescription</code>时，使用由<code>createOffer</code>生成的值。</p><p>通常，在此调用之后，你会将offer发送给远端Peer，他们将调用<code>setRemoteDescription</code>，将此offer设入。</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p>收到远端Peer发来的offer之后，我们通过<code>setRemoteDescription</code>通知本地Agent。这就是使用JavaScript API传递“信令”的方式。</p><p>双方都调用过<code>setRemoteDescription</code>后，WebRTC Agent现在拥有足够的信息来开始进行点对点（P2P）通信！</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code>允许WebRTC Agent随时添加更多的远程ICE候选对象。该API将ICE候选对象发送到ICE子系统，并且对更大的WebRTC连接没有其他影响。</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code>是收到远端Peer的RTP数据包时触发的回调。传入的RTP数据包的格式应该已在传递给<code>setRemoteDescription</code>的会话描述中声明。</p><p>WebRTC使用SSRC并查找关联的<code>MediaStream</code>和<code>MediaStreamTrack</code>，并使用<code>MediaStream</code>和<code>MediaStreamTrack</code>中的详细信息来触发此回调。</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code>是ICE Agent的状态变化时触发的回调。当网络连接或断开时，你将得到此通知。</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code>是ICE Agent和DTLS Agent状态的组合。当ICE和DTLS都成功完成时，你将得到此通知。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li class=active><a href=https://webrtcforthecurious.com/zh/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/1dfaa6172b8964b32953e2ee1338ff6a9f9930d6 title="最后修改者 katepangLiu | March 7, 2022" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 7, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.zh-cn/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc是什么>WebRTC是什么？</a></li><li><a href=#为什么我应该学习webrtc>为什么我应该学习WebRTC？</a></li><li><a href=#webrtc协议是一组其他技术的集合体>WebRTC协议是一组其他技术的集合体</a><ul><li><a href=#信令peer如何在webrtc中找到彼此>信令：peer如何在WebRTC中找到彼此</a></li><li><a href=#使用stunturn进行连接和nat穿透>使用STUN/TURN进行连接和NAT穿透</a></li><li><a href=#使用dtls和srtp加密传输层>使用DTLS和SRTP加密传输层</a></li><li><a href=#通过rtp和sctp进行点对点通信>通过RTP和SCTP进行点对点通信</a></li></ul></li><li><a href=#webrtc是一系列协议的集合>WebRTC是一系列协议的集合</a></li><li><a href=#webrtcapi如何工作>WebRTC（API）如何工作</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>