<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="安全性 # WebRTC 具有哪些安全性保障？ # 每个 WebRTC 连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的 WebRTC Agent 正是生成会话描述的 Agent。
没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC 无法防止会话描述被修改。攻击者可以通过更改 ICE 候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。
译注：这里指的是，P2P 连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过 man-in-the-middle 方式伪装中间人同时与通信双方建立连接并通信。 它是如何做到的？ # WebRTC 使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / DTLS）和 安全实时传输协议（Secure Real-time Transport Protocol / SRTP）。
DTLS 使你可以协商会话，然后在两个 peer 之间安全地交换数据。它是 TLS 的同类产品，TLS 是 HTTPS 所使用的技术，而 DTLS 与 TLS 的区别仅在与其使用 UDP 而不是 TCP 作为其传输层。这也意味着 DTLS 协议必须处理不可靠的数据传输。SRTP 是专为安全的交换媒体数据而设计的。相对于 DTLS 而言，使用 SRTP 对传输媒体数据有一些优化。
DTLS 先被使用。它通过 ICE 提供的连接进行一次握手。DTLS 是一种客户端 / 服务器协议，因此其中一侧需要开始握手。客户端 / 服务器的角色是在信令中被确定的。在 DTLS 握手期间，双方都会提供证书。 握手完成后，需要将收到的证书与会话描述中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的 WebRTC Agent。接下来，可以将 DTLS 连接用于 DataChannel 通信。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/04-securing/"><meta property="og:site_name" content="给好奇者的WebRTC"><meta property="og:title" content="安全性"><meta property="og:description" content="安全性 # WebRTC 具有哪些安全性保障？ # 每个 WebRTC 连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的 WebRTC Agent 正是生成会话描述的 Agent。
没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC 无法防止会话描述被修改。攻击者可以通过更改 ICE 候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。
译注：这里指的是，P2P 连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过 man-in-the-middle 方式伪装中间人同时与通信双方建立连接并通信。 它是如何做到的？ # WebRTC 使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / DTLS）和 安全实时传输协议（Secure Real-time Transport Protocol / SRTP）。
DTLS 使你可以协商会话，然后在两个 peer 之间安全地交换数据。它是 TLS 的同类产品，TLS 是 HTTPS 所使用的技术，而 DTLS 与 TLS 的区别仅在与其使用 UDP 而不是 TCP 作为其传输层。这也意味着 DTLS 协议必须处理不可靠的数据传输。SRTP 是专为安全的交换媒体数据而设计的。相对于 DTLS 而言，使用 SRTP 对传输媒体数据有一些优化。
DTLS 先被使用。它通过 ICE 提供的连接进行一次握手。DTLS 是一种客户端 / 服务器协议，因此其中一侧需要开始握手。客户端 / 服务器的角色是在信令中被确定的。在 DTLS 握手期间，双方都会提供证书。 握手完成后，需要将收到的证书与会话描述中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的 WebRTC Agent。接下来，可以将 DTLS 连接用于 DataChannel 通信。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-04-13T12:59:52+08:00"><title>安全性 | 给好奇者的WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/zh/docs/04-securing/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/04-securing/ title=امنیت><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/04-securing/ title=Securing><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/04-securing/ title=Securing><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/04-securing/ title=Securing><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/04-securing/ title=Güvenlik><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/04-securing/ title=보안><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.3010f895b5ac0d7726f337b8e62d437ce44907a39a1c966472a902d2d47b2a23.js integrity="sha256-MBD4lbWsDXcm8ze45i1DfORJB6OaHJZkcqkC0tR7KiM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>给好奇者的WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/04-securing/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/04-securing/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/04-securing/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/04-securing/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/04-securing/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/04-securing/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/04-securing/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/04-securing/>한국어</a></li></ul></li></ul><ul><li><a href=/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=/zh/docs/02-signaling/>信令</a></li><li><a href=/zh/docs/03-connecting/>连接</a></li><li><a href=/zh/docs/04-securing/ class=active>安全性</a></li><li><a href=/zh/docs/05-real-time-networking/>搭建实时网络</a></li><li><a href=/zh/docs/06-media-communication/>媒体通信</a></li><li><a href=/zh/docs/07-data-communication/>数据通信</a></li><li><a href=/zh/docs/08-applied-webrtc/>WebRTC 应用场景</a></li><li><a href=/zh/docs/09-debugging/>调试</a></li><li><a href=/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=/zh/docs/11-faq/>常见问题</a></li><li><a href=/zh/docs/12-glossary/>术语</a></li><li><a href=/zh/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>安全性</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc-具有哪些安全性保障>WebRTC 具有哪些安全性保障？</a></li><li><a href=#它是如何做到的>它是如何做到的？</a></li><li><a href=#安全性-101>安全性 101</a><ul><li><a href=#明文和密文>明文和密文</a></li><li><a href=#cipher>Cipher</a></li><li><a href=#哈希函数>哈希函数</a></li><li><a href=#公钥--私钥加密>公钥 / 私钥加密</a></li><li><a href=#diffie-hellman-交换>Diffie-Hellman 交换</a></li><li><a href=#伪随机函数prf>伪随机函数（PRF）</a></li><li><a href=#密钥派生kdf>密钥派生（KDF）</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#消息身份验证代码message-authentication-code>消息身份验证代码（Message Authentication Code）</a></li><li><a href=#密钥轮换>密钥轮换</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#数据包格式>数据包格式</a></li><li><a href=#握手状态机><code>握手</code>状态机</a></li><li><a href=#密钥的生成>密钥的生成</a></li><li><a href=#交换-applicationdata>交换 ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#会话创建>会话创建</a></li><li><a href=#交换媒体数据>交换媒体数据</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=安全性>安全性
<a class=anchor href=#%e5%ae%89%e5%85%a8%e6%80%a7>#</a></h1><h2 id=webrtc-具有哪些安全性保障>WebRTC 具有哪些安全性保障？
<a class=anchor href=#webrtc-%e5%85%b7%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%80%a7%e4%bf%9d%e9%9a%9c>#</a></h2><p>每个 WebRTC 连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的 WebRTC Agent 正是生成会话描述的 Agent。</p><p>没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC 无法防止会话描述被修改。攻击者可以通过更改 ICE 候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。</p><blockquote class="book-hint info">译注：这里指的是，P2P 连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过 man-in-the-middle 方式伪装中间人同时与通信双方建立连接并通信。</blockquote><h2 id=它是如何做到的>它是如何做到的？
<a class=anchor href=#%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e7%9a%84>#</a></h2><p>WebRTC 使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / <a href=https://tools.ietf.org/html/rfc6347>DTLS</a>）和 安全实时传输协议（Secure Real-time Transport Protocol / <a href=https://tools.ietf.org/html/rfc3711>SRTP</a>）。</p><p>DTLS 使你可以协商会话，然后在两个 peer 之间安全地交换数据。它是 TLS 的同类产品，TLS 是 HTTPS 所使用的技术，而 DTLS 与 TLS 的区别仅在与其使用 UDP 而不是 TCP 作为其传输层。这也意味着 DTLS 协议必须处理不可靠的数据传输。SRTP 是专为安全的交换媒体数据而设计的。相对于 DTLS 而言，使用 SRTP 对传输媒体数据有一些优化。</p><p>DTLS 先被使用。它通过 ICE 提供的连接进行一次握手。DTLS 是一种客户端 / 服务器协议，因此其中一侧需要开始握手。客户端 / 服务器的角色是在信令中被确定的。在 DTLS 握手期间，双方都会提供证书。
握手完成后，需要将收到的证书与<code>会话描述</code>中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的 WebRTC Agent。接下来，可以将 DTLS 连接用于 DataChannel 通信。</p><p>要创建 SRTP 会话，我们使用 DTLS 生成的密钥对其进行初始化。SRTP 没有握手机制，因此必须使用外部密钥进行引导。一旦完成此操作，媒体数据即可以用 SRTP 加密并进行交换！</p><h2 id=安全性-101>安全性 101
<a class=anchor href=#%e5%ae%89%e5%85%a8%e6%80%a7-101>#</a></h2><p>要了解本章介绍的技术，你首先需要了解这些术语。密码学是一个棘手的主题，因此其他资源也是值得参考的！</p><h3 id=明文和密文>明文和密文
<a class=anchor href=#%e6%98%8e%e6%96%87%e5%92%8c%e5%af%86%e6%96%87>#</a></h3><p>明文是 cipher 的输入。密文是 cipher 的输出。</p><h3 id=cipher>Cipher
<a class=anchor href=#cipher>#</a></h3><p>Cipher 是将明文转换为密文的一系列步骤。Cipher 可以反过来运行，因此你可以将密文恢复为明文。一个 cipher 通常拥有一个更改其行为的密钥。还有一个术语是加密和解密。</p><p>举例来说，一个简单的 cipher 是 ROT13。也就是每个字母向前移动 13 个字符。要解密这个 cipher，需要每个字母向后移动 13 个字符。明文 <code>HELLO</code> 将成为密文 <code>URYYB</code>。 在这种情况下，Cipher 是 ROT，密钥是 13。</p><h3 id=哈希函数>哈希函数
<a class=anchor href=#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0>#</a></h3><p>哈希函数是一种生成摘要的单向过程。给定一个输入，它每次都会生成相同的输出。其重要特点是输出<em>不</em>可逆。也就是说，根据输出的摘要，无法确定其输入。当你要确认消息未被篡改时，哈希函数很有用。</p><p>哈希函数可以很简单，比如只是对输入间隔取字母。这样 HELLO 将变成 HLO。你不能认为 <code>HELLO</code> 就是输入，但可以确认如果输入的是 <code>HELLO</code>，那么结果是匹配的。</p><h3 id=公钥--私钥加密>公钥 / 私钥加密
<a class=anchor href=#%e5%85%ac%e9%92%a5--%e7%a7%81%e9%92%a5%e5%8a%a0%e5%af%86>#</a></h3><p>公钥 / 私钥加密描述了 DTLS 和 SRTP 使用的 cipher 类型。在此系统中，你有两个密钥，即公钥和私钥。公钥用于加密消息，可以安全共享。
私钥用于解密消息，永远不应共享。当解密那些使用对应的公钥加密的消息时，它是唯一的密钥。</p><h3 id=diffie-hellman-交换>Diffie-Hellman 交换
<a class=anchor href=#diffie-hellman-%e4%ba%a4%e6%8d%a2>#</a></h3><p>Diffie-Hellman 交换允许两个以前从未见过的用户通过 Internet 安全的创建一个共享的秘密信息。用户 <code>A</code> 可以将秘密信息发送给用户 <code>B</code>，而不必担心被窃听。破解该信息的难度将取决于破解离散对数问题的难度。
你不必完全理解该算法是如何工作的，但这可以帮助你了解是什么使得 DTLS 握手变得可行的。</p><p>Wikipedia 在<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>此处</a>中有一个实际的例子。</p><h3 id=伪随机函数prf>伪随机函数（PRF）
<a class=anchor href=#%e4%bc%aa%e9%9a%8f%e6%9c%ba%e5%87%bd%e6%95%b0prf>#</a></h3><p>伪随机函数是一个预定义函数，用于生成随机出现的值。它可能需要多个输入并生成一个输出。</p><h3 id=密钥派生kdf>密钥派生（KDF）
<a class=anchor href=#%e5%af%86%e9%92%a5%e6%b4%be%e7%94%9fkdf>#</a></h3><p>密钥派生是一类伪随机函数。是一种用于增强密钥的安全性的方法。一种常见的模式是密钥扩展。</p><p>假设你获得的密钥为 8 字节。你可以使用 KDF 使其更坚固。</p><h3 id=nonce>Nonce
<a class=anchor href=#nonce>#</a></h3><p>Nonce 是 cipher 的附加输入。这样，即使你多次加密同一条消息，也可以从 cipher 中获得不同的输出。</p><p>如果将同一条消息加密 10 次，cipher 将为你提供 10 次相同的密文。通过使用 nonce，在使用同一个密钥的情况下，你将得到不同的输入。需要注意的是，每条消息都要使用不同的 nonce！ 否则就没有太大意义了。</p><h3 id=消息身份验证代码message-authentication-code>消息身份验证代码（Message Authentication Code）
<a class=anchor href=#%e6%b6%88%e6%81%af%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e4%bb%a3%e7%a0%81message-authentication-code>#</a></h3><p>消息身份验证代码（MAC）是放在消息末尾的哈希值。MAC 能证明该消息来自你期望的用户。</p><p>如果你不使用 MAC，攻击者可能会插入无效的消息。因为他们不知道密钥，所以这些消息解密后是无意义的垃圾内容。</p><h3 id=密钥轮换>密钥轮换
<a class=anchor href=#%e5%af%86%e9%92%a5%e8%bd%ae%e6%8d%a2>#</a></h3><p>密钥轮换是一种间隔一段时间便更改密钥的做法。这种做法会使得被窃取的密钥影响较小。如果密钥被窃取或泄漏，那么只有很少的数据可以被解密。</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS（数据报传输层安全协议）允许两个 peer 在没有预先存在的配置的情况下建立安全的通信。即使有人窃听了通信，他们也将无法解密消息。</p><p>为了使 DTLS 客户端和服务器进行通信，他们需要就 cipher 和密钥达成一致。他们通过进行 DTLS 握手来确定这些值。在握手期间，消息为纯文本格式。
当 DTLS 客户端 / 服务器交换了足够的详细信息以开始加密时，它会发送 <code>Change Cipher Spec</code>（更改 Cipher 规格）消息。在此消息之后，后续的每个消息都将会被加密！</p><h3 id=数据包格式>数据包格式
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%8c%85%e6%a0%bc%e5%bc%8f>#</a></h3><p>每个 DTLS 数据包开头都包含一个头部信息。</p><h4 id=内容类型>内容类型
<a class=anchor href=#%e5%86%85%e5%ae%b9%e7%b1%bb%e5%9e%8b>#</a></h4><p>你可以看到数据包包括以下几种类型：</p><ul><li><code>20</code> - Change Cipher Spec（更改 Cipher 规格）</li><li><code>22</code> - Handshake（握手）</li><li><code>23</code> - Application Data（应用程序数据）</li></ul><p><code>握手</code>用于交换详细信息以开始会话。 <code>更改 Cipher 规格</code>用于通知另一端所有内容都将被加密。<code>应用程序数据</code>是加密的消息。</p><h4 id=版本>版本
<a class=anchor href=#%e7%89%88%e6%9c%ac>#</a></h4><p>版本可以是 <code>0x0000feff</code>（DTLS v1.0）或 <code>0x0000fefd</code>（DTLS v1.2），没有 v1.1。</p><h4 id=epoch时段>Epoch（时段）
<a class=anchor href=#epoch%e6%97%b6%e6%ae%b5>#</a></h4><p>时段从 <code>0</code> 开始，但在<code>更改 Cipher 规格</code>之后变为 <code>1</code>。在非零时段的任何消息都将被加密。</p><h4 id=序列号>序列号
<a class=anchor href=#%e5%ba%8f%e5%88%97%e5%8f%b7>#</a></h4><p>序列号用于保持消息顺序。每条消息都会增加序列号。当 Epoch（时段）增加时，序列号重新开始。</p><h4 id=长度和有效载荷>长度和有效载荷
<a class=anchor href=#%e9%95%bf%e5%ba%a6%e5%92%8c%e6%9c%89%e6%95%88%e8%bd%bd%e8%8d%b7>#</a></h4><p>有效载荷是特定于<code>内容类型</code>的。对于<code>应用程序数据</code>而言，<code>有效载荷</code>是加密的数据。对于<code>握手</code>，它会根据消息而有所不同。长度是指<code>有效载荷</code>的大小。</p><h3 id=握手状态机><code>握手</code>状态机
<a class=anchor href=#%e6%8f%a1%e6%89%8b%e7%8a%b6%e6%80%81%e6%9c%ba>#</a></h3><p>在握手期间，客户端 / 服务器交换一系列消息。这些消息被分为多个 Flight。每个 Flight 中可能有多个消息（或只有一个）。
直到收到 Flight 中的所有消息，该 Flight 才算完成。我们将在下面更详细地描述每条消息的目的。</p><p><img src=../../images/04-handshake.png alt=握手 title=握手></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello 是客户端发送的初始消息。它包含一个属性列表。这些属性告诉服务器客户端支持的 cipher 和功能。对于 WebRTC，这也是我们选择 SRTP cipher 方式的原因。它还包含将用于生成会话密钥的随机数据。</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>服务器将 HelloVerifyRequest 发送到客户端。这是为了确认客户端准备继续发送请求。然后，客户端重新发送 ClientHello，但这一次需要携带 HelloVerifyRequest 中提供的令牌。</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello 是服务器响应消息，是此次会话的配置信息。它包含此会话直到结束时将使用的 cipher。它还包含服务器端的随机数据。</p><h4 id=certificate>Certificate
<a class=anchor href=#certificate>#</a></h4><p>Certificate 包含客户端或服务器的证书。它被用来唯一识别我们与之通信的对方。握手结束后，我们将确保这个证书的哈希与 <code>SessionDescription</code> 中的指纹相匹配。</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>这些消息用于传输公共密钥。在启动时，客户端和服务器都会生成密钥对。握手后，这些值将被用来生成 <code>Pre-Master Secret</code>。</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>CertificateRequest 由服务端发送，用来通知客户端需要一个证书。服务端既可以请求一个证书，也可以要求必须提供证书。</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone 通知客户端此时服务器已完成握手动作。</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>发送者用 CertificateVerify 消息来证明他已经获得了 Certificate 消息中发送的私钥。</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec 通知接收者在此消息之后发送的所有内容都将被加密。</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished 消息是加密的，它包含所有消息的哈希。用来断言握手过程未被篡改。</p><h3 id=密钥的生成>密钥的生成
<a class=anchor href=#%e5%af%86%e9%92%a5%e7%9a%84%e7%94%9f%e6%88%90>#</a></h3><p>握手完成后，你可以开始发送加密数据。Cipher 是由服务器选择的，位于 ServerHello 消息中。但接下来如何生成密钥呢？</p><p>首先，我们需要生成 <code>Pre-Master Secret</code>。为了获得该值，我们通过 <code>ServerKeyExchange</code> 和 <code>ClientKeyExchange</code> 消息，使用 Diffie-Hellman 算法来交换密钥。细节因选定的 Cipher 而异。</p><p>接下来，生成 <code>Master Secret</code>。每个版本的 DTLS 都有一个定义的 <code>Pseudorandom function</code>（伪随机函数）。对于 DTLS 1.2，伪随机函数会在 <code>ClientHello</code> 和 <code>ServerHello</code> 中获取 <code>Pre-Master Secret</code> 和随机值。
运行 <code>Pseudorandom function</code> 后，获得的输出是 <code>Master Secret</code>。<code>Master Secret</code> 是用于 Cipher 的值。</p><h3 id=交换-applicationdata>交换 ApplicationData
<a class=anchor href=#%e4%ba%a4%e6%8d%a2-applicationdata>#</a></h3><p>DTLS 的主要内容是 <code>ApplicationData</code>。现在我们有了一个初始化好的 Cipher，我们可以开始加密和发送数据了。</p><p>如前所述，<code>ApplicationData</code> 消息使用一个 DTLS 标头。<code>Payload</code> 中填充了密文。你现在可以正常使用 DTLS 会话，并且可以安全地进行通信。</p><p>DTLS 具有更多有趣的功能，例如重新协商等。WebRTC 中不使用这些功能，因此此处不作介绍。</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP 是针对加密 RTP 数据包专门涉及的协议。要启动 SRTP 会话，需要指定密钥和 cipher。与 DTLS 不同，它没有握手机制。所有的配置和密钥都是在 DTLS 握手期间生成的。</p><p>DTLS 提供了专用的 API，用来导出密钥以供另一个进程使用。这是在<a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>中定义的</p><h3 id=会话创建>会话创建
<a class=anchor href=#%e4%bc%9a%e8%af%9d%e5%88%9b%e5%bb%ba>#</a></h3><p>SRTP 定义了一个密钥派生函数，用于处理输入。在创建 SRTP 会话时，密钥派生函数将被执行，用输入数据生成 SRTP Cipher 的密钥。之后，你可以继续处理媒体。</p><h3 id=交换媒体数据>交换媒体数据
<a class=anchor href=#%e4%ba%a4%e6%8d%a2%e5%aa%92%e4%bd%93%e6%95%b0%e6%8d%ae>#</a></h3><p>每个 RTP 数据包都有一个 16 位的 SequenceNumber（序列号）。这些序列号用于使数据包保持顺序，就像主键一样。在通话期间，这些序列号将滚动累加。SRTP 会对其进行跟踪，并将其称为滚动计数器。</p><p>加密数据包时，SRTP 使用滚动计数器和序列号作为 nonce。这是为了确保即使两次发送相同的数据，密文也会有所不同。这样做很重要，可以阻止攻击者识别模式或尝试重播攻击。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/675d3fc910ae99bdc59b0896997d9e94f781a1b0 title='最后修改者 ReEcho | 四月 13, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>四月 13, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc-具有哪些安全性保障>WebRTC 具有哪些安全性保障？</a></li><li><a href=#它是如何做到的>它是如何做到的？</a></li><li><a href=#安全性-101>安全性 101</a><ul><li><a href=#明文和密文>明文和密文</a></li><li><a href=#cipher>Cipher</a></li><li><a href=#哈希函数>哈希函数</a></li><li><a href=#公钥--私钥加密>公钥 / 私钥加密</a></li><li><a href=#diffie-hellman-交换>Diffie-Hellman 交换</a></li><li><a href=#伪随机函数prf>伪随机函数（PRF）</a></li><li><a href=#密钥派生kdf>密钥派生（KDF）</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#消息身份验证代码message-authentication-code>消息身份验证代码（Message Authentication Code）</a></li><li><a href=#密钥轮换>密钥轮换</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#数据包格式>数据包格式</a></li><li><a href=#握手状态机><code>握手</code>状态机</a></li><li><a href=#密钥的生成>密钥的生成</a></li><li><a href=#交换-applicationdata>交换 ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#会话创建>会话创建</a></li><li><a href=#交换媒体数据>交换媒体数据</a></li></ul></li></ul></nav></div></aside></main></body></html>