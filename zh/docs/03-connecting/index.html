<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="为什么WebRTC需要专用的子系统进行连接？ #  目前，大多数部署的应用程序都通过客户端/服务器方式进行连接。客户端/服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。
WebRTC不使用客户端/服务器模型，它建立点对点（P2P）连接。 在P2P连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测WebRTC中的传输地址（IP和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC将收集所有可能收集的信息，并将尽力实现两个WebRTC Agent之间的双向通信。
听起来简单，建立点对点连接实际上可能会非常困难。这些Agent可能位于没有直接连接的不同网络中。即使在两个Agent可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP <-> TCP）或使用不同的IP版本（IPv4 <-> IPv6）。
尽管在建立点对点连接方面存在一些困难，在WebRTC提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端/服务器技术的一些优势。
降低带宽成本 #  由于媒体通信直接发生在peer之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。
更低延迟 #  直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。
安全的端到端通信 #  直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。
它是如何工作的？ #  上面描述的连接过程是通过Interactive Connectivity Establishment（交互式连接建立/ICE） 实现的。这是另一个在WebRTC之前就已经出现的协议。
ICE是一种用来寻找两个ICE Agent之间通信的最佳方式的协议。每个ICE Agent都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent认为这个传输地址可能可以被对端访问到。接下来ICE将确定候选地址的最佳搭配。
本章稍后将详细介绍实际的ICE过程。要了解ICE为什么存在，最好先了解我们要面临的网络特性。
现实世界的网络限制 #  ICE就是克服现实世界网络限制的方法。在我们开始讨论ICE如何解决问题之前，先讨论一下有哪些实际问题。
不在同一个网络中 #  在大多数情况下，两个WebRTC Agent不在同一个网络中。典型的呼叫通常是在没有直接连接的不同网络中的两个WebRTC Agent之间进行的。
下面是通过公共互联网连接的两个不同网络的示意图。在每个网络中，你拥有两个主机。
对于同一网络中的主机来说，互相连接非常容易。例如在192.168.0.1 -> 192.168.0.2之间通讯就很容易！这两个主机无需任何外部帮助即可相互连接。
但是，使用Router B的主机无法直接访问Router A背后的任何主机。你如何区分Router A后面的192.168.0.1主机和Router B后面相同IP的主机之间的区别呢？它们都使用内网IP！使用Router B的主机可以将数据直接发送到Router A，但是请求在那里就结束了。Router A怎么知道它应该将消息转发给哪台主机呢？
协议限制 #  有些网络不允许UDP通信，或者也有可能不允许TCP。有些网络的MTU（Maximum Transmission Unit/最大传输单元）可能非常低。网络管理员可以更改许多变量，这些修改可能会使通信变得困难。
防火墙/IDS规则 #  另一个问题是深度数据包检查和其他智能过滤方式。某些网络管理员将运行一些软件，这些软件会试图处理每个数据包。很多时候，这些软件无法识别WebRTC的数据包，由于它们不知道如何处理，它们可能会阻拦这些数据包，例如，它们可能将WebRTC数据包视为不在端口白名单上的可疑UDP数据包。
NAT映射 #  NAT（网络地址转换）映射是使得WebRTC连接成为可能的魔法。WebRTC就是使用NAT让处于完全不同的子网中的两个peer进行通信，从而解决了上述&#34;不在同一网络中&#34;的问题。尽管它带来了新的挑战，但让我们先来解释一下NAT映射是如何工作的。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="连接"><meta property="og:description" content="为什么WebRTC需要专用的子系统进行连接？ #  目前，大多数部署的应用程序都通过客户端/服务器方式进行连接。客户端/服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。
WebRTC不使用客户端/服务器模型，它建立点对点（P2P）连接。 在P2P连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测WebRTC中的传输地址（IP和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC将收集所有可能收集的信息，并将尽力实现两个WebRTC Agent之间的双向通信。
听起来简单，建立点对点连接实际上可能会非常困难。这些Agent可能位于没有直接连接的不同网络中。即使在两个Agent可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP <-> TCP）或使用不同的IP版本（IPv4 <-> IPv6）。
尽管在建立点对点连接方面存在一些困难，在WebRTC提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端/服务器技术的一些优势。
降低带宽成本 #  由于媒体通信直接发生在peer之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。
更低延迟 #  直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。
安全的端到端通信 #  直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。
它是如何工作的？ #  上面描述的连接过程是通过Interactive Connectivity Establishment（交互式连接建立/ICE） 实现的。这是另一个在WebRTC之前就已经出现的协议。
ICE是一种用来寻找两个ICE Agent之间通信的最佳方式的协议。每个ICE Agent都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent认为这个传输地址可能可以被对端访问到。接下来ICE将确定候选地址的最佳搭配。
本章稍后将详细介绍实际的ICE过程。要了解ICE为什么存在，最好先了解我们要面临的网络特性。
现实世界的网络限制 #  ICE就是克服现实世界网络限制的方法。在我们开始讨论ICE如何解决问题之前，先讨论一下有哪些实际问题。
不在同一个网络中 #  在大多数情况下，两个WebRTC Agent不在同一个网络中。典型的呼叫通常是在没有直接连接的不同网络中的两个WebRTC Agent之间进行的。
下面是通过公共互联网连接的两个不同网络的示意图。在每个网络中，你拥有两个主机。
对于同一网络中的主机来说，互相连接非常容易。例如在192.168.0.1 -> 192.168.0.2之间通讯就很容易！这两个主机无需任何外部帮助即可相互连接。
但是，使用Router B的主机无法直接访问Router A背后的任何主机。你如何区分Router A后面的192.168.0.1主机和Router B后面相同IP的主机之间的区别呢？它们都使用内网IP！使用Router B的主机可以将数据直接发送到Router A，但是请求在那里就结束了。Router A怎么知道它应该将消息转发给哪台主机呢？
协议限制 #  有些网络不允许UDP通信，或者也有可能不允许TCP。有些网络的MTU（Maximum Transmission Unit/最大传输单元）可能非常低。网络管理员可以更改许多变量，这些修改可能会使通信变得困难。
防火墙/IDS规则 #  另一个问题是深度数据包检查和其他智能过滤方式。某些网络管理员将运行一些软件，这些软件会试图处理每个数据包。很多时候，这些软件无法识别WebRTC的数据包，由于它们不知道如何处理，它们可能会阻拦这些数据包，例如，它们可能将WebRTC数据包视为不在端口白名单上的可疑UDP数据包。
NAT映射 #  NAT（网络地址转换）映射是使得WebRTC连接成为可能的魔法。WebRTC就是使用NAT让处于完全不同的子网中的两个peer进行通信，从而解决了上述&#34;不在同一网络中&#34;的问题。尽管它带来了新的挑战，但让我们先来解释一下NAT映射是如何工作的。"><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/03-connecting/"><meta property="article:modified_time" content="2021-11-25T22:25:59+01:00"><meta property="og:site_name" content="给好奇者的WebRTC"><title>连接 | 给好奇者的WebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=stylesheet href=/book.min.6c7c6446dfdee7c8c933e9bbc6e80ee3ed6c913b2a59519f2092c3c6a9d63e55.css integrity="sha256-bHxkRt/e58jJM+m7xugO4+1skTsqWVGfIJLDxqnWPlU="><script defer src=/zh.search.min.086e1197795d83be942a3ad8601927f0528ccf0c85cd7902e913e9631597e8d3.js integrity="sha256-CG4Rl3ldg76UKjrYYBkn8FKMzwyFzXkC6RPpYxWX6NM="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/zh><span>给好奇者的WebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/02-signaling/>信令</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/ class=active>连接</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>安全性</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/05-real-time-networking/>搭建实时网络</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>媒体通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>数据通信</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/>WebRTC应用场景</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>调试</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/11-faq/>常见问题</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/12-glossary/>Glossary</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>连接</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#降低带宽成本>降低带宽成本</a></li><li><a href=#更低延迟>更低延迟</a></li><li><a href=#安全的端到端通信>安全的端到端通信</a></li></ul></li><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#现实世界的网络限制>现实世界的网络限制</a><ul><li><a href=#不在同一个网络中>不在同一个网络中</a></li><li><a href=#协议限制>协议限制</a></li><li><a href=#防火墙ids规则>防火墙/IDS规则</a></li></ul></li><li><a href=#nat映射>NAT映射</a><ul><li><a href=#创建映射>创建映射</a></li><li><a href=#映射创建的行为>映射创建的行为</a></li><li><a href=#映射过滤行为>映射过滤行为</a></li><li><a href=#映射的刷新>映射的刷新</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#协议结构>协议结构</a></li><li><a href=#创建nat映射>创建NAT映射</a></li><li><a href=#确定nat类型>确定NAT类型</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn生命周期>TURN生命周期</a></li><li><a href=#turn-使用方法>TURN 使用方法</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#创建ice-agent>创建ICE Agent</a></li><li><a href=#候选地址收集>候选地址收集</a></li><li><a href=#连通性检查>连通性检查</a></li><li><a href=#候选地址选择>候选地址选择</a></li><li><a href=#重新启动>重新启动</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=为什么webrtc需要专用的子系统进行连接>为什么WebRTC需要专用的子系统进行连接？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88webrtc%e9%9c%80%e8%a6%81%e4%b8%93%e7%94%a8%e7%9a%84%e5%ad%90%e7%b3%bb%e7%bb%9f%e8%bf%9b%e8%a1%8c%e8%bf%9e%e6%8e%a5>#</a></h1><p>目前，大多数部署的应用程序都通过客户端/服务器方式进行连接。客户端/服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。</p><p>WebRTC不使用客户端/服务器模型，它建立点对点（P2P）连接。 在P2P连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测WebRTC中的传输地址（IP和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC将收集所有可能收集的信息，并将尽力实现两个WebRTC Agent之间的双向通信。</p><p>听起来简单，建立点对点连接实际上可能会非常困难。这些Agent可能位于没有直接连接的不同网络中。即使在两个Agent可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP &lt;-> TCP）或使用不同的IP版本（IPv4 &lt;-> IPv6）。</p><p>尽管在建立点对点连接方面存在一些困难，在WebRTC提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端/服务器技术的一些优势。</p><h3 id=降低带宽成本>降低带宽成本
<a class=anchor href=#%e9%99%8d%e4%bd%8e%e5%b8%a6%e5%ae%bd%e6%88%90%e6%9c%ac>#</a></h3><p>由于媒体通信直接发生在peer之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。</p><h3 id=更低延迟>更低延迟
<a class=anchor href=#%e6%9b%b4%e4%bd%8e%e5%bb%b6%e8%bf%9f>#</a></h3><p>直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。</p><h3 id=安全的端到端通信>安全的端到端通信
<a class=anchor href=#%e5%ae%89%e5%85%a8%e7%9a%84%e7%ab%af%e5%88%b0%e7%ab%af%e9%80%9a%e4%bf%a1>#</a></h3><p>直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。</p><h2 id=它是如何工作的>它是如何工作的？
<a class=anchor href=#%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84>#</a></h2><p>上面描述的连接过程是通过Interactive Connectivity Establishment（<a href=https://tools.ietf.org/html/rfc8445>交互式连接建立/ICE</a>） 实现的。这是另一个在WebRTC之前就已经出现的协议。</p><p>ICE是一种用来寻找两个ICE Agent之间通信的最佳方式的协议。每个ICE Agent都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent认为这个传输地址可能可以被对端访问到。接下来ICE将确定候选地址的最佳搭配。</p><p>本章稍后将详细介绍实际的ICE过程。要了解ICE为什么存在，最好先了解我们要面临的网络特性。</p><h2 id=现实世界的网络限制>现实世界的网络限制
<a class=anchor href=#%e7%8e%b0%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e7%bd%91%e7%bb%9c%e9%99%90%e5%88%b6>#</a></h2><p>ICE就是克服现实世界网络限制的方法。在我们开始讨论ICE如何解决问题之前，先讨论一下有哪些实际问题。</p><h3 id=不在同一个网络中>不在同一个网络中
<a class=anchor href=#%e4%b8%8d%e5%9c%a8%e5%90%8c%e4%b8%80%e4%b8%aa%e7%bd%91%e7%bb%9c%e4%b8%ad>#</a></h3><p>在大多数情况下，两个WebRTC Agent不在同一个网络中。典型的呼叫通常是在没有直接连接的不同网络中的两个WebRTC Agent之间进行的。</p><p>下面是通过公共互联网连接的两个不同网络的示意图。在每个网络中，你拥有两个主机。</p><p><img src=../../images/03-two-networks.png alt=两个网络 title=两个网络></p><p>对于同一网络中的主机来说，互相连接非常容易。例如在<code>192.168.0.1 -> 192.168.0.2</code>之间通讯就很容易！这两个主机无需任何外部帮助即可相互连接。</p><p>但是，使用<code>Router B</code>的主机无法直接访问<code>Router A</code>背后的任何主机。你如何区分<code>Router A</code>后面的<code>192.168.0.1</code>主机和<code>Router B</code>后面相同IP的主机之间的区别呢？它们都使用内网IP！使用<code>Router B</code>的主机可以将数据直接发送到<code>Router A</code>，但是请求在那里就结束了。<code>Router A</code>怎么知道它应该将消息转发给哪台主机呢？</p><h3 id=协议限制>协议限制
<a class=anchor href=#%e5%8d%8f%e8%ae%ae%e9%99%90%e5%88%b6>#</a></h3><p>有些网络不允许UDP通信，或者也有可能不允许TCP。有些网络的MTU（Maximum Transmission Unit/最大传输单元）可能非常低。网络管理员可以更改许多变量，这些修改可能会使通信变得困难。</p><h3 id=防火墙ids规则>防火墙/IDS规则
<a class=anchor href=#%e9%98%b2%e7%81%ab%e5%a2%99ids%e8%a7%84%e5%88%99>#</a></h3><p>另一个问题是<code>深度数据包检查</code>和其他智能过滤方式。某些网络管理员将运行一些软件，这些软件会试图处理每个数据包。很多时候，这些软件无法识别WebRTC的数据包，由于它们不知道如何处理，它们可能会阻拦这些数据包，例如，它们可能将WebRTC数据包视为不在端口白名单上的可疑UDP数据包。</p><h2 id=nat映射>NAT映射
<a class=anchor href=#nat%e6%98%a0%e5%b0%84>#</a></h2><p>NAT（网络地址转换）映射是使得WebRTC连接成为可能的魔法。WebRTC就是使用NAT让处于完全不同的子网中的两个peer进行通信，从而解决了上述"不在同一网络中"的问题。尽管它带来了新的挑战，但让我们先来解释一下NAT映射是如何工作的。</p><p>NAT映射不使用中继，代理或服务器。跟上一个例子一样，我们有<code>Agent 1</code>和<code>Agent 2</code>，它们位于不同的网络中。然而，流量穿透了路由器。看起来就像这样：</p><p><img src=../../images/03-nat-mapping.png alt=NAT映射 title=NAT映射></p><p>想要这样通信的话，你需要创建一个NAT映射。Agent 1使用端口7000与Agent 2建立WebRTC连接。这将创建一个<code>192.168.0.1:7000</code>到<code>5.0.0.1:7000</code>的绑定。然后，Agent 2将数据包发送到<code>5.0.0.1:7000</code>时，数据包会被转发给Agent 1。在这个例子中，创建一个NAT映射，就像是在路由器中做了一次自动化的端口转发。</p><p>NAT映射的缺点是：映射的形式不止一种（例如静态端口转发），并且映射的实现方式在不同的网络中也是不一样的。ISP和硬件制造商可能会以不同的方式来实现NAT映射。在某些情况下，网络管理员甚至可能禁用它。</p><p>好消息是，NAT映射的所有行为都是可以理解和观察到的，因此ICE Agent能够确认其创建了NAT映射，并确认该映射的属性。</p><p>描述这些行为的文档是 <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>。</p><h3 id=创建映射>创建映射
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e6%98%a0%e5%b0%84>#</a></h3><p>创建映射是最简单的部分。当你将数据包发送到网络外部的地址时，一个映射就被创建出来了！NAT映射只是由NAT分配的一个临时的公共IP和端口。出站的消息将被重写，使得其源地址变为新创建的映射地址。如果有消息被成功发到映射地址，消息会被自动路由返回给NAT网络中创建这个映射地址的主机。说到映射相关的细节，这就开始变得复杂了。</p><h3 id=映射创建的行为>映射创建的行为
<a class=anchor href=#%e6%98%a0%e5%b0%84%e5%88%9b%e5%bb%ba%e7%9a%84%e8%a1%8c%e4%b8%ba>#</a></h3><p>映射创建分为三类：</p><h4 id=端点无关的映射>端点无关的映射
<a class=anchor href=#%e7%ab%af%e7%82%b9%e6%97%a0%e5%85%b3%e7%9a%84%e6%98%a0%e5%b0%84>#</a></h4><p>这种创建方式为NAT网络中的所有发送者只创建一个映射。如果你将两个数据包发送到两个不同的远程地址，这个NAT映射将被重用。两个远程主机将看到相同的源IP和端口。如果远程主机响应，它将被发送回相同的本地侦听器。</p><p>这是最好的情况。要使得呼叫能够建立起来，至少一侧必须是这种类型。</p><h4 id=地址相关的映射>地址相关的映射
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e7%9b%b8%e5%85%b3%e7%9a%84%e6%98%a0%e5%b0%84>#</a></h4><p>每次将数据包发送到新地址时，都会创建一个新的映射。如果你将两个数据包发送到不同的主机，则会创建两个映射。如果将两个数据包发送到同一远程主机，但目标端口不同，则不会创建新的映射。</p><h4 id=地址和端口相关的映射>地址和端口相关的映射
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e5%92%8c%e7%ab%af%e5%8f%a3%e7%9b%b8%e5%85%b3%e7%9a%84%e6%98%a0%e5%b0%84>#</a></h4><p>如果远程IP或端口不同，则会创建一个新的映射。如果将两个数据包发送到同一远程主机，但目标端口不同，则将创建一个新的映射。</p><h3 id=映射过滤行为>映射过滤行为
<a class=anchor href=#%e6%98%a0%e5%b0%84%e8%bf%87%e6%bb%a4%e8%a1%8c%e4%b8%ba>#</a></h3><p>映射过滤是关于允许谁使用映射的规则。它们分为三个类似的类别：</p><h4 id=端点无关的过滤>端点无关的过滤
<a class=anchor href=#%e7%ab%af%e7%82%b9%e6%97%a0%e5%85%b3%e7%9a%84%e8%bf%87%e6%bb%a4>#</a></h4><p>任何人都可以使用该映射。你可以与其他多个peer共享该映射，他们都可以向该映射发送流量。</p><h4 id=地址相关的过滤>地址相关的过滤
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e7%9b%b8%e5%85%b3%e7%9a%84%e8%bf%87%e6%bb%a4>#</a></h4><p>只有为其创建映射的主机才能使用该映射。如果你将数据包发送到主机<code>A</code>，则它可以根据需要响应任意数量的数据包。如果主机<code>B</code>尝试将数据包发送到该映射，将被忽略。</p><h4 id=地址和端口相关的过滤>地址和端口相关的过滤
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e5%92%8c%e7%ab%af%e5%8f%a3%e7%9b%b8%e5%85%b3%e7%9a%84%e8%bf%87%e6%bb%a4>#</a></h4><p>仅有创建映射的主机和端口可以使用该映射。如果你将数据包发送到主机<code>A:5000</code>，则它可以根据需要响应任意数量的数据包。如果主机<code>A：5001</code>尝试将数据包发送到该映射，将被忽略。</p><h3 id=映射的刷新>映射的刷新
<a class=anchor href=#%e6%98%a0%e5%b0%84%e7%9a%84%e5%88%b7%e6%96%b0>#</a></h3><p>通常的建议是，如果5分钟未使用映射，则应将其销毁。但这完全取决于ISP或硬件制造商。</p><blockquote class="book-hint info">译注：换个说法，NAT映射的创建即是NAT网络中的主机<code>发送</code>数据时，路由器的处理方式；而过滤即是<code>接收</code>数据时，路由器的处理方式。映射的刷新即是路由器<code>释放</code>映射的处理方式。不同网络情况不同，因此某些特定的搭配会导致两个网络间无法建立P2P连接。在穿透相关的技术中，将不同的情况称为不同的<code>锥形</code>。</blockquote><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN（NAT会话传输实用程序）是一种用来配合NAT使用的协议。这是WebRTC（和ICE！）之前的另一项技术。它由<a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>定义，该文件还定义了STUN数据包结构。STUN协议也在ICE/TURN中被使用。</p><p>STUN很有用，因为它允许以编程方式创建NAT映射。在STUN之前，我们能够创建NAT映射，但是我们不知道映射的IP和端口是什么！STUN不仅使你能够创建映射，还可以让你获取映射的详细信息，你可以他人分享这些详细信息，然后他们便可以通过你刚刚创建的映射向你传回数据。</p><p>让我们从对STUN的基本描述开始。稍后，我们再将话题扩展到TURN和ICE的用法。现在，我们只打算描述请求/响应流程来创建映射。然后，我们将讨论如何获取该映射的详细信息以便与他人共享。当你在ICE URLs中有一个用于WebRTC PeerConnection的<code>stun:</code>服务器时，此过程就会发生。简而言之，STUN向NAT外部的STUN服务器发送请求，服务器返回其在请求中观察到的内容，STUN根据这些内容来帮助NAT后面的端点找出已创建的映射。</p><h3 id=协议结构>协议结构
<a class=anchor href=#%e5%8d%8f%e8%ae%ae%e7%bb%93%e6%9e%84>#</a></h3><p>每个STUN数据包都具有以下结构：</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-消息类型>STUN 消息类型
<a class=anchor href=#stun-%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b>#</a></h4><p>每个STUN数据包都有一个类型。目前，我们仅关心以下几种：</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><p>为了创建一个NAT映射，我们发出一个<code>Binding Request</code>。然后服务器回应一个<code>Binding Response</code>。</p><h4 id=消息长度>消息长度
<a class=anchor href=#%e6%b6%88%e6%81%af%e9%95%bf%e5%ba%a6>#</a></h4><p>这就是<code>Data</code>段的长度。这一段中包含由<code>消息类型</code>所定义的任意数据。</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>指的是固定值<code>0x2112A442</code>，以网络字节顺序发送。这个值有助于将STUN流量与其他协议区分开。</p><h4 id=交互transactionid>交互（Transaction）ID
<a class=anchor href=#%e4%ba%a4%e4%ba%92transactionid>#</a></h4><p>一个96-bit的标识符，用于唯一标识一个请求/响应对。这可以帮助你配对请求和响应。</p><h4 id=数据>数据
<a class=anchor href=#%e6%95%b0%e6%8d%ae>#</a></h4><p>数据将包含一个STUN属性的列表。一个STUN属性具有以下结构：</p><pre><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><code>STUN Binding Request</code>不使用任何属性。这意味着一个<code>STUN Binding Request</code>仅包含header。</p><p><code>STUN Binding Response</code>使用一个<code>XOR-MAPPED-ADDRESS (0x0020)</code>。此属性包含一个IP和一个端口。这正是所创建的NAT映射的IP和端口！</p><h3 id=创建nat映射>创建NAT映射
<a class=anchor href=#%e5%88%9b%e5%bb%banat%e6%98%a0%e5%b0%84>#</a></h3><p>使用STUN创建NAT映射只需要发送一个请求！你向STUN服务器发送一个<code>STUN Binding Request</code>。然后，STUN服务器回应一个<code>STUN Binding Response</code>。
该<code>STUN Binding Response</code>将包含<code>映射地址</code>。<code>映射地址</code>是STUN服务器看到你的方式，也是你的<code>NAT映射</code>。
如果你希望某人向你发送数据包，那么你应该共享该<code>映射地址</code>。</p><p>人们还会将<code>映射地址</code>称为<code>公网IP</code>或<code>Server Reflexive Candidate</code>。</p><h3 id=确定nat类型>确定NAT类型
<a class=anchor href=#%e7%a1%ae%e5%ae%9anat%e7%b1%bb%e5%9e%8b>#</a></h3><p>不幸的是，<code>映射地址</code>可能并非在所有情况下都可用。如果是<code>地址相关的映射</code>，则只有STUN服务器才能将流量发送回给你。如果你共享它，那么另一个peer尝试向该地址发送的消息将被丢弃。这使得该peer无法与别的peer交流。如果STUN服务器还可以为你将数据包转发给对端peer，你可能会发现<code>地址相关的映射</code>问题实际上是可以解决的！这也就是下面将要说到的TURN解决方案。</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a>定义了一种方法，可以运行一个测试来确定你的NAT类型。这很有用，因为你可能会提前知道是否可以进行直接连接。</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>在无法建立直接连接的情况下，<a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a>中定义了TURN（使用中继穿透NAT）。当你的两个peer的NAT类型不兼容，或者双方使用不同协议时，就需要使用TURN！TURN也可以被用于保护隐私的目的。如果通过TURN运行所有通讯，客户的真实地址在对端是被隐藏的。</p><p>TURN使用专用服务器。该服务器充当客户端的代理。客户端连接到TURN服务器并创建一个对应的<code>Allocation</code>。通过创建该<code>Allocation</code>，客户端将获得一个临时<code>IP/端口/协议</code>三元组，其他peer可以使用该<code>IP/端口/协议</code>将数据发送给该客户端。这个新的监听地址被称为<code>中继传输地址</code>。你可将其视为转发地址并分享给他人，以便其他人可以通过TURN向你发送流量！对于每个将获得该<code>中继传输地址</code>的peer，你必须为其创建一个新的<code>Permission</code>，以允许它与你进行通信。</p><p>当你通过TURN发送出站流量时，它会通过<code>中继传输地址</code>发送。当远程peer获得该出站流量时，他们会看到数据来自TURN服务器。</p><h3 id=turn生命周期>TURN生命周期
<a class=anchor href=#turn%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h3><p>下面就是一个客户端创建TURN <code>allocation</code>时必须做的所有事情。对于其他peer而言，与使用TURN服务器的客户端进行通信和其他客户端没有任何区别，先获得IP和端口，然后像跟其他任何主机一样通信。</p><h4 id=allocations>Allocations
<a class=anchor href=#allocations>#</a></h4><p>Allocations是TURN的核心。本质上，一个<code>allocation</code>就是一个"TURN会话&rdquo;。要创建一个TURN allocation，你需要与TURN <code>Server Transport Address</code>（服务器传输地址，通常在3478端口）进行通信。</p><p>创建allocation时，你需要提供/确定以下内容：</p><ul><li>用户名/密码 - 创建TURN allocation时需要身份验证。</li><li>Allocation传输方式 - <code>中继传输地址</code>可以是UDP或TCP方式。</li><li>连续端口 - 你可以为多个allocation请求顺序排列的一系列端口，这点与WebRTC无关。</li></ul><p>如果请求成功，你将在TURN服务器上获得响应，在响应的数据部分，包含以下的STUN属性：</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>TURN Client</code>的<code>Mapped Address</code>。当有人将数据发送到<code>中继传输地址</code>时，数据将被转发到该地址。</li><li><code>RELAYED-ADDRESS</code> - 这是你提供给其他客户端的地址。如果有人将数据包发送到该地址，数据包会被转发到TURN客户端。</li><li><code>LIFETIME</code> - Allocation被销毁的时间。你可以通过发送<code>Refresh</code>请求来延长这一时间。</li></ul><blockquote class="book-hint info">译注：上面两个地址很拗口，但实际上理解起来并不复杂。<code>Mapped Address</code>是Turn Client的实际地址，也就是Turn Server收到数据包时的<code>目标地址</code>。而<code>Relayed Address</code>是Turn Client的名义地址，也就是其他WebRTC Agent要发送数据给这个Turn Client时，所使用的地址。</blockquote><h4 id=权限>权限
<a class=anchor href=#%e6%9d%83%e9%99%90>#</a></h4><p>在你为远程主机创建权限之前，远程主机是无法通过你的<code>中继传输地址</code>发送数据的。所谓创建权限，即是告知TURN服务器一个"可以用来发送入站流量"的IP和端口。</p><p>远程主机需要先为你提供TURN服务器上使用的IP和端口。这意味着它应该先向TURN服务器发送一个<code>STUN绑定请求</code>。 有时会发生这样一个常见的错误情况，即是远程主机发送<code>STUN绑定请求</code>到另外一台服务器，然后再要求TURN服务器为此IP创建权限。</p><p>对于上面那种错误情况，假设你要为一个使用<code>地址相关的映射</code>的NAT网络的主机创建权限，如果你从其他TURN服务器生成<code>映射地址</code>，则所有入站流量都将被丢弃。因为每次他们与其他主机通信时，它都会生成一个新的映射。如果未被刷新，权限将在5分钟后过期。</p><blockquote class="book-hint info">译注：对于这个常见的错误情况，实际指的是被连接的主机从TURN服务器以外的STUN/TURN服务器获取本机IP，再告知发起连接的主机这样的情况。当被连接的主机使用<code>地址相关的映射</code>类型的NAT时，它获取的IP在当前的TURN服务器上是无效的。</blockquote><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>这是TURN客户端将消息发送到远端peer时所使用的两个消息。</p><p>SendIndication是一个自包含的消息。它包含你希望发送的数据，以及你希望发送的目标。如果你要向远端peer发送大量消息的话，这种方式很昂贵。因为如果要发送1,000条消息，目标IP地址就被重复了1,000次！</p><p>ChannelData允许你发送数据，但不需要重复IP地址。你需要先创建一个具有IP和端口的通道（Channel）。然后使用ChannelId发送，IP和端口将在服务器端被填充进去。如果你要发送大量消息，这是更好的选择。</p><h4 id=刷新>刷新
<a class=anchor href=#%e5%88%b7%e6%96%b0>#</a></h4><p>Allocations将自动销毁。要避免其过早销毁，TURN客户端必须在创建allocation时指定的<code>LIFETIME</code>到来之前，及时刷新它们。</p><h3 id=turn-使用方法>TURN 使用方法
<a class=anchor href=#turn-%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95>#</a></h3><p>TURN有两种用法。通常情况下，一个peer会作为"TURN客户端"连接，而另一方则直接进行通信。在某些情况下，你可能在两侧都需要使用TURN服务。举例来说，当两个客户端都位于在禁用UDP的网络中时，只能通过TCP连接到各自的TURN服务器来建立连接。</p><p>下面这些图有助于说明TURN的用法。</p><h4 id=单个-turn-allocation-通信>单个 TURN Allocation 通信
<a class=anchor href=#%e5%8d%95%e4%b8%aa-turn-allocation-%e9%80%9a%e4%bf%a1>#</a></h4><p><img src=../../images/03-one-turn-allocation.png alt="单个 TURN Allocation" title="单个 TURN Allocation"></p><h4 id=双重-turn-allocation-通信>双重 TURN Allocation 通信
<a class=anchor href=#%e5%8f%8c%e9%87%8d-turn-allocation-%e9%80%9a%e4%bf%a1>#</a></h4><p><img src=../../images/03-two-turn-allocations.png alt="双重 TURN Allocation" title="双重 TURN Allocation"></p><blockquote class="book-hint info">译注：单个TURN Allocation的情况，指的是一个TURN Client和另一个可访问的UDP Client的通信。双重TURN Allocation的情况，指的是两个TURN Client之间通信。</blockquote><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE（交互式连接建立）是WebRTC连接两个Agent的方式。这也是一项WebRTC前就有的技术，在<a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>中定义！ICE是用于建立连接的协议。它会确定两个peer之间所有可能的路由，然后确保你保持连接状态。</p><p>这些路由被称为<code>Candidate Pair（候选地址对）</code>，也就是本地地址和远程地址的配对。这就是STUN和TURN在ICE中发挥作用的地方。这些地址可以是你的本地IP地址，<code>NAT映射</code>或<code>中继传输地址</code>。通信双方需要收集它们要使用的所有地址，交换这些地址，然后尝试连接！</p><p>两个ICE Agent使用ICE ping数据包（正式名称为连通性检查）通信以建立连接。一旦建立连接后，他们就可以发送任何数据。感觉就像使用普通socket一样。连通性检查使用STUN协议。</p><h3 id=创建ice-agent>创建ICE Agent
<a class=anchor href=#%e5%88%9b%e5%bb%baice-agent>#</a></h3><p>ICE Agent要么处于<code>控制中</code>，要么处于<code>受控中</code>。<code>控制中</code>的 Agent是决定选择<code>候选对</code>的 Agent。通常来说，发送offer的peer是<code>控制中</code>的一方。</p><p>每一方都必须有一个<code>用户片段</code>和一个<code>密码</code>。必须先交换这两个值，接下来才能进行连接性检查。<code>用户片段</code>以纯文本形式发送，用于多个ICE会话的解复用（demux）。
<code>密码</code>用于生成<code>MESSAGE-INTEGRITY</code>属性。在每个STUN数据包的末尾，都有这个属性，该属性是使用<code>密码</code>作为密钥的整个数据包的哈希值。这用于验证数据包并确保它未被篡改。</p><p>对于WebRTC，所有这些值都通过上一章中所述的<code>会话描述</code>进行分发。</p><h3 id=候选地址收集>候选地址收集
<a class=anchor href=#%e5%80%99%e9%80%89%e5%9c%b0%e5%9d%80%e6%94%b6%e9%9b%86>#</a></h3><p>现在，我们需要收集所有可能联通的地址。这些地址被称为候选地址(Candidate)。</p><h4 id=主机>主机
<a class=anchor href=#%e4%b8%bb%e6%9c%ba>#</a></h4><p>主机候选地址直接在本地接口上侦听。可以是UDP或TCP方式。</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>mDNS候选地址类似于主机候选地址，但是其IP地址是隐藏的。你不必给对方提供你的IP地址，只需要给他们提供一个UUID作为主机名。然后设置一个多播监听器，并在有人请求你发布的UUID时进行响应。</p><p>如果你与Agent位于同一网络中，则可以通过多播找到彼此。如果不在同一网络中，则将无法连接（除非网络管理员明确配置网络以允许多播数据包通过）。</p><p>这对于保护隐私很有用。以前，用户可以通过WebRTC使用主机候选地址（甚至无需尝试与你连接）来找出你的本地IP地址。而使用mDNS候选地址的话，他们只能获得随机的UUID。</p><h4 id=服务器自反server-reflextive>服务器自反（Server Reflextive）
<a class=anchor href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%87%aa%e5%8f%8dserver-reflextive>#</a></h4><p>服务器自反候选地址是通过对STUN服务器执行<code>STUN绑定请求</code>时生成的。</p><p>当你收到<code>STUN绑定响应</code>时，<code>XOR-MAPPED-ADDRESS</code>就是你的服务器自反候选地址。</p><h4 id=peer自反>Peer自反
<a class=anchor href=#peer%e8%87%aa%e5%8f%8d>#</a></h4><p>Peer自反候选地址是指，当你从你不知道的地址收到入站请求时，由于ICE是经过身份验证的协议，因此你知道这些传输是合法的，这只是意味着远端Peer是通过它也不知道的地址与你通信。</p><p>这通常会发生在这样的情况下，当<code>主机候选地址</code>与<code>服务器自反候选地址</code>进行通信时，由于你是在子网外部进行通信，因此创建了一个新的<code>NAT映射</code>。还记得我们说过的连通性检查实际上是STUN数据包吗？STUN响应的格式自然允许peer报告Peer自反地址。</p><h4 id=中继>中继
<a class=anchor href=#%e4%b8%ad%e7%bb%a7>#</a></h4><p>中继候选地址是通过使用TURN服务器生成的。</p><p>在与TURN服务器进行初始握手之后，你将获得<code>RELAYED-ADDRESS</code>，这就是你的中继候选地址。</p><h3 id=连通性检查>连通性检查
<a class=anchor href=#%e8%bf%9e%e9%80%9a%e6%80%a7%e6%a3%80%e6%9f%a5>#</a></h3><p>现在我们知道了远程Agent的<code>用户片段</code>，<code>密码</code>和候选地址。我们可以尝试连接了！ 候选地址可以相互配对。因此，如果每边有3个候选地址，那么现在就有9个候选地址对。</p><p>看起来像这样</p><p><img src=../../images/03-connectivity-checks.png alt=连通性检查 title=连通性检查></p><h3 id=候选地址选择>候选地址选择
<a class=anchor href=#%e5%80%99%e9%80%89%e5%9c%b0%e5%9d%80%e9%80%89%e6%8b%a9>#</a></h3><p><code>控制中</code>的Agent和<code>受控中</code>的Agent都开始在每个候选地址对上发送流量数据。这样是必须的，因为如果一个Agent位于一个<code>地址相关映射</code>的网络中，这样会创建<code>Peer自反候选地址</code>。</p><p>每个收到流量数据的<code>候选地址对</code>，会被提升为<code>有效候选地址</code>对。接下来，<code>控制中</code>的Agent将指定一个<code>有效候选地址</code>对。这就是<code>提名候选地址对</code>。然后，<code>控制中</code>的Agent和<code>受控中</code>的Agent再尝试进行一轮双向通信。如果成功，则<code>提名候选地址对</code>将成为<code>选定的候选地址对</code>！它将被用于后面的会话中。</p><h3 id=重新启动>重新启动
<a class=anchor href=#%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8>#</a></h3><p>如果<code>选定的候选地址对</code>由于任何原因停止工作（如：NAT映射到期，TURN服务器崩溃等），则ICEAgent将进入<code>失败</code>状态。此时可以重新启动两个Agent，然后重新完整执行整个过程。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/03-connecting/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Svenska</a></li><li class=active><a href=https://webrtcforthecurious.com/zh/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
日本語</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/bf9a5cb7bbf9fe7a42f24ee08d9472d1b523b234 title="最后修改者 jngd | November 25, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 25, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content.zh-cn/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#降低带宽成本>降低带宽成本</a></li><li><a href=#更低延迟>更低延迟</a></li><li><a href=#安全的端到端通信>安全的端到端通信</a></li></ul></li><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#现实世界的网络限制>现实世界的网络限制</a><ul><li><a href=#不在同一个网络中>不在同一个网络中</a></li><li><a href=#协议限制>协议限制</a></li><li><a href=#防火墙ids规则>防火墙/IDS规则</a></li></ul></li><li><a href=#nat映射>NAT映射</a><ul><li><a href=#创建映射>创建映射</a></li><li><a href=#映射创建的行为>映射创建的行为</a></li><li><a href=#映射过滤行为>映射过滤行为</a></li><li><a href=#映射的刷新>映射的刷新</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#协议结构>协议结构</a></li><li><a href=#创建nat映射>创建NAT映射</a></li><li><a href=#确定nat类型>确定NAT类型</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn生命周期>TURN生命周期</a></li><li><a href=#turn-使用方法>TURN 使用方法</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#创建ice-agent>创建ICE Agent</a></li><li><a href=#候选地址收集>候选地址收集</a></li><li><a href=#连通性检查>连通性检查</a></li><li><a href=#候选地址选择>候选地址选择</a></li><li><a href=#重新启动>重新启动</a></li></ul></li></ul></nav></div></aside></main></body></html>