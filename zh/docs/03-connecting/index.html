<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="连接 # 为什么 WebRTC 需要专用的子系统进行连接？ # 目前，大多数部署的应用程序都通过客户端 / 服务器方式进行连接。客户端 / 服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。
WebRTC 不使用客户端 / 服务器模型，它建立点对点（P2P）连接。 在 P2P 连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测 WebRTC 中的传输地址（IP 和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC 将收集所有可能收集的信息，并将尽力实现两个 WebRTC Agent 之间的双向通信。
听起来简单，建立点对点连接实际上可能会非常困难。这些 Agent 可能位于没有直接连接的不同网络中。即使在两个 Agent 可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP <-> TCP）或使用不同的 IP 版本（IPv4 <-> IPv6）。
尽管在建立点对点连接方面存在一些困难，在 WebRTC 提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端 / 服务器技术的一些优势。
降低带宽成本 # 由于媒体通信直接发生在 peer 之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。
更低延迟 # 直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。
安全的端到端通信 # 直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。
它是如何工作的？ # 上面描述的连接过程是通过 Interactive Connectivity Establishment（交互式连接建立 /ICE） 实现的。这是另一个在 WebRTC 之前就已经出现的协议。
ICE 是一种用来寻找两个 ICE Agent 之间通信的最佳方式的协议。每个 ICE Agent 都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent 认为这个传输地址可能可以被对端访问到。接下来 ICE 将确定候选地址的最佳搭配。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/03-connecting/"><meta property="og:site_name" content="给好奇者的WebRTC"><meta property="og:title" content="连接"><meta property="og:description" content="连接 # 为什么 WebRTC 需要专用的子系统进行连接？ # 目前，大多数部署的应用程序都通过客户端 / 服务器方式进行连接。客户端 / 服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。
WebRTC 不使用客户端 / 服务器模型，它建立点对点（P2P）连接。 在 P2P 连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测 WebRTC 中的传输地址（IP 和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC 将收集所有可能收集的信息，并将尽力实现两个 WebRTC Agent 之间的双向通信。
听起来简单，建立点对点连接实际上可能会非常困难。这些 Agent 可能位于没有直接连接的不同网络中。即使在两个 Agent 可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP <-> TCP）或使用不同的 IP 版本（IPv4 <-> IPv6）。
尽管在建立点对点连接方面存在一些困难，在 WebRTC 提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端 / 服务器技术的一些优势。
降低带宽成本 # 由于媒体通信直接发生在 peer 之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。
更低延迟 # 直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。
安全的端到端通信 # 直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。
它是如何工作的？ # 上面描述的连接过程是通过 Interactive Connectivity Establishment（交互式连接建立 /ICE） 实现的。这是另一个在 WebRTC 之前就已经出现的协议。
ICE 是一种用来寻找两个 ICE Agent 之间通信的最佳方式的协议。每个 ICE Agent 都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent 认为这个传输地址可能可以被对端访问到。接下来 ICE 将确定候选地址的最佳搭配。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-08-04T01:28:50+08:00"><title>连接 | 给好奇者的WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/zh/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.3010f895b5ac0d7726f337b8e62d437ce44907a39a1c966472a902d2d47b2a23.js integrity="sha256-MBD4lbWsDXcm8ze45i1DfORJB6OaHJZkcqkC0tR7KiM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>给好奇者的WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=/zh/docs/02-signaling/>信令</a></li><li><a href=/zh/docs/03-connecting/ class=active>连接</a></li><li><a href=/zh/docs/04-securing/>安全性</a></li><li><a href=/zh/docs/05-real-time-networking/>搭建实时网络</a></li><li><a href=/zh/docs/06-media-communication/>媒体通信</a></li><li><a href=/zh/docs/07-data-communication/>数据通信</a></li><li><a href=/zh/docs/08-applied-webrtc/>WebRTC 应用场景</a></li><li><a href=/zh/docs/09-debugging/>调试</a></li><li><a href=/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=/zh/docs/11-faq/>常见问题</a></li><li><a href=/zh/docs/12-glossary/>术语</a></li><li><a href=/zh/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>连接</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#为什么-webrtc-需要专用的子系统进行连接>为什么 WebRTC 需要专用的子系统进行连接？</a><ul><li><a href=#降低带宽成本>降低带宽成本</a></li><li><a href=#更低延迟>更低延迟</a></li><li><a href=#安全的端到端通信>安全的端到端通信</a></li></ul></li><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#现实世界的网络限制>现实世界的网络限制</a><ul><li><a href=#不在同一个网络中>不在同一个网络中</a></li><li><a href=#协议限制>协议限制</a></li><li><a href=#防火墙-ids-规则>防火墙 /IDS 规则</a></li></ul></li><li><a href=#nat-映射>NAT 映射</a><ul><li><a href=#创建映射>创建映射</a></li><li><a href=#映射创建的行为>映射创建的行为</a></li><li><a href=#映射过滤行为>映射过滤行为</a></li><li><a href=#映射的刷新>映射的刷新</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#协议结构>协议结构</a></li><li><a href=#创建-nat-映射>创建 NAT 映射</a></li><li><a href=#确定-nat-类型>确定 NAT 类型</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-生命周期>TURN 生命周期</a></li><li><a href=#turn-使用方法>TURN 使用方法</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#创建-ice-agent>创建 ICE Agent</a></li><li><a href=#候选地址收集>候选地址收集</a></li><li><a href=#连通性检查>连通性检查</a></li><li><a href=#候选地址选择>候选地址选择</a></li><li><a href=#重新启动>重新启动</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=连接>连接
<a class=anchor href=#%e8%bf%9e%e6%8e%a5>#</a></h1><h2 id=为什么-webrtc-需要专用的子系统进行连接>为什么 WebRTC 需要专用的子系统进行连接？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88-webrtc-%e9%9c%80%e8%a6%81%e4%b8%93%e7%94%a8%e7%9a%84%e5%ad%90%e7%b3%bb%e7%bb%9f%e8%bf%9b%e8%a1%8c%e8%bf%9e%e6%8e%a5>#</a></h2><p>目前，大多数部署的应用程序都通过客户端 / 服务器方式进行连接。客户端 / 服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。</p><p>WebRTC 不使用客户端 / 服务器模型，它建立点对点（P2P）连接。 在 P2P 连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测 WebRTC 中的传输地址（IP 和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC 将收集所有可能收集的信息，并将尽力实现两个 WebRTC Agent 之间的双向通信。</p><p>听起来简单，建立点对点连接实际上可能会非常困难。这些 Agent 可能位于没有直接连接的不同网络中。即使在两个 Agent 可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP &lt;-> TCP）或使用不同的 IP 版本（IPv4 &lt;-> IPv6）。</p><p>尽管在建立点对点连接方面存在一些困难，在 WebRTC 提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端 / 服务器技术的一些优势。</p><h3 id=降低带宽成本>降低带宽成本
<a class=anchor href=#%e9%99%8d%e4%bd%8e%e5%b8%a6%e5%ae%bd%e6%88%90%e6%9c%ac>#</a></h3><p>由于媒体通信直接发生在 peer 之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。</p><h3 id=更低延迟>更低延迟
<a class=anchor href=#%e6%9b%b4%e4%bd%8e%e5%bb%b6%e8%bf%9f>#</a></h3><p>直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。</p><h3 id=安全的端到端通信>安全的端到端通信
<a class=anchor href=#%e5%ae%89%e5%85%a8%e7%9a%84%e7%ab%af%e5%88%b0%e7%ab%af%e9%80%9a%e4%bf%a1>#</a></h3><p>直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。</p><h2 id=它是如何工作的>它是如何工作的？
<a class=anchor href=#%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84>#</a></h2><p>上面描述的连接过程是通过 Interactive Connectivity Establishment（<a href=https://tools.ietf.org/html/rfc8445>交互式连接建立 /ICE</a>） 实现的。这是另一个在 WebRTC 之前就已经出现的协议。</p><p>ICE 是一种用来寻找两个 ICE Agent 之间通信的最佳方式的协议。每个 ICE Agent 都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent 认为这个传输地址可能可以被对端访问到。接下来 ICE 将确定候选地址的最佳搭配。</p><p>本章稍后将详细介绍实际的 ICE 过程。要了解 ICE 为什么存在，最好先了解我们要面临的网络特性。</p><h2 id=现实世界的网络限制>现实世界的网络限制
<a class=anchor href=#%e7%8e%b0%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e7%bd%91%e7%bb%9c%e9%99%90%e5%88%b6>#</a></h2><p>ICE 就是克服现实世界网络限制的方法。在我们开始讨论 ICE 如何解决问题之前，先讨论一下有哪些实际问题。</p><h3 id=不在同一个网络中>不在同一个网络中
<a class=anchor href=#%e4%b8%8d%e5%9c%a8%e5%90%8c%e4%b8%80%e4%b8%aa%e7%bd%91%e7%bb%9c%e4%b8%ad>#</a></h3><p>在大多数情况下，两个 WebRTC Agent 不在同一个网络中。典型的呼叫通常是在没有直接连接的不同网络中的两个 WebRTC Agent 之间进行的。</p><p>下面是通过公共互联网连接的两个不同网络的示意图。在每个网络中，你拥有两个主机。</p><p><img src=../../images/03-two-networks.png alt=两个网络 title=两个网络></p><p>对于同一网络中的主机来说，互相连接非常容易。例如在 <code>192.168.0.1 -> 192.168.0.2</code> 之间通讯就很容易！这两个主机无需任何外部帮助即可相互连接。</p><p>但是，使用 <code>Router B</code> 的主机无法直接访问 <code>Router A</code> 背后的任何主机。你如何区分 <code>Router A</code> 后面的 <code>192.168.0.1</code> 主机和 <code>Router B</code> 后面相同 IP 的主机之间的区别呢？它们都使用内网 IP！使用 <code>Router B</code> 的主机可以将数据直接发送到 <code>Router A</code>，但是请求在那里就结束了。<code>Router A</code> 怎么知道它应该将消息转发给哪台主机呢？</p><h3 id=协议限制>协议限制
<a class=anchor href=#%e5%8d%8f%e8%ae%ae%e9%99%90%e5%88%b6>#</a></h3><p>有些网络不允许 UDP 通信，或者也有可能不允许 TCP。有些网络的 MTU（Maximum Transmission Unit/ 最大传输单元）可能非常低。网络管理员可以更改许多变量，这些修改可能会使通信变得困难。</p><h3 id=防火墙-ids-规则>防火墙 /IDS 规则
<a class=anchor href=#%e9%98%b2%e7%81%ab%e5%a2%99-ids-%e8%a7%84%e5%88%99>#</a></h3><p>另一个问题是<code>深度数据包检查</code>和其他智能过滤方式。某些网络管理员将运行一些软件，这些软件会试图处理每个数据包。很多时候，这些软件无法识别 WebRTC 的数据包，由于它们不知道如何处理，它们可能会阻拦这些数据包，例如，它们可能将 WebRTC 数据包视为不在端口白名单上的可疑 UDP 数据包。</p><h2 id=nat-映射>NAT 映射
<a class=anchor href=#nat-%e6%98%a0%e5%b0%84>#</a></h2><p>NAT（网络地址转换）映射是使得 WebRTC 连接成为可能的魔法。WebRTC 就是使用 NAT 让处于完全不同的子网中的两个 peer 进行通信，从而解决了上述 " 不在同一网络中 " 的问题。尽管它带来了新的挑战，但让我们先来解释一下 NAT 映射是如何工作的。</p><p>NAT 映射不使用中继，代理或服务器。跟上一个例子一样，我们有 <code>Agent 1</code> 和 <code>Agent 2</code>，它们位于不同的网络中。然而，流量穿透了路由器。看起来就像这样：</p><p><img src=../../images/03-nat-mapping.png alt="NAT 映射" title=NAT映射></p><p>想要这样通信的话，你需要创建一个 NAT 映射。Agent 1 使用端口 7000 与 Agent 2 建立 WebRTC 连接。这将创建一个 <code>192.168.0.1:7000</code> 到 <code>5.0.0.1:7000</code> 的绑定。然后，Agent 2 将数据包发送到 <code>5.0.0.1:7000</code> 时，数据包会被转发给 Agent 1。在这个例子中，创建一个 NAT 映射，就像是在路由器中做了一次自动化的端口转发。</p><p>NAT 映射的缺点是：映射的形式不止一种（例如静态端口转发），并且映射的实现方式在不同的网络中也是不一样的。ISP 和硬件制造商可能会以不同的方式来实现 NAT 映射。在某些情况下，网络管理员甚至可能禁用它。</p><p>好消息是，NAT 映射的所有行为都是可以理解和观察到的，因此 ICE Agent 能够确认其创建了 NAT 映射，并确认该映射的属性。</p><p>描述这些行为的文档是 <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>。</p><h3 id=创建映射>创建映射
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e6%98%a0%e5%b0%84>#</a></h3><p>创建映射是最简单的部分。当你将数据包发送到网络外部的地址时，一个映射就被创建出来了！NAT 映射只是由 NAT 分配的一个临时的公共 IP 和端口。出站的消息将被重写，使得其源地址变为新创建的映射地址。如果有消息被成功发到映射地址，消息会被自动路由返回给 NAT 网络中创建这个映射地址的主机。说到映射相关的细节，这就开始变得复杂了。</p><h3 id=映射创建的行为>映射创建的行为
<a class=anchor href=#%e6%98%a0%e5%b0%84%e5%88%9b%e5%bb%ba%e7%9a%84%e8%a1%8c%e4%b8%ba>#</a></h3><p>映射创建分为三类：</p><h4 id=端点无关的映射>端点无关的映射
<a class=anchor href=#%e7%ab%af%e7%82%b9%e6%97%a0%e5%85%b3%e7%9a%84%e6%98%a0%e5%b0%84>#</a></h4><p>这种创建方式为 NAT 网络中的所有发送者只创建一个映射。如果你将两个数据包发送到两个不同的远程地址，这个 NAT 映射将被重用。两个远程主机将看到相同的源 IP 和端口。如果远程主机响应，它将被发送回相同的本地侦听器。</p><p>这是最好的情况。要使得呼叫能够建立起来，至少一侧必须是这种类型。</p><h4 id=地址相关的映射>地址相关的映射
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e7%9b%b8%e5%85%b3%e7%9a%84%e6%98%a0%e5%b0%84>#</a></h4><p>每次将数据包发送到新地址时，都会创建一个新的映射。如果你将两个数据包发送到不同的主机，则会创建两个映射。如果将两个数据包发送到同一远程主机，但目标端口不同，则不会创建新的映射。</p><h4 id=地址和端口相关的映射>地址和端口相关的映射
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e5%92%8c%e7%ab%af%e5%8f%a3%e7%9b%b8%e5%85%b3%e7%9a%84%e6%98%a0%e5%b0%84>#</a></h4><p>如果远程 IP 或端口不同，则会创建一个新的映射。如果将两个数据包发送到同一远程主机，但目标端口不同，则将创建一个新的映射。</p><h3 id=映射过滤行为>映射过滤行为
<a class=anchor href=#%e6%98%a0%e5%b0%84%e8%bf%87%e6%bb%a4%e8%a1%8c%e4%b8%ba>#</a></h3><p>映射过滤是关于允许谁使用映射的规则。它们分为三个类似的类别：</p><h4 id=端点无关的过滤>端点无关的过滤
<a class=anchor href=#%e7%ab%af%e7%82%b9%e6%97%a0%e5%85%b3%e7%9a%84%e8%bf%87%e6%bb%a4>#</a></h4><p>任何人都可以使用该映射。你可以与其他多个 peer 共享该映射，他们都可以向该映射发送流量。</p><h4 id=地址相关的过滤>地址相关的过滤
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e7%9b%b8%e5%85%b3%e7%9a%84%e8%bf%87%e6%bb%a4>#</a></h4><p>只有为其创建映射的主机才能使用该映射。如果你将数据包发送到主机 <code>A</code>，则它可以根据需要响应任意数量的数据包。如果主机 <code>B</code> 尝试将数据包发送到该映射，将被忽略。</p><h4 id=地址和端口相关的过滤>地址和端口相关的过滤
<a class=anchor href=#%e5%9c%b0%e5%9d%80%e5%92%8c%e7%ab%af%e5%8f%a3%e7%9b%b8%e5%85%b3%e7%9a%84%e8%bf%87%e6%bb%a4>#</a></h4><p>仅有创建映射的主机和端口可以使用该映射。如果你将数据包发送到主机 <code>A:5000</code>，则它可以根据需要响应任意数量的数据包。如果主机 <code>A：5001</code> 尝试将数据包发送到该映射，将被忽略。</p><h3 id=映射的刷新>映射的刷新
<a class=anchor href=#%e6%98%a0%e5%b0%84%e7%9a%84%e5%88%b7%e6%96%b0>#</a></h3><p>通常的建议是，如果 5 分钟未使用映射，则应将其销毁。但这完全取决于 ISP 或硬件制造商。</p><blockquote class="book-hint info">译注：换个说法，NAT 映射的创建即是 NAT 网络中的主机<code>发送</code>数据时，路由器的处理方式；而过滤即是<code>接收</code>数据时，路由器的处理方式。映射的刷新即是路由器<code>释放</code>映射的处理方式。不同网络情况不同，因此某些特定的搭配会导致两个网络间无法建立 P2P 连接。在穿透相关的技术中，将不同的情况称为不同的<code>锥形</code>。</blockquote><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN（NAT 会话传输实用程序）是一种用来配合 NAT 使用的协议。这是 WebRTC（和 ICE！）之前的另一项技术。它由<a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>定义，该文件还定义了 STUN 数据包结构。STUN 协议也在 ICE/TURN 中被使用。</p><p>STUN 很有用，因为它允许以编程方式创建 NAT 映射。在 STUN 之前，我们能够创建 NAT 映射，但是我们不知道映射的 IP 和端口是什么！STUN 不仅使你能够创建映射，还可以让你获取映射的详细信息，你可以他人分享这些详细信息，然后他们便可以通过你刚刚创建的映射向你传回数据。</p><p>让我们从对 STUN 的基本描述开始。稍后，我们再将话题扩展到 TURN 和 ICE 的用法。现在，我们只打算描述请求 / 响应流程来创建映射。然后，我们将讨论如何获取该映射的详细信息以便与他人共享。当你在 ICE URLs 中有一个用于 WebRTC PeerConnection 的 <code>stun:</code> 服务器时，此过程就会发生。简而言之，STUN 向 NAT 外部的 STUN 服务器发送请求，服务器返回其在请求中观察到的内容，STUN 根据这些内容来帮助 NAT 后面的端点找出已创建的映射。</p><h3 id=协议结构>协议结构
<a class=anchor href=#%e5%8d%8f%e8%ae%ae%e7%bb%93%e6%9e%84>#</a></h3><p>每个 STUN 数据包都具有以下结构：</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-消息类型>STUN 消息类型
<a class=anchor href=#stun-%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b>#</a></h4><p>每个 STUN 数据包都有一个类型。目前，我们仅关心以下几种：</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><p>为了创建一个 NAT 映射，我们发出一个 <code>Binding Request</code>。然后服务器回应一个 <code>Binding Response</code>。</p><h4 id=消息长度>消息长度
<a class=anchor href=#%e6%b6%88%e6%81%af%e9%95%bf%e5%ba%a6>#</a></h4><p>这就是 <code>Data</code> 段的长度。这一段中包含由<code>消息类型</code>所定义的任意数据。</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>指的是固定值 <code>0x2112A442</code>，以网络字节顺序发送。这个值有助于将 STUN 流量与其他协议区分开。</p><h4 id=交互transactionid>交互（Transaction）ID
<a class=anchor href=#%e4%ba%a4%e4%ba%92transactionid>#</a></h4><p>一个 96-bit 的标识符，用于唯一标识一个请求 / 响应对。这可以帮助你配对请求和响应。</p><h4 id=数据>数据
<a class=anchor href=#%e6%95%b0%e6%8d%ae>#</a></h4><p>数据将包含一个 STUN 属性的列表。一个 STUN 属性具有以下结构：</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><code>STUN Binding Request</code> 不使用任何属性。这意味着一个 <code>STUN Binding Request</code> 仅包含 header。</p><p><code>STUN Binding Response</code> 使用一个 <code>XOR-MAPPED-ADDRESS (0x0020)</code>。此属性包含一个 IP 和一个端口。这正是所创建的 NAT 映射的 IP 和端口！</p><h3 id=创建-nat-映射>创建 NAT 映射
<a class=anchor href=#%e5%88%9b%e5%bb%ba-nat-%e6%98%a0%e5%b0%84>#</a></h3><p>使用 STUN 创建 NAT 映射只需要发送一个请求！你向 STUN 服务器发送一个 <code>STUN Binding Request</code>。然后，STUN 服务器回应一个 <code>STUN Binding Response</code>。
该 <code>STUN Binding Response</code> 将包含<code>映射地址</code>。<code>映射地址</code>是 STUN 服务器看到你的方式，也是你的 <code>NAT 映射</code>。
如果你希望某人向你发送数据包，那么你应该共享该<code>映射地址</code>。</p><p>人们还会将<code>映射地址</code>称为<code>公网 IP</code> 或 <code>Server Reflexive Candidate</code>。</p><h3 id=确定-nat-类型>确定 NAT 类型
<a class=anchor href=#%e7%a1%ae%e5%ae%9a-nat-%e7%b1%bb%e5%9e%8b>#</a></h3><p>不幸的是，<code>映射地址</code>可能并非在所有情况下都可用。如果是<code>地址相关的映射</code>，则只有 STUN 服务器才能将流量发送回给你。如果你共享它，那么另一个 peer 尝试向该地址发送的消息将被丢弃。这使得该 peer 无法与别的 peer 交流。如果 STUN 服务器还可以为你将数据包转发给对端 peer，你可能会发现<code>地址相关的映射</code>问题实际上是可以解决的！这也就是下面将要说到的 TURN 解决方案。</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a>定义了一种方法，可以运行一个测试来确定你的 NAT 类型。这很有用，因为你可能会提前知道是否可以进行直接连接。</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>在无法建立直接连接的情况下，<a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a>中定义了 TURN（使用中继穿透 NAT）。当你的两个 peer 的 NAT 类型不兼容，或者双方使用不同协议时，就需要使用 TURN！TURN 也可以被用于保护隐私的目的。如果通过 TURN 运行所有通讯，客户的真实地址在对端是被隐藏的。</p><p>TURN 使用专用服务器。该服务器充当客户端的代理。客户端连接到 TURN 服务器并创建一个对应的 <code>Allocation</code>。通过创建该 <code>Allocation</code>，客户端将获得一个临时 <code>IP/ 端口 / 协议</code>三元组，其他 peer 可以使用该 <code>IP/ 端口 / 协议</code>将数据发送给该客户端。这个新的监听地址被称为<code>中继传输地址</code>。你可将其视为转发地址并分享给他人，以便其他人可以通过 TURN 向你发送流量！对于每个将获得该<code>中继传输地址</code>的 peer，你必须为其创建一个新的 <code>Permission</code>，以允许它与你进行通信。</p><p>当你通过 TURN 发送出站流量时，它会通过<code>中继传输地址</code>发送。当远程 peer 获得该出站流量时，他们会看到数据来自 TURN 服务器。</p><h3 id=turn-生命周期>TURN 生命周期
<a class=anchor href=#turn-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h3><p>下面就是一个客户端创建 TURN <code>allocation</code> 时必须做的所有事情。对于其他 peer 而言，与使用 TURN 服务器的客户端进行通信和其他客户端没有任何区别，先获得 IP 和端口，然后像跟其他任何主机一样通信。</p><h4 id=allocations>Allocations
<a class=anchor href=#allocations>#</a></h4><p>Allocations 是 TURN 的核心。本质上，一个 <code>allocation</code> 就是一个 &ldquo;TURN 会话 &ldquo;。要创建一个 TURN allocation，你需要与 TURN <code>Server Transport Address</code>（服务器传输地址，通常在 3478 端口）进行通信。</p><p>创建 allocation 时，你需要提供 / 确定以下内容：</p><ul><li>用户名 / 密码 - 创建 TURN allocation 时需要身份验证。</li><li>Allocation 传输方式 - 服务器（<code>中继传输地址</code>）与 peer 之间的传输协议， 可以是 UDP 或 TCP。</li><li>连续端口 - 你可以为多个 allocation 请求顺序排列的一系列端口，这点与 WebRTC 无关。</li></ul><p>如果请求成功，你将在 TURN 服务器上获得响应，在响应的数据部分，包含以下的 STUN 属性：</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>TURN Client</code> 的 <code>Mapped Address</code>。当有人将数据发送到<code>中继传输地址</code>时，数据将被转发到该地址。</li><li><code>RELAYED-ADDRESS</code> - 这是你提供给其他客户端的地址。如果有人将数据包发送到该地址，数据包会被转发到 TURN 客户端。</li><li><code>LIFETIME</code> - Allocation 被销毁的时间。你可以通过发送 <code>Refresh</code> 请求来延长这一时间。</li></ul><blockquote class="book-hint info">译注：上面两个地址很拗口，但实际上理解起来并不复杂。<code>Mapped Address</code> 是 Turn Client 的实际地址，也就是 Turn Server 收到数据包时的<code>目标地址</code>。而 <code>Relayed Address</code> 是 Turn Client 的名义地址，也就是其他 WebRTC Agent 要发送数据给这个 Turn Client 时，所使用的地址。</blockquote><h4 id=权限>权限
<a class=anchor href=#%e6%9d%83%e9%99%90>#</a></h4><p>在你为远程主机创建权限之前，远程主机是无法通过你的<code>中继传输地址</code>发送数据的。所谓创建权限，即是告知 TURN 服务器一个 " 可以用来发送入站流量 " 的 IP 和端口。</p><p>远程主机需要先为你提供 TURN 服务器上使用的 IP 和端口。这意味着它应该先向 TURN 服务器发送一个 <code>STUN 绑定请求</code>。 有时会发生这样一个常见的错误情况，即是远程主机发送 <code>STUN 绑定请求</code>到另外一台服务器，然后再要求 TURN 服务器为此 IP 创建权限。</p><p>对于上面那种错误情况，假设你要为一个使用<code>地址相关的映射</code>的 NAT 网络的主机创建权限，如果你从其他 TURN 服务器生成<code>映射地址</code>，则所有入站流量都将被丢弃。因为每次他们与其他主机通信时，它都会生成一个新的映射。如果未被刷新，权限将在 5 分钟后过期。</p><blockquote class="book-hint info">译注：对于这个常见的错误情况，实际指的是被连接的主机从 TURN 服务器以外的 STUN/TURN 服务器获取本机 IP，再告知发起连接的主机这样的情况。当被连接的主机使用<code>地址相关的映射</code>类型的 NAT 时，它获取的 IP 在当前的 TURN 服务器上是无效的。</blockquote><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>这是 TURN 客户端将消息发送到远端 peer 时所使用的两个消息。</p><p>SendIndication 是一个自包含的消息。它包含你希望发送的数据，以及你希望发送的目标。如果你要向远端 peer 发送大量消息的话，这种方式很昂贵。因为如果要发送 1,000 条消息，目标 IP 地址就被重复了 1,000 次！</p><p>ChannelData 允许你发送数据，但不需要重复 IP 地址。你需要先创建一个具有 IP 和端口的通道（Channel）。然后使用 ChannelId 发送，IP 和端口将在服务器端被填充进去。如果你要发送大量消息，这是更好的选择。</p><h4 id=刷新>刷新
<a class=anchor href=#%e5%88%b7%e6%96%b0>#</a></h4><p>Allocations 将自动销毁。要避免其过早销毁，TURN 客户端必须在创建 allocation 时指定的 <code>LIFETIME</code> 到来之前，及时刷新它们。</p><h3 id=turn-使用方法>TURN 使用方法
<a class=anchor href=#turn-%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95>#</a></h3><p>TURN 有两种用法。通常情况下，一个 peer 会作为 &ldquo;TURN 客户端 " 连接，而另一方则直接进行通信。在某些情况下，你可能在两侧都需要使用 TURN 服务。举例来说，当两个客户端都位于在禁用 UDP 的网络中时，只能通过 TCP 连接到各自的 TURN 服务器来建立连接。</p><p>下面这些图有助于说明 TURN 的用法。</p><h4 id=单个-turn-allocation-通信>单个 TURN Allocation 通信
<a class=anchor href=#%e5%8d%95%e4%b8%aa-turn-allocation-%e9%80%9a%e4%bf%a1>#</a></h4><p><img src=../../images/03-one-turn-allocation.png alt="单个 TURN Allocation" title="单个 TURN Allocation"></p><h4 id=双重-turn-allocation-通信>双重 TURN Allocation 通信
<a class=anchor href=#%e5%8f%8c%e9%87%8d-turn-allocation-%e9%80%9a%e4%bf%a1>#</a></h4><p><img src=../../images/03-two-turn-allocations.png alt="双重 TURN Allocation" title="双重 TURN Allocation"></p><blockquote class="book-hint info">译注：单个 TURN Allocation 的情况，指的是一个 TURN Client 和另一个可访问的 UDP Client 的通信。双重 TURN Allocation 的情况，指的是两个 TURN Client 之间通信。</blockquote><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE（交互式连接建立）是 WebRTC 连接两个 Agent 的方式。这也是一项 WebRTC 前就有的技术，在<a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>中定义！ICE 是用于建立连接的协议。它会确定两个 peer 之间所有可能的路由，然后确保你保持连接状态。</p><p>这些路由被称为 <code>Candidate Pair（候选地址对）</code>，也就是本地地址和远程地址的配对。这就是 STUN 和 TURN 在 ICE 中发挥作用的地方。这些地址可以是你的本地 IP 地址，<code>NAT 映射</code>或<code>中继传输地址</code>。通信双方需要收集它们要使用的所有地址，交换这些地址，然后尝试连接！</p><p>两个 ICE Agent 使用 ICE ping 数据包（正式名称为连通性检查）通信以建立连接。一旦建立连接后，他们就可以发送任何数据。感觉就像使用普通 socket 一样。连通性检查使用 STUN 协议。</p><h3 id=创建-ice-agent>创建 ICE Agent
<a class=anchor href=#%e5%88%9b%e5%bb%ba-ice-agent>#</a></h3><p>ICE Agent 要么处于<code>控制中</code>，要么处于<code>受控中</code>。<code>控制中</code>的 Agent 是决定选择<code>候选对</code>的 Agent。通常来说，发送 offer 的 peer 是<code>控制中</code>的一方。</p><p>每一方都必须有一个<code>用户片段</code>和一个<code>密码</code>。必须先交换这两个值，接下来才能进行连接性检查。<code>用户片段</code>以纯文本形式发送，用于多个 ICE 会话的解复用（demux）。
<code>密码</code>用于生成 <code>MESSAGE-INTEGRITY</code> 属性。在每个 STUN 数据包的末尾，都有这个属性，该属性是使用<code>密码</code>作为密钥的整个数据包的哈希值。这用于验证数据包并确保它未被篡改。</p><p>对于 WebRTC，所有这些值都通过上一章中所述的<code>会话描述</code>进行分发。</p><h3 id=候选地址收集>候选地址收集
<a class=anchor href=#%e5%80%99%e9%80%89%e5%9c%b0%e5%9d%80%e6%94%b6%e9%9b%86>#</a></h3><p>现在，我们需要收集所有可能联通的地址。这些地址被称为候选地址 (Candidate)。</p><h4 id=主机>主机
<a class=anchor href=#%e4%b8%bb%e6%9c%ba>#</a></h4><p>主机候选地址直接在本地接口上侦听。可以是 UDP 或 TCP 方式。</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>mDNS 候选地址类似于主机候选地址，但是其 IP 地址是隐藏的。你不必给对方提供你的 IP 地址，只需要给他们提供一个 UUID 作为主机名。然后设置一个多播监听器，并在有人请求你发布的 UUID 时进行响应。</p><p>如果你与 Agent 位于同一网络中，则可以通过多播找到彼此。如果不在同一网络中，则将无法连接（除非网络管理员明确配置网络以允许多播数据包通过）。</p><p>这对于保护隐私很有用。以前，用户可以通过 WebRTC 使用主机候选地址（甚至无需尝试与你连接）来找出你的本地 IP 地址。而使用 mDNS 候选地址的话，他们只能获得随机的 UUID。</p><h4 id=服务器自反server-reflextive>服务器自反（Server Reflextive）
<a class=anchor href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%87%aa%e5%8f%8dserver-reflextive>#</a></h4><p>服务器自反候选地址是通过对 STUN 服务器执行 <code>STUN 绑定请求</code>时生成的。</p><p>当你收到 <code>STUN 绑定响应</code>时，<code>XOR-MAPPED-ADDRESS</code> 就是你的服务器自反候选地址。</p><h4 id=peer-自反>Peer 自反
<a class=anchor href=#peer-%e8%87%aa%e5%8f%8d>#</a></h4><p>当远端 Peer 从其之前未知的地址收到本端发出的请求时，远端 Peer 将会报告（反射）他看到的本端地址给我们，这个地址就是本端的 Peer 自反候选地址。由于 ICE 是经过身份验证的协议，因此远端 Peer 知道是本端而非其他人在与他通信。</p><p>这通常会发生在这样的情况下，当<code>主机候选地址</code>与<code>服务器自反候选地址</code>进行通信时，由于你是在子网外部进行通信，因此创建了一个新的 <code>NAT 映射</code>。还记得我们说过的连通性检查实际上是 STUN 数据包吗？STUN 响应的格式自然允许 peer 报告 Peer 自反地址。</p><h4 id=中继>中继
<a class=anchor href=#%e4%b8%ad%e7%bb%a7>#</a></h4><p>中继候选地址是通过使用 TURN 服务器生成的。</p><p>在与 TURN 服务器进行初始握手之后，你将获得 <code>RELAYED-ADDRESS</code>，这就是你的中继候选地址。</p><h3 id=连通性检查>连通性检查
<a class=anchor href=#%e8%bf%9e%e9%80%9a%e6%80%a7%e6%a3%80%e6%9f%a5>#</a></h3><p>现在我们知道了远程 Agent 的<code>用户片段</code>，<code>密码</code>和候选地址。我们可以尝试连接了！ 候选地址可以相互配对。因此，如果每边有 3 个候选地址，那么现在就有 9 个候选地址对。</p><p>看起来像这样</p><p><img src=../../images/03-connectivity-checks.png alt=连通性检查 title=连通性检查></p><h3 id=候选地址选择>候选地址选择
<a class=anchor href=#%e5%80%99%e9%80%89%e5%9c%b0%e5%9d%80%e9%80%89%e6%8b%a9>#</a></h3><p><code>控制中</code>的 Agent 和<code>受控中</code>的 Agent 都开始在每个候选地址对上发送流量数据。这样是必须的，因为如果一个 Agent 位于一个<code>地址相关映射</code>的网络中，这样会创建 <code>Peer 自反候选地址</code>。</p><p>每个收到流量数据的<code>候选地址对</code>，会被提升为<code>有效候选地址</code>对。接下来，<code>控制中</code>的 Agent 将指定一个<code>有效候选地址</code>对。这就是<code>提名候选地址对</code>。然后，<code>控制中</code>的 Agent 和<code>受控中</code>的 Agent 再尝试进行一轮双向通信。如果成功，则<code>提名候选地址对</code>将成为<code>选定的候选地址对</code>！它将被用于后面的会话中。</p><h3 id=重新启动>重新启动
<a class=anchor href=#%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8>#</a></h3><p>如果<code>选定的候选地址对</code>由于任何原因停止工作（如：NAT 映射到期，TURN 服务器崩溃等），则 ICEAgent 将进入<code>失败</code>状态。此时可以重新启动两个 Agent，然后重新完整执行整个过程。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/16e937c5a7f77e756086253bded0903902ca0de2 title='最后修改者 Yang2096 | 八月 3, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>八月 3, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#为什么-webrtc-需要专用的子系统进行连接>为什么 WebRTC 需要专用的子系统进行连接？</a><ul><li><a href=#降低带宽成本>降低带宽成本</a></li><li><a href=#更低延迟>更低延迟</a></li><li><a href=#安全的端到端通信>安全的端到端通信</a></li></ul></li><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#现实世界的网络限制>现实世界的网络限制</a><ul><li><a href=#不在同一个网络中>不在同一个网络中</a></li><li><a href=#协议限制>协议限制</a></li><li><a href=#防火墙-ids-规则>防火墙 /IDS 规则</a></li></ul></li><li><a href=#nat-映射>NAT 映射</a><ul><li><a href=#创建映射>创建映射</a></li><li><a href=#映射创建的行为>映射创建的行为</a></li><li><a href=#映射过滤行为>映射过滤行为</a></li><li><a href=#映射的刷新>映射的刷新</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#协议结构>协议结构</a></li><li><a href=#创建-nat-映射>创建 NAT 映射</a></li><li><a href=#确定-nat-类型>确定 NAT 类型</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-生命周期>TURN 生命周期</a></li><li><a href=#turn-使用方法>TURN 使用方法</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#创建-ice-agent>创建 ICE Agent</a></li><li><a href=#候选地址收集>候选地址收集</a></li><li><a href=#连通性检查>连通性检查</a></li><li><a href=#候选地址选择>候选地址选择</a></li><li><a href=#重新启动>重新启动</a></li></ul></li></ul></nav></div></aside></main></body></html>