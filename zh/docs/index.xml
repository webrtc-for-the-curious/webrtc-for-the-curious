<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on 给好奇者的WebRTC</title><link>https://webrtcforthecurious.com/zh/docs/</link><description>Recent content in Docs on 给好奇者的WebRTC</description><generator>Hugo</generator><language>zh</language><atom:link href="https://webrtcforthecurious.com/zh/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>是什么，为什么，如何使用</title><link>https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/</guid><description>是什么，为什么，如何使用 # WebRTC 是什么？ # WebRTC 是 Web 实时通信（Real-Time Communication）的缩写，它既是 API 也是协议。WebRTC 协议是两个 WebRTC Agent 协商双向安全实时通信的一组规则。开发人员可以通过 WebRTC API 使用 WebRTC 协议。目前 WebRTC API 仅有 JavaScript 版本。
可以用 HTTP 和 Fetch API 之间的关系作为类比。WebRTC 协议就是 HTTP，而 WebRTC API 就是 Fetch API。
除了 JavaScript 语言，WebRTC 协议也可以在其他 API 和语言中使用。你还可以找到 WebRTC 的服务器和特定领域的工具。所有这些实现都使用 WebRTC 协议，以便它们可以彼此交互。
WebRTC 协议由 IETF 工作组在rtcweb中维护。WebRTC API 的 W3C 文档在webrtc。
为什么我应该学习 WebRTC？ # 下面这些是 WebRTC 可以带给你的东西。这并不是一份详尽的清单，只是列举一些你在学习中可能感兴趣的点。如果你还不了解所有这些术语，请不要担心，本书将陆续将这些概念教给你。
开放标准 多种实现 在浏览器中可用 强制加密 NAT 穿透 复用现有技术 拥塞控制 亚秒级延迟 WebRTC 协议是一组其他技术的集合体 # 这个主题需要整本书来解释。但是，首先，我们将其分为四个步骤。</description></item><item><title>信令</title><link>https://webrtcforthecurious.com/zh/docs/02-signaling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/02-signaling/</guid><description>信令 # 什么是 WebRTC 信令？ # 当一个 WebRTC Agent 被创建时，它对其他 peer 一无所知。它不知道它将与谁联系，也不知道它们将发送些什么！ 信令是使呼叫成为可能的初始引导程序。交换信令消息后，WebRTC Agent 才可以直接相互通信。
信令消息只是文本。WebRTC Agent 并不关心它们的传递方式。信令通常使用 Websockets 分享，但这不是必需的。
WebRTC 信令如何工作？ # WebRTC 使用到一种现有的协议，称为会话描述协议（Session Description Protocol，简称 SDP）。两个 WebRTC Agent 会将建立连接所需的所有状态通过此协议来分享。该协议本身亦易于阅读和理解。 但要理解 WebRTC 填充于协议中的所有值，是有些复杂的。
SDP 并不是 WebRTC 特有的。我们将首先学习会话描述协议，这里甚至不用提到 WebRTC。WebRTC 实际上仅是利用了 SDP 协议的子集，因此我们将仅介绍我们所需的内容。 理解协议后，我们将继续结合 WebRTC 来说明其在实际中的应用方法。
什么是 会话描述协议（SDP）？ # 会话描述协议定义于 RFC 8866 中。它是一个 key/value 协议，每一行是一个值。看起来类似于 INI 文件。 一个会话描述包含零个或多个媒体描述。对此模型，可以理解为会话描述包含了一个媒体描述的数组。
一个媒体描述通常映射到单个媒体流。因此，如果你想描述一个包含三个视频流和两个音轨的呼叫，需要五个媒体描述。
如何阅读 SDP 信息 # 会话描述中的每一行都将以一个单字符开始，这是你的 key。单字符后面将跟随一个等号。等号后的所有内容都是 value。value 结束的地方将有一个换行符。
会话描述协议定义了所有有效的 key。对于协议中定义的 key，你只能使用字母。这些 key 都有重要的意义，稍后将对此进行解释。</description></item><item><title>连接</title><link>https://webrtcforthecurious.com/zh/docs/03-connecting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/03-connecting/</guid><description>连接 # 为什么 WebRTC 需要专用的子系统进行连接？ # 目前，大多数部署的应用程序都通过客户端 / 服务器方式进行连接。客户端 / 服务器方式连接要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。
WebRTC 不使用客户端 / 服务器模型，它建立点对点（P2P）连接。 在 P2P 连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测 WebRTC 中的传输地址（IP 和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC 将收集所有可能收集的信息，并将尽力实现两个 WebRTC Agent 之间的双向通信。
听起来简单，建立点对点连接实际上可能会非常困难。这些 Agent 可能位于没有直接连接的不同网络中。即使在两个 Agent 可以直接连接的情况下，你可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP &amp;lt;-&amp;gt; TCP）或使用不同的 IP 版本（IPv4 &amp;lt;-&amp;gt; IPv6）。
尽管在建立点对点连接方面存在一些困难，在 WebRTC 提供的下面这些属性的帮助下，你仍然可以获得相对于传统客户端 / 服务器技术的一些优势。
降低带宽成本 # 由于媒体通信直接发生在 peer 之间，因此你无需为之付费，也无需托管一个单独的服务器来转发媒体。
更低延迟 # 直接通信时速度更快！当用户必须通过你的服务器运行所有内容时，这会使传输速度变慢。
安全的端到端通信 # 直接通信更安全。由于用户数据根本没有通过你的服务器，因此用户压根不需要考虑你的服务器会不会解密其数据。
它是如何工作的？ # 上面描述的连接过程是通过 Interactive Connectivity Establishment（交互式连接建立 /ICE） 实现的。这是另一个在 WebRTC 之前就已经出现的协议。
ICE 是一种用来寻找两个 ICE Agent 之间通信的最佳方式的协议。每个 ICE Agent 都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE Agent 认为这个传输地址可能可以被对端访问到。接下来 ICE 将确定候选地址的最佳搭配。</description></item><item><title>安全性</title><link>https://webrtcforthecurious.com/zh/docs/04-securing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/04-securing/</guid><description>安全性 # WebRTC 具有哪些安全性保障？ # 每个 WebRTC 连接都经过身份验证和加密。你可以确信第三方看不到你发送的内容，也无法插入虚假消息。你还可以确保与你进行通信的 WebRTC Agent 正是生成会话描述的 Agent。
没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC 无法防止会话描述被修改。攻击者可以通过更改 ICE 候选地址和证书指纹来对你进行中间人攻击（man-in-the-middle）。
译注：这里指的是，P2P 连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过 man-in-the-middle 方式伪装中间人同时与通信双方建立连接并通信。 它是如何做到的？ # WebRTC 使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / DTLS）和 安全实时传输协议（Secure Real-time Transport Protocol / SRTP）。
DTLS 使你可以协商会话，然后在两个 peer 之间安全地交换数据。它是 TLS 的同类产品，TLS 是 HTTPS 所使用的技术，而 DTLS 与 TLS 的区别仅在与其使用 UDP 而不是 TCP 作为其传输层。这也意味着 DTLS 协议必须处理不可靠的数据传输。SRTP 是专为安全的交换媒体数据而设计的。相对于 DTLS 而言，使用 SRTP 对传输媒体数据有一些优化。
DTLS 先被使用。它通过 ICE 提供的连接进行一次握手。DTLS 是一种客户端 / 服务器协议，因此其中一侧需要开始握手。客户端 / 服务器的角色是在信令中被确定的。在 DTLS 握手期间，双方都会提供证书。 握手完成后，需要将收到的证书与会话描述中的证书哈希进行比较。这是为了确定握手的目标就是你所期望的 WebRTC Agent。接下来，可以将 DTLS 连接用于 DataChannel 通信。</description></item><item><title>搭建实时网络</title><link>https://webrtcforthecurious.com/zh/docs/05-real-time-networking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/05-real-time-networking/</guid><description>实时网络 # 为什么网络在实时通信中如此重要？ # 网络是实时通信中的限制因素。在理想的世界中，我们将拥有无限的带宽，并且数据包会即时到达。但事实并非如此。网络是受限的，且其限定条件随时可能更改。测量和观察网络状况也是一个难题。根据你所使用的硬件，软件及其配置，你可能看到不同的表现。
实时通信也带来了其他大多数领域中不存在的问题。对于网站开发人员来说，如果你的网站在某些网络上运行速度较慢，那不是致命问题。只要所有数据到达，用户都会感到满意。但对于 WebRTC，如果你的数据延迟了，那就没用了。没有人在乎 5 秒钟前的电话会议中所说过的话。因此，在开发一个实时通信系统时，必须作出权衡。我的时间限制是多少，可以发送多少数据？
本章介绍了适用于数据和媒体通信的概念。在后面的章节中，我们将超出理论范围，讨论一下 WebRTC 的媒体和数据子系统如何解决这些问题。
网络的哪些属性让它很难 ? # 在所有网络上都能有效工作的代码很复杂。你会面对许多不同的因素，它们都可以相互影响。这些是开发人员将遇到的最常见问题。
带宽 # 带宽是可以在给定路径上传输的最大数据速率。请记住，它不是一个静态数字，这一点很重要。带宽会随着使用者的增多（或减少）而改变。
传输时间和往返时间 # 传输时间指的是一个数据包需要多长时间到达。像带宽一样，这不是恒定的。传输时间随时可能波动。
传输时间 = 接收时间 - 发送时间
要计算传输时间，你需要将发送方和接收方的时钟以毫秒级精度同步。 即使一个很小的偏差也会导致传输时间的测量结果不可靠。 由于 WebRTC 在高度异构的环境中运行，因此依靠主机之间完美的时间同步（来测量传输时间）几乎是不可能的。
往返时间测量是对不完美的时钟同步的一种解决方法。
（要测量往返时间，）WebRTC peer 不使用分布式时钟，而是发送一个特殊数据包，携带名为 sendertime1 的自己的时间戳。 合作的 peer 接收到这个特殊数据包后，会将时间戳返还给发送方。 当原始发送方获得返还的时间戳时，它会用当前时间 sendertime2 减去 sendertime1 时间戳。 得到的时间差称为 &amp;quot; 往返传播延迟（round-trip propagation delay）&amp;quot;，或者就使用更常见的 &amp;quot; 往返时间 &amp;ldquo;。
rtt（往返时间） = sendertime2 - sendertime1
一般认为，往返时间的一半可以用来较好地近似传输时间。 但此解决方法并非没有缺点。 它假设发送和接收数据包花费的时间是相等的。 但是，在蜂窝网络上，发送和接收操作可能不是时间对称的。 你可能已经注意到了，手机上的上传速度几乎总是低于下载速度。
传输时间 = rtt（往返时间）/2
关于往返时间测量的技术，在RTCP 的发送方和接收方报告章节中有更详细的描述。</description></item><item><title>媒体通信</title><link>https://webrtcforthecurious.com/zh/docs/06-media-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/06-media-communication/</guid><description>媒体通信 # 我可以从 WebRTC 的媒体通信中得到什么？ # WebRTC 允许你发送和接收无限多条音频和视频流。你可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！你甚至可以将网络摄像头的音频和视频放到你桌面的视频中，然后将此视频以 feed 的形式发送出去。
WebRTC 协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，你正与之通信的 WebRTC Agent 可能没有必要的工具来接受它。
WebRTC 针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC 根据网络状况作出响应，并尝试利用可用资源为你提供最佳体验。
它是如何工作的？ # WebRTC 使用RFC 1889中定义的两个既有协议 RTP 和 RTCP。
RTP（实时传输协议 /Real-time Transport Protocol）是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为你提供了实现这些规则的工具。RTP 提供了流的设计，因此你可以通过一个连接发布多个媒体源。它还为你提供了完善媒体传递途径所需的计时和排序信息。
RTCP（RTP 控制协议 /RTP Control Protocol）是用于传达有关呼叫的元数据的协议。其格式非常灵活，并允许你可以添加所需的任何元数据。这点被用来传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为你提供了响应变化的网络状况所必需的双向通信能力。
延迟与质量 # 实时媒体就是要在延迟和质量之间进行权衡。你愿意忍受的延迟时间越长，可以预期的视频质量就越高。
现实世界的局限性 # 下面这些限制都是由现实世界的局限性引起的。它们都是你需要考虑的网络特性。
视频是复杂的 # 传输视频并不容易。要存储 30 分钟未经压缩的 720p 的 8-bit 视频，你需要大约 110GB。按照这个数据，4 人电话会议就开不成了。我们需要一种缩小容量的方法，而答案就是视频压缩。但是，这并非没有缺点。
视频 101 # 我们不会深入介绍视频压缩，只需要让大家足以理解为什么 RTP 是这么设计的。视频压缩会将视频编码为一种新格式，这样可以需要较少的 bit 数来表示同一视频。
有损和无损压缩 # 你可以将视频编码为无损（无信息丢失）或有损（信息可能丢失）压缩。由于无损编码需要将更多的数据发送到对端，这样会导致更高的流延迟和更多的丢包，因此 RTP 通常使用有损压缩，即使这样可能会导致视频质量不佳。
帧内和帧间压缩 # 视频压缩有两种类型。首先是帧内压缩。帧内压缩减少了用于描述单个视频帧的 bit 数。相同的技术被用来压缩静态图片，例如 JPEG 压缩方法。</description></item><item><title>数据通信</title><link>https://webrtcforthecurious.com/zh/docs/07-data-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/07-data-communication/</guid><description>数据通信 # 我可以从 WebRTC 的数据通信中获得什么？ # WebRTC 提供用于数据通信的数据通道。在两个 peer 之间，你可以打开 65,534 个数据通道。 数据通道基于数据报，并且每个通道都有其自己的持久性设置。默认设置下，每个数据通道都能保证有序交付。
如果你从传递媒体数据的角度开始接触 WebRTC，可能数据通道看起来是一种浪费。当我只使用 HTTP 或 WebSocket 就能传递数据的时候，为什么需要整个数据通道子系统呢？
数据通道的真正强大之处在于，你可以将它们配置为像 UDP 一样进行无序 / 有损传递。 对于低延迟和高性能的情况，这是必需的。你可以测量背压，并确保你仅发送网络支持的最大数据量。
它是如何工作的？ # WebRTC 使用RFC 4960中定义的流控制传输协议（SCTP）。SCTP 是一种传输层协议，旨在替代 TCP 或 UDP。对于 WebRTC，我们将 SCTP 用作在 DTLS 连接上运行的应用层协议。
SCTP 为你提供流，并且每个流都可以独立配置。WebRTC 数据通道只是基于流的简单抽象。有关持久性和顺序的设置会被直接传递到 SCTP Agent 中。
数据通道具有 SCTP 无法表达的某些功能，例如通道标签。为了解决该问题，WebRTC 使用了RFC 8832中定义的数据通道建立协议（DCEP）。DCEP 定义了一条消息，用于传递通道标签和协议。
DCEP # DCEP 只有两个消息 DATA_CHANNEL_OPEN 和 DATA_CHANNEL_ACK。对于打开的每个数据通道，远端必须以 ack 响应。
DATA_CHANNEL_OPEN # 该消息由希望打开数据通道的 WebRTC Agent 发送。
封包格式 # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | Channel Type | Priority | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reliability Parameter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Label Length | Protocol Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \ \ / Label / \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \ \ / Protocol / \ \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 消息类型（Message Type） # 消息类型是一个静态值 0x03。</description></item><item><title>WebRTC 应用场景</title><link>https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/</guid><description>WebRTC 应用场景 # 现在你已经知道 WebRTC 的工作原理，到了使用它的时候了！本章探讨人们使用 WebRTC 构建什么以及他们是如何实现的。你将学到基于 WebRTC 发生的所有有趣的事情。WebRTC 的功能是有代价的。建立产品级的 WebRTC 服务相当有挑战性。本章将尝试解释这些挑战性的根源，这样你遇到问题时就能有所准备。
用例 # 许多人认为 WebRTC 只是一种在 web 浏览器中实现电话会议的技术。实际上，它能做的不仅如此！ WebRTC 被广泛用于各种用例。新的用例一直在出现。在本章中，我们将列出一些常见的用例，并探讨一下 WebRTC 是如何对它们进行革新的。
电话会议 # 电话会议是 WebRTC 的原始用例。该协议包含浏览器中几个必要功能，这些功能没有其他协议提供支持。你可以使用 WebSockets 构建会议系统，在各种条件都满足的情况下，它可能可以工作。但如果你希望在现实世界的网络条件下部署一些服务，那么 WebRTC 是最佳选择。
WebRTC 为媒体提供拥塞控制和自适应比特率。随着网络条件的变化，用户仍将获得最佳体验。开发人员不必编写任何其他代码来处理这些情况。
参与者可以发送和接收多个流。在呼叫过程中，他们还可以随时添加和删除这些流。编解码器也经过协商。所有这些功能都是由浏览器提供的，开发人员无需编写任何自定义代码。
数据通道也对电话会议有所助益。用户可以发送元数据或共享文档。如果更看重性能而不是可靠性，可以创建多个流并对其进行配置。
广播 # 许多使用 WebRTC 的新项目开始出现在广播领域中。协议为媒体的发布者和消费者都提供了很多支持。
浏览器中的 WebRTC 使得用户可以轻松发布视频。这样用户不需要下载新的客户端。 任何具有 Web 浏览器的平台都可以发布视频。发布者可以发送多个音轨 / 视频流，并可以随时对其进行修改或删除。传统协议中每个连接只允许一个音频或一个视频流，与之相比，这是一个巨大的改进。
WebRTC 使开发人员可以更好地控制延迟和质量之间的权衡。如果不允许延迟超过特定阈值更重要，那么为此你可能愿意容忍对解码质量做一些让步。你也可以将播放器配置为在媒体到达时立即播放。如果是使用在 TCP 之上的其他协议，要完成这一点并不是那么容易。但在浏览器中，你只需要请求数据，就这么简单。
远程访问 # 远程访问是当你通过 WebRTC 访问远端的另一台计算机。你可以完全控制远程主机，也可以只控制一个应用程序。当本地硬件无法执行繁重的计算任务时，这非常有用。例如，运行新的视频游戏或 CAD 软件。WebRTC 能够通过下面三种方式彻底改变对物理空间的需求。
WebRTC 可用于远程访问那些无法直接路由的主机。使用 NAT 遍历，你可以访问仅通过 STUN 可用的计算机。这对于安全性和隐私性非常有用。你的用户不必通过中转或所谓 &amp;quot; 跳转盒 &amp;quot; 来路由视频。NAT 遍历还使得部署更加容易。你不必担心端口转发问题或提前设置静态 IP。</description></item><item><title>调试</title><link>https://webrtcforthecurious.com/zh/docs/09-debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/09-debugging/</guid><description>调试 # 调试 WebRTC 可能是一项艰巨的任务。有很多部分都处于运行状态，每一个部分都可能出现问题。如果你不够细心，可能会浪费数周的时间来查看错误的模块。当你最终找到出错的部分时，你还需要学习一些知识才能理解问题的根源。
本章将带你学习 WebRTC 的调试。它将向你展示如何分析并定位相关问题。确定问题后，我们将快速介绍一下流行的调试工具。
分解问题 # 开始调试时，你需要先分解问题的源头。从以下题目开始：
信令故障 # 网络故障 # 使用 netcat 测试你的 STUN 服务器：
准备 20 字节的绑定请求数据包：
echo -ne &amp;#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&amp;#34; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 解释：
00 01 是消息类型。 00 00 是数据段的长度。 21 12 a4 42 是 magic cookie。 54 45 53 54 54 45 53 54 54 45 53 54 （解码成 ASCII 就是 TESTTESTTEST） 是 12 字节的 transaction ID。 发送请求并等待 32 字节的响应：</description></item><item><title>历史</title><link>https://webrtcforthecurious.com/zh/docs/10-history-of-webrtc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/10-history-of-webrtc/</guid><description>历史 # 在学习 WebRTC 时，开发人员经常对其复杂性感到沮丧，他们认为一些 WebRTC 功能与他们当前的项目无关，并希望 WebRTC 能够更简单一些。但问题是不同的开发者有迥然不同的应用场景。实时通信有着一段丰富的历史，人们在这个领域创造过很多不同的东西。
WebRTC 是由一系列协议组成的，本章包含了对这些协议作者的采访。 这些采访可以让我们更深入的了解作者们在构建每个协议时所做的设计，并以关于 WebRTC 本身的采访结束。当你理解了软件的意图和设计，你可以用它构建出更有效率的系统。
RTP # RTP 和 RTCP 是处理 WebRTC 的所有媒体传输的协议。它是在 1996 年 1 月的RFC 1889中定义的。 我们很幸运地邀请到其中一位作者Ron Frederick自己来谈论这个问题。Ron 最近向 GitHub 上传了Network Video tool，这是一个展示了 RTP 的项目。
用他自己的话讲 # 在 1992 年 10 月，我开始尝试使用 Sun VideoPix 帧采集卡，当时的想法是编写一个基于 IP 多播的网络视频会议工具。它是根据 &amp;ldquo;vat&amp;rdquo; 建模的，&amp;ldquo;vat&amp;rdquo; 是 LBL 开发的一个音频会议工具，它为参加会议的用户使用了类似的轻量级会话协议，你可以简单地使用此工具将数据发送到特定的多播组，并监听来自该组中其他小组成员的任何流量。
为了使程序真正成功，它需要先压缩视频数据，然后再将其发布到网络上。我的目标是在大约 128 kbps 或标准家庭 ISDN 线路的带宽上生成可接受的可视数据流。我还希望在一半带宽下生成仍能被观看到的东西。这意味着我需要将特定图像尺寸和帧率的视频压缩到大约 20 分之一的大小。我实现了这种压缩，并申请了专利，专利是 US5485212A：用于电话会议的软件视频压缩。
1992 年 11 月上旬，我向互联网社区发布了视频会议工具 &amp;ldquo;nv&amp;rdquo;（二进制形式）。经过一些初步测试后，它被用于在全球范围内对 11 月 Internet 工程任务组的部分进行视频广播。在 15 个国家 / 地区中，大约有 200 个子网能够接收此广播，并且一周中的某个时候，大约有 50-100 人使用 &amp;ldquo;nv&amp;rdquo; 接收了视频。</description></item><item><title>常见问题</title><link>https://webrtcforthecurious.com/zh/docs/11-faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/11-faq/</guid><description> 常见问题 # 为什么 WebRTC 使用 UDP？ NAT 穿透需要 UDP。没有 NAT 穿透，就无法建立 P2P 连接。UDP 不像 TCP 那样 &amp;quot; 保证送达 &amp;ldquo;，因此 WebRTC 在用户级别提供这一特性。
要了解更多信息，请参考 连接 章节。
数据通道最多可以有几个？ 因为流标识符有 16 位，所以最多有 65534 个通道。你可以随时关闭再创建一个新的。 WebRTC 是否有带宽限制？ 数据通道和 RTP 都使用拥塞控制。这意味着 WebRTC 会主动测量你的带宽并尝试使用最佳数值。这是一种平衡措施，这样可以尽量发送数据，而不会使网络连接过载。 我可以发送二进制数据吗？ 是的，你可以通过数据通道发送文本和二进制数据。 WebRTC 延迟怎么样？ 对于未作调整的媒体，估计不到 500 毫秒。如果你愿意为延迟调整或牺牲音质 / 画质，有开发人员将延迟降到了 100ms 以下。
数据通道支持 &amp;quot; 部分可靠性 &amp;quot; 选项，该选项可以减少由于有损连接上的数据重传而引起的延迟。如果配置正确的话，速度可以超过 TCP TLS 连接。
什么情况下我会需要无序交付的数据通道？ 有时，新的信息会淘汰旧的信息（例如对象的位置信息）；或者，每个消息都是彼此独立的，并且你需要避免行头阻塞延迟。 我可以通过数据通道发送音频或视频吗？ 是的，你可以通过数据通道发送任何数据。如果是在浏览器中这样使用，你就需要自行对数据进行解码，然后将其传递给媒体播放器进行渲染；在使用媒体通道时，这部分是自动完成的。</description></item><item><title>术语</title><link>https://webrtcforthecurious.com/zh/docs/12-glossary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/12-glossary/</guid><description>术语 # ACK: Acknowledgment (确认报文) AVP: Audio and Video profile (音频视频描述) B-Frame: Bi-directional Predicted Frame. A partial picture, is a modification of previous and future pictures. (双向预测帧，存储图片的部分信息，存储的是相对前一张图片和后一张图片的差异信息) DCEP: Data Channel Establishment Protocol defined in RFC 8832 (DataChannel 建立协议) DeMux: Demultiplexer (解复用器) DLSR: delay since last sender report (从最近一个 Sender Report 开始的时间延迟) DTLS: Datagram Transport Layer Security defined in RFC 6347 E2E: end-to-end FEC: Forward Error Correction (前向纠错) FIR: Full INTRA-frame Request (完整 I 帧请求) G.</description></item><item><title>Reference</title><link>https://webrtcforthecurious.com/zh/docs/13-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/zh/docs/13-reference/</guid><description>Reference # WebRTC(W3C) # WebRTC 1.0: Real-Time Communication Between Browsers [26 January 2021] (Status: Recommendation) Web Real-Time Communications Working Group - Publications WebRTC(RFC) # RFC8825: Overview: Real-Time Protocols for Browser-Based Applications H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8826: Security Considerations for WebRTC E. Rescorla [January 2021] (Status: PROPOSED STANDARD) RFC8836: Congestion Control Requirements for Interactive Real-Time Media R. Jesup, Z. Sarker [January 2021] (Status: INFORMATIONAL) RFC8854: WebRTC Forward Error Correction Requirements J.</description></item></channel></rss>