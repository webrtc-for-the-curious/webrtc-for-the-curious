<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="연결 # 왜 WebRTC에는 전용 ‘연결’ 하위 시스템이 필요한가요? # 대부분의 애플리케이션은 클라이언트/서버 연결을 사용합니다. 이 모델에서는 서버가 안정적인 전송 주소(IP/포트)를 가져야 하며, 클라이언트가 서버에 요청하면 서버가 응답합니다.
WebRTC는 클라이언트/서버 모델이 아니라 P2P(Peer-to-Peer) 연결을 수립합니다. P2P에서는 연결 수립의 책임이 양쪽 피어에 균등하게 분산됩니다. 이는 WebRTC에서의 전송 주소(IP/포트)를 미리 가정할 수 없고, 심지어 세션 중에도 바뀔 수 있기 때문입니다. WebRTC는 가능한 모든 정보를 수집해 두 WebRTC 에이전트 간 양방향 통신을 성사시키기 위해 많은 과정을 수행합니다."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ko/docs/03-connecting/"><meta property="og:site_name" content="호기심 많은 이를 위한 WebRTC"><meta property="og:title" content="연결"><meta property="og:description" content="연결 # 왜 WebRTC에는 전용 ‘연결’ 하위 시스템이 필요한가요? # 대부분의 애플리케이션은 클라이언트/서버 연결을 사용합니다. 이 모델에서는 서버가 안정적인 전송 주소(IP/포트)를 가져야 하며, 클라이언트가 서버에 요청하면 서버가 응답합니다.
WebRTC는 클라이언트/서버 모델이 아니라 P2P(Peer-to-Peer) 연결을 수립합니다. P2P에서는 연결 수립의 책임이 양쪽 피어에 균등하게 분산됩니다. 이는 WebRTC에서의 전송 주소(IP/포트)를 미리 가정할 수 없고, 심지어 세션 중에도 바뀔 수 있기 때문입니다. WebRTC는 가능한 모든 정보를 수집해 두 WebRTC 에이전트 간 양방향 통신을 성사시키기 위해 많은 과정을 수행합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-05T05:58:35+09:00"><title>연결 | 호기심 많은 이를 위한 WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ko/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Подключение><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ko.search.min.ff0bd92bfe13d1c7aaf7e993114720b4672b5caaa2c71caa427a6de130de2755.js integrity="sha256-/wvZK/4T0ceq9+mTEUcgtGcrXKqixxyqQnpt4TDeJ1U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ko/><span>호기심 많은 이를 위한 WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
한국어</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li></ul></li></ul><ul><li><a href=/ko/docs/01-what-why-and-how/>무엇, 왜, 어떻게?</a></li><li><a href=/ko/docs/02-signaling/>시그널링</a></li><li><a href=/ko/docs/03-connecting/ class=active>연결</a></li><li><a href=/ko/docs/04-securing/>보안</a></li><li><a href=/ko/docs/05-real-time-networking/>실시간 네트워킹</a></li><li><a href=/ko/docs/06-media-communication/>미디어 통신</a></li><li><a href=/ko/docs/07-data-communication/>데이터 통신</a></li><li><a href=/ko/docs/08-applied-webrtc/>적용 WebRTC</a></li><li><a href=/ko/docs/09-debugging/>디버깅</a></li><li><a href=/ko/docs/10-history-of-webrtc/>역사</a></li><li><a href=/ko/docs/11-faq/>자주 묻는 질문(FAQ)</a></li><li><a href=/ko/docs/12-glossary/>용어집</a></li><li><a href=/ko/docs/13-reference/>참고 자료</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>연결</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#왜-webrtc에는-전용-연결-하위-시스템이-필요한가요>왜 WebRTC에는 전용 ‘연결’ 하위 시스템이 필요한가요?</a><ul><li><a href=#대역폭-비용-절감>대역폭 비용 절감</a></li><li><a href=#더-낮은-지연>더 낮은 지연</a></li><li><a href=#안전한-종단-간e2e-통신>안전한 종단 간(E2E) 통신</a></li></ul></li><li><a href=#어떻게-동작하나요>어떻게 동작하나요?</a></li><li><a href=#실제-네트워크의-제약>실제 네트워크의 제약</a><ul><li><a href=#같은-네트워크가-아님>같은 네트워크가 아님</a></li><li><a href=#프로토콜-제한>프로토콜 제한</a></li><li><a href=#방화벽ids-규칙>방화벽/IDS 규칙</a></li></ul></li><li><a href=#nat-매핑>NAT 매핑</a><ul><li><a href=#stun>STUN</a></li><li><a href=#nat-유형-판별>NAT 유형 판별</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-수명주기>TURN 수명주기</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#ice-에이전트-생성>ICE 에이전트 생성</a></li><li><a href=#후보-수집>후보 수집</a></li><li><a href=#연결성-검사>연결성 검사</a></li><li><a href=#후보-선택>후보 선택</a></li><li><a href=#재시작>재시작</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=연결>연결
<a class=anchor href=#%ec%97%b0%ea%b2%b0>#</a></h1><h2 id=왜-webrtc에는-전용-연결-하위-시스템이-필요한가요>왜 WebRTC에는 전용 ‘연결’ 하위 시스템이 필요한가요?
<a class=anchor href=#%ec%99%9c-webrtc%ec%97%90%eb%8a%94-%ec%a0%84%ec%9a%a9-%ec%97%b0%ea%b2%b0-%ed%95%98%ec%9c%84-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9d%b4-%ed%95%84%ec%9a%94%ed%95%9c%ea%b0%80%ec%9a%94>#</a></h2><p>대부분의 애플리케이션은 클라이언트/서버 연결을 사용합니다. 이 모델에서는 서버가 안정적인 전송 주소(IP/포트)를 가져야 하며,
클라이언트가 서버에 요청하면 서버가 응답합니다.</p><p>WebRTC는 클라이언트/서버 모델이 아니라 P2P(Peer-to-Peer) 연결을 수립합니다. P2P에서는 연결 수립의 책임이 양쪽 피어에 균등하게 분산됩니다.
이는 WebRTC에서의 전송 주소(IP/포트)를 미리 가정할 수 없고, 심지어 세션 중에도 바뀔 수 있기 때문입니다. WebRTC는 가능한 모든 정보를 수집해
두 WebRTC 에이전트 간 양방향 통신을 성사시키기 위해 많은 과정을 수행합니다.</p><p>그러나 P2P 연결을 수립하는 일은 쉽지 않습니다. 서로 다른 네트워크에 있어서 직접 연결이 불가능할 수 있습니다. 직접 연결이 가능한 상황에서도
문제가 생길 수 있습니다. 어떤 경우에는 두 클라이언트가 같은 네트워크 프로토콜(UDP &lt;-> TCP)을 쓰지 않거나, 서로 다른 IP 버전(IPv4 &lt;-> IPv6)을
사용할 수 있습니다.</p><p>이러한 어려움에도 불구하고, WebRTC가 제공하는 특성 덕분에 전통적인 클라이언트/서버 기술 대비 다음과 같은 장점을 얻게 됩니다.</p><h3 id=대역폭-비용-절감>대역폭 비용 절감
<a class=anchor href=#%eb%8c%80%ec%97%ad%ed%8f%ad-%eb%b9%84%ec%9a%a9-%ec%a0%88%ea%b0%90>#</a></h3><p>미디어가 피어 간에 직접 전달되므로, 미디어를 중계하는 별도 서버를 운영하거나 비용을 지불할 필요가 없습니다.</p><h3 id=더-낮은-지연>더 낮은 지연
<a class=anchor href=#%eb%8d%94-%eb%82%ae%ec%9d%80-%ec%a7%80%ec%97%b0>#</a></h3><p>직접 통신이 더 빠릅니다! 모든 트래픽을 서버를 경유해 보내야 하면 전송이 느려집니다.</p><h3 id=안전한-종단-간e2e-통신>안전한 종단 간(E2E) 통신
<a class=anchor href=#%ec%95%88%ec%a0%84%ed%95%9c-%ec%a2%85%eb%8b%a8-%ea%b0%84e2e-%ed%86%b5%ec%8b%a0>#</a></h3><p>직접 통신은 더 안전합니다. 데이터가 서버를 경유하지 않으므로, 심지어 서버 운영자를 신뢰할 필요도 줄어듭니다.</p><h2 id=어떻게-동작하나요>어떻게 동작하나요?
<a class=anchor href=#%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%98%eb%82%98%ec%9a%94>#</a></h2><p>위 과정을 표준화한 것이 ICE(Interactive Connectivity Establishment, <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>)입니다. WebRTC 이전부터 존재하던 프로토콜입니다.</p><p>ICE는 두 ICE 에이전트가 통신하기에 최적의 경로를 찾는 프로토콜입니다. 각 ICE 에이전트는 자신에 도달 가능한 방법들을 공개하는데, 이를 후보(candidate)라 부릅니다.
후보는 다른 피어가 접근할 수 있다고 예상하는 전송 주소입니다. ICE는 이 후보들 중 최적의 쌍을 선택합니다.</p><p>구체적인 ICE 동작은 이 장 후반에서 다룹니다. 먼저 ICE가 왜 필요한지, 극복해야 하는 네트워크 행태를 이해하는 것이 도움이 됩니다.</p><h2 id=실제-네트워크의-제약>실제 네트워크의 제약
<a class=anchor href=#%ec%8b%a4%ec%a0%9c-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%ec%9d%98-%ec%a0%9c%ec%95%bd>#</a></h2><p>ICE는 현실 세계 네트워크의 제약을 극복하는 데 초점을 둡니다. 해결책을 보기 전에 문제를 먼저 짚어봅시다.</p><h3 id=같은-네트워크가-아님>같은 네트워크가 아님
<a class=anchor href=#%ea%b0%99%ec%9d%80-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%ea%b0%80-%ec%95%84%eb%8b%98>#</a></h3><p>대부분의 경우 상대 WebRTC 에이전트는 같은 네트워크에 있지 않습니다. 일반적인 통화는 서로 다른 네트워크에 있는 두 에이전트 간에 이뤄지며,
직접 연결이 없습니다.</p><p>아래는 공용 인터넷으로 연결된 두 개의 서로 다른 네트워크를 보여줍니다. 각 네트워크에는 두 개의 호스트가 있습니다.</p><p><img src=../images/03-two-networks.png alt="Two networks" title="Two networks"></p><p>같은 네트워크 내 호스트끼리는 연결이 쉽습니다. <code>192.168.0.1 -> 192.168.0.2</code> 간 통신은 어렵지 않습니다! 외부 도움 없이도 가능합니다.</p><p>하지만 <code>Router B</code> 뒤의 호스트는 <code>Router A</code> 뒤의 대상에 직접 접근할 방법이 없습니다. <code>Router A</code> 뒤의 <code>192.168.0.1</code>과 <code>Router B</code> 뒤의 동일한 IP를
어떻게 구분할까요? 둘 다 사설 IP이기 때문입니다! <code>Router B</code>의 호스트가 <code>Router A</code>로 트래픽을 보낼 수는 있지만, 요청은 라우터에서 끝납니다.
<code>Router A</code>는 어떤 호스트로 전달해야 할지 알 수 없습니다.</p><h3 id=프로토콜-제한>프로토콜 제한
<a class=anchor href=#%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c-%ec%a0%9c%ed%95%9c>#</a></h3><p>어떤 네트워크는 UDP를 전혀 허용하지 않거나, TCP를 허용하지 않을 수 있습니다. MTU(최대 전송 단위)가 매우 낮을 수도 있습니다. 네트워크 관리자가 바꿀 수 있는
변수가 많아 통신을 어렵게 만들 수 있습니다.</p><h3 id=방화벽ids-규칙>방화벽/IDS 규칙
<a class=anchor href=#%eb%b0%a9%ed%99%94%eb%b2%bdids-%ea%b7%9c%ec%b9%99>#</a></h3><p>깊은 패킷 검사(DPI) 등 지능형 필터링을 수행하는 경우도 있습니다. 일부 관리자는 모든 패킷을 해석하려는 소프트웨어를 사용합니다. 이 소프트웨어가 WebRTC를
이해하지 못하면, 화이트리스트에 없는 임의 포트의 UDP 패킷처럼 보인다는 이유로 차단할 수 있습니다.</p><h2 id=nat-매핑>NAT 매핑
<a class=anchor href=#nat-%eb%a7%a4%ed%95%91>#</a></h2><p>NAT(Network Address Translation) 매핑은 WebRTC 연결을 가능케 하는 핵심 요소입니다. 이는 앞서 언급한 “같은 네트워크가 아님” 문제를 해결하여,
완전히 다른 서브넷의 두 피어가 통신하도록 합니다. 새로운 과제를 만들기도 하지만, 먼저 NAT 매핑이 어떻게 동작하는지 살펴봅시다.</p><p>릴레이나 프록시, 서버를 사용하지 않습니다. <code>Agent 1</code>과 <code>Agent 2</code>가 서로 다른 네트워크에 있지만, 트래픽은 완전히 통과합니다. 시각화하면 다음과 같습니다.</p><p><img src=../images/03-nat-mapping.png alt="NAT mapping" title="NAT mapping"></p><p>이 통신을 가능하게 하려면 NAT 매핑을 수립합니다. Agent 1이 포트 7000을 사용해 Agent 2와 WebRTC 연결을 수립하면,
<code>192.168.0.1:7000</code> ↔ <code>5.0.0.1:7000</code> 바인딩이 생성됩니다. 이렇게 되면 Agent 2는 이 매핑으로 Agent 1에 트래픽을 보낼 수 있습니다. NAT의 동작은
매핑 정책에 따라 달라질 수 있으며, 주소/포트 의존적일 수도 있습니다. 이로 인해 직접 통신이 항상 가능한 것은 아니며, 이후에 설명할 TURN이 필요할 수 있습니다.</p><h3 id=stun>STUN
<a class=anchor href=#stun>#</a></h3><p>STUN(Session Traversal Utilities for NAT, <a href=https://datatracker.ietf.org/doc/html/rfc8489>RFC 8489</a>)은 NAT 매핑을 알아내는 표준 프로토콜입니다.
STUN 패킷은 고정 크기 헤더와 속성 목록으로 구성되며, 핵심 메시지 타입은 다음과 같습니다.</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><p>Binding Request를 STUN 서버로 보내면, 응답으로 Binding Response를 받습니다. 이 응답에 포함된 <code>XOR-MAPPED-ADDRESS(0x0020)</code> 속성이
바로 생성된 NAT 매핑의 공인 IP/포트입니다. 이를 ‘Server Reflexive 후보’라고도 부릅니다.</p><h3 id=nat-유형-판별>NAT 유형 판별
<a class=anchor href=#nat-%ec%9c%a0%ed%98%95-%ed%8c%90%eb%b3%84>#</a></h3><p>안타깝게도 매핑이 항상 유용한 것은 아닙니다. 매핑이 주소 의존적(Address Dependent)인 경우, STUN 서버만 응답을 보낼 수 있고 다른 피어의 트래픽은
드롭될 수 있습니다. 이 경우 직접 통신에는 쓸모가 없습니다. <a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a>은 NAT 유형을 판별하는 시험 방법을
정의합니다. 미리 직접 연결 가능성을 판단하는 데 유용합니다. 직접이 어렵다면 아래의 TURN을 사용합니다.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN(Traversal Using Relays around NAT, <a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a>)은 직접 연결이 불가능할 때의 해결책입니다.
서로 호환되지 않는 NAT 유형이거나, 동일한 프로토콜을 사용할 수 없는 경우에도 사용할 수 있습니다. 프라이버시를 위해서도 TURN을 쓸 수 있습니다.
모든 통신을 TURN을 통해 보내면 클라이언트의 실제 주소를 숨길 수 있습니다.</p><p>TURN은 전용 서버를 사용합니다. 클라이언트는 TURN 서버에 연결해 ‘할당(Allocation)’을 생성합니다. 그러면 임시 IP/포트/프로토콜인 <code>RELAYED-ADDRESS</code>를
부여받고, 여기에 들어오는 트래픽은 클라이언트로 포워딩됩니다. 각 원격 피어에 대해 통신을 허용하려면 ‘Permission’을 생성해야 합니다.</p><h3 id=turn-수명주기>TURN 수명주기
<a class=anchor href=#turn-%ec%88%98%eb%aa%85%ec%a3%bc%ea%b8%b0>#</a></h3><p>TURN 할당을 만들려면 다음을 수행합니다.</p><ul><li>사용자 이름/비밀번호: TURN 할당에는 인증이 필요합니다.</li><li>할당 전송 방식: 릴레이와 피어 간 전송 프로토콜(UDP 또는 TCP)</li><li>Even-Port: 연속 포트를 요청(일반 WebRTC에는 크게 중요하지 않음)</li></ul><p>성공 시 응답의 속성에는 다음이 포함됩니다.</p><ul><li><code>XOR-MAPPED-ADDRESS</code>: TURN 클라이언트의 매핑 주소. 릴레이 주소로 들어온 트래픽의 포워딩 대상</li><li><code>RELAYED-ADDRESS</code>: 다른 클라이언트에게 제공할 주소(이 주소로 오면 클라이언트로 릴레이)</li><li><code>LIFETIME</code>: 할당 만료 시간. <code>Refresh</code> 요청으로 연장 가능</li></ul><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE(Interactive Connectivity Establishment)는 WebRTC가 두 에이전트를 연결하는 방법입니다(<a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>).
두 피어 사이의 가능한 모든 경로를 파악하고, 연결 유지까지 책임지는 프로토콜입니다. 후보쌍(candidate pair)은 로컬/원격 전송 주소의 쌍이며,
여기서 STUN과 TURN이 사용됩니다. 각 측은 사용할 주소들을 수집해 교환하고, 연결을 시도합니다.</p><p>ICE 에이전트 간에는 연결성 검사(connectivity checks)라 불리는 ICE 핑(STUN 기반)을 주고받아 연결을 수립합니다. 연결이 성립하면 일반 소켓처럼
임의의 데이터를 보낼 수 있습니다.</p><h3 id=ice-에이전트-생성>ICE 에이전트 생성
<a class=anchor href=#ice-%ec%97%90%ec%9d%b4%ec%a0%84%ed%8a%b8-%ec%83%9d%ec%84%b1>#</a></h3><p>ICE 에이전트는 <code>Controlling</code> 또는 <code>Controlled</code> 역할 중 하나입니다. <code>Controlling</code> 에이전트가 최종 선택된 후보쌍을 결정합니다. 일반적으로 오퍼를
보내는 쪽이 Controlling입니다.</p><p>양쪽 모두 <code>user fragment</code>와 <code>password</code>를 가져야 하며, 연결성 검사를 시작하기 전에 교환되어야 합니다. <code>user fragment</code>는 평문으로 전송되어 여러 ICE 세션을
디멕스하는 데 유용합니다. <code>password</code>는 <code>MESSAGE-INTEGRITY</code> 계산에 사용됩니다. 각 STUN 패킷 끝에는 패킷 전체의 해시가 포함되며, 키로 <code>password</code>를
사용합니다. 이는 패킷 인증과 변조 방지에 쓰입니다. WebRTC에서는 이 값들을 앞 장에서 설명한 세션 설명을 통해 교환합니다.</p><h3 id=후보-수집>후보 수집
<a class=anchor href=#%ed%9b%84%eb%b3%b4-%ec%88%98%ec%a7%91>#</a></h3><p>이제 도달 가능한 모든 주소(후보)를 수집합니다.</p><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><p>로컬 인터페이스에서 직접 수신하는 후보입니다(UDP 또는 TCP).</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>Host 후보와 유사하지만 IP를 가리지 않고 UUID 호스트명을 제공합니다. 멀티캐스트 리스너를 띄우고, 공개한 UUID 질의에 응답합니다. 같은 네트워크면 멀티캐스트로
서로를 찾을 수 있지만, 네트워크가 다르면 일반적으로 연결되지 않습니다(관리자가 멀티캐스트 트래버설을 허용하지 않는 한). 로컬 IP 노출을 막아 프라이버시를
향상할 수 있습니다.</p><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><p>STUN Binding Request/Response를 통해 얻은 <code>XOR-MAPPED-ADDRESS</code>로 생성되는 후보입니다.</p><h4 id=peer-reflexive>Peer Reflexive
<a class=anchor href=#peer-reflexive>#</a></h4><p>알려지지 않은 주소에서 유효한(인증된) 트래픽을 받은 경우 생성되는 후보입니다. 예컨대 Host 후보 ↔ Server Reflexive 후보 간 통신에서 서브넷 외부와 통신하며
새 NAT 매핑이 생기는 경우가 이에 해당합니다. STUN 응답 형식은 피어 반사 주소를 자연스럽게 보고할 수 있습니다.</p><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><p>TURN 서버에서 핸드셰이크 후 부여되는 <code>RELAYED-ADDRESS</code>로 생성되는 후보입니다.</p><h3 id=연결성-검사>연결성 검사
<a class=anchor href=#%ec%97%b0%ea%b2%b0%ec%84%b1-%ea%b2%80%ec%82%ac>#</a></h3><p>이제 원격 에이전트의 <code>user fragment</code>, <code>password</code>, 후보를 모두 알게 되었으니 연결을 시도합니다! 모든 후보는 서로 페어링됩니다. 각 측에 후보가 3개라면
9개의 후보쌍이 만들어집니다.</p><p>시각화하면 다음과 같습니다.</p><p><img src=../images/03-connectivity-checks.png alt="Connectivity checks" title="Connectivity checks"></p><h3 id=후보-선택>후보 선택
<a class=anchor href=#%ed%9b%84%eb%b3%b4-%ec%84%a0%ed%83%9d>#</a></h3><p>Controlling/Controlled 에이전트는 모든 후보쌍에 트래픽을 시도합니다. 한 에이전트가 주소 의존 매핑 뒤에 있는 경우, 이 과정에서 Peer Reflexive 후보가
생길 수 있기 때문입니다.</p><p>트래픽이 오간 후보쌍은 <code>Valid Candidate</code>로 승격됩니다. Controlling 에이전트는 <code>Valid</code> 후보쌍 중 하나를 지명(nominate)하고, 이 쌍을 대상으로 양방향
통신을 한 번 더 시도합니다. 성공하면 <code>Selected Candidate Pair</code>가 되며, 세션 내내 이 쌍이 사용됩니다.</p><h3 id=재시작>재시작
<a class=anchor href=#%ec%9e%ac%ec%8b%9c%ec%9e%91>#</a></h3><p>선택된 후보쌍이 어떤 이유로든 동작을 멈추면(NAT 매핑 만료, TURN 장애 등) ICE 에이전트는 <code>Failed</code> 상태로 전이합니다. 양측 모두 재시작하여 전체 과정을
다시 수행할 수 있습니다.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/d197b9fa3dc748f7270405361db6750321c85ea8 title='Last modified by seonghoon.baek | 9월 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>9월 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#왜-webrtc에는-전용-연결-하위-시스템이-필요한가요>왜 WebRTC에는 전용 ‘연결’ 하위 시스템이 필요한가요?</a><ul><li><a href=#대역폭-비용-절감>대역폭 비용 절감</a></li><li><a href=#더-낮은-지연>더 낮은 지연</a></li><li><a href=#안전한-종단-간e2e-통신>안전한 종단 간(E2E) 통신</a></li></ul></li><li><a href=#어떻게-동작하나요>어떻게 동작하나요?</a></li><li><a href=#실제-네트워크의-제약>실제 네트워크의 제약</a><ul><li><a href=#같은-네트워크가-아님>같은 네트워크가 아님</a></li><li><a href=#프로토콜-제한>프로토콜 제한</a></li><li><a href=#방화벽ids-규칙>방화벽/IDS 규칙</a></li></ul></li><li><a href=#nat-매핑>NAT 매핑</a><ul><li><a href=#stun>STUN</a></li><li><a href=#nat-유형-판별>NAT 유형 판별</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-수명주기>TURN 수명주기</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#ice-에이전트-생성>ICE 에이전트 생성</a></li><li><a href=#후보-수집>후보 수집</a></li><li><a href=#연결성-검사>연결성 검사</a></li><li><a href=#후보-선택>후보 선택</a></li><li><a href=#재시작>재시작</a></li></ul></li></ul></nav></div></aside></main></body></html>