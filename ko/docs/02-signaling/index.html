<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="시그널링 # WebRTC 시그널링이란? # WebRTC 에이전트를 생성했을 때, 상대 피어에 대해 아는 것은 없습니다. 누구와 연결할지, 무엇을 보낼지 전혀 모릅니다! 시그널링은 통화를 가능하게 만드는 초기 부트스트랩 단계입니다. 이 값들을 교환한 뒤에는 WebRTC 에이전트끼리 직접 통신할 수 있습니다.
시그널링 메시지는 단지 텍스트일 뿐입니다. WebRTC 에이전트는 어떤 전송 수단을 쓰는지 신경 쓰지 않습니다. 보통 WebSocket으로 주고받지만, 필수는 아닙니다.
WebRTC 시그널링은 어떻게 동작하나? # WebRTC는 Session Description Protocol(SDP)이라는 기존 프로토콜을 사용합니다. 이 프로토콜을 통해 두 WebRTC 에이전트는 연결 수립에 필요한 모든 상태를 공유합니다."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ko/docs/02-signaling/"><meta property="og:site_name" content="호기심 많은 이를 위한 WebRTC"><meta property="og:title" content="시그널링"><meta property="og:description" content="시그널링 # WebRTC 시그널링이란? # WebRTC 에이전트를 생성했을 때, 상대 피어에 대해 아는 것은 없습니다. 누구와 연결할지, 무엇을 보낼지 전혀 모릅니다! 시그널링은 통화를 가능하게 만드는 초기 부트스트랩 단계입니다. 이 값들을 교환한 뒤에는 WebRTC 에이전트끼리 직접 통신할 수 있습니다.
시그널링 메시지는 단지 텍스트일 뿐입니다. WebRTC 에이전트는 어떤 전송 수단을 쓰는지 신경 쓰지 않습니다. 보통 WebSocket으로 주고받지만, 필수는 아닙니다.
WebRTC 시그널링은 어떻게 동작하나? # WebRTC는 Session Description Protocol(SDP)이라는 기존 프로토콜을 사용합니다. 이 프로토콜을 통해 두 WebRTC 에이전트는 연결 수립에 필요한 모든 상태를 공유합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-05T05:58:35+09:00"><title>시그널링 | 호기심 많은 이를 위한 WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ko/docs/02-signaling/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/02-signaling/ title=Signaling><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/02-signaling/ title=Signalering><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/02-signaling/ title=Сигнализация><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/02-signaling/ title=信令><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/02-signaling/ title=シグナリング><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/02-signaling/ title=سیگنالینگ><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/02-signaling/ title=Signaling><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/02-signaling/ title=Signaling><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/02-signaling/ title=Signaling><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/02-signaling/ title=Sinyalleşme><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ko.search.min.ff0bd92bfe13d1c7aaf7e993114720b4672b5caaa2c71caa427a6de130de2755.js integrity="sha256-/wvZK/4T0ceq9+mTEUcgtGcrXKqixxyqQnpt4TDeJ1U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ko/><span>호기심 많은 이를 위한 WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
한국어</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/02-signaling/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/02-signaling/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/02-signaling/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/02-signaling/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/02-signaling/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/02-signaling/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/02-signaling/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/02-signaling/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/02-signaling/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/02-signaling/>Türkçe</a></li></ul></li></ul><ul><li><a href=/ko/docs/01-what-why-and-how/>무엇, 왜, 어떻게?</a></li><li><a href=/ko/docs/02-signaling/ class=active>시그널링</a></li><li><a href=/ko/docs/03-connecting/>연결</a></li><li><a href=/ko/docs/04-securing/>보안</a></li><li><a href=/ko/docs/05-real-time-networking/>실시간 네트워킹</a></li><li><a href=/ko/docs/06-media-communication/>미디어 통신</a></li><li><a href=/ko/docs/07-data-communication/>데이터 통신</a></li><li><a href=/ko/docs/08-applied-webrtc/>적용 WebRTC</a></li><li><a href=/ko/docs/09-debugging/>디버깅</a></li><li><a href=/ko/docs/10-history-of-webrtc/>역사</a></li><li><a href=/ko/docs/11-faq/>자주 묻는 질문(FAQ)</a></li><li><a href=/ko/docs/12-glossary/>용어집</a></li><li><a href=/ko/docs/13-reference/>참고 자료</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>시그널링</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc-시그널링이란>WebRTC 시그널링이란?</a></li><li><a href=#webrtc-시그널링은-어떻게-동작하나>WebRTC 시그널링은 어떻게 동작하나?</a></li><li><a href=#session-description-protocolsdp이란>Session Description Protocol(SDP)이란?</a><ul><li><a href=#sdp-읽는-법>SDP 읽는 법</a></li><li><a href=#webrtc가-사용하는-sdp-키>WebRTC가 사용하는 SDP 키</a></li><li><a href=#세션-설명의-미디어-설명>세션 설명의 미디어 설명</a></li><li><a href=#전체-예시>전체 예시</a></li></ul></li><li><a href=#sdp와-webrtc의-결합-방식>SDP와 WebRTC의 결합 방식</a><ul><li><a href=#오퍼와-앤서>오퍼와 앤서</a></li><li><a href=#트랜시버-송수신의-단위>트랜시버: 송수신의 단위</a></li><li><a href=#webrtc가-쓰는-sdp-값들>WebRTC가 쓰는 SDP 값들</a></li><li><a href=#webrtc-세션-설명-예시>WebRTC 세션 설명 예시</a></li><li><a href=#추가-주제>추가 주제</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=시그널링>시그널링
<a class=anchor href=#%ec%8b%9c%ea%b7%b8%eb%84%90%eb%a7%81>#</a></h1><h2 id=webrtc-시그널링이란>WebRTC 시그널링이란?
<a class=anchor href=#webrtc-%ec%8b%9c%ea%b7%b8%eb%84%90%eb%a7%81%ec%9d%b4%eb%9e%80>#</a></h2><p>WebRTC 에이전트를 생성했을 때, 상대 피어에 대해 아는 것은 없습니다. 누구와 연결할지, 무엇을 보낼지 전혀 모릅니다!
시그널링은 통화를 가능하게 만드는 초기 부트스트랩 단계입니다. 이 값들을 교환한 뒤에는 WebRTC 에이전트끼리 직접 통신할 수 있습니다.</p><p>시그널링 메시지는 단지 텍스트일 뿐입니다. WebRTC 에이전트는 어떤 전송 수단을 쓰는지 신경 쓰지 않습니다. 보통 WebSocket으로 주고받지만, 필수는 아닙니다.</p><h2 id=webrtc-시그널링은-어떻게-동작하나>WebRTC 시그널링은 어떻게 동작하나?
<a class=anchor href=#webrtc-%ec%8b%9c%ea%b7%b8%eb%84%90%eb%a7%81%ec%9d%80-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%98%eb%82%98>#</a></h2><p>WebRTC는 Session Description Protocol(SDP)이라는 기존 프로토콜을 사용합니다. 이 프로토콜을 통해 두 WebRTC 에이전트는
연결 수립에 필요한 모든 상태를 공유합니다. 프로토콜 자체는 읽고 이해하기 쉽습니다. 복잡함은 WebRTC가 채워 넣는 값들을 이해하는 데서 옵니다.</p><p>이 프로토콜은 WebRTC 전용이 아닙니다. 먼저 WebRTC와 무관하게 SDP를 학습합니다. WebRTC는 이 프로토콜의 일부만 사용하므로 필요한 부분만 다룹니다.
프로토콜을 이해한 다음, WebRTC에서의 실제 사용 방법을 살펴보겠습니다.</p><h2 id=session-description-protocolsdp이란>Session Description Protocol(SDP)이란?
<a class=anchor href=#session-description-protocolsdp%ec%9d%b4%eb%9e%80>#</a></h2><p>SDP는 <a href=https://tools.ietf.org/html/rfc8866>RFC 8866</a>에 정의되어 있습니다. 각 줄이 키/값 형태이며, 값 뒤에 개행이 옵니다. INI 파일과 비슷한 느낌입니다.
세션 설명(Session Description)은 0개 이상의 미디어 설명(Media Description)을 포함합니다. 즉, 세션 설명은 미디어 설명의 배열로 모델링할 수 있습니다.</p><p>하나의 미디어 설명은 보통 하나의 미디어 스트림에 대응합니다. 예를 들어 비디오 3개와 오디오 2개로 이루어진 통화를 설명하려면 5개의 미디어 설명이 필요합니다.</p><h3 id=sdp-읽는-법>SDP 읽는 법
<a class=anchor href=#sdp-%ec%9d%bd%eb%8a%94-%eb%b2%95>#</a></h3><p>세션 설명의 모든 줄은 한 글자의 키로 시작합니다. 그 뒤에 등호가 오며, 등호 뒤가 값입니다. 값이 끝나면 개행으로 마무리합니다.</p><p>SDP는 사용할 수 있는 키를 정의합니다. 키는 알파벳 문자만 사용할 수 있으며 각 키는 중요한 의미를 갖습니다(뒤에서 설명).</p><p>다음은 SDP 일부 예시입니다.</p><pre tabindex=0><code>a=my-sdp-value
a=second-value
</code></pre><p>두 줄이 있으며, 둘 다 키는 <code>a</code>입니다. 첫 줄의 값은 <code>my-sdp-value</code>, 둘째 줄의 값은 <code>second-value</code>입니다.</p><h3 id=webrtc가-사용하는-sdp-키>WebRTC가 사용하는 SDP 키
<a class=anchor href=#webrtc%ea%b0%80-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-sdp-%ed%82%a4>#</a></h3><p>SDP에 정의된 모든 키를 WebRTC가 사용하는 것은 아닙니다. <a href=https://datatracker.ietf.org/doc/html/rfc8829>RFC 8829</a>에 정의된 JSEP(JavaScript Session Establishment Protocol)에서 사용하는 키만 중요합니다.
지금 이해해야 할 핵심 키는 다음 일곱 가지입니다.</p><ul><li><code>v</code> - 버전, 항상 <code>0</code>이어야 합니다.</li><li><code>o</code> - 오리진, 재협상 시 유용한 고유 ID를 담습니다.</li><li><code>s</code> - 세션 이름, <code>-</code> 여야 합니다.</li><li><code>t</code> - 타이밍, <code>0 0</code> 여야 합니다.</li><li><code>m</code> - 미디어 설명(<code>m=&lt;media> &lt;port> &lt;proto> &lt;fmt> ...</code>), 아래에서 자세히 설명합니다.</li><li><code>a</code> - 속성(Attribute), 자유 텍스트 필드. WebRTC에서 가장 흔한 줄입니다.</li><li><code>c</code> - 연결 정보, <code>IN IP4 0.0.0.0</code>이어야 합니다.</li></ul><h3 id=세션-설명의-미디어-설명>세션 설명의 미디어 설명
<a class=anchor href=#%ec%84%b8%ec%85%98-%ec%84%a4%eb%aa%85%ec%9d%98-%eb%af%b8%eb%94%94%ec%96%b4-%ec%84%a4%eb%aa%85>#</a></h3><p>하나의 세션 설명은 제한 없이 많은 미디어 설명을 담을 수 있습니다.</p><p>미디어 설명은 여러 포맷 목록을 포함하며, 각 포맷은 RTP Payload Type에 매핑됩니다. 실제 코덱은 미디어 설명 내부의 <code>rtpmap</code> 속성으로 정의합니다.
RTP와 Payload Type의 중요성은 미디어 장에서 자세히 다룹니다. 각 미디어 설명에는 제한 없이 많은 속성을 가질 수 있습니다.</p><p>다음 예시를 봅시다.</p><pre tabindex=0><code>v=0
m=audio 4000 RTP/AVP 111
a=rtpmap:111 OPUS/48000/2
m=video 4000 RTP/AVP 96
a=rtpmap:96 VP8/90000
a=my-sdp-value
</code></pre><p>두 개의 미디어 설명이 있습니다. 오디오 타입의 <code>111</code> 포맷 하나, 비디오 타입의 <code>96</code> 포맷 하나입니다. 첫 번째 미디어 설명에는 하나의 속성이 있으며,
Payload Type <code>111</code>을 Opus에 매핑합니다. 두 번째 미디어 설명에는 두 개의 속성이 있으며, 첫 번째는 <code>96</code>을 VP8에 매핑하고 두 번째는 단순 속성 <code>my-sdp-value</code>입니다.</p><h3 id=전체-예시>전체 예시
<a class=anchor href=#%ec%a0%84%ec%b2%b4-%ec%98%88%ec%8b%9c>#</a></h3><p>앞서 설명한 개념을 모두 합친 예시입니다. WebRTC가 사용하는 SDP의 모든 요소가 들어 있습니다. 이 예시를 읽을 수 있다면 어떤 WebRTC SDP든 읽을 수 있습니다!</p><pre tabindex=0><code>v=0
o=- 0 0 IN IP4 127.0.0.1
s=-
c=IN IP4 127.0.0.1
t=0 0
m=audio 4000 RTP/AVP 111
a=rtpmap:111 OPUS/48000/2
m=video 4002 RTP/AVP 96
a=rtpmap:96 VP8/90000
</code></pre><ul><li><code>v</code>, <code>o</code>, <code>s</code>, <code>c</code>, <code>t</code>는 정의되지만 WebRTC 세션 자체에는 영향을 주지 않습니다.</li><li><code>audio</code>와 <code>video</code> 두 개의 미디어 설명이 있습니다.</li><li>각 미디어 설명에는 하나의 속성이 있으며, 이는 RTP 파이프라인의 세부를 구성합니다(“미디어 통신” 장에서 설명).</li></ul><h2 id=sdp와-webrtc의-결합-방식>SDP와 WebRTC의 결합 방식
<a class=anchor href=#sdp%ec%99%80-webrtc%ec%9d%98-%ea%b2%b0%ed%95%a9-%eb%b0%a9%ec%8b%9d>#</a></h2><p>다음으로 WebRTC가 SDP를 ‘어떻게’ 사용하는지 이해해야 합니다.</p><h3 id=오퍼와-앤서>오퍼와 앤서
<a class=anchor href=#%ec%98%a4%ed%8d%bc%ec%99%80-%ec%95%a4%ec%84%9c>#</a></h3><p>WebRTC는 Offer/Answer 모델을 사용합니다. 한쪽 WebRTC 에이전트가 통화를 시작하겠다는 “오퍼(Offer)”를 제안하고, 상대 에이전트가 이를 수락하면 “앤서(Answer)”를 반환합니다.</p><p>이 과정에서 응답자는 미디어 설명에서 지원하지 않는 코덱을 거부할 수 있습니다. 이렇게 두 피어는 서로 교환 가능한 포맷을 합의합니다.</p><h3 id=트랜시버-송수신의-단위>트랜시버: 송수신의 단위
<a class=anchor href=#%ed%8a%b8%eb%9e%9c%ec%8b%9c%eb%b2%84-%ec%86%a1%ec%88%98%ec%8b%a0%ec%9d%98-%eb%8b%a8%ec%9c%84>#</a></h3><p>트랜시버(Transceiver)는 API에서 보게 되는 WebRTC 고유 개념으로, 본질적으로 미디어 설명을 JavaScript API로 노출한 것입니다. 트랜시버를 만들 때마다
로컬 SDP에 새 미디어 설명이 추가됩니다.</p><p>WebRTC의 각 미디어 설명에는 방향 속성이 있습니다. 예를 들어 “나는 이 코덱을 보낼 수 있지만, 받지는 않겠다”와 같이 선언할 수 있습니다. 가능한 값은 다음 네 가지입니다.</p><ul><li><code>send</code></li><li><code>recv</code></li><li><code>sendrecv</code></li><li><code>inactive</code></li></ul><h3 id=webrtc가-쓰는-sdp-값들>WebRTC가 쓰는 SDP 값들
<a class=anchor href=#webrtc%ea%b0%80-%ec%93%b0%eb%8a%94-sdp-%ea%b0%92%eb%93%a4>#</a></h3><p>다음은 WebRTC 에이전트의 SDP에서 자주 보게 되는 속성들입니다. 많은 값은 아직 다루지 않은 하위 시스템을 제어합니다.</p><h4 id=groupbundle><code>group:BUNDLE</code>
<a class=anchor href=#groupbundle>#</a></h4><p>번들은 여러 종류의 트래픽을 하나의 연결로 다루는 방식입니다. 일부 구현은 미디어 스트림마다 전용 연결을 사용하지만, 번들을 사용하는 것이 바람직합니다.</p><h4 id=fingerprintsha-256><code>fingerprint:sha-256</code>
<a class=anchor href=#fingerprintsha-256>#</a></h4><p>DTLS에 사용하는 인증서의 해시입니다. DTLS 핸드셰이크가 끝나면 실제 인증서와 비교해 예상한 피어와 통신 중인지 확인합니다.</p><h4 id=setup><code>setup:</code>
<a class=anchor href=#setup>#</a></h4><p>ICE 연결 이후 DTLS 에이전트의 동작(클라이언트/서버 역할)을 제어합니다. 가능한 값은 다음과 같습니다.</p><ul><li><code>setup:active</code> - DTLS 클라이언트로 동작</li><li><code>setup:passive</code> - DTLS 서버로 동작</li><li><code>setup:actpass</code> - 상대 에이전트가 선택하도록 요청</li></ul><h4 id=mid><code>mid</code>
<a class=anchor href=#mid>#</a></h4><p>세션 설명 내에서 미디어 스트림을 식별하는 데 사용하는 값입니다.</p><h4 id=ice-ufrag><code>ice-ufrag</code>
<a class=anchor href=#ice-ufrag>#</a></h4><p>ICE 에이전트의 user fragment 값으로, ICE 트래픽 인증에 사용됩니다.</p><h4 id=ice-pwd><code>ice-pwd</code>
<a class=anchor href=#ice-pwd>#</a></h4><p>ICE 에이전트의 비밀번호로, ICE 트래픽 인증에 사용됩니다.</p><h4 id=rtpmap><code>rtpmap</code>
<a class=anchor href=#rtpmap>#</a></h4><p>특정 코덱을 RTP Payload Type에 매핑합니다. Payload Type은 고정이 아니므로, 오퍼 측이 통화마다 코덱별 타입을 정합니다.</p><h4 id=fmtp><code>fmtp</code>
<a class=anchor href=#fmtp>#</a></h4><p>특정 Payload Type의 추가 매개변수를 정의합니다. 예를 들어 특정 비디오 프로파일이나 인코더 설정을 전달할 때 유용합니다.</p><h4 id=candidate><code>candidate</code>
<a class=anchor href=#candidate>#</a></h4><p>ICE 에이전트가 제공하는 ICE 후보입니다. WebRTC 에이전트가 사용 가능한 하나의 주소를 나타냅니다. 자세한 내용은 다음 장에서 다룹니다.</p><h4 id=ssrc><code>ssrc</code>
<a class=anchor href=#ssrc>#</a></h4><p>SSRC(Synchronization Source)는 하나의 미디어 스트림 트랙을 정의합니다.</p><p><code>label</code>은 개별 스트림의 ID이고, <code>mslabel</code>은 여러 스트림을 담을 수 있는 컨테이너 ID입니다.</p><h3 id=webrtc-세션-설명-예시>WebRTC 세션 설명 예시
<a class=anchor href=#webrtc-%ec%84%b8%ec%85%98-%ec%84%a4%eb%aa%85-%ec%98%88%ec%8b%9c>#</a></h3><p>다음은 WebRTC 클라이언트가 생성한 완전한 SDP입니다.</p><pre tabindex=0><code>v=0
o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0
s=-
t=0 0
a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E
a=group:BUNDLE 0 1
m=audio 9 UDP/TLS/RTP/SAVPF 111
c=IN IP4 0.0.0.0
a=setup:active
a=mid:0
a=ice-ufrag:CsxzEWmoKpJyscFj
a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10;useinbandfec=1
a=ssrc:350842737 cname:yvKPspsHcYcwGFTw
a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV
a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV
a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw
a=ssrc:350842737 label:DfQnKjQQuwceLFdV
a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV
a=sendrecv
a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0
a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0
a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0
a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0
a=end-of-candidates
m=video 9 UDP/TLS/RTP/SAVPF 96
c=IN IP4 0.0.0.0
a=setup:active
a=mid:1
a=ice-ufrag:CsxzEWmoKpJyscFj
a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:96 VP8/90000
a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ
a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW
a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ
a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW
a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW
a=sendrecv
</code></pre><p>이 메시지로부터 알 수 있는 점은 다음과 같습니다.</p><ul><li>오디오와 비디오, 두 개의 미디어 섹션이 있습니다.</li><li>둘 다 <code>sendrecv</code> 트랜시버입니다. 두 스트림을 받고, 두 스트림을 보낼 수 있습니다.</li><li>ICE 후보와 인증 세부 정보가 있어 연결을 시도할 수 있습니다.</li><li>인증서 지문이 있어 안전한 통화를 설정할 수 있습니다.</li></ul><h3 id=추가-주제>추가 주제
<a class=anchor href=#%ec%b6%94%ea%b0%80-%ec%a3%bc%ec%a0%9c>#</a></h3><p>이후 버전에서 다음 주제도 다룰 예정입니다.</p><ul><li>재협상(Renegotiation)</li><li>시뮬캐스트(Simulcast)</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/d197b9fa3dc748f7270405361db6750321c85ea8 title='Last modified by seonghoon.baek | 9월 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>9월 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/02-signaling.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc-시그널링이란>WebRTC 시그널링이란?</a></li><li><a href=#webrtc-시그널링은-어떻게-동작하나>WebRTC 시그널링은 어떻게 동작하나?</a></li><li><a href=#session-description-protocolsdp이란>Session Description Protocol(SDP)이란?</a><ul><li><a href=#sdp-읽는-법>SDP 읽는 법</a></li><li><a href=#webrtc가-사용하는-sdp-키>WebRTC가 사용하는 SDP 키</a></li><li><a href=#세션-설명의-미디어-설명>세션 설명의 미디어 설명</a></li><li><a href=#전체-예시>전체 예시</a></li></ul></li><li><a href=#sdp와-webrtc의-결합-방식>SDP와 WebRTC의 결합 방식</a><ul><li><a href=#오퍼와-앤서>오퍼와 앤서</a></li><li><a href=#트랜시버-송수신의-단위>트랜시버: 송수신의 단위</a></li><li><a href=#webrtc가-쓰는-sdp-값들>WebRTC가 쓰는 SDP 값들</a></li><li><a href=#webrtc-세션-설명-예시>WebRTC 세션 설명 예시</a></li><li><a href=#추가-주제>추가 주제</a></li></ul></li></ul></nav></div></aside></main></body></html>