<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="데이터 통신 # WebRTC 데이터 통신으로 무엇을 할 수 있나요? # WebRTC는 데이터 채널을 제공합니다. 두 피어 사이에 최대 65,534개의 채널을 열 수 있습니다. 데이터 채널은 데이터그램 기반이며, 채널마다 내구성(재전송/시간 제한/순서 보장)을 독립적으로 설정할 수 있습니다. 기본은 보장된 순서 전달입니다.
미디어 관점에서 보면 데이터 채널은 과해 보일 수 있습니다. HTTP/WebSocket으로도 보낼 수 있지 않나? 하지만 데이터 채널의 힘은 무질서/손실 허용(UDP 유사) 동작으로 구성할 수 있다는 데 있습니다. 낮은 지연/고성능에 필수적이며, 백프레셔를 측정해 네트워크 용량을 넘지 않도록 보낼 수 있습니다."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ko/docs/07-data-communication/"><meta property="og:site_name" content="호기심 많은 이를 위한 WebRTC"><meta property="og:title" content="데이터 통신"><meta property="og:description" content="데이터 통신 # WebRTC 데이터 통신으로 무엇을 할 수 있나요? # WebRTC는 데이터 채널을 제공합니다. 두 피어 사이에 최대 65,534개의 채널을 열 수 있습니다. 데이터 채널은 데이터그램 기반이며, 채널마다 내구성(재전송/시간 제한/순서 보장)을 독립적으로 설정할 수 있습니다. 기본은 보장된 순서 전달입니다.
미디어 관점에서 보면 데이터 채널은 과해 보일 수 있습니다. HTTP/WebSocket으로도 보낼 수 있지 않나? 하지만 데이터 채널의 힘은 무질서/손실 허용(UDP 유사) 동작으로 구성할 수 있다는 데 있습니다. 낮은 지연/고성능에 필수적이며, 백프레셔를 측정해 네트워크 용량을 넘지 않도록 보낼 수 있습니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-05T05:58:35+09:00"><title>데이터 통신 | 호기심 많은 이를 위한 WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ko/docs/07-data-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/07-data-communication/ title=Datakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/07-data-communication/ title="Коммуникация данных"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/07-data-communication/ title=数据通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/07-data-communication/ title=データ・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/07-data-communication/ title="ارتباط داده ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/07-data-communication/ title="Veri İletişimi"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ko.search.min.ff0bd92bfe13d1c7aaf7e993114720b4672b5caaa2c71caa427a6de130de2755.js integrity="sha256-/wvZK/4T0ceq9+mTEUcgtGcrXKqixxyqQnpt4TDeJ1U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ko/><span>호기심 많은 이를 위한 WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
한국어</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/07-data-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/07-data-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/07-data-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/07-data-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/07-data-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/07-data-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/07-data-communication/>Türkçe</a></li></ul></li></ul><ul><li><a href=/ko/docs/01-what-why-and-how/>무엇, 왜, 어떻게?</a></li><li><a href=/ko/docs/02-signaling/>시그널링</a></li><li><a href=/ko/docs/03-connecting/>연결</a></li><li><a href=/ko/docs/04-securing/>보안</a></li><li><a href=/ko/docs/05-real-time-networking/>실시간 네트워킹</a></li><li><a href=/ko/docs/06-media-communication/>미디어 통신</a></li><li><a href=/ko/docs/07-data-communication/ class=active>데이터 통신</a></li><li><a href=/ko/docs/08-applied-webrtc/>적용 WebRTC</a></li><li><a href=/ko/docs/09-debugging/>디버깅</a></li><li><a href=/ko/docs/10-history-of-webrtc/>역사</a></li><li><a href=/ko/docs/11-faq/>자주 묻는 질문(FAQ)</a></li><li><a href=/ko/docs/12-glossary/>용어집</a></li><li><a href=/ko/docs/13-reference/>참고 자료</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>데이터 통신</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc-데이터-통신으로-무엇을-할-수-있나요>WebRTC 데이터 통신으로 무엇을 할 수 있나요?</a></li><li><a href=#어떻게-동작하나요>어떻게 동작하나요?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#sctp-핵심-개념>SCTP 핵심 개념</a><ul><li><a href=#전송-시퀀스-번호tsn>전송 시퀀스 번호(TSN)</a></li><li><a href=#스트림-식별자시퀀스-번호>스트림 식별자/시퀀스 번호</a></li><li><a href=#ppidpayload-protocol-identifier>PPID(Payload Protocol Identifier)</a></li></ul></li><li><a href=#주요-청크>주요 청크</a><ul><li><a href=#data>DATA</a></li><li><a href=#init>INIT</a></li><li><a href=#sack>SACK</a></li><li><a href=#heartbeat--abort--shutdown--error>HEARTBEAT / ABORT / SHUTDOWN / ERROR</a></li><li><a href=#forward-tsn>FORWARD TSN</a></li></ul></li><li><a href=#상태-머신>상태 머신</a><ul><li><a href=#연결-수립-흐름>연결 수립 흐름</a></li><li><a href=#연결-종료-흐름>연결 종료 흐름</a></li><li><a href=#keep-alive>Keep-Alive</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=데이터-통신>데이터 통신
<a class=anchor href=#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ed%86%b5%ec%8b%a0>#</a></h1><h2 id=webrtc-데이터-통신으로-무엇을-할-수-있나요>WebRTC 데이터 통신으로 무엇을 할 수 있나요?
<a class=anchor href=#webrtc-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ed%86%b5%ec%8b%a0%ec%9c%bc%eb%a1%9c-%eb%ac%b4%ec%97%87%ec%9d%84-%ed%95%a0-%ec%88%98-%ec%9e%88%eb%82%98%ec%9a%94>#</a></h2><p>WebRTC는 데이터 채널을 제공합니다. 두 피어 사이에 최대 65,534개의 채널을 열 수 있습니다. 데이터 채널은 데이터그램 기반이며,
채널마다 내구성(재전송/시간 제한/순서 보장)을 독립적으로 설정할 수 있습니다. 기본은 보장된 순서 전달입니다.</p><p>미디어 관점에서 보면 데이터 채널은 과해 보일 수 있습니다. HTTP/WebSocket으로도 보낼 수 있지 않나? 하지만 데이터 채널의 힘은
무질서/손실 허용(UDP 유사) 동작으로 구성할 수 있다는 데 있습니다. 낮은 지연/고성능에 필수적이며, 백프레셔를 측정해 네트워크 용량을
넘지 않도록 보낼 수 있습니다.</p><h2 id=어떻게-동작하나요>어떻게 동작하나요?
<a class=anchor href=#%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%98%eb%82%98%ec%9a%94>#</a></h2><p>WebRTC는 <a href=https://tools.ietf.org/html/rfc4960>RFC 4960</a>의 SCTP(Stream Control Transmission Protocol)를 사용합니다. 원래 전송 계층용이지만,
WebRTC에서는 DTLS 위의 응용 계층 프로토콜로 사용합니다. SCTP는 ‘스트림’을 제공하며 각 스트림을 독립적으로 구성할 수 있습니다. 데이터 채널은
이에 대한 얇은 추상화로, 내구성/순서 옵션은 SCTP 에이전트에 그대로 전달됩니다.</p><p>또한 채널 라벨처럼 SCTP가 직접 표현하지 못하는 정보는 <a href=https://tools.ietf.org/html/rfc8832>RFC 8832</a>의 DCEP(Data Channel Establishment Protocol)로
교환합니다.</p><h2 id=dcep>DCEP
<a class=anchor href=#dcep>#</a></h2><p>DCEP에는 <code>DATA_CHANNEL_OPEN</code>과 <code>DATA_CHANNEL_ACK</code> 두 메시지만 있습니다. 채널을 열면 상대는 ACK로 응답해야 합니다.</p><h3 id=data_channel_open>DATA_CHANNEL_OPEN
<a class=anchor href=#data_channel_open>#</a></h3><p>채널을 열고자 하는 에이전트가 전송합니다. 필드는 다음 의미를 갖습니다.</p><ul><li>Message Type: <code>0x03</code></li><li>Channel Type: 내구성/순서 속성<ul><li><code>RELIABLE</code>(<code>0x00</code>): 손실 없음, 순서 보장</li><li><code>RELIABLE_UNORDERED</code>(<code>0x80</code>): 손실 없음, 무질서 허용</li><li><code>PARTIAL_RELIABLE_REXMIT</code>(<code>0x01</code>): 제한 횟수 재전송 후 손실 허용, 순서 보장</li><li><code>PARTIAL_RELIABLE_REXMIT_UNORDERED</code>(<code>0x81</code>): 위와 동일, 무질서 허용</li><li><code>PARTIAL_RELIABLE_TIMED</code>(<code>0x02</code>): 제한 시간 내 도착하지 않으면 손실 허용, 순서 보장</li><li><code>PARTIAL_RELIABLE_TIMED_UNORDERED</code>(<code>0x82</code>): 위와 동일, 무질서 허용</li></ul></li><li>Priority: 높은 우선순위가 먼저 스케줄됨</li><li>Reliability Parameter: <code>REXMIT</code>(재전송 횟수) 또는 <code>TIMED</code>(재전송 시간, ms)</li><li>Label: 채널 이름(UTF-8)</li><li>Protocol: 비어 있지 않다면 [RFC 6455]의 WebSocket 서브프로토콜 레지스트리 값을 권장</li></ul><h3 id=data_channel_ack>DATA_CHANNEL_ACK
<a class=anchor href=#data_channel_ack>#</a></h3><p>원격이 채널 오픈을 수락했음을 알립니다.</p><h2 id=sctp-핵심-개념>SCTP 핵심 개념
<a class=anchor href=#sctp-%ed%95%b5%ec%8b%ac-%ea%b0%9c%eb%85%90>#</a></h2><h3 id=전송-시퀀스-번호tsn>전송 시퀀스 번호(TSN)
<a class=anchor href=#%ec%a0%84%ec%86%a1-%ec%8b%9c%ed%80%80%ec%8a%a4-%eb%b2%88%ed%98%b8tsn>#</a></h3><p>모든 DATA 청크의 전역 고유 번호입니다. 손실/무질서 판단에 사용합니다.</p><h3 id=스트림-식별자시퀀스-번호>스트림 식별자/시퀀스 번호
<a class=anchor href=#%ec%8a%a4%ed%8a%b8%eb%a6%bc-%ec%8b%9d%eb%b3%84%ec%9e%90%ec%8b%9c%ed%80%80%ec%8a%a4-%eb%b2%88%ed%98%b8>#</a></h3><p>각 스트림에는 ID가 있고, 메시지 단위의 시퀀스 번호가 있습니다(<code>U=0</code>일 때 순서 판단에 사용).</p><h3 id=ppidpayload-protocol-identifier>PPID(Payload Protocol Identifier)
<a class=anchor href=#ppidpayload-protocol-identifier>#</a></h3><p>전송 데이터의 타입을 나타냅니다. WebRTC는 <code>DCEP(50)</code>, <code>String(51)</code>, <code>Binary(53)</code>, <code>String Empty(56)</code>, <code>Binary Empty(57)</code>를 사용합니다.</p><h2 id=주요-청크>주요 청크
<a class=anchor href=#%ec%a3%bc%ec%9a%94-%ec%b2%ad%ed%81%ac>#</a></h2><h3 id=data>DATA
<a class=anchor href=#data>#</a></h3><p>사용자 데이터 전달에 사용합니다. <code>U</code>(무질서), <code>B/E</code>(분할 메시지의 시작/끝), <code>TSN</code>, <code>Stream ID</code>, <code>Stream Seq</code>, <code>PPID</code> 등을 포함합니다.</p><h3 id=init>INIT
<a class=anchor href=#init>#</a></h3><p>연결(Association) 생성 시작. 쿠키용 Initiate Tag, 수신 윈도 크기(a_rwnd), 송/수신 스트림 수, 초기 TSN, 선택 매개변수 등을 담습니다.</p><h3 id=sack>SACK
<a class=anchor href=#sack>#</a></h3><p>수신 확인(Selective ACK). 누적 TSN ACK, 수신 윈도 크기, 갭 ACK 블록, 중복 TSN 등을 보고합니다.</p><h3 id=heartbeat--abort--shutdown--error>HEARTBEAT / ABORT / SHUTDOWN / ERROR
<a class=anchor href=#heartbeat--abort--shutdown--error>#</a></h3><p>연결 상태 확인, 비정상 종료, 정상 종료, 비치명적 오류 보고 등에 사용됩니다.</p><h3 id=forward-tsn>FORWARD TSN
<a class=anchor href=#forward-tsn>#</a></h3><p>더 이상 필요 없는 오래된 데이터 구간을 건너뛰도록 누적 TSN을 앞으로 당깁니다(실시간 무용 데이터 스킵).</p><h2 id=상태-머신>상태 머신
<a class=anchor href=#%ec%83%81%ed%83%9c-%eb%a8%b8%ec%8b%a0>#</a></h2><h3 id=연결-수립-흐름>연결 수립 흐름
<a class=anchor href=#%ec%97%b0%ea%b2%b0-%ec%88%98%eb%a6%bd-%ed%9d%90%eb%a6%84>#</a></h3><p><code>INIT</code>/<code>INIT ACK</code>로 능력/설정을 교환합니다. SCTP는 핸드셰이크 중 쿠키를 사용해 상대를 검증하고(DOS/MITM 방지), <code>COOKIE ECHO</code>/<code>COOKIE ACK</code>로
완료합니다. 이후 DATA 교환이 시작됩니다.</p><p><img src=../images/07-connection-establishment.png alt="Connection establishment" title="Connection establishment"></p><h3 id=연결-종료-흐름>연결 종료 흐름
<a class=anchor href=#%ec%97%b0%ea%b2%b0-%ec%a2%85%eb%a3%8c-%ed%9d%90%eb%a6%84>#</a></h3><p><code>SHUTDOWN</code>으로 우아한 종료를 시작합니다. 각 측은 마지막 전송 TSN을 공유해 데이터 손실 없이 종료합니다.</p><h3 id=keep-alive>Keep-Alive
<a class=anchor href=#keep-alive>#</a></h3><p><code>HEARTBEAT REQUEST/ACK</code>를 주기적으로 교환해 연결을 유지하고, 왕복 시간을 추정합니다.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/d197b9fa3dc748f7270405361db6750321c85ea8 title='Last modified by seonghoon.baek | 9월 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>9월 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/07-data-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc-데이터-통신으로-무엇을-할-수-있나요>WebRTC 데이터 통신으로 무엇을 할 수 있나요?</a></li><li><a href=#어떻게-동작하나요>어떻게 동작하나요?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#sctp-핵심-개념>SCTP 핵심 개념</a><ul><li><a href=#전송-시퀀스-번호tsn>전송 시퀀스 번호(TSN)</a></li><li><a href=#스트림-식별자시퀀스-번호>스트림 식별자/시퀀스 번호</a></li><li><a href=#ppidpayload-protocol-identifier>PPID(Payload Protocol Identifier)</a></li></ul></li><li><a href=#주요-청크>주요 청크</a><ul><li><a href=#data>DATA</a></li><li><a href=#init>INIT</a></li><li><a href=#sack>SACK</a></li><li><a href=#heartbeat--abort--shutdown--error>HEARTBEAT / ABORT / SHUTDOWN / ERROR</a></li><li><a href=#forward-tsn>FORWARD TSN</a></li></ul></li><li><a href=#상태-머신>상태 머신</a><ul><li><a href=#연결-수립-흐름>연결 수립 흐름</a></li><li><a href=#연결-종료-흐름>연결 종료 흐름</a></li><li><a href=#keep-alive>Keep-Alive</a></li></ul></li></ul></nav></div></aside></main></body></html>