<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="미디어 통신 # WebRTC 미디어 통신으로 무엇을 할 수 있나요? # WebRTC는 무제한의 오디오/비디오 트랙을 보낼 수 있고 받을 수 있습니다. 통화 중에도 언제든 스트림을 추가/제거할 수 있으며, 서로 독립적으로 보낼 수도, 하나의 연결로 번들링할 수도 있습니다. 예를 들어 데스크톱 화면 비디오에 웹캠의 오디오/비디오를 함께 보낼 수 있습니다.
WebRTC 프로토콜은 코덱에 중립적입니다. 기저 전송은 존재하지 않는 형식까지도 이론상 지원할 수 있습니다. 다만 상대 에이전트가 해당 코덱을 처리할 수 있어야 합니다."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ko/docs/06-media-communication/"><meta property="og:site_name" content="호기심 많은 이를 위한 WebRTC"><meta property="og:title" content="미디어 통신"><meta property="og:description" content="미디어 통신 # WebRTC 미디어 통신으로 무엇을 할 수 있나요? # WebRTC는 무제한의 오디오/비디오 트랙을 보낼 수 있고 받을 수 있습니다. 통화 중에도 언제든 스트림을 추가/제거할 수 있으며, 서로 독립적으로 보낼 수도, 하나의 연결로 번들링할 수도 있습니다. 예를 들어 데스크톱 화면 비디오에 웹캠의 오디오/비디오를 함께 보낼 수 있습니다.
WebRTC 프로토콜은 코덱에 중립적입니다. 기저 전송은 존재하지 않는 형식까지도 이론상 지원할 수 있습니다. 다만 상대 에이전트가 해당 코덱을 처리할 수 있어야 합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-05T05:58:35+09:00"><title>미디어 통신 | 호기심 많은 이를 위한 WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ko/docs/06-media-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/06-media-communication/ title=Mediakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/06-media-communication/ title=Медиа-коммуникация><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/06-media-communication/ title=媒体通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/06-media-communication/ title=メディア・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/06-media-communication/ title="ارتباط رسانه ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/06-media-communication/ title="Comunicación de Medios"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/06-media-communication/ title="Medya İletişimi"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ko.search.min.ff0bd92bfe13d1c7aaf7e993114720b4672b5caaa2c71caa427a6de130de2755.js integrity="sha256-/wvZK/4T0ceq9+mTEUcgtGcrXKqixxyqQnpt4TDeJ1U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ko/><span>호기심 많은 이를 위한 WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
한국어</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/06-media-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/06-media-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/06-media-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/06-media-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/06-media-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/06-media-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/06-media-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/06-media-communication/>Türkçe</a></li></ul></li></ul><ul><li><a href=/ko/docs/01-what-why-and-how/>무엇, 왜, 어떻게?</a></li><li><a href=/ko/docs/02-signaling/>시그널링</a></li><li><a href=/ko/docs/03-connecting/>연결</a></li><li><a href=/ko/docs/04-securing/>보안</a></li><li><a href=/ko/docs/05-real-time-networking/>실시간 네트워킹</a></li><li><a href=/ko/docs/06-media-communication/ class=active>미디어 통신</a></li><li><a href=/ko/docs/07-data-communication/>데이터 통신</a></li><li><a href=/ko/docs/08-applied-webrtc/>적용 WebRTC</a></li><li><a href=/ko/docs/09-debugging/>디버깅</a></li><li><a href=/ko/docs/10-history-of-webrtc/>역사</a></li><li><a href=/ko/docs/11-faq/>자주 묻는 질문(FAQ)</a></li><li><a href=/ko/docs/12-glossary/>용어집</a></li><li><a href=/ko/docs/13-reference/>참고 자료</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>미디어 통신</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc-미디어-통신으로-무엇을-할-수-있나요>WebRTC 미디어 통신으로 무엇을 할 수 있나요?</a></li><li><a href=#어떻게-동작하나요>어떻게 동작하나요?</a></li><li><a href=#지연과-품질의-균형>지연과 품질의 균형</a><ul><li><a href=#현실적-제약>현실적 제약</a></li><li><a href=#비디오는-복잡하다>비디오는 복잡하다</a></li></ul></li><li><a href=#비디오-101>비디오 101</a><ul><li><a href=#손실무손실-압축>손실/무손실 압축</a></li><li><a href=#인트라인터-프레임-압축>인트라/인터 프레임 압축</a></li><li><a href=#인터-프레임-종류>인터 프레임 종류</a></li><li><a href=#비디오는-섬세하다>비디오는 섬세하다</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#패킷-형식요점>패킷 형식(요점)</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#fir와-pli>FIR와 PLI</a></li><li><a href=#nack>NACK</a></li><li><a href=#송신수신-리포트srrr>송신/수신 리포트(SR/RR)</a></li></ul></li><li><a href=#함께-문제를-푸는-방식>함께 문제를 푸는 방식</a><ul><li><a href=#순방향-오류-정정fec>순방향 오류 정정(FEC)</a></li><li><a href=#적응형-비트레이트와-대역폭-추정>적응형 비트레이트와 대역폭 추정</a></li></ul></li><li><a href=#네트워크-상태의-식별과-교환>네트워크 상태의 식별과 교환</a><ul><li><a href=#receiversender-reportsrrsr>Receiver/Sender Reports(RR/SR)</a></li><li><a href=#tmmbrtmmbn-remb-twcc와-gcc>TMMBR/TMMBN, REMB, TWCC와 GCC</a></li><li><a href=#대역폭-추정의-대안>대역폭 추정의 대안</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=미디어-통신>미디어 통신
<a class=anchor href=#%eb%af%b8%eb%94%94%ec%96%b4-%ed%86%b5%ec%8b%a0>#</a></h1><h2 id=webrtc-미디어-통신으로-무엇을-할-수-있나요>WebRTC 미디어 통신으로 무엇을 할 수 있나요?
<a class=anchor href=#webrtc-%eb%af%b8%eb%94%94%ec%96%b4-%ed%86%b5%ec%8b%a0%ec%9c%bc%eb%a1%9c-%eb%ac%b4%ec%97%87%ec%9d%84-%ed%95%a0-%ec%88%98-%ec%9e%88%eb%82%98%ec%9a%94>#</a></h2><p>WebRTC는 무제한의 오디오/비디오 트랙을 보낼 수 있고 받을 수 있습니다. 통화 중에도 언제든 스트림을 추가/제거할 수 있으며,
서로 독립적으로 보낼 수도, 하나의 연결로 번들링할 수도 있습니다. 예를 들어 데스크톱 화면 비디오에 웹캠의 오디오/비디오를 함께 보낼 수 있습니다.</p><p>WebRTC 프로토콜은 코덱에 중립적입니다. 기저 전송은 존재하지 않는 형식까지도 이론상 지원할 수 있습니다. 다만 상대 에이전트가 해당 코덱을
처리할 수 있어야 합니다.</p><p>또한 WebRTC는 동적인 네트워크 상태에 대응하도록 설계되었습니다. 통화 중 대역폭이 늘거나 줄 수 있고, 갑작스런 패킷 손실도 생길 수 있습니다.
프로토콜은 이러한 상황에 반응해 가능한 최선의 경험을 제공하려고 합니다.</p><h2 id=어떻게-동작하나요>어떻게 동작하나요?
<a class=anchor href=#%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%98%eb%82%98%ec%9a%94>#</a></h2><p>WebRTC는 RTP와 RTCP를 사용합니다(둘 다 <a href=https://tools.ietf.org/html/rfc1889>RFC 1889</a>).</p><p>RTP(Real-time Transport Protocol)는 실제 미디어를 운반합니다. 지연/신뢰성 규칙은 강제하지 않지만, 이를 구현할 도구를 제공합니다. 하나의 연결에서
여러 미디어 스트림을 운반할 수 있도록 스트림 모델과, 미디어 파이프라인에 필요한 타이밍/정렬 정보를 제공합니다.</p><p>RTCP(RTP Control Protocol)는 통화에 대한 메타데이터를 교환합니다. 포맷이 유연해 원하는 메타데이터를 넣을 수 있습니다. 통화 통계를 전달하고,
패킷 손실 처리, 혼잡 제어 구현에 사용됩니다. 네트워크 변화에 대응하기 위한 양방향 통신을 제공합니다.</p><h2 id=지연과-품질의-균형>지연과 품질의 균형
<a class=anchor href=#%ec%a7%80%ec%97%b0%ea%b3%bc-%ed%92%88%ec%a7%88%ec%9d%98-%ea%b7%a0%ed%98%95>#</a></h2><p>실시간 미디어는 지연과 화질 사이에서 절충이 필요합니다. 더 큰 지연을 허용할수록 더 높은 화질을 기대할 수 있습니다.</p><h3 id=현실적-제약>현실적 제약
<a class=anchor href=#%ed%98%84%ec%8b%a4%ec%a0%81-%ec%a0%9c%ec%95%bd>#</a></h3><p>모든 제약은 현실 세계 네트워크의 한계에서 옵니다. 극복해야 할 네트워크 특성입니다.</p><h3 id=비디오는-복잡하다>비디오는 복잡하다
<a class=anchor href=#%eb%b9%84%eb%94%94%ec%98%a4%eb%8a%94-%eb%b3%b5%ec%9e%a1%ed%95%98%eb%8b%a4>#</a></h3><p>비디오 전송은 쉽지 않습니다. 예컨대 30분 분량의 무압축 720p 8비트 비디오는 약 110GB가 필요합니다. 4인 회의를 생각하면 불가능합니다. 해법은
압축이며, 당연히 대가가 따릅니다.</p><h2 id=비디오-101>비디오 101
<a class=anchor href=#%eb%b9%84%eb%94%94%ec%98%a4-101>#</a></h2><p>비디오 압축의 모든 것을 다루지는 않고, RTP가 왜 그렇게 설계되었는지를 이해할 만큼만 설명합니다. 압축은 더 적은 비트로 같은 영상을 표현합니다.</p><h3 id=손실무손실-압축>손실/무손실 압축
<a class=anchor href=#%ec%86%90%ec%8b%a4%eb%ac%b4%ec%86%90%ec%8b%a4-%ec%95%95%ec%b6%95>#</a></h3><p>무손실(정보 손실 없음)과 손실(일부 손실 허용) 방식이 있습니다. 무손실은 더 많은 데이터를 전송해야 하므로 지연이 늘고 손실이 늘어납니다.
RTP에서는 보통 손실 압축을 사용합니다.</p><h3 id=인트라인터-프레임-압축>인트라/인터 프레임 압축
<a class=anchor href=#%ec%9d%b8%ed%8a%b8%eb%9d%bc%ec%9d%b8%ed%84%b0-%ed%94%84%eb%a0%88%ec%9e%84-%ec%95%95%ec%b6%95>#</a></h3><p>인트라 프레임은 단일 프레임 내부에서 중복을 줄입니다(JPEG과 유사). 인터 프레임은 연속된 프레임 간 중복을 줄입니다.</p><h3 id=인터-프레임-종류>인터 프레임 종류
<a class=anchor href=#%ec%9d%b8%ed%84%b0-%ed%94%84%eb%a0%88%ec%9e%84-%ec%a2%85%eb%a5%98>#</a></h3><ul><li>I-프레임: 완전한 그림, 단독 디코딩 가능</li><li>P-프레임: 이전 그림 대비 변경분만 포함</li><li>B-프레임: 이전/이후 그림을 모두 참조해 변경분만 포함</li></ul><p><img src=../images/06-frame-types.png alt="Frame types" title="Frame types"></p><h3 id=비디오는-섬세하다>비디오는 섬세하다
<a class=anchor href=#%eb%b9%84%eb%94%94%ec%98%a4%eb%8a%94-%ec%84%ac%ec%84%b8%ed%95%98%eb%8b%a4>#</a></h3><p>비디오 압축은 강한 상태성을 갖습니다. I-프레임의 일부를 잃으면? P-프레임은 무엇을 수정해야 하는지 어떻게 알까요? 복잡해질수록 문제는 커집니다.
다행히 RTP/RTCP가 해법을 가지고 있습니다.</p><h2 id=rtp>RTP
<a class=anchor href=#rtp>#</a></h2><h3 id=패킷-형식요점>패킷 형식(요점)
<a class=anchor href=#%ed%8c%a8%ed%82%b7-%ed%98%95%ec%8b%9d%ec%9a%94%ec%a0%90>#</a></h3><p>RTP 헤더에는 버전, 페이로드 타입(코덱 식별), 시퀀스 번호(손실/재정렬 판단), 타임스탬프(동기화), SSRC(스트림 식별) 등이 포함됩니다. 시퀀스 번호는
패킷 손실/순서 판단에, 타임스탬프는 디코딩/재생 타이밍에 쓰입니다.</p><h2 id=rtcp>RTCP
<a class=anchor href=#rtcp>#</a></h2><p>RTCP 패킷은 다양한 타입이 있습니다. 공통 헤더에는 버전, 패딩, 리포트 개수, 패킷 타입, 길이, 페이로드가 옵니다.</p><p>자주 보는 타입은 다음과 같습니다.</p><ul><li>192: FIR(Full INTRA-frame Request)</li><li>193: NACK(Negative ACKnowledgement)</li><li>200: Sender Report</li><li>201: Receiver Report</li><li>205: Generic RTP Feedback</li><li>206: Payload Specific Feedback</li></ul><h3 id=fir와-pli>FIR와 PLI
<a class=anchor href=#fir%ec%99%80-pli>#</a></h3><p>FIR/PLI는 모두 키프레임(I-프레임) 재전송을 요청합니다. <a href=https://tools.ietf.org/html/rfc5104>RFC 5104</a>에 따르면 손실 상황에는 PLI를,
그 외(예: 새 참가자 입장)에는 FIR을 사용합니다. 실무에서는 두 경우 모두 인코더에 키프레임 생성을 요청합니다.</p><h3 id=nack>NACK
<a class=anchor href=#nack>#</a></h3><p>NACK은 특정 RTP 패킷 하나의 재전송을 요청합니다. RTP가 작은 조각으로 나뉘어 있어, 프레임 전체 재전송보다 대역폭 효율이 좋습니다. 송신자가
해당 패킷을 보유하지 않으면 무시됩니다.</p><h3 id=송신수신-리포트srrr>송신/수신 리포트(SR/RR)
<a class=anchor href=#%ec%86%a1%ec%8b%a0%ec%88%98%ec%8b%a0-%eb%a6%ac%ed%8f%ac%ed%8a%b8srrr>#</a></h3><p>엔드포인트 간 통계(손실률, 누적 손실, 최고 시퀀스, 지터, 송신 시각 등)를 주고받습니다. RTT 계산과 혼잡 제어에 사용됩니다.</p><p>RTT 계산은 다음과 같습니다.</p><p><code>rtt = sendertime2 - sendertime1 - DLSR</code></p><p><img src=../images/06-rtt.png alt="Round-trip time" title="Round-trip time"></p><h2 id=함께-문제를-푸는-방식>함께 문제를 푸는 방식
<a class=anchor href=#%ed%95%a8%ea%bb%98-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%ed%91%b8%eb%8a%94-%eb%b0%a9%ec%8b%9d>#</a></h2><h3 id=순방향-오류-정정fec>순방향 오류 정정(FEC)
<a class=anchor href=#%ec%88%9c%eb%b0%a9%ed%96%a5-%ec%98%a4%eb%a5%98-%ec%a0%95%ec%a0%95fec>#</a></h3><p>요청을 기다리지 않고 여분 데이터를 함께 보내 손실에 대비합니다. 손실이 지속적이면 NACK보다 지연이 적습니다.</p><h3 id=적응형-비트레이트와-대역폭-추정>적응형 비트레이트와 대역폭 추정
<a class=anchor href=#%ec%a0%81%ec%9d%91%ed%98%95-%eb%b9%84%ed%8a%b8%eb%a0%88%ec%9d%b4%ed%8a%b8%ec%99%80-%eb%8c%80%ec%97%ad%ed%8f%ad-%ec%b6%94%ec%a0%95>#</a></h3><p>세션 중 가용 대역폭은 크게 변할 수 있습니다. 인코딩 비트레이트를 예측/현재/미래 대역폭에 맞춰 조정합니다. 이를 위해 대역폭 추정 알고리즘과
네트워크 특성 교환이 필요합니다.</p><h2 id=네트워크-상태의-식별과-교환>네트워크 상태의 식별과 교환
<a class=anchor href=#%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%83%81%ed%83%9c%ec%9d%98-%ec%8b%9d%eb%b3%84%ea%b3%bc-%ea%b5%90%ed%99%98>#</a></h2><p>WebRTC는 양방향으로 대역폭, RTT, 지터, 손실을 관측/전달해야 합니다. 대표적인 접근은 다음과 같습니다.</p><h3 id=receiversender-reportsrrsr>Receiver/Sender Reports(RR/SR)
<a class=anchor href=#receiversender-reportsrrsr>#</a></h3><p><a href=https://tools.ietf.org/html/rfc3550#section-6.4>RFC 3550</a> 정의. RR이 네트워크 품질(손실, RTT, 지터)을 보고하고, 송신자는 이를 바탕으로 비트레이트를
추정/조정합니다. 필드에는 Fraction Lost, Cumulative Lost, Extended Highest Seq, Interarrival Jitter, Last SR Timestamp 등이 포함됩니다.</p><h3 id=tmmbrtmmbn-remb-twcc와-gcc>TMMBR/TMMBN, REMB, TWCC와 GCC
<a class=anchor href=#tmmbrtmmbn-remb-twcc%ec%99%80-gcc>#</a></h3><h4 id=gccgoogle-congestion-control>GCC(Google Congestion Control)
<a class=anchor href=#gccgoogle-congestion-control>#</a></h4><p>손실 기반 컨트롤러와 지연 기반 컨트롤러를 결합해 대역폭을 추정합니다(<a href=https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>draft-ietf-rmcat-gcc-02</a>).
수신측 피드백(TMMBR/TMMBN/REMB) 또는 송신측 피드백(TWCC)과 함께 동작합니다.</p><h4 id=tmmbrtmmbn-remb>TMMBR/TMMBN, REMB
<a class=anchor href=#tmmbrtmmbn-remb>#</a></h4><p>수신측이 허용 비트레이트를 알려 송신자가 인코더 비트레이트를 조정합니다. 인코더 편차, 규격화 미흡 등 한계가 있어 실무에서는 세심한 튜닝이 필요합니다.
<img src=../images/06-remb.png alt=REMB title=REMB></p><h4 id=twcctransport-wide-congestion-control>TWCC(Transport-Wide Congestion Control)
<a class=anchor href=#twcctransport-wide-congestion-control>#</a></h4><p>패킷 도착 시간을 송신자에 상세히 제공해, 송신자가 직접 지연 변동/손실을 추정하고 빠르게 조정합니다. SR/RR의 송신자 중심성과 REMB의 정밀 측정을
절충한 방식입니다.
<img src=../images/06-twcc-idea.png alt=TWCC title=TWCC></p><p>송신자는 보낸 패킷의 크기/타임스탬프/시퀀스를 추적하고, 수신 리포트의 도착 간격과 비교해 혼잡을 감지합니다.</p><h3 id=대역폭-추정의-대안>대역폭 추정의 대안
<a class=anchor href=#%eb%8c%80%ec%97%ad%ed%8f%ad-%ec%b6%94%ec%a0%95%ec%9d%98-%eb%8c%80%ec%95%88>#</a></h3><p>가장 널리 쓰이는 구현은 &ldquo;Google Congestion Control"입니다. 대안으로 NADA, SCReAM 등이 있습니다.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/d197b9fa3dc748f7270405361db6750321c85ea8 title='Last modified by seonghoon.baek | 9월 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>9월 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/06-media-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc-미디어-통신으로-무엇을-할-수-있나요>WebRTC 미디어 통신으로 무엇을 할 수 있나요?</a></li><li><a href=#어떻게-동작하나요>어떻게 동작하나요?</a></li><li><a href=#지연과-품질의-균형>지연과 품질의 균형</a><ul><li><a href=#현실적-제약>현실적 제약</a></li><li><a href=#비디오는-복잡하다>비디오는 복잡하다</a></li></ul></li><li><a href=#비디오-101>비디오 101</a><ul><li><a href=#손실무손실-압축>손실/무손실 압축</a></li><li><a href=#인트라인터-프레임-압축>인트라/인터 프레임 압축</a></li><li><a href=#인터-프레임-종류>인터 프레임 종류</a></li><li><a href=#비디오는-섬세하다>비디오는 섬세하다</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#패킷-형식요점>패킷 형식(요점)</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#fir와-pli>FIR와 PLI</a></li><li><a href=#nack>NACK</a></li><li><a href=#송신수신-리포트srrr>송신/수신 리포트(SR/RR)</a></li></ul></li><li><a href=#함께-문제를-푸는-방식>함께 문제를 푸는 방식</a><ul><li><a href=#순방향-오류-정정fec>순방향 오류 정정(FEC)</a></li><li><a href=#적응형-비트레이트와-대역폭-추정>적응형 비트레이트와 대역폭 추정</a></li></ul></li><li><a href=#네트워크-상태의-식별과-교환>네트워크 상태의 식별과 교환</a><ul><li><a href=#receiversender-reportsrrsr>Receiver/Sender Reports(RR/SR)</a></li><li><a href=#tmmbrtmmbn-remb-twcc와-gcc>TMMBR/TMMBN, REMB, TWCC와 GCC</a></li><li><a href=#대역폭-추정의-대안>대역폭 추정의 대안</a></li></ul></li></ul></nav></div></aside></main></body></html>