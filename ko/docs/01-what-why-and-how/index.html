<!doctype html><html lang=ko dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="무엇, 왜, 어떻게? # WebRTC란 무엇인가? # WebRTC(Web Real-Time Communication)는 API이자 프로토콜입니다. WebRTC 프로토콜은 두 WebRTC 에이전트가 실시간 양방향 안전 통신을 협상하기 위한 규칙 집합입니다. WebRTC API는 개발자가 이 WebRTC 프로토콜을 사용할 수 있게 합니다. WebRTC API는 JavaScript를 대상으로 합니다.
HTTP와 Fetch API의 관계에 비유할 수 있습니다. WebRTC 프로토콜이 HTTP라면, WebRTC API는 Fetch API에 해당합니다.
WebRTC 프로토콜은 JavaScript 외의 언어로도 구현되어 있습니다. 서버와 도메인 특화 도구들도 존재합니다. 이 모든 구현은 WebRTC 프로토콜을 사용하므로 상호 운용이 가능합니다."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/"><meta property="og:site_name" content="호기심 많은 이를 위한 WebRTC"><meta property="og:title" content="무엇, 왜, 어떻게?"><meta property="og:description" content="무엇, 왜, 어떻게? # WebRTC란 무엇인가? # WebRTC(Web Real-Time Communication)는 API이자 프로토콜입니다. WebRTC 프로토콜은 두 WebRTC 에이전트가 실시간 양방향 안전 통신을 협상하기 위한 규칙 집합입니다. WebRTC API는 개발자가 이 WebRTC 프로토콜을 사용할 수 있게 합니다. WebRTC API는 JavaScript를 대상으로 합니다.
HTTP와 Fetch API의 관계에 비유할 수 있습니다. WebRTC 프로토콜이 HTTP라면, WebRTC API는 Fetch API에 해당합니다.
WebRTC 프로토콜은 JavaScript 외의 언어로도 구현되어 있습니다. 서버와 도메인 특화 도구들도 존재합니다. 이 모든 구현은 WebRTC 프로토콜을 사용하므로 상호 운용이 가능합니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-05T05:58:35+09:00"><title>무엇, 왜, 어떻게? | 호기심 많은 이를 위한 WebRTC</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ title="Vad, varför och hur"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/ title="Что, Зачем и Как"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/ title="Quoi, Pourquoi et Comment"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ title="Apa, Mengapa, dan Bagaimana"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ title="¿Qué, Por qué y Cómo?"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ title="Ne, Neden ve Nasıl"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ko.search.min.ff0bd92bfe13d1c7aaf7e993114720b4672b5caaa2c71caa427a6de130de2755.js integrity="sha256-/wvZK/4T0ceq9+mTEUcgtGcrXKqixxyqQnpt4TDeJ1U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ko/><span>호기심 많은 이를 위한 WebRTC</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
한국어</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/>Türkçe</a></li></ul></li></ul><ul><li><a href=/ko/docs/01-what-why-and-how/ class=active>무엇, 왜, 어떻게?</a></li><li><a href=/ko/docs/02-signaling/>시그널링</a></li><li><a href=/ko/docs/03-connecting/>연결</a></li><li><a href=/ko/docs/04-securing/>보안</a></li><li><a href=/ko/docs/05-real-time-networking/>실시간 네트워킹</a></li><li><a href=/ko/docs/06-media-communication/>미디어 통신</a></li><li><a href=/ko/docs/07-data-communication/>데이터 통신</a></li><li><a href=/ko/docs/08-applied-webrtc/>적용 WebRTC</a></li><li><a href=/ko/docs/09-debugging/>디버깅</a></li><li><a href=/ko/docs/10-history-of-webrtc/>역사</a></li><li><a href=/ko/docs/11-faq/>자주 묻는 질문(FAQ)</a></li><li><a href=/ko/docs/12-glossary/>용어집</a></li><li><a href=/ko/docs/13-reference/>참고 자료</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>무엇, 왜, 어떻게?</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#webrtc란-무엇인가>WebRTC란 무엇인가?</a></li><li><a href=#왜-webrtc를-배워야-하나요>왜 WebRTC를 배워야 하나요?</a></li><li><a href=#webrtc-프로토콜은-여러-기술의-집합>WebRTC 프로토콜은 여러 기술의 집합</a><ul><li><a href=#시그널링-webrtc에서-단말들은-어떻게-서로를-찾을까>시그널링: WebRTC에서 단말들은 어떻게 서로를 찾을까?</a></li><li><a href=#연결과-nat-우회-stunturn>연결과 NAT 우회: STUN/TURN</a></li><li><a href=#보안-어떻게-안전하게-만들까>보안: 어떻게 안전하게 만들까?</a></li><li><a href=#통신-무엇을-어떻게-주고받을까>통신: 무엇을 어떻게 주고받을까?</a></li></ul></li><li><a href=#webrtc-api는-어떻게-동작하나>WebRTC API는 어떻게 동작하나?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=무엇-왜-어떻게>무엇, 왜, 어떻게?
<a class=anchor href=#%eb%ac%b4%ec%97%87-%ec%99%9c-%ec%96%b4%eb%96%bb%ea%b2%8c>#</a></h1><h2 id=webrtc란-무엇인가>WebRTC란 무엇인가?
<a class=anchor href=#webrtc%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80>#</a></h2><p>WebRTC(Web Real-Time Communication)는 API이자 프로토콜입니다. WebRTC 프로토콜은 두 WebRTC 에이전트가
실시간 양방향 안전 통신을 협상하기 위한 규칙 집합입니다. WebRTC API는 개발자가 이 WebRTC 프로토콜을 사용할 수 있게 합니다.
WebRTC API는 JavaScript를 대상으로 합니다.</p><p>HTTP와 Fetch API의 관계에 비유할 수 있습니다. WebRTC 프로토콜이 HTTP라면, WebRTC API는 Fetch API에 해당합니다.</p><p>WebRTC 프로토콜은 JavaScript 외의 언어로도 구현되어 있습니다. 서버와 도메인 특화 도구들도 존재합니다.
이 모든 구현은 WebRTC 프로토콜을 사용하므로 상호 운용이 가능합니다.</p><p>WebRTC 프로토콜은 IETF(Internet Engineering Task Force)의 <a href=https://datatracker.ietf.org/wg/rtcweb/documents>rtcweb</a> 작업 그룹에서 관리되며,
WebRTC API는 <a href=https://www.w3.org/TR/webrtc>W3C</a>에 문서화되어 있습니다.</p><h2 id=왜-webrtc를-배워야-하나요>왜 WebRTC를 배워야 하나요?
<a class=anchor href=#%ec%99%9c-webrtc%eb%a5%bc-%eb%b0%b0%ec%9b%8c%ec%95%bc-%ed%95%98%eb%82%98%ec%9a%94>#</a></h2><p>WebRTC는 다음과 같은 이점을 제공합니다.</p><ul><li>개방형 표준</li><li>다중 구현체</li><li>웹 브라우저 지원</li><li>의무적 암호화</li><li>NAT 우회</li><li>기존 기술 재사용</li><li>혼잡 제어</li><li>1초 미만 지연</li></ul><p>이 목록은 전부가 아니라 예시에 불과합니다. 아직 익숙하지 않은 용어가 있더라도 걱정하지 마세요.
이 책을 읽는 동안 자연스럽게 의미를 배우게 됩니다.</p><h2 id=webrtc-프로토콜은-여러-기술의-집합>WebRTC 프로토콜은 여러 기술의 집합
<a class=anchor href=#webrtc-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%ec%9d%80-%ec%97%ac%eb%9f%ac-%ea%b8%b0%ec%88%a0%ec%9d%98-%ec%a7%91%ed%95%a9>#</a></h2><p>WebRTC 프로토콜은 방대하여 책 한 권이 필요할 주제입니다. 시작을 위해 네 단계로 나누어 보겠습니다.</p><ol><li>시그널링(Signaling)</li><li>연결(Connecting)</li><li>보안(Securing)</li><li>통신(Communication)</li></ol><p>이 단계들은 순차적입니다. 앞 단계를 충분히 이해해야 다음 단계로 넘어갈 수 있습니다.</p><p>WebRTC의 흥미로운 점은 각 단계가 다시 많은 프로토콜로 이루어져 있다는 것입니다! WebRTC는 이미 존재하는 다양한 기술을 조합해 만듭니다.
즉, WebRTC는 완전히 새로운 발명이라기보다 2000년대 초반부터 잘 이해된 기술들의 조합과 구성으로 볼 수 있습니다.</p><p>각 단계는 별도 장에서 자세히 다루지만, 먼저 높은 수준에서 개념을 잡아두면 도움이 됩니다. 단계들이 서로 의존하므로,
각 단계의 목적을 염두에 두면 세부 설명을 이해하기 쉬워집니다.</p><h3 id=시그널링-webrtc에서-단말들은-어떻게-서로를-찾을까>시그널링: WebRTC에서 단말들은 어떻게 서로를 찾을까?
<a class=anchor href=#%ec%8b%9c%ea%b7%b8%eb%84%90%eb%a7%81-webrtc%ec%97%90%ec%84%9c-%eb%8b%a8%eb%a7%90%eb%93%a4%ec%9d%80-%ec%96%b4%eb%96%bb%ea%b2%8c-%ec%84%9c%eb%a1%9c%eb%a5%bc-%ec%b0%be%ec%9d%84%ea%b9%8c>#</a></h3><p>WebRTC 에이전트는 시작 시점에 누구와 무엇을 통신할지 알지 못합니다. 바로 이 문제를 시그널링이 해결합니다!
시그널링은 두 독립적인 WebRTC 에이전트가 통신을 시작할 수 있도록 호출을 개시합니다.</p><p>시그널링에는 SDP(Session Description Protocol)라는 평문 텍스트 프로토콜을 사용합니다. 각 SDP 메시지는 키-값으로 이뤄지며,
여러 개의 “미디어 섹션”을 포함합니다. 두 WebRTC 에이전트가 교환하는 SDP에는 다음과 같은 정보가 들어갑니다.</p><ul><li>에이전트가 접근 가능한 IP와 포트(ICE 후보)</li><li>전송하려는 오디오/비디오 트랙의 개수</li><li>각 에이전트가 지원하는 오디오/비디오 코덱</li><li>연결 과정에서 사용하는 값들(<code>uFrag</code>/<code>uPwd</code>)</li><li>보안 설정에 사용하는 값(인증서 지문)</li></ul><p>중요한 점은, 시그널링은 대개 “대역 외(out-of-band)”로 이뤄진다는 것입니다. 즉, 애플리케이션은 보통 WebRTC 자체가 아닌
적절한 메시징 수단을 사용해 시그널링 메시지를 교환합니다. SDPs를 주고받기 위해 적합한 어떤 아키텍처도 사용할 수 있으며
많은 애플리케이션은 기존 인프라(예: REST API, WebSocket 연결, 인증 프록시 서버 등)를 그대로 활용합니다.</p><h3 id=연결과-nat-우회-stunturn>연결과 NAT 우회: STUN/TURN
<a class=anchor href=#%ec%97%b0%ea%b2%b0%ea%b3%bc-nat-%ec%9a%b0%ed%9a%8c-stunturn>#</a></h3><p>두 WebRTC 에이전트가 SDP를 교환하면 서로 연결을 시도할 수 있을 만큼의 정보를 갖추게 됩니다. 이를 위해 WebRTC는
ICE(Interactive Connectivity Establishment)라는 확립된 기술을 사용합니다.</p><p>ICE는 WebRTC보다 오래된 프로토콜로, 중앙 서버 없이 두 에이전트 간 직접 연결을 수립할 수 있게 해 줍니다.
두 에이전트는 같은 네트워크에 있을 수도, 지구 반대편에 있을 수도 있습니다.</p><p>ICE는 직접 연결을 가능하게 하지만, 진정한 마법은 ‘NAT 우회’와 STUN/TURN 서버의 사용에 있습니다.
이 두 개념은 다른 서브넷에 있는 ICE 에이전트와 통신하기 위해 필요한 모든 것입니다. 자세한 내용은 뒤에서 다룹니다.</p><p>연결이 성립되면 두 에이전트는 미디어와 데이터 전송을 위한 기반을 얻게 됩니다. 이 과정 전반은 연결성 검사, 후보 수집과 우선순위화,
그리고 최종 후보 쌍 선정 등으로 구성됩니다.</p><h3 id=보안-어떻게-안전하게-만들까>보안: 어떻게 안전하게 만들까?
<a class=anchor href=#%eb%b3%b4%ec%95%88-%ec%96%b4%eb%96%bb%ea%b2%8c-%ec%95%88%ec%a0%84%ed%95%98%ea%b2%8c-%eb%a7%8c%eb%93%a4%ea%b9%8c>#</a></h3><p>연결이 수립된 뒤에는 보안이 중요합니다. WebRTC는 DTLS를 통해 키 교환과 상호 인증을 수행하고, SRTP로 미디어를 암호화합니다.
데이터 채널은 DTLS 위의 SCTP를 통해 보호됩니다. 이렇게 해서 전송 중 콘텐츠가 도청되거나 변조되는 것을 방지합니다.</p><h3 id=통신-무엇을-어떻게-주고받을까>통신: 무엇을 어떻게 주고받을까?
<a class=anchor href=#%ed%86%b5%ec%8b%a0-%eb%ac%b4%ec%97%87%ec%9d%84-%ec%96%b4%eb%96%bb%ea%b2%8c-%ec%a3%bc%ea%b3%a0%eb%b0%9b%ec%9d%84%ea%b9%8c>#</a></h3><p>보안 채널이 준비되면 실제 통신이 시작됩니다. 미디어는 RTP/SRTP로, 데이터는 SCTP(DataChannel)로 전송됩니다.
코덱, 전송률 제어, 패킷 손실 대응, 지터 버퍼 등 실시간 전송 품질을 좌우하는 요소들이 여기에 포함됩니다.</p><p><img src=../images/01-webrtc-agent.png alt="WebRTC 에이전트" title="Diagrama de Agente WebRTC"></p><h2 id=webrtc-api는-어떻게-동작하나>WebRTC API는 어떻게 동작하나?
<a class=anchor href=#webrtc-api%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%98%eb%82%98>#</a></h2><p>이 절은 앞서 설명한 WebRTC 프로토콜이 JavaScript API와 어떻게 대응되는지 설명합니다. API의 모든 기능을 다루는
광범위한 데모가 아니라, 전체를 묶어 이해할 수 있는 사고 모델을 제시합니다.
프로토콜이나 API가 익숙하지 않다면 걱정하지 마세요. 더 배우고 돌아와도 좋습니다!</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p><code>RTCPeerConnection</code>은 최상위 수준의 ‘WebRTC 세션’입니다. 앞서 언급한 모든 하위 시스템을 포함하지만,
아직 이 시점에는 구체적인 동작이 일어나지 않습니다.</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code>은 새로운 RTP 스트림을 만듭니다. 이 스트림에는 무작위 동기화 소스(SSRC)가 할당됩니다.
이 스트림은 <code>createOffer</code>가 생성하는 세션 설명의 미디어 섹션에 포함됩니다. <code>addTrack</code>을 호출할 때마다
새 미디어 섹션과 SSRC가 추가됩니다.</p><p>SRTP 세션이 성립되는 즉시, 이 미디어 패킷들은 SRTP로 암호화되어 ICE를 통해 전송됩니다.</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p><code>createDataChannel</code>은 기존에 SCTP 연결이 없다면 새로운 SCTP 연결을 만듭니다. SCTP는 기본적으로 활성화되어 있지 않으며,
한쪽에서 데이터 채널을 요청할 때 시작됩니다.</p><p>DTLS 세션이 수립되면, SCTP 연결은 DTLS로 암호화된 패킷을 ICE를 통해 전송하기 시작합니다.</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code>는 원격 단말과 공유할 로컬 상태의 세션 설명을 생성합니다.</p><p><code>createOffer</code> 자체는 로컬 단말의 상태를 바꾸지 않습니다.</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code>은 요청된 변경을 확정합니다. <code>addTrack</code>, <code>createDataChannel</code> 등은 이 호출 전까지는 일시적인 상태이며,
보통 <code>createOffer</code>가 만든 값을 <code>setLocalDescription</code>에 전달합니다.</p><p>대개 이 다음 단계로, 생성된 오퍼를 원격 단말에 전송하고, 원격 단말은 이를 받아 <code>setRemoteDescription</code>을 호출합니다.</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p><code>setRemoteDescription</code>은 원격 후보의 상태를 로컬 에이전트에 알립니다. JavaScript API 관점에서 시그널링을 수행하는 단계입니다.</p><p>양쪽에서 <code>setRemoteDescription</code> 호출이 끝나면, 이제 WebRTC 에이전트들은 P2P 통신을 시작하기에 충분한 정보를 갖춘 것입니다!</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code>는 언제든지 원격 ICE 후보를 추가할 수 있게 합니다. 이 API는 후보를 ICE 하위 시스템에 직접 전달하며,
그 외 WebRTC 연결 전반에는 영향을 주지 않습니다.</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code>은 원격 단말에서 RTP 패킷을 수신했을 때 발생합니다. 들어오는 패킷은 <code>setRemoteDescription</code>에 전달된 세션 설명에
기재되어 있습니다.</p><p>WebRTC는 SSRC를 바탕으로 연결된 <code>MediaStream</code>과 <code>MediaStreamTrack</code>을 찾아, 이 정보를 담아 콜백을 호출합니다.</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code>는 ICE 에이전트의 상태 변화가 있을 때 반영됩니다. 네트워크 연결성에 변화가 생기면 이를 통해 알림을 받습니다.</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code>는 ICE와 DTLS 상태를 조합해 보여줍니다. ICE와 DTLS가 성공적으로 완료되었을 때 등을 확인할 수 있습니다.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/d197b9fa3dc748f7270405361db6750321c85ea8 title='Last modified by seonghoon.baek | 9월 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>9월 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#webrtc란-무엇인가>WebRTC란 무엇인가?</a></li><li><a href=#왜-webrtc를-배워야-하나요>왜 WebRTC를 배워야 하나요?</a></li><li><a href=#webrtc-프로토콜은-여러-기술의-집합>WebRTC 프로토콜은 여러 기술의 집합</a><ul><li><a href=#시그널링-webrtc에서-단말들은-어떻게-서로를-찾을까>시그널링: WebRTC에서 단말들은 어떻게 서로를 찾을까?</a></li><li><a href=#연결과-nat-우회-stunturn>연결과 NAT 우회: STUN/TURN</a></li><li><a href=#보안-어떻게-안전하게-만들까>보안: 어떻게 안전하게 만들까?</a></li><li><a href=#통신-무엇을-어떻게-주고받을까>통신: 무엇을 어떻게 주고받을까?</a></li></ul></li><li><a href=#webrtc-api는-어떻게-동작하나>WebRTC API는 어떻게 동작하나?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>