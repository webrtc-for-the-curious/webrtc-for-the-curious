<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>소개 on 호기심 많은 이를 위한 WebRTC</title><link>https://webrtcforthecurious.com/ko/</link><description>Recent content in 소개 on 호기심 많은 이를 위한 WebRTC</description><generator>Hugo</generator><language>ko</language><atom:link href="https://webrtcforthecurious.com/ko/index.xml" rel="self" type="application/rss+xml"/><item><title>무엇, 왜, 어떻게?</title><link>https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/</guid><description>무엇, 왜, 어떻게? # WebRTC란 무엇인가? # WebRTC(Web Real-Time Communication)는 API이자 프로토콜입니다. WebRTC 프로토콜은 두 WebRTC 에이전트가 실시간 양방향 안전 통신을 협상하기 위한 규칙 집합입니다. WebRTC API는 개발자가 이 WebRTC 프로토콜을 사용할 수 있게 합니다. WebRTC API는 JavaScript를 대상으로 합니다.
HTTP와 Fetch API의 관계에 비유할 수 있습니다. WebRTC 프로토콜이 HTTP라면, WebRTC API는 Fetch API에 해당합니다.
WebRTC 프로토콜은 JavaScript 외의 언어로도 구현되어 있습니다. 서버와 도메인 특화 도구들도 존재합니다. 이 모든 구현은 WebRTC 프로토콜을 사용하므로 상호 운용이 가능합니다.</description></item><item><title>시그널링</title><link>https://webrtcforthecurious.com/ko/docs/02-signaling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/02-signaling/</guid><description>시그널링 # WebRTC 시그널링이란? # WebRTC 에이전트를 생성했을 때, 상대 피어에 대해 아는 것은 없습니다. 누구와 연결할지, 무엇을 보낼지 전혀 모릅니다! 시그널링은 통화를 가능하게 만드는 초기 부트스트랩 단계입니다. 이 값들을 교환한 뒤에는 WebRTC 에이전트끼리 직접 통신할 수 있습니다.
시그널링 메시지는 단지 텍스트일 뿐입니다. WebRTC 에이전트는 어떤 전송 수단을 쓰는지 신경 쓰지 않습니다. 보통 WebSocket으로 주고받지만, 필수는 아닙니다.
WebRTC 시그널링은 어떻게 동작하나? # WebRTC는 Session Description Protocol(SDP)이라는 기존 프로토콜을 사용합니다. 이 프로토콜을 통해 두 WebRTC 에이전트는 연결 수립에 필요한 모든 상태를 공유합니다.</description></item><item><title>연결</title><link>https://webrtcforthecurious.com/ko/docs/03-connecting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/03-connecting/</guid><description>연결 # 왜 WebRTC에는 전용 ‘연결’ 하위 시스템이 필요한가요? # 대부분의 애플리케이션은 클라이언트/서버 연결을 사용합니다. 이 모델에서는 서버가 안정적인 전송 주소(IP/포트)를 가져야 하며, 클라이언트가 서버에 요청하면 서버가 응답합니다.
WebRTC는 클라이언트/서버 모델이 아니라 P2P(Peer-to-Peer) 연결을 수립합니다. P2P에서는 연결 수립의 책임이 양쪽 피어에 균등하게 분산됩니다. 이는 WebRTC에서의 전송 주소(IP/포트)를 미리 가정할 수 없고, 심지어 세션 중에도 바뀔 수 있기 때문입니다. WebRTC는 가능한 모든 정보를 수집해 두 WebRTC 에이전트 간 양방향 통신을 성사시키기 위해 많은 과정을 수행합니다.</description></item><item><title>보안</title><link>https://webrtcforthecurious.com/ko/docs/04-securing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/04-securing/</guid><description>보안 # WebRTC는 어떤 보안을 제공하나요? # 모든 WebRTC 연결은 인증되고 암호화됩니다. 제3자가 당신이 보내는 내용을 엿보거나 가짜 메시지를 삽입할 수 없습니다. 또한 세션 설명(Session Description)을 생성한 바로 그 WebRTC 에이전트와 통신하고 있음을 보장할 수 있습니다.
이 메시지들이 변조되지 않는 것이 매우 중요합니다. 전송 중 세션 설명을 제3자가 읽는 것은 괜찮지만, WebRTC는 그 내용이 수정되는 것에 대해 자체 보호 장치가 없습니다. 공격자는 ICE 후보를 바꾸고 인증서 지문을 바꿔 중간자 공격을 시도할 수 있습니다.</description></item><item><title>실시간 네트워킹</title><link>https://webrtcforthecurious.com/ko/docs/05-real-time-networking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/05-real-time-networking/</guid><description>실시간 네트워킹 # 왜 실시간 통신에서 네트워킹이 중요한가요? # 네트워크는 실시간 통신의 한계 요소입니다. 이상적으로는 무한 대역폭과 즉시 도착하는 패킷이 있으면 좋겠지만, 현실은 다릅니다. 네트워크는 제한적이며 언제든 조건이 변할 수 있습니다. 네트워크 상태를 측정/관찰하는 일도 어렵습니다. 하드웨어, 소프트웨어, 설정에 따라 행동이 달라질 수 있습니다.
실시간 통신에는 다른 영역에 없는 문제가 있습니다. 웹사이트가 어떤 네트워크에서 좀 느려도, 데이터만 모두 도착하면 사용자는 괜찮습니다. 하지만 WebRTC에서는 데이터가 늦으면 무용지물입니다. 5초 전에 회의에서 한 말을 지금 받는 건 의미가 없습니다.</description></item><item><title>미디어 통신</title><link>https://webrtcforthecurious.com/ko/docs/06-media-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/06-media-communication/</guid><description>미디어 통신 # WebRTC 미디어 통신으로 무엇을 할 수 있나요? # WebRTC는 무제한의 오디오/비디오 트랙을 보낼 수 있고 받을 수 있습니다. 통화 중에도 언제든 스트림을 추가/제거할 수 있으며, 서로 독립적으로 보낼 수도, 하나의 연결로 번들링할 수도 있습니다. 예를 들어 데스크톱 화면 비디오에 웹캠의 오디오/비디오를 함께 보낼 수 있습니다.
WebRTC 프로토콜은 코덱에 중립적입니다. 기저 전송은 존재하지 않는 형식까지도 이론상 지원할 수 있습니다. 다만 상대 에이전트가 해당 코덱을 처리할 수 있어야 합니다.</description></item><item><title>데이터 통신</title><link>https://webrtcforthecurious.com/ko/docs/07-data-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/07-data-communication/</guid><description>데이터 통신 # WebRTC 데이터 통신으로 무엇을 할 수 있나요? # WebRTC는 데이터 채널을 제공합니다. 두 피어 사이에 최대 65,534개의 채널을 열 수 있습니다. 데이터 채널은 데이터그램 기반이며, 채널마다 내구성(재전송/시간 제한/순서 보장)을 독립적으로 설정할 수 있습니다. 기본은 보장된 순서 전달입니다.
미디어 관점에서 보면 데이터 채널은 과해 보일 수 있습니다. HTTP/WebSocket으로도 보낼 수 있지 않나? 하지만 데이터 채널의 힘은 무질서/손실 허용(UDP 유사) 동작으로 구성할 수 있다는 데 있습니다. 낮은 지연/고성능에 필수적이며, 백프레셔를 측정해 네트워크 용량을 넘지 않도록 보낼 수 있습니다.</description></item><item><title>적용 WebRTC</title><link>https://webrtcforthecurious.com/ko/docs/08-applied-webrtc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/08-applied-webrtc/</guid><description>적용 WebRTC # 이제 WebRTC가 어떻게 동작하는지 알았으니, 실제로 만들어볼 차례입니다! 이 장에서는 사람들이 WebRTC로 무엇을 만들고, 어떻게 만들고 있는지 살펴봅니다. WebRTC로 벌어지는 흥미로운 일들을 배우게 될 것입니다. 다만 강력함에는 대가가 있습니다. 프로덕션급 WebRTC 서비스를 구축하는 일은 도전적입니다. 이 장에서는 여러분이 마주치기 전에 그런 도전 과제를 미리 설명합니다.
사용 사례별 # 많은 이들이 WebRTC를 브라우저 화상회의 기술로만 생각하지만, 그 이상입니다! WebRTC는 매우 다양한 애플리케이션에 쓰입니다. 새로운 사용 사례도 계속 등장하고 있습니다.</description></item><item><title>디버깅</title><link>https://webrtcforthecurious.com/ko/docs/09-debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/09-debugging/</guid><description>디버깅 # WebRTC 디버깅은 만만치 않습니다. 구성요소가 많고, 각자 독립적으로 실패할 수 있습니다. 잘못된 부분을 오래 들여다보느라 시간을 낭비하기 쉽습니다. 이 장은 문제를 분해하고, 인기 있는 도구로 진단하는 방법을 안내합니다.
문제를 격리하라 # 어디에서 문제가 비롯되는지 초기에 구분하세요.
시그널링 실패 # 시그널링 채널이 연결되고, SDP/ICE 후보가 정상적으로 교환되는지부터 확인합니다.
네트워킹 실패 # STUN 서버를 netcat으로 점검할 수 있습니다.
20바이트 바인딩 요청 패킷 준비 echo -ne &amp;#34;\x00\x01\x00\x00\x21\x12\xA4\x42TESTTESTTEST&amp;#34; | hexdump -C 요청 전송 후 32바이트 응답 확인 stunserver=stun1.</description></item><item><title>역사</title><link>https://webrtcforthecurious.com/ko/docs/10-history-of-webrtc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/10-history-of-webrtc/</guid><description>역사 # WebRTC는 기능이 많고 복잡해 보일 수 있습니다. 그러나 이런 복잡성은 다양한 실시간 통신 요구를 포괄하려는 과정에서 생겨났습니다. 이 장은 WebRTC를 구성하는 주요 프로토콜들의 역사와 설계 의도를 간략히 소개합니다. 배경을 이해하면 더 효과적인 시스템을 설계할 수 있습니다.
RTP # RTP/RTCP는 WebRTC의 미디어 전송을 담당하며, 1996년 RFC 1889로 공개되었습니다. 초기 인터넷 멀티캐스트 실험과 화상회의 도구에서 출발해, 오늘날까지도 실시간 미디어 전송의 표준으로 자리 잡았습니다.
맥락과 의도 # 당시 목표는 제한된 대역폭(예: ISDN 128kbps)에서도 수용 가능한 화질을 제공하는 것이었습니다.</description></item><item><title>자주 묻는 질문(FAQ)</title><link>https://webrtcforthecurious.com/ko/docs/11-faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/11-faq/</guid><description>FAQ # 왜 WebRTC는 UDP를 쓰나요? NAT 우회에는 UDP가 필요합니다. NAT 우회가 없다면 P2P 연결을 수립할 수 없습니다. UDP는 TCP처럼 “보장 전달”이 없으므로, WebRTC가 상위 레이어에서 이를 처리합니다.
연결 장을 참고하세요.
DataChannel은 몇 개까지 만들 수 있나요? 식별자(스트림 ID)가 16비트이므로 최대 65,534개입니다. 필요할 때 닫았다가 새로 열 수 있습니다. WebRTC에 대역폭 제한이 있나요? DataChannel과 RTP 모두 혼잡 제어를 사용합니다. 즉, WebRTC가 대역폭을 지속적으로 측정해 최적 사용량을 시도합니다. 가능한 많이 보내되, 연결을 과부하시키지 않는 선에서 균형을 맞춥니다.</description></item><item><title>용어집</title><link>https://webrtcforthecurious.com/ko/docs/12-glossary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/12-glossary/</guid><description>용어집 # ACK: Acknowledgment(확인 응답) AVP: Audio and Video profile B-Frame: 양방향 예측 프레임. 이전/이후 그림을 참고해 부분만 담는 프레임 DCEP: Data Channel Establishment Protocol, RFC 8832 DeMux: Demultiplexer(역다중화) DLSR: Delay since last sender report DTLS: Datagram Transport Layer Security, RFC 6347 E2E: End-to-End(종단 간) FEC: Forward Error Correction FIR: Full INTRA-frame Request G.711: 협대역 오디오 코덱 GCC: Google Congestion Control, draft-ietf-rmcat-gcc-02 H.264: 범용 오디오비주얼 인코딩 규격 H.265: ITU-T H.</description></item><item><title>참고 자료</title><link>https://webrtcforthecurious.com/ko/docs/13-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webrtcforthecurious.com/ko/docs/13-reference/</guid><description>참고 자료 # WebRTC(W3C) # WebRTC 1.0: Real-Time Communication Between Browsers [2021-01-26] (Status: Recommendation) Web Real-Time Communications Working Group - Publications WebRTC(RFC) # RFC8825: Overview: Real-Time Protocols for Browser-Based Applications H. Alvestrand [2021-01] (Status: PROPOSED STANDARD) RFC8826: Security Considerations for WebRTC E. Rescorla [2021-01] (Status: PROPOSED STANDARD) RFC8836: Congestion Control Requirements for Interactive Real-Time Media R. Jesup, Z. Sarker [2021-01] (Status: INFORMATIONAL) RFC8854: WebRTC Forward Error Correction Requirements J. Uberti [2021-01] (Status: PROPOSED STANDARD) DTLS # RFC6347: Datagram Transport Layer Security Version 1.</description></item></channel></rss>