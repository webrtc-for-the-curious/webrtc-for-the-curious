<!doctype html><html lang=fa dir=rtl><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="#ارتباطات رسانه ای
از ارتباطات رسانه ای WebRTC چه چیزی دریافت می کنم؟ # WebRTC به شما امکان ارسال و دریافت تعداد نامحدودی از جریان های صوتی و تصویری را می دهد. می‌توانید این جریان‌ها را در هر زمانی در طول تماس اضافه و حذف کنید. این جریان ها می توانند همه مستقل باشند، یا می توانند با هم جمع شوند! می توانید یک فید ویدیویی از دسکتاپ خود ارسال کنید و سپس صدا و تصویر را از وب کم خود اضافه کنید."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/fa/docs/06-media-communication/"><meta property="og:site_name" content="WebRTC برای کنجکاوها"><meta property="og:title" content="ارتباط رسانه ای"><meta property="og:description" content="#ارتباطات رسانه ای
از ارتباطات رسانه ای WebRTC چه چیزی دریافت می کنم؟ # WebRTC به شما امکان ارسال و دریافت تعداد نامحدودی از جریان های صوتی و تصویری را می دهد. می‌توانید این جریان‌ها را در هر زمانی در طول تماس اضافه و حذف کنید. این جریان ها می توانند همه مستقل باشند، یا می توانند با هم جمع شوند! می توانید یک فید ویدیویی از دسکتاپ خود ارسال کنید و سپس صدا و تصویر را از وب کم خود اضافه کنید."><meta property="og:locale" content="fa"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-07-29T13:34:56-04:00"><title>ارتباط رسانه ای | WebRTC برای کنجکاوها</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/fa/docs/06-media-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/06-media-communication/ title=Mediakommunikation><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/06-media-communication/ title=媒体通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/06-media-communication/ title=メディア・コミュニケーション><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/06-media-communication/ title="Medya İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/06-media-communication/ title="미디어 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fa.search.min.8b42327044e674f28b539739f3740e92d53360646e8ec8ea1c5cd8a5df75f52f.js integrity="sha256-i0IycETmdPKLU5c583QOktUzYGRujsjqHFzYpd919S8=" crossorigin=anonymous></script></head><body dir=rtl><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/fa/><span>WebRTC برای کنجکاوها</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=جستجو aria-label=جستجو maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/06-media-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/06-media-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/06-media-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/06-media-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/06-media-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/06-media-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/06-media-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/06-media-communication/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/06-media-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/fa/docs/01-what-why-and-how/>چه چیزی، چرا و چگونه</a></li><li><a href=/fa/docs/02-signaling/>سیگنالینگ</a></li><li><a href=/fa/docs/03-connecting/>اتصال</a></li><li><a href=/fa/docs/04-securing/>امنیت</a></li><li><a href=/fa/docs/05-real-time-networking/>شبکه بی درنگ</a></li><li><a href=/fa/docs/06-media-communication/ class=active>ارتباط رسانه ای</a></li><li><a href=/fa/docs/07-data-communication/>ارتباط داده ای</a></li><li><a href=/fa/docs/08-applied-webrtc/>اعمال کردن WebRTC</a></li><li><a href=/fa/docs/09-debugging/>اشکال زدایی</a></li><li><a href=/fa/docs/11-faq/>پرسش و پاسخ</a></li><li><a href=/fa/docs/12-glossary/>واژه نامه</a></li><li><a href=/fa/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>ارتباط رسانه ای</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#از-ارتباطات-رسانه-ای-webrtc-چه-چیزی-دریافت-می-کنم>از ارتباطات رسانه ای WebRTC چه چیزی دریافت می کنم؟</a></li><li><a href=#چگونه-کار-می-کند>چگونه کار می کند؟</a></li><li><a href=#تاخیر-و-کیفیت>تاخیر و کیفیت</a><ul><li><a href=#محدودیت-های-دنیای-واقعی>محدودیت های دنیای واقعی</a></li><li><a href=#ویدئو-پیچیده-است>ویدئو پیچیده است</a></li></ul></li><li><a href=#ویدئو-101>ویدئو 101</a><ul><li><a href=#فشرده-سازی-lossy-and-lossless>فشرده سازی Lossy and Lossless</a></li><li><a href=#فشرده-سازی-درون-و-بین-قاب>فشرده سازی درون و بین قاب</a></li><li><a href=#انواع-بین-فریم>انواع بین فریم</a></li><li><a href=#ویدئو-حساس-است>ویدئو حساس است</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#قالب-بسته>قالب بسته</a></li><li><a href=#برنامه-های-افزودنی>برنامه های افزودنی</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#قالب-بسته-1>قالب بسته</a></li><li><a href=#درخواست-کامل-درون-فریم-fir-و-نشان-از-دست-دادن-تصویر-pli>درخواست کامل درون فریم (FIR) و نشان از دست دادن تصویر (PLI)</a></li><li><a href=#تصدیق-منفی>تصدیق منفی</a></li><li><a href=#گزارش-فرستنده-و-گیرنده>گزارش فرستنده و گیرنده</a></li></ul></li><li><a href=#چگونه-rtprtcp-مشکلات-را-با-هم-حل-می-کند>چگونه RTP/RTCP مشکلات را با هم حل می کند</a><ul><li><a href=#تصحیح-خطای-بازارسال>تصحیح خطای بازارسال</a></li><li><a href=#تخمین-نرخ-بیت-و-پهنای-باند-تطبیقی>تخمین نرخ بیت و پهنای باند تطبیقی</a></li></ul></li><li><a href=#شناسایی-و-برقراری-ارتباط-وضعیت-شبکه>شناسایی و برقراری ارتباط وضعیت شبکه</a><ul><li><a href=#گزارش-های-گیرنده--گزارش-های-فرستنده>گزارش های گیرنده / گزارش های فرستنده</a></li><li><a href=#tmmbr-tmmbn-remb-و-twcc-جفت-شده-با-gcc>TMMBR، TMMBN، REMB و TWCC، جفت شده با GCC</a></li></ul></li><li><a href=#جایگزین-های-تخمین-پهنای-باند>جایگزین های تخمین پهنای باند</a></li></ul></nav></aside></header><article class="markdown book-article"><div dir=rtl><p>#ارتباطات رسانه ای</p><h2 id=از-ارتباطات-رسانه-ای-webrtc-چه-چیزی-دریافت-می-کنم>از ارتباطات رسانه ای WebRTC چه چیزی دریافت می کنم؟
<a class=anchor href=#%d8%a7%d8%b2-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7%d8%a7%d8%aa-%d8%b1%d8%b3%d8%a7%d9%86%d9%87-%d8%a7%db%8c-webrtc-%da%86%d9%87-%da%86%db%8c%d8%b2%db%8c-%d8%af%d8%b1%db%8c%d8%a7%d9%81%d8%aa-%d9%85%db%8c-%da%a9%d9%86%d9%85>#</a></h2><p>WebRTC به شما امکان ارسال و دریافت تعداد نامحدودی از جریان های صوتی و تصویری را می دهد. می‌توانید این جریان‌ها را در هر زمانی در طول تماس اضافه و حذف کنید. این جریان ها می توانند همه مستقل باشند، یا می توانند با هم جمع شوند! می توانید یک فید ویدیویی از دسکتاپ خود ارسال کنید و سپس صدا و تصویر را از وب کم خود اضافه کنید.</p><p>پروتکل WebRTC کدک آگنوستیک(با همه ی دستگاه ها و سیستم عامل ها کار می کند) است. حمل و نقل زیربنایی از همه چیز پشتیبانی می کند، حتی چیزهایی که هنوز وجود ندارند! با این حال، عامل WebRTC که با آن در ارتباط هستید ممکن است ابزار لازم برای پذیرش آن را نداشته باشد.</p><p>WebRTC همچنین برای رسیدگی به شرایط شبکه پویا طراحی شده است. در طول تماس، پهنای باند شما ممکن است افزایش یا کاهش یابد. شاید به طور ناگهانی از دست دادن بسته های زیادی را تجربه کنید. پروتکل برای رسیدگی به همه اینها طراحی شده است. WebRTC به شرایط شبکه پاسخ می دهد و سعی می کند بهترین تجربه ممکن را با منابع موجود به شما ارائه دهد.</p><h2 id=چگونه-کار-می-کند>چگونه کار می کند؟
<a class=anchor href=#%da%86%da%af%d9%88%d9%86%d9%87-%da%a9%d8%a7%d8%b1-%d9%85%db%8c-%da%a9%d9%86%d8%af>#</a></h2><p>WebRTC از دو پروتکل از پیش موجود RTP و RTCP استفاده می کند که هر دو در <a href=https://tools.ietf.org/html/rfc1889>RFC 1889</a> تعریف شده اند.</p><p>RTP (پروتکل ارتباطی در زمان بی درنگ) پروتکلی است که رسانه(صدا و تصویر) را منتقل می کند. این به گونه ای طراحی شده است که امکان ارسال بلادرنگ ویدیو را فراهم کند. هیچ قاعده‌ای در مورد تأخیر یا قابلیت اطمینان تعیین نمی‌کند، اما ابزارهایی را برای پیاده‌سازی آنها در اختیار شما قرار می‌دهد. RTP به شما جریان رسانه ای (صدا و تصویر) ارایه می دهد، بنابراین می توانید چندین خط رسانه(چندین صدا و تصویر) را روی یک اتصال بفرستید. همچنین زمان بندی و اطلاعات سفارشی را که برای مقدار دهی اولیه خط رسانه نیاز دارید در اختیار شما قرار می دهد.</p><p>RTCP (پروتکل کنترل RTP) پروتکلی است که فرا داده یا متادیتا را در مورد تماس تعیین می کند. قالب فراداده بسیار منعطف است و به شما امکان می دهد هر فراداده ای را که می خواهید اضافه کنید. از این مورد برای برقراری ارتباط آماری در مورد تماس استفاده می شود(مانند پهنای باند و نرخ فریم). همچنین برای کنترل از دست دادن بسته ها و اجرای کنترل ازدحام استفاده می شود. این پروتکل ارتباط دو طرفه لازم برای پاسخ به شرایط متغیر شبکه را به شما می دهد.</p><h2 id=تاخیر-و-کیفیت>تاخیر و کیفیت
<a class=anchor href=#%d8%aa%d8%a7%d8%ae%db%8c%d8%b1-%d9%88-%da%a9%db%8c%d9%81%db%8c%d8%aa>#</a></h2><p>در رسانه های بلادرنگ توازنی(تریدآف) بین تأخیر و کیفیت وجود دارد. هرچه زمان تاخیر بیشتری را تحمل کنید، می توانید انتظار ویدیوی با کیفیت بالاتری داشته باشید.</p><h3 id=محدودیت-های-دنیای-واقعی>محدودیت های دنیای واقعی
<a class=anchor href=#%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa-%d9%87%d8%a7%db%8c-%d8%af%d9%86%db%8c%d8%a7%db%8c-%d9%88%d8%a7%d9%82%d8%b9%db%8c>#</a></h3><p>این محدودیت ها همه ناشی از محدودیت های دنیای واقعی است. همه آنها ویژگی های شبکه شما هستند که باید بر آنها غلبه کنید.</p><h3 id=ویدئو-پیچیده-است>ویدئو پیچیده است
<a class=anchor href=#%d9%88%db%8c%d8%af%d8%a6%d9%88-%d9%be%db%8c%da%86%db%8c%d8%af%d9%87-%d8%a7%d8%b3%d8%aa>#</a></h3><p>ارتباط ویدئویی آسان نیست. برای ذخیره 30 دقیقه ویدیوی 720 8 بیتی فشرده نشده، به حدود 110 گیگابایت حافظه نیاز دارید. با این حجم از حافظه، یک کنفرانس تلفنی 4 نفره اتفاق نمی افتد. ما به راهی برای کوچکتر کردن آن نیاز داریم و پاسخ آن فشرده سازی ویدیو است. هر چند که مشکلاتی نیز به بار می آورد.</p><h2 id=ویدئو-101>ویدئو 101
<a class=anchor href=#%d9%88%db%8c%d8%af%d8%a6%d9%88-101>#</a></h2><p>ما قصد نداریم فشرده سازی ویدیو را به طور عمیق پوشش دهیم، بلکه به اندازه ای است که بفهمیم چرا RTP به این شکل طراحی شده توضیح خواهیم داد. فشرده‌سازی ویدیو، ویدیو را در قالب جدیدی کد می‌کند که برای نمایش همان ویدیو به بیت‌های کمتری نیاز دارد.</p><h3 id=فشرده-سازی-lossy-and-lossless>فشرده سازی Lossy and Lossless
<a class=anchor href=#%d9%81%d8%b4%d8%b1%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-lossy-and-lossless>#</a></h3><p>می‌توانید ویدیو را به گونه‌ای کد کنید که بدون اتلاف (هیچ اطلاعاتی از بین نرود) باشد یا با اتلاف (ممکن است اطلاعات از بین برود) باشد. از آنجایی که کد کردن بدون اتلاف نیاز به داده های بیشتری برای ارسال به همتا دارد، که باعث می شود جریان تاخیری بالاتر و بسته های حذف شده بیشتری ایجاد شود، RTP معمولاً از فشرده سازی با اتلاف استفاده می کند حتی اگر کیفیت ویدیو به خوبی نباشد.</p><h3 id=فشرده-سازی-درون-و-بین-قاب>فشرده سازی درون و بین قاب
<a class=anchor href=#%d9%81%d8%b4%d8%b1%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d8%af%d8%b1%d9%88%d9%86-%d9%88-%d8%a8%db%8c%d9%86-%d9%82%d8%a7%d8%a8>#</a></h3><p>فشرده سازی ویدئو در دو نوع ارائه می شود. اولین مورد درون قاب یا فریم است(فشرده سازی خود فریم). فشرده سازی درون فریم بیت های مورد استفاده برای توصیف یک فریم ویدئو را کاهش می دهد. از همین روش ها برای فشرده سازی تصاویر ثابت استفاده می شود، مانند روش فشرده سازی JPEG.</p><p>نوع دوم فشرده سازی بین قاب(فریم) است. از آنجایی که ویدیو از تصاویر زیادی تشکیل شده است، ما به دنبال راه هایی هستیم که اطلاعات یکسانی را دوبار ارسال نکنیم.</p><h3 id=انواع-بین-فریم>انواع بین فریم
<a class=anchor href=#%d8%a7%d9%86%d9%88%d8%a7%d8%b9-%d8%a8%db%8c%d9%86-%d9%81%d8%b1%db%8c%d9%85>#</a></h3><p>سپس شما سه نوع قاب دارید:</p><ul><li><strong>I-Frame</strong> - یک تصویر کامل، می تواند بدون هیچ چیز دیگری رمزگشایی شود.</li><li><strong>P-Frame</strong> - یک تصویر جزئی که فقط شامل تغییرات نسبت به عکس قبلی است.</li><li><strong>B-Frame</strong> - یک تصویر جزئی، اصلاحی از تصاویر قبلی و آینده است.</li></ul><p>در زیر تصویر سه نوع قاب وجود دارد.</p><p><img src=../images/06-frame-types.png alt="انواع قاب" title="انواع قاب"></p><h3 id=ویدئو-حساس-است>ویدئو حساس است
<a class=anchor href=#%d9%88%db%8c%d8%af%d8%a6%d9%88-%d8%ad%d8%b3%d8%a7%d8%b3-%d8%a7%d8%b3%d8%aa>#</a></h3><p>فشرده‌سازی ویدیو به‌طور باورنکردنی چند حالتی است و انتقال آن را از طریق اینترنت دشوار می‌کند. اگر بخشی از I-Frame را گم کنید چه اتفاقی می‌افتد؟ چگونه یک P-Frame می داند چه چیزی را باید تغییر دهد؟ همانطور که فشرده سازی ویدئو پیچیده تر می شود، این مشکل حتی بیشتر می شود. خوشبختانه RTP و RTCP راه حلی برای این مشکل دارند.</p><h2 id=rtp>RTP
<a class=anchor href=#rtp>#</a></h2><h3 id=قالب-بسته>قالب بسته
<a class=anchor href=#%d9%82%d8%a7%d9%84%d8%a8-%d8%a8%d8%b3%d8%aa%d9%87>#</a></h3><p>هر بسته RTP دارای ساختار زیر است:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=نسخه-v>نسخه (V)
<a class=anchor href=#%d9%86%d8%b3%d8%ae%d9%87-v>#</a></h4><p><code>نسخه</code> همیشه <code>2</code> است</p><h4 id=پدینگ-p>پدینگ (P)
<a class=anchor href=#%d9%be%d8%af%db%8c%d9%86%da%af-p>#</a></h4><p><code>Padding</code> یک صفر و یک(بولین) است که کنترل می‌کند آیا محموله دارای بالشتک(پدینگ) است.</p><p>آخرین بایت محموله، حاوی تعداد بایت های padding اضافه شده است.</p><h4 id=پسوند-x>پسوند (X)
<a class=anchor href=#%d9%be%d8%b3%d9%88%d9%86%d8%af-x>#</a></h4><p>اگر تنظیم شود، هدر RTP پسوندهایی خواهد داشت. این با جزئیات بیشتر در زیر توضیح داده شده است.</p><h4 id=تعداد-csrc-cc>تعداد CSRC (CC)
<a class=anchor href=#%d8%aa%d8%b9%d8%af%d8%a7%d8%af-csrc-cc>#</a></h4><p>تعداد شناسه‌های <code>CSRC</code> که بعد از <code>SSRC</code> و قبل از بارگذاری تعیین می شوند.</p><h4 id=نشانگر-m>نشانگر (M)
<a class=anchor href=#%d9%86%d8%b4%d8%a7%d9%86%da%af%d8%b1-m>#</a></h4><p>بیت نشانگر معنای از پیش تعیین شده ای ندارد و می تواند هر طور که کاربر دوست دارد استفاده شود.</p><p>در برخی موارد زمانی تنظیم می شود که کاربر در حال صحبت است. همچنین معمولاً برای علامت گذاری یک فریم کلیدی استفاده می شود.</p><h4 id=نوع-بار-pt>نوع بار (PT)
<a class=anchor href=#%d9%86%d9%88%d8%b9-%d8%a8%d8%a7%d8%b1-pt>#</a></h4><p><code>Payload Type</code> یک شناسه منحصر به فرد برای کدک هایی است که توسط این بسته منتقل می شود.</p><p>برای WebRTC <code>نوع بار</code> پویا است. VP8 در یک تماس ممکن است با دیگری متفاوت باشد. پیشنهاد دهنده در تماس، نگاشت <code>انواع بار</code> را به کدک‌ها در <code>شرح جلسه(SDP)</code> تعیین می‌کند.</p><h4 id=شماره-ترتیب>شماره ترتیب
<a class=anchor href=#%d8%b4%d9%85%d8%a7%d8%b1%d9%87-%d8%aa%d8%b1%d8%aa%db%8c%d8%a8>#</a></h4><p><code>Sequence Number</code> برای ترتیب گرفتن بسته ها در یک جریان استفاده می شود. هر بار که یک بسته ارسال می شود، <code>شماره ترتیبی</code> یک عدد افزایش می یابد.</p><p>RTP به گونه ای طراحی شده است که در شبکه های با اتلاف قابل استفاده باشد. این به گیرنده راهی می دهد تا تشخیص دهد که چه زمانی بسته ها گم شده است.</p><h4 id=مهر-زمانی>مهر زمانی
<a class=anchor href=#%d9%85%d9%87%d8%b1-%d8%b2%d9%85%d8%a7%d9%86%db%8c>#</a></h4><p>لحظه ای است که بسته برای ارسال آماده می شود. این مهر زمانی یک ساعت جهانی نیست، بلکه چقدر زمان در جریان رسانه ها سپری شده است. چندین بسته RTP می توانند دارای مهر زمانی یکسانی باشند اگر برای مثال همه آنها بخشی از یک قاب ویدیو باشند.</p><h4 id=منبع-همگام-سازی-ssrc>منبع همگام سازی (SSRC)
<a class=anchor href=#%d9%85%d9%86%d8%a8%d8%b9-%d9%87%d9%85%da%af%d8%a7%d9%85-%d8%b3%d8%a7%d8%b2%db%8c-ssrc>#</a></h4><p><code>SSRC</code> شناسه منحصربه‌فرد برای این جریان است. این به شما امکان می دهد چندین جریان رسانه را روی یک جریان RTP منتقل کنید.</p><h4 id=منبع-اضافه-کننده-csrc>منبع اضافه کننده (CSRC)
<a class=anchor href=#%d9%85%d9%86%d8%a8%d8%b9-%d8%a7%d8%b6%d8%a7%d9%81%d9%87-%da%a9%d9%86%d9%86%d8%af%d9%87-csrc>#</a></h4><p>فهرستی که آنچه را که <code>SSRC</code> به این بسته اضافه کرده است را بیان می‌کند.</p><p>این معمولا برای نشان دادن صحبت کردن استفاده می شود. فرض کنید در سمت سرور چندین فید صوتی را در یک جریان RTP ترکیب کرده اید. سپس می توانید از این فیلد برای گفتن &ldquo;جریان ورودی A و C در این لحظه صحبت می کردند&rdquo; استفاده کنید.</p><h4 id=payload>Payload
<a class=anchor href=#payload>#</a></h4><p>اگر پرچم padding تنظیم شده باشد، داده های بار واقعی ممکن است با شمارش تعداد بایت های padding اضافه شده به پایان برسد.</p><h3 id=برنامه-های-افزودنی>برنامه های افزودنی
<a class=anchor href=#%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87-%d9%87%d8%a7%db%8c-%d8%a7%d9%81%d8%b2%d9%88%d8%af%d9%86%db%8c>#</a></h3><h2 id=rtcp>RTCP
<a class=anchor href=#rtcp>#</a></h2><h3 id=قالب-بسته-1>قالب بسته
<a class=anchor href=#%d9%82%d8%a7%d9%84%d8%a8-%d8%a8%d8%b3%d8%aa%d9%87-1>#</a></h3><p>هر بسته RTCP ساختار زیر را دارد:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |       PT      |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=نسخه-v-1>نسخه (V)
<a class=anchor href=#%d9%86%d8%b3%d8%ae%d9%87-v-1>#</a></h4><p><code>نسخه</code> همیشه <code>2</code> است.</p><h4 id=padding-p>Padding (P)
<a class=anchor href=#padding-p>#</a></h4><p><code>Padding</code> یک صفر یا یک(بولین) است که کنترل می‌کند آیا محموله دارای بالشتک یا پدینگ است یا خیر.</p><p>آخرین بایت محموله حاوی تعداد بایت های padding اضافه شده است.</p><h4 id=تعداد-گزارش-پذیرش-rc>تعداد گزارش پذیرش (RC)
<a class=anchor href=#%d8%aa%d8%b9%d8%af%d8%a7%d8%af-%da%af%d8%b2%d8%a7%d8%b1%d8%b4-%d9%be%d8%b0%db%8c%d8%b1%d8%b4-rc>#</a></h4><p>تعداد گزارش ها در یک بسته RTCP می تواند شامل چندین رویداد باشد.</p><h4 id=نوع-بسته-pt>نوع بسته (PT)
<a class=anchor href=#%d9%86%d9%88%d8%b9-%d8%a8%d8%b3%d8%aa%d9%87-pt>#</a></h4><p>شناسه منحصر به فرد برای نوع بسته RTCP را نوع بسته می گویند. یک نماینده WebRTC نیازی به پشتیبانی از همه این انواع ندارد و پشتیبانی بین Agent ها می تواند متفاوت باشد. اینها مواردی هستند که معمولاً ممکن است ببینید:</p><ul><li><code>192</code> - درخواست کامل درون فریم (<code>FIR</code>)</li><li><code>193</code> - تصدیق های(ACK) منفی (&ldquo;NACK&rdquo;)</li><li><code>200</code> - گزارش فرستنده</li><li><code>201</code> - گزارش گیرنده</li><li><code>205</code> - بازخورد عمومی RTP</li><li><code>206</code> - بازخورد ویژه بار</li></ul><p>اهمیت این انواع بسته در زیر با جزئیات بیشتر توضیح داده خواهد شد.</p><h3 id=درخواست-کامل-درون-فریم-fir-و-نشان-از-دست-دادن-تصویر-pli>درخواست کامل درون فریم (FIR) و نشان از دست دادن تصویر (PLI)
<a class=anchor href=#%d8%af%d8%b1%d8%ae%d9%88%d8%a7%d8%b3%d8%aa-%da%a9%d8%a7%d9%85%d9%84-%d8%af%d8%b1%d9%88%d9%86-%d9%81%d8%b1%db%8c%d9%85-fir-%d9%88-%d9%86%d8%b4%d8%a7%d9%86-%d8%a7%d8%b2-%d8%af%d8%b3%d8%aa-%d8%af%d8%a7%d8%af%d9%86-%d8%aa%d8%b5%d9%88%db%8c%d8%b1-pli>#</a></h3><p>هر دو پیام <code>FIR</code> و <code>PLI</code> هدفی مشابه دارند. این پیام‌ها یک فریم کلید کامل از فرستنده درخواست می‌کنند.
<code>PLI</code> زمانی استفاده می‌شود که فریم‌های جزئی به رمزگشا داده می‌شود، اما قادر به رمزگشایی آنها نبوده است.
این ممکن است به این دلیل اتفاق بیفتد که شما بسته های زیادی از دست داده اید، یا شاید رمزگشا از کار افتاده است.</p><p>طبق تعریف <a href=https://tools.ietf.org/html/rfc5104#section-4.3.1.2>RFC 5104</a> ، <code>FIR</code> نباید در هنگام از دست رفتن بسته ها یا فریم ها استفاده شود. این کار PLI است. <code>FIR</code> یک فریم کلیدی را به دلایلی غیر از دست دادن بسته درخواست می کند - برای مثال زمانی که یک عضو جدید وارد یک کنفرانس ویدیویی می شود. آنها برای شروع دیکود کردن جریان ویدئو به یک فریم کلید کامل نیاز دارند، رمزگشا تا رسیدن فریم کلیدی، فریم‌ها را دور می‌اندازد.</p><p>این ایده خوبی است که گیرنده بلافاصله پس از اتصال درخواست یک فریم کامل کلید را بدهد، این امر تأخیر بین اتصال و نمایش تصویر در صفحه کاربر را به حداقل می رساند.</p><p>بسته‌های <code>PLI</code> بخشی از پیام‌های بازخورد خاص Payload هستند.</p><p>در عمل، نرم‌افزاری که قادر به مدیریت هر دو بسته <code>PLI</code> و <code>FIR</code> است، در هر دو حالت یکسان عمل می‌کند. این یک سیگنال به کد کننده ارسال می کند تا یک قاب کامل کلید جدید تولید کند.</p><h3 id=تصدیق-منفی>تصدیق منفی
<a class=anchor href=#%d8%aa%d8%b5%d8%af%db%8c%d9%82-%d9%85%d9%86%d9%81%db%8c>#</a></h3><p><code>NACK</code> درخواست می کند که یک بسته RTP تکی دوباره ارسال شود. این معمولاً به دلیل از دست رفتن بسته RTP ایجاد می شود، اما ممکن است به دلیل تاخیر هم اتفاق بیفتد.</p><p><code>NACK</code>ها پهنای باند بسیار بیشتری نسبت به درخواست ارسال مجدد کل فریم دارند. از آنجایی که RTP بسته ها را به قطعات بسیار کوچک تقسیم می کند، شما در واقع فقط یک قطعه کوچک از دست رفته را دوباره درخواست می کنید. گیرنده یک پیام RTCP با SSRC و شماره دنباله ایجاد می کند. اگر فرستنده این بسته RTP را برای ارسال مجدد در دسترس نداشته باشد، آن گاه پیام را نادیده می گیرد.</p><h3 id=گزارش-فرستنده-و-گیرنده>گزارش فرستنده و گیرنده
<a class=anchor href=#%da%af%d8%b2%d8%a7%d8%b1%d8%b4-%d9%81%d8%b1%d8%b3%d8%aa%d9%86%d8%af%d9%87-%d9%88-%da%af%db%8c%d8%b1%d9%86%d8%af%d9%87>#</a></h3><p>این گزارش ها برای ارسال آمار بین عامل ها استفاده می شود. این مقدار بسته های واقعی دریافت شده و جیتر را با هم ارتباط می دهد.</p><p>گزارش ها را می توان برای تشخیص و کنترل ازدحام استفاده کرد.</p><h2 id=چگونه-rtprtcp-مشکلات-را-با-هم-حل-می-کند>چگونه RTP/RTCP مشکلات را با هم حل می کند
<a class=anchor href=#%da%86%da%af%d9%88%d9%86%d9%87-rtprtcp-%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-%d8%b1%d8%a7-%d8%a8%d8%a7-%d9%87%d9%85-%d8%ad%d9%84-%d9%85%db%8c-%da%a9%d9%86%d8%af>#</a></h2><p>RTP و RTCP با هم کار می کنند تا تمام مشکلات ناشی از شبکه ها را حل کنند. این تکنیک ها همچنان در حال تغییر هستند!</p><h3 id=تصحیح-خطای-بازارسال>تصحیح خطای بازارسال
<a class=anchor href=#%d8%aa%d8%b5%d8%ad%db%8c%d8%ad-%d8%ae%d8%b7%d8%a7%db%8c-%d8%a8%d8%a7%d8%b2%d8%a7%d8%b1%d8%b3%d8%a7%d9%84>#</a></h3><p>صحیح خطای بازارسال، همچنین به عنوان FEC نیز شناخته می شود. روش دیگری برای مقابله با از دست دادن بسته است. FEC زمانی است که شما یک داده را چندین بار ارسال می کنید، بدون اینکه حتی درخواست شود. این در سطح RTP یا حتی سطح پایین‌تر با کدک انجام می شود.</p><p>اگر از دست دادن بسته برای یک تماس ثابت باشد، FEC راه حلی با تاخیر بسیار کمتری نسبت به NACK است. زمان رفت و برگشت درخواست، و سپس ارسال مجدد بسته از دست رفته می تواند برای NACK ها هم مهم باشد.</p><h3 id=تخمین-نرخ-بیت-و-پهنای-باند-تطبیقی>تخمین نرخ بیت و پهنای باند تطبیقی
<a class=anchor href=#%d8%aa%d8%ae%d9%85%db%8c%d9%86-%d9%86%d8%b1%d8%ae-%d8%a8%db%8c%d8%aa-%d9%88-%d9%be%d9%87%d9%86%d8%a7%db%8c-%d8%a8%d8%a7%d9%86%d8%af-%d8%aa%d8%b7%d8%a8%db%8c%d9%82%db%8c>#</a></h3><p>همانطور که در فصل <a href=../05-%d8%b4%d8%a8%da%a9%d9%87-%d8%a8%db%8c-%d8%af%d8%b1%d9%86%da%af/>شبکه بی درنگ</a> بحث شد، شبکه ها غیرقابل پیش بینی و غیرقابل اعتماد هستند. در دسترس بودن پهنای باند می تواند چندین بار در طول یک جلسه تغییر کند.
غیر معمول نیست که شاهد تغییر چشمگیر پهنای باند موجود در عرض یک ثانیه باشیم.</p><p>ایده اصلی تنظیم نرخ کدینگ بر اساس پهنای باند شبکه پیش‌بینی‌شده ی فعلی و آینده است.
این تضمین می کند که سیگنال تصویری و صوتی با بهترین کیفیت ممکن منتقل می شود و اتصال به دلیل ازدحام شبکه قطع نمی شود.
احتمالاتی که رفتار شبکه را مدل می کند و سعی می کند آن را پیش بینی کند به عنوان تخمین پهنای باند شناخته می شود.</p><p>تفاوت های ظریف زیادی در این مورد وجود دارد، بنابراین اجازه دهید جزئیات بیشتری را بررسی کنیم.</p><h2 id=شناسایی-و-برقراری-ارتباط-وضعیت-شبکه>شناسایی و برقراری ارتباط وضعیت شبکه
<a class=anchor href=#%d8%b4%d9%86%d8%a7%d8%b3%d8%a7%db%8c%db%8c-%d9%88-%d8%a8%d8%b1%d9%82%d8%b1%d8%a7%d8%b1%db%8c-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7-%d9%88%d8%b6%d8%b9%db%8c%d8%aa-%d8%b4%d8%a8%da%a9%d9%87>#</a></h2><p>RTP/RTCP روی انواع شبکه‌های مختلف اجرا می‌شود و در نتیجه برای برخی رایج است
ارتباط در مسیر خود از فرستنده به گیرنده قطع شود. در سطح انتقال UDP ،
هیچ مکانیزم داخلی برای ارسال مجدد بسته وجود ندارد، چه رسد به مدیریت ازدحام.</p><p>برای ارائه بهترین تجربه به کاربران، WebRTC باید کیفیت های مربوط به مسیر شبکه را تخمین بزند و با تغییر پارامتر های شبکه، کیفیت ها در طول زمان وفق دهد. مقادیر کلیدی برای نظارت عبارتند از: در دسترس بودن
پهنای باند (در هر جهت، زیرا ممکن است متقارن نباشد)، زمان رفت و برگشت، و لرزش (نوسانات)
در رفت و برگشت. باید از دست دادن بسته ها بررسی کند و تغییرات لازم را به کیفیت ویدیو بدهد.</p><p>دو هدف اصلی برای این پروتکل ها وجود دارد:</p><ol><li>پهنای باند موجود (در هر جهت) توسط شبکه را تخمین بزند.</li><li>ویژگی های ارتباطی شبکه بین فرستنده و گیرنده متوجه شود.</li></ol><p>RTP/RTCP سه رویکرد متفاوت برای رفع این مشکل دارد. همه آنها جوانب مثبت و منفی خود را دارند،
و به طور کلی هر نسل نسبت به نسل های قبلی خود پیشرفت کرده است. این که کدام پیاده سازی را قرار استفاده می کنید، در درجه اول به پشته نرم افزاری که در دسترس مشتریان شما و کتابخانه های موجود است بستگی دارد</p><h3 id=گزارش-های-گیرنده--گزارش-های-فرستنده>گزارش های گیرنده / گزارش های فرستنده
<a class=anchor href=#%da%af%d8%b2%d8%a7%d8%b1%d8%b4-%d9%87%d8%a7%db%8c-%da%af%db%8c%d8%b1%d9%86%d8%af%d9%87--%da%af%d8%b2%d8%a7%d8%b1%d8%b4-%d9%87%d8%a7%db%8c-%d9%81%d8%b1%d8%b3%d8%aa%d9%86%d8%af%d9%87>#</a></h3><p>اولین پیاده سازی، جفت Receiver Reports و مکمل آن Sender Reports است. اینها
پیام‌های RTCP است که در <a href=https://tools.ietf.org/html/rfc3550#section-6.4>RFC 3550</a> تعریف شده‌اند و
مسئول ارتباط وضعیت شبکه بین نقاط پایانی است. Receiver Reports بر روی این تمرکز دارد که
کیفیت های ارتباطی در مورد شبکه (از جمله از دست دادن بسته، زمان رفت و برگشت و جیتر)، و
با الگوریتم های دیگر همگام شود بعد از آن مسئول تخمین پهنای باند موجود بر اساس
این گزارش ها است.</p><p>گزارش های فرستنده و گیرنده (SR و RR) با هم تصویری از کیفیت شبکه را ترسیم می کنند. این مقادیر برای هر SSRC در یک برنامه زمانی ارسال می شود، و این مقادیر ورودی هایی هستند که هنگام تخمین شبکه استفاده می شوند
این تخمین ها توسط فرستنده پس از دریافت داده های RR ساخته می شوند که حاوی
فیلد های زیر هستند:</p><ul><li><strong>ضریب از دست رفتن</strong> - چند درصد از بسته ها از آخرین گزارش گیرنده از بین رفته اند.</li><li><strong>مجموع تعداد بسته های از دست رفته</strong> - تعداد بسته هایی که در طول کل تماس از بین رفته اند.</li><li><strong>بزرگترین شماره دریافت شده</strong> - آخرین شماره دنباله دریافتی چه بوده است، و
چند بار تکرار شده است</li><li><strong>مهر زمان گزارش آخرین فرستنده</strong> - آخرین زمان شناخته شده در فرستنده، برای محاسبه زمان رفت و برگشت استفاده می شود</li></ul><p>SR و RR با هم کار می کنند تا زمان رفت و برگشت را محاسبه کنند.</p><p>فرستنده زمان محلی خود <code>sendertime1</code> که در SR است را ذخیره می کند. هنگامی که گیرنده یک بسته SR دریافت می کند، آن را دوباره به RR پس می فرستد. و یک چیز دیگر، RR نیز <code>sendertime1</code> است که به تازگی از فرستنده گرفته است ذخیره می کند.
بین دریافت SR و ارسال RR تاخیر وجود خواهد داشت. به همین دلیل، RR نیز
شامل زمان <code>تأخیر از آخرین گزارش فرستنده</code> است - که به آن <code>DLSR</code> گویند. <code>DLSR</code> برای تنظیم
تخمین زمان رفت و برگشت در مراحل بعدی استفاده می شود. هنگامی که فرستنده RR را دریافت کرد،
<code>sendertime1</code> و <code>DLSR</code> از زمان کنونی <code>sendertime2</code> کم می کند. این زمان دلتا را رفت و برگشت تاخیر یا انتشار یا زمان رفت و برگشت می نامند</p><p><code>rtt = sendertime2 - sendertime1 - DLSR</code></p><p>زمان رفت و برگشت به زبان فارسی ساده:</p><ul><li>من برای شما پیامی با قرائت فعلی ساعتم ارسال می کنم، مثلا می گویم ساعت 16:20 و 42 ثانیه و 420 میلی ثانیه است.</li><li>شما همان مُهر زمان را برای من باز می گردانید.</li><li>شما همچنین زمان سپری شده از خواندن پیام من تا ارسال مجدد پیام، مثلاً 5 میلی ثانیه را در نظر می گیرید.</li><li>هنگامی که زمان را به قبلی دریافت کردم، دوباره به ساعت نگاه می کنم.</li><li>اکنون ساعت من می گوید 4:20 بعد از ظهر، 42 ثانیه و 690 میلی ثانیه.</li><li>یعنی 265 میلی ثانیه (690 - 420 - 5) طول کشید تا بسته به شما رسید و به سمت من برگشت.</li><li>بنابراین زمان رفت و برگشت 265 میلی ثانیه است.</li></ul><p><img src=../images/06-rtt.png alt="زمان رفت و برگشت" title="زمان رفت و برگشت"></p><h3 id=tmmbr-tmmbn-remb-و-twcc-جفت-شده-با-gcc>TMMBR، TMMBN، REMB و TWCC، جفت شده با GCC
<a class=anchor href=#tmmbr-tmmbn-remb-%d9%88-twcc-%d8%ac%d9%81%d8%aa-%d8%b4%d8%af%d9%87-%d8%a8%d8%a7-gcc>#</a></h3><h4 id=google-congestion-control-gcc>Google Congestion Control (GCC)
<a class=anchor href=#google-congestion-control-gcc>#</a></h4><p>الگوریتم کنترل ازدحام Google (GCC) (به طور خلاصه در
<a href=https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>draft-ietf-rmcat-gcc-02</a> توضیح داده شده است)
به چالش تخمین پهنای باند می پردازد. این الگوریتم با انواع پروتکل های دیگر همگام می شود تا
الزامات ارتباطی مرتبط را تسهیل کند. در نتیجه برای اجرا در هر دو طرف گیرنده (هنگامی که با TMMBR/TMMBN یا REMB اجرا می شود) و یا حتی در هر دو سمت ارسال کننده (هنگامی که با TWCC اجرا می شود) بسیار مناسب است.</p><p>برای رسیدن به تخمین‌هایی برای پهنای باند موجود، GCC روی از دست دادن بسته‌ها و نوسانات فریم تمرکز می‌کند.
زمان رسیدن به عنوان دو معیار اصلی آن می باشد. این معیارها را از طریق دو کنترلر مرتبط اجرا می کند:
کنترل کننده مبتنی بر از دست رفتن و کنترل کننده مبتنی بر تاخیر.</p><p>اولین جزء GCC، کنترل کننده مبتنی بر از دست رفتن بسیار ساده است:</p><ul><li>اگر از دست دادن بسته بالاتر از 10٪ باشد، تخمین پهنای باند کاهش می یابد.</li><li>اگر از دست دادن بسته بین 2-10٪ باشد، تخمین پهنای باند ثابت می ماند.</li><li>اگر از دست دادن بسته کمتر از 2٪ باشد، تخمین پهنای باند افزایش می یابد.</li></ul><p>اندازه گیری از دست دادن بسته ها در بازه هایی انجام می شود. وابسته به پروتکل ارتباطی هنگام شده،
از دست دادن بسته ممکن است به طور صریح اعلام شود (مانند TWCC) یا استنباط شود (مانند TMMBR/TMMBN
و REMB). این درصدها در طول بازه های زمانی حدود یک ثانیه ارزیابی می شوند.</p><p>تابع دوم با کنترل کننده مبتنی بر از دست رفتن کار می کند و به تغییرات بسته در هنگام رسیدن بسته نگاه می کند
. هدف این کنترلر مبتنی بر تاخیر شناسایی زمانی است که شبکه های متصل به حالت ازدحام می روندو
به طور فزاینده ای شلوغ می شود و ممکن است تخمین های پهنای باند را حتی قبل از دست دادن بسته ها کاهش دهد. در
تئوری به این گونه است که شلوغ ترین محل اتصال شبکه در طول مسیر، بسته ها را تا زمان پر شدن بافر به صف می برد.
اگر آن روتر به دریافت بسته ادامه دهد ممکن است ترافیک بیشتر از آنچه که بتواند باز ارسال کند شود و مجبور شود تمام بسته هایی را که نمی تواند بافر کند را رها(drop) کند.
این نوع از دست رفتن بسته ها برای ارتباطات بی درنگ یا با تاخیر کم مخرب است ولی همچنین می تواند خروجی برای تمامی ارتباطات روی آن لینک را کاهش دهد و باید به صورت ایده آل از آن اجتناب شود.
بنابراین GCC قبل از اینکه از دست رفتن بسته ها رخ دهد سعی می کند بفهمد که لینک های شبکه و صف های ژرف در حال بزرگتر شدن هستند یا خیر. اگر در طول زمان تاخیر های صف بیشتر مشاده شد، استفاده پهنای باند را کاهش می دهد.</p><p>برای رسیدن به این هدف، GCC سعی می‌کند با اندازه‌گیری افزایش‌های کم رفت و برگت بسته افزایش عمق صف را استنباط کند.
&ldquo;زمان بین ورود&rdquo; فریم ها، را ثبت می کند<code>t(i) - t(i-1)</code>: تفاوت در زمان رسیدن
دو گروه بسته (به طور کلی، فریم های ویدیویی متوالی) می باشد. این گروه از بسته ها اغلبا
در فواصل زمانی معین (مثلاً هر 1/24 ثانیه برای یک ویدیوی 24 فریم بر ثانیه) حرکت می کند. در نتیجه،
اندازه گیری زمان بین ورود به سادگی ثبت اختلاف زمانی بین شروع
اولین گروه بسته (یعنی فریم) و اولین فریم از گروه بعدی است.</p><p>در نمودار زیر، میانگین افزایش تاخیر بین بسته‌ها +20 میلی‌ثانیه است که نشانگر واضحی از ازدحام شبکه است</p><p><img src=../images/06-twcc.png alt="TWCC با تاخیر" title="TWCC با تاخیر"></p><p>اگر زمان بین ورود در طول زمان افزایش یابد، نشانه ای از افزایش عمق صف در رابط های شبکه متصل شده فرض می شود و به عنوان ازدحام شبکه در نظر گرفته می شود. (توجه: GCC به اندازه کافی هوشمند است که این اندازه‌گیری‌ها را برای نوسانات اندازه بایت فریم کنترل کند.) GCC اندازه‌گیری‌های تاخیر خود را با استفاده از <a href=https://en.wikipedia.org/wiki/Kalman_filter>Kalman filter</a> اصلاح می‌کند و اندازه‌گیری‌های زیادی از شبکه انجام می‌دهد که شامل زمان های رفت و برگشت (و تغییرات آن) قبل از علامت گذاری ازدحام است می شود. می‌توان فیلتر کالمن GCC را به‌عنوان جایگزینی رگرسیون خطی در نظر گرفت: کمک به پیش‌بینی‌های دقیق حتی زمانی که جیتر نویز را به اندازه‌گیری‌های زمان‌بندی اضافه می‌کند. پس از علامت گذاری ازدحام، GCC نرخ بیت موجود را کاهش می دهد. از طرف دیگر، تحت شرایط ثابت شبکه، می‌تواند به آرامی تخمین‌های پهنای باند خود را افزایش دهد تا مقادیر بار بالاتر را آزمایش کند.</p><h4 id=tmmbr-tmmbn-و-remb>TMMBR، TMMBN، و REMB
<a class=anchor href=#tmmbr-tmmbn-%d9%88-remb>#</a></h4><p>برای TMMBR/TMMBN و REMB، طرف دریافت کننده ابتدا پهنای باند ورودی موجود را تخمین می زند (با استفاده از پروتکلی مانند GCC)، و سپس این تخمین های پهنای باند را به فرستنده های راه دور ارسال می کند. آنها نیازی به مبادله جزئیات در مورد از دست دادن بسته یا سایر خصوصیات در مورد ازدحام شبکه ندارند زیرا عملکرد در سمت گیرنده به آنها اجازه می دهد تا زمان بین ورود و از دست دادن بسته را به طور مستقیم اندازه گیری کنند. در عوض، TMMBR، TMMBN، و REMB فقط پهنای باند را که خودشان تخمین می زنند، مبادله می کنند:</p><ul><li><strong>درخواست نرخ بیت حداکثر جریان رسانه موقت</strong> - یک مانتیس/نمای نرخ بیت درخواستی برای یک SSRC منفرد.</li><li><strong>اعلان نرخ بیت حداکثر جریان رسانه موقت</strong> - پیامی برای اطلاع از دریافت TMMBR.</li><li><strong>حداکثر نرخ بیت تخمینی گیرنده</strong> - یک مانتیس/نمای نرخ بیت درخواستی برای کل جلسه.</li></ul><p>TMMBR و TMMBN ابتدا آمدند و در <a href=https://tools.ietf.org/html/rfc5104>RFC 5104</a> تعریف شده‌اند. REMB بعداً آمد، پیش‌نویسی در<a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-remb-03>draft-alvestrand-rmcat-remb</a> فرستاده شد، اما هرگز استاندارد نشد.</p><p>یک نمونه جلسه که از REMB استفاده می کند و ممکن است مانند زیر عمل کند:</p><p><img src=../images/06-remb.png alt=REMB title=REMB></p><p>این روش روی کاغذ عالی عمل می کند. فرستنده تخمینی را از گیرنده دریافت می کند، نرخ بیت کدینگ را روی مقدار دریافتی تنظیم می کند. تادا! ما با شرایط شبکه سازگار شده ایم.</p><p>با این حال در عمل، رویکرد REMB دارای اشکالات متعددی است.</p><p>ناکارآمدی کدینگ اولین مورد است. هنگامی که یک بیت ریت برای کدینگ تنظیم می کنید، لزوماً نرخ بیت دقیقی را که شما درخواست کرده اید، تولید نمی کند. بسته به تنظیمات کدینگ و فریمی که کدگذاری می‌شود، ممکن است کدینگ بیت‌های بیشتر یا کمتری تولید کند.</p><p>به عنوان مثال، استفاده از کدینگ x264 با <code>tune= zeolatency</code> می تواند به طور قابل توجهی از نرخ بیت هدف مشخص شده منحرف شود. در اینجا یک سناریوی احتمالی وجود دارد:</p><ul><li>فرض کنید با تنظیم بیت ریت روی 1000 کیلوبیت در ثانیه شروع می کنیم.</li><li>انکودر تنها 700 کیلوبیت در ثانیه خروجی می دهد، زیرا ویژگی های فرکانس بالا برای کدینگ کافی وجود ندارد. (&ldquo;نگاه به افق(از روی بیکاری)&rdquo;.)</li><li>بیایید همچنین تصور کنیم که گیرنده ویدیوی 700 کیلوبیت بر ثانیه را با اتلاف صفر دریافت کند. سپس قانون REMB 1 را اعمال می کند تا نرخ بیت ورودی را 8٪ افزایش دهد.</li><li>گیرنده یک بسته REMB با پیشنهاد 756 کیلوبیت بر ثانیه (700 کیلوبیت در ثانیه * 1.08) برای فرستنده ارسال می کند.</li><li>فرستنده نرخ بیت کدینگ را روی 756 کیلوبیت بر ثانیه تنظیم می کند.</li><li>کدینگ نرخ بیت حتی کمتری را خروجی می دهد.</li><li>این روند به تکرار خود ادامه می دهد و میزان بیت را به حداقل مطلق کاهش می دهد.</li></ul><p>می‌توانید ببینید که چگونه این باعث تنظیم پارامترهای کدینگ سنگین می‌شود و کاربران را با ویدیوهای غیرقابل تماشا حتی در یک اتصال عالی شگفت‌زده می‌کند.</p><h4 id=کنترل-ازدحام-گسترده-ارتباطات>کنترل ازدحام گسترده ارتباطات
<a class=anchor href=#%da%a9%d9%86%d8%aa%d8%b1%d9%84-%d8%a7%d8%b2%d8%af%d8%ad%d8%a7%d9%85-%da%af%d8%b3%d8%aa%d8%b1%d8%af%d9%87-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7%d8%a7%d8%aa>#</a></h4><p>Transport Wide Congestion Control آخرین پیشرفت در ارتباط وضعیت شبکه RTCP است که در <a href=https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01>draft-holmer-rmcat-transport-wide-cc-extensions-01</a> تعریف شده است. ، اما هرگز استاندارد نشده است.</p><p>TWCC از یک اصل ساده استفاده می کند:</p><p><img src=../images/06-twcc-idea.png alt=TWCC title=TWCC></p><p>با استفاده از REMB، گیرنده طرف فرستنده نرخ بیت دانلود موجود مطلع می کند. از اندازه‌گیری‌های دقیقی در مورد از دست دادن بسته استنباط‌شده استفاده می‌کند و تنها داده‌هایی را که در مورد رسیدن بین بسته‌ها دارد، استفاده می‌کند</p><p>TWCC تقریباً یک رویکرد ترکیبی بین پروتکل‌های نسل SR/RR و REMB است. تخمین پهنای باند را به سمت فرستنده بازمی گرداند (مشابه SR/RR)، اما تکنیک تخمین پهنای باند آن بیشتر شبیه به نسل REMB است.</p><p>با TWCC، گیرنده به فرستنده اجازه می دهد زمان رسیدن هر بسته را بداند. این اطلاعات کافی برای فرستنده برای اندازه‌گیری تغییرات تأخیر رسیدن بین بسته‌ها، و همچنین شناسایی بسته‌هایی است که رها شده‌اند یا خیلی دیر رسیده‌اند تا به فید صوتی/تصویری کمک کنند. با رد و بدل شدن این داده ها به طور مکرر، فرستنده می تواند به سرعت با شرایط متغیر شبکه سازگار شود و پهنای باند خروجی خود را با استفاده از الگوریتمی مانند GCC تغییر دهد.</p><p>فرستنده بسته‌های ارسالی، شماره‌های ترتیبی، اندازه‌ها و مُهرهای زمانی آنها را پیگیری می‌کند. هنگامی که فرستنده پیام های RTCP را از گیرنده دریافت می کند، تاخیرهای ارسال بین بسته ها را با تاخیرهای دریافت مقایسه می کند. اگر تأخیر دریافت افزایش یابد، سیگنال ازدحام شبکه می دهد و فرستنده باید اقدامات اصلاحی را انجام دهد.</p><p>با ارائه داده های خام به فرستنده، TWCC نمای عالی از شرایط شبکه را در زمان واقعی ارائه می دهد:</p><ul><li>از رفتار از دست دادن بسته تقریباً فوری تا بسته های از دست رفته ی تکی</li><li>ارسال بیت ریت دقیق</li><li>نرخ بیت دریافت دقیق</li><li>اندازه گیری Jitter</li><li>تفاوت بین تاخیر ارسال و دریافت بسته</li><li>شرح نحوه تحمل شبکه، انفجاری یا ثابت</li></ul><p>یکی از مهم ترین کمک های TWCC انعطاف پذیری است که برای توسعه دهندگان WebRTC فراهم می کند. با ادغام الگوریتم کنترل ازدحام در سمت ارسال، کد کلاینت ساده ای را امکان پذیر می کند که می تواند به طور گسترده مورد استفاده قرار گیرد و در طول زمان به حداقل پیشرفت هایی نیز نیاز دارد. الگوریتم‌های پیچیده کنترل تراکم را می‌توان با سرعت بیشتری روی سخت‌افزاری که مستقیماً کنترل می‌کنند، پیاده‌سازی کرد (مانند SFU، که در بخش 8 مورد بحث قرار گرفت). در مورد مرورگرها و دستگاه های تلفن همراه، این بدان معناست که آن کلاینت ها می توانند بدون نیاز به استانداردسازی یا به روز رسانی مرورگر (که ممکن است زمان زیادی طول بکشد تا به طور گسترده در دسترس باشند) از پیشرفت های الگوریتم بهره مند شوند.</p><h2 id=جایگزین-های-تخمین-پهنای-باند>جایگزین های تخمین پهنای باند
<a class=anchor href=#%d8%ac%d8%a7%db%8c%da%af%d8%b2%db%8c%d9%86-%d9%87%d8%a7%db%8c-%d8%aa%d8%ae%d9%85%db%8c%d9%86-%d9%be%d9%87%d9%86%d8%a7%db%8c-%d8%a8%d8%a7%d9%86%d8%af>#</a></h2><p>بیشترین پیاده سازی &ldquo;یک الگوریتم کنترل ازدحام Google برای ارتباطات بلادرنگ&rdquo; است که در <a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-congestion-02>draft-alvestrand-rmcat-congestion</a> تعریف شده است.</p><p>چندین جایگزین برای GCC وجود دارد، به عنوان مثال <a href=https://tools.ietf.org/html/draft-zhu-rmcat-nada-04>NADA: یک طرح کنترل یکپارچه ازدحام برای رسانه های زمان واقعی</a> و <a href=https://tools.ietf.org/html/draft-johansson-rmcat-scream-cc-05>SCReAM - انطباق نرخ خودکار برای چند رسانه</a>.</p></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/33443552b6e66bb37249eef21e148e35cc87a9bf title='آخرین بار ویرایش شده توسط Amin | ژوئیهٔ 29, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>ژوئیهٔ 29, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/06-media-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>این صفحه را ویرایش کنید</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#از-ارتباطات-رسانه-ای-webrtc-چه-چیزی-دریافت-می-کنم>از ارتباطات رسانه ای WebRTC چه چیزی دریافت می کنم؟</a></li><li><a href=#چگونه-کار-می-کند>چگونه کار می کند؟</a></li><li><a href=#تاخیر-و-کیفیت>تاخیر و کیفیت</a><ul><li><a href=#محدودیت-های-دنیای-واقعی>محدودیت های دنیای واقعی</a></li><li><a href=#ویدئو-پیچیده-است>ویدئو پیچیده است</a></li></ul></li><li><a href=#ویدئو-101>ویدئو 101</a><ul><li><a href=#فشرده-سازی-lossy-and-lossless>فشرده سازی Lossy and Lossless</a></li><li><a href=#فشرده-سازی-درون-و-بین-قاب>فشرده سازی درون و بین قاب</a></li><li><a href=#انواع-بین-فریم>انواع بین فریم</a></li><li><a href=#ویدئو-حساس-است>ویدئو حساس است</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#قالب-بسته>قالب بسته</a></li><li><a href=#برنامه-های-افزودنی>برنامه های افزودنی</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#قالب-بسته-1>قالب بسته</a></li><li><a href=#درخواست-کامل-درون-فریم-fir-و-نشان-از-دست-دادن-تصویر-pli>درخواست کامل درون فریم (FIR) و نشان از دست دادن تصویر (PLI)</a></li><li><a href=#تصدیق-منفی>تصدیق منفی</a></li><li><a href=#گزارش-فرستنده-و-گیرنده>گزارش فرستنده و گیرنده</a></li></ul></li><li><a href=#چگونه-rtprtcp-مشکلات-را-با-هم-حل-می-کند>چگونه RTP/RTCP مشکلات را با هم حل می کند</a><ul><li><a href=#تصحیح-خطای-بازارسال>تصحیح خطای بازارسال</a></li><li><a href=#تخمین-نرخ-بیت-و-پهنای-باند-تطبیقی>تخمین نرخ بیت و پهنای باند تطبیقی</a></li></ul></li><li><a href=#شناسایی-و-برقراری-ارتباط-وضعیت-شبکه>شناسایی و برقراری ارتباط وضعیت شبکه</a><ul><li><a href=#گزارش-های-گیرنده--گزارش-های-فرستنده>گزارش های گیرنده / گزارش های فرستنده</a></li><li><a href=#tmmbr-tmmbn-remb-و-twcc-جفت-شده-با-gcc>TMMBR، TMMBN، REMB و TWCC، جفت شده با GCC</a></li></ul></li><li><a href=#جایگزین-های-تخمین-پهنای-باند>جایگزین های تخمین پهنای باند</a></li></ul></nav></div></aside></main></body></html>