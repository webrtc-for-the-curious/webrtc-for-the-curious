<!doctype html><html lang=ru dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Подключение # Почему WebRTC нужна выделенная подсистема для подключения? # Большинство приложений, развернутых сегодня, устанавливают клиент-серверные соединения. Клиент-серверное соединение требует, чтобы сервер имел стабильный, известный транспортный адрес. Клиент связывается с сервером, и сервер отвечает.
WebRTC не использует клиент-серверную модель, а устанавливает одноранговые (P2P) соединения. В P2P-соединении задача создания соединения равномерно распределена между обоими пирами. Это связано с тем, что транспортный адрес (IP и порт) в WebRTC не может быть предположен и может даже измениться во время сеанса."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ru/docs/03-connecting/"><meta property="og:site_name" content="WebRTC для любопытных"><meta property="og:title" content="Подключение"><meta property="og:description" content="Подключение # Почему WebRTC нужна выделенная подсистема для подключения? # Большинство приложений, развернутых сегодня, устанавливают клиент-серверные соединения. Клиент-серверное соединение требует, чтобы сервер имел стабильный, известный транспортный адрес. Клиент связывается с сервером, и сервер отвечает.
WebRTC не использует клиент-серверную модель, а устанавливает одноранговые (P2P) соединения. В P2P-соединении задача создания соединения равномерно распределена между обоими пирами. Это связано с тем, что транспортный адрес (IP и порт) в WebRTC не может быть предположен и может даже измениться во время сеанса."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-13T15:58:02+03:00"><title>Подключение | WebRTC для любопытных</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ru/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Conexión><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ru.search.min.6405c2eee678bba77211860cbe0852ac3c3d10eac7c7a2510b23161024e8c31c.js integrity="sha256-ZAXC7uZ4u6dyEYYMvghSrDw9EOrHx6JRCyMWECTowxw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ru/><span>WebRTC для любопытных</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Поиск aria-label=Поиск maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Русский</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/03-connecting/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/ru/docs/01-what-why-and-how/>Что, Зачем и Как</a></li><li><a href=/ru/docs/02-signaling/>Сигнализация</a></li><li><a href=/ru/docs/03-connecting/ class=active>Подключение</a></li><li><a href=/ru/docs/04-securing/>Защита</a></li><li><a href=/ru/docs/05-real-time-networking/>Сетевое взаимодействие в реальном времени</a></li><li><a href=/ru/docs/06-media-communication/>Медиа-коммуникация</a></li><li><a href=/ru/docs/07-data-communication/>Коммуникация данных</a></li><li><a href=/ru/docs/08-applied-webrtc/>Прикладной WebRTC</a></li><li><a href=/ru/docs/09-debugging/>Отладка</a></li><li><a href=/ru/docs/10-history-of-webrtc/>История</a></li><li><a href=/ru/docs/11-faq/>Часто задаваемые вопросы</a></li><li><a href=/ru/docs/12-glossary/>Глоссарий</a></li><li><a href=/ru/docs/13-reference/>Справочник</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Подключение</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#почему-webrtc-нужна-выделенная-подсистема-для-подключения>Почему WebRTC нужна выделенная подсистема для подключения?</a><ul><li><a href=#уменьшенные-затраты-на-пропускную-способность>Уменьшенные затраты на пропускную способность</a></li><li><a href=#нижняя-задержка>Нижняя задержка</a></li><li><a href=#безопасная-e2e-связь>Безопасная E2E-связь</a></li></ul></li><li><a href=#как-это-работает>Как это работает?</a></li><li><a href=#сетевые-реальные-ограничения>Сетевые реальные ограничения</a><ul><li><a href=#не-в-одной-сети>Не в одной сети</a></li><li><a href=#протокольные-ограничения>Протокольные ограничения</a></li><li><a href=#правила-брандмауэраids>Правила брандмауэра/IDS</a></li></ul></li><li><a href=#nat-маппинг>NAT-маппинг</a><ul><li><a href=#создание-маппинга>Создание маппинга</a></li><li><a href=#поведение-создания-маппинга>Поведение создания маппинга</a></li><li><a href=#поведение-фильтрации-маппинга>Поведение фильтрации маппинга</a></li><li><a href=#обновление-маппинга>Обновление маппинга</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#структура-пакета>Структура пакета</a></li><li><a href=#создание-nat-маппинга>Создание NAT-маппинга</a></li><li><a href=#определение-типа-nat>Определение типа NAT</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#жизненный-цикл-turn>Жизненный цикл TURN</a></li><li><a href=#использование-turn>Использование TURN</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#создание-ice-агента>Создание ICE-агента</a></li><li><a href=#сбор-кандидатов>Сбор кандидатов</a></li><li><a href=#проверка-связности>Проверка связности</a></li><li><a href=#выбор-кандидата>Выбор кандидата</a></li><li><a href=#перезапуски>Перезапуски</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=подключение>Подключение
<a class=anchor href=#%d0%bf%d0%be%d0%b4%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5>#</a></h1><h2 id=почему-webrtc-нужна-выделенная-подсистема-для-подключения>Почему WebRTC нужна выделенная подсистема для подключения?
<a class=anchor href=#%d0%bf%d0%be%d1%87%d0%b5%d0%bc%d1%83-webrtc-%d0%bd%d1%83%d0%b6%d0%bd%d0%b0-%d0%b2%d1%8b%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%bd%d0%b0%d1%8f-%d0%bf%d0%be%d0%b4%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%b0-%d0%b4%d0%bb%d1%8f-%d0%bf%d0%be%d0%b4%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h2><p>Большинство приложений, развернутых сегодня, устанавливают клиент-серверные соединения. Клиент-серверное соединение требует, чтобы сервер имел стабильный, известный транспортный адрес. Клиент связывается с сервером, и сервер отвечает.</p><p>WebRTC не использует клиент-серверную модель, а устанавливает одноранговые (P2P) соединения. В P2P-соединении задача создания соединения равномерно распределена между обоими пирами. Это связано с тем, что транспортный адрес (IP и порт) в WebRTC не может быть предположен и может даже измениться во время сеанса. WebRTC соберет всю доступную информацию и приложит все усилия для достижения двунаправленной связи между двумя WebRTC-агентами.</p><p>Установление одноранговой связности может быть сложным. Эти агенты могут находиться в разных сетях без прямой связности. В ситуациях, где прямая связность существует, все еще могут возникать другие проблемы. В некоторых случаях ваши клиенты не говорят на одних сетевых протоколах (UDP &lt;-> TCP) или используют разные версии IP (IPv4 &lt;-> IPv6).</p><p>Несмотря на эти сложности при настройке P2P-соединения, вы получаете преимущества перед традиционной клиент-серверной технологией благодаря следующим атрибутам, которые предлагает WebRTC.</p><h3 id=уменьшенные-затраты-на-пропускную-способность>Уменьшенные затраты на пропускную способность
<a class=anchor href=#%d1%83%d0%bc%d0%b5%d0%bd%d1%8c%d1%88%d0%b5%d0%bd%d0%bd%d1%8b%d0%b5-%d0%b7%d0%b0%d1%82%d1%80%d0%b0%d1%82%d1%8b-%d0%bd%d0%b0-%d0%bf%d1%80%d0%be%d0%bf%d1%83%d1%81%d0%ba%d0%bd%d1%83%d1%8e-%d1%81%d0%bf%d0%be%d1%81%d0%be%d0%b1%d0%bd%d0%be%d1%81%d1%82%d1%8c>#</a></h3><p>Поскольку медиакоммуникация происходит непосредственно между пирами, вам не нужно платить за, или размещать отдельный сервер для передачи медиа.</p><h3 id=нижняя-задержка>Нижняя задержка
<a class=anchor href=#%d0%bd%d0%b8%d0%b6%d0%bd%d1%8f%d1%8f-%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b0>#</a></h3><p>Связь быстрее, когда она прямая! Когда пользователь должен запускать все через ваш сервер, это замедляет передачи.</p><h3 id=безопасная-e2e-связь>Безопасная E2E-связь
<a class=anchor href=#%d0%b1%d0%b5%d0%b7%d0%be%d0%bf%d0%b0%d1%81%d0%bd%d0%b0%d1%8f-e2e-%d1%81%d0%b2%d1%8f%d0%b7%d1%8c>#</a></h3><p>Прямая связь безопаснее. Поскольку пользователи не маршрутизируют данные через ваш сервер, им даже не нужно доверять вам, что вы не расшифруете их.</p><h2 id=как-это-работает>Как это работает?
<a class=anchor href=#%d0%ba%d0%b0%d0%ba-%d1%8d%d1%82%d0%be-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d0%b5%d1%82>#</a></h2><p>Процесс, описанный выше, называется Установление интерактивной связности (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>). Другой протокол, который предшествует WebRTC.</p><p>ICE - это протокол, который пытается найти лучший способ связи между двумя ICE-агентами. Каждый ICE-агент публикует способы, которыми он достижим, это называется кандидатами. Кандидат - это по сути транспортный адрес агента, который он считает достижимым для другого пира. ICE затем определяет лучшую пару кандидатов.</p><p>Фактический процесс ICE описывается более подробно позже в этой главе. Для понимания того, почему существует ICE, полезно понять, какие сетевые поведения мы преодолеваем.</p><h2 id=сетевые-реальные-ограничения>Сетевые реальные ограничения
<a class=anchor href=#%d1%81%d0%b5%d1%82%d0%b5%d0%b2%d1%8b%d0%b5-%d1%80%d0%b5%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d0%be%d0%b3%d1%80%d0%b0%d0%bd%d0%b8%d1%87%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h2><p>ICE - это все о преодолении ограничений реальных сетей. Прежде чем мы исследуем решение, давайте поговорим о реальных проблемах.</p><h3 id=не-в-одной-сети>Не в одной сети
<a class=anchor href=#%d0%bd%d0%b5-%d0%b2-%d0%be%d0%b4%d0%bd%d0%be%d0%b9-%d1%81%d0%b5%d1%82%d0%b8>#</a></h3><p>Большую часть времени другой WebRTC-агент даже не будет в той же сети. Обычный звонок обычно происходит между двумя WebRTC-агентами в разных сетях с отсутствием прямой связности.</p><p>Ниже приведен график двух разных сетей, соединенных через публичный интернет. В каждой сети у вас два хоста.</p><p><img src=../images/03-two-networks.png alt="Две сети" title="Две сети"></p><p>Для хостов в одной сети соединение очень просто. Связь между <code>192.168.0.1 -> 192.168.0.2</code> легко сделать! Эти два хоста могут подключиться друг к другу без какой-либо внешней помощи.</p><p>Однако хост, использующий <code>Router B</code>, не имеет способа напрямую получить доступ к чему-либо за <code>Router A</code>. Как вы можете сказать разницу между <code>192.168.0.1</code> за <code>Router A</code> и тем же IP за <code>Router B</code>? Это частные IP! Хост, использующий <code>Router B</code>, мог бы отправить трафик непосредственно к <code>Router A</code>, но запрос завершится там. Как <code>Router A</code> знает, какой хост он должен передать сообщение?</p><h3 id=протокольные-ограничения>Протокольные ограничения
<a class=anchor href=#%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d0%be%d0%b3%d1%80%d0%b0%d0%bd%d0%b8%d1%87%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h3><p>Некоторые сети вообще не позволяют трафик UDP, или, возможно, они не позволяют TCP. Некоторые сети могут иметь очень низкий MTU (Maximum Transmission Unit). Существует множество переменных, которые сетевые администраторы могут изменять, что может сделать связь сложной.</p><h3 id=правила-брандмауэраids>Правила брандмауэра/IDS
<a class=anchor href=#%d0%bf%d1%80%d0%b0%d0%b2%d0%b8%d0%bb%d0%b0-%d0%b1%d1%80%d0%b0%d0%bd%d0%b4%d0%bc%d0%b0%d1%83%d1%8d%d1%80%d0%b0ids>#</a></h3><p>Другой - &ldquo;Глубокая проверка пакетов&rdquo; и другие интеллектуальные фильтры. Некоторые сетевые администраторы будут запускать программное обеспечение, которое пытается обрабатывать каждый пакет. Часто это программное обеспечение не понимает WebRTC, поэтому оно блокирует его, потому что оно не знает, что делать, например, обрабатывая пакеты WebRTC как подозрительные UDP-пакеты на произвольном порту, который не белый.</p><h2 id=nat-маппинг>NAT-маппинг
<a class=anchor href=#nat-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3>#</a></h2><p>NAT (Network Address Translation) маппинг - это волшебство, которое делает возможным подключение WebRTC. Это как WebRTC позволяет двум пирам в совершенно разных подсетях общаться, решая проблему &ldquo;не в одной сети&rdquo; выше. Хотя это создает новые вызовы, давайте объясним, как работает NAT-маппинг сначала.</p><p>Он не использует ретрансляцию, прокси или сервер. Снова у нас есть <code>Agent 1</code> и <code>Agent 2</code>, и они находятся в разных сетях. Однако трафик течет полностью через. Визуализируется это так:</p><p><img src=../images/03-nat-mapping.png alt=NAT-маппинг title=NAT-маппинг></p><p>Чтобы сделать эту связь, вы устанавливаете NAT-маппинг. Agent 1 использует порт 7000 для установки WebRTC-соединения с Agent 2. Это создает привязку <code>192.168.0.1:7000</code> к <code>5.0.0.1:7000</code>. Это затем позволяет Agent 2 достичь Agent 1, отправляя пакеты на <code>5.0.0.1:7000</code>. Создание NAT-маппинга, как в этом примере, похоже на автоматизированную версию настройки портового перенаправления в вашем роутере.</p><p>Недостатком NAT-маппинга является то, что нет единого вида маппинга (например, статическое портовое перенаправление), и поведение несогласовано между сетями. ISPs и производители оборудования могут делать это по-разному. В некоторых случаях сетевые администраторы могут даже отключить его.</p><p>Хорошая новость в том, что полный диапазон поведений понятен и наблюдаем, поэтому ICE-агент способен подтвердить, что он создал NAT-маппинг, и атрибуты маппинга.</p><p>Документ, описывающий эти поведения, - <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>.</p><h3 id=создание-маппинга>Создание маппинга
<a class=anchor href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h3><p>Создание маппинга - это самая простая часть. Когда вы отправляете пакет по адресу вне вашей сети, создается маппинг! NAT-маппинг - это временный публичный IP и порт, который выделяется вашим NAT. Исходящее сообщение будет переписано, чтобы иметь свой источник, заданный новым адресом маппинга. Если сообщение отправлено на маппинг, оно будет автоматически маршрутизироваться обратно к хосту внутри NAT, который его создал. Детали вокруг маппинга - это то, где все усложняется.</p><h3 id=поведение-создания-маппинга>Поведение создания маппинга
<a class=anchor href=#%d0%bf%d0%be%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d1%8f-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h3><p>Создание маппинга делится на три разных категории:</p><h4 id=конечная-точка-независимая-от-маппинга>Конечная точка, независимая от маппинга
<a class=anchor href=#%d0%ba%d0%be%d0%bd%d0%b5%d1%87%d0%bd%d0%b0%d1%8f-%d1%82%d0%be%d1%87%d0%ba%d0%b0-%d0%bd%d0%b5%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d0%b0%d1%8f-%d0%be%d1%82-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h4><p>Создается один маппинг для каждого отправителя внутри NAT. Если вы отправите два пакета на два разных удаленных адреса, маппинг будет переиспользован. Оба удаленных хоста увидят один и тот же IP-адрес и порт. Если удаленные хосты отвечают, они будут отправлены обратно к той же локальной слушательной точке.</p><p>Это лучший сценарий. Для работы звонка, по крайней мере, одна сторона МОЖЕТ быть этого типа.</p><h4 id=адрес-зависимый-от-маппинга>Адрес, зависимый от маппинга
<a class=anchor href=#%d0%b0%d0%b4%d1%80%d0%b5%d1%81-%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d1%8b%d0%b9-%d0%be%d1%82-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h4><p>Создается новый маппинг каждый раз, когда вы отправляете пакет по новому адресу. Если вы отправите два пакета на разные хосты, создадутся два маппинга. Если вы отправите два пакета на один удаленный хост, но разные порты назначения, новый маппинг НЕ будет создан.</p><h4 id=адрес-и-порт-зависимый-от-маппинга>Адрес и порт, зависимый от маппинга
<a class=anchor href=#%d0%b0%d0%b4%d1%80%d0%b5%d1%81-%d0%b8-%d0%bf%d0%be%d1%80%d1%82-%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d1%8b%d0%b9-%d0%be%d1%82-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h4><p>Создается новый маппинг, если удаленный IP или порт отличается. Если вы отправите два пакета на один удаленный хост, но разные порты назначения, создается новый маппинг.</p><h3 id=поведение-фильтрации-маппинга>Поведение фильтрации маппинга
<a class=anchor href=#%d0%bf%d0%be%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d1%84%d0%b8%d0%bb%d1%8c%d1%82%d1%80%d0%b0%d1%86%d0%b8%d0%b8-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h3><p>Поведение фильтрации - это правила, которые определяют, кто может использовать маппинг. Они делятся на три похожие категории:</p><h4 id=конечная-точка-независимая-от-фильтрации>Конечная точка, независимая от фильтрации
<a class=anchor href=#%d0%ba%d0%be%d0%bd%d0%b5%d1%87%d0%bd%d0%b0%d1%8f-%d1%82%d0%be%d1%87%d0%ba%d0%b0-%d0%bd%d0%b5%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d0%b0%d1%8f-%d0%be%d1%82-%d1%84%d0%b8%d0%bb%d1%8c%d1%82%d1%80%d0%b0%d1%86%d0%b8%d0%b8>#</a></h4><p>Кто угодно может использовать маппинг. Вы можете поделиться маппингом с несколькими другими пирами, и они могут все отправить трафик к нему.</p><h4 id=адрес-зависимый-от-фильтрации>Адрес, зависимый от фильтрации
<a class=anchor href=#%d0%b0%d0%b4%d1%80%d0%b5%d1%81-%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d1%8b%d0%b9-%d0%be%d1%82-%d1%84%d0%b8%d0%bb%d1%8c%d1%82%d1%80%d0%b0%d1%86%d0%b8%d0%b8>#</a></h4><p>Только хост, для которого создан маппинг, может использовать маппинг. Если вы отправите пакет на хост <code>A</code>, вы можете получить ответ только от этого же хоста. Если хост <code>B</code> попытается отправить пакет на этот маппинг, он будет проигнорирован.</p><h4 id=адрес-и-порт-зависимый-от-фильтрации>Адрес и порт, зависимый от фильтрации
<a class=anchor href=#%d0%b0%d0%b4%d1%80%d0%b5%d1%81-%d0%b8-%d0%bf%d0%be%d1%80%d1%82-%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d1%8b%d0%b9-%d0%be%d1%82-%d1%84%d0%b8%d0%bb%d1%8c%d1%82%d1%80%d0%b0%d1%86%d0%b8%d0%b8>#</a></h4><p>Только хост и порт, для которых создан маппинг, могут использовать этот маппинг. Если вы отправите пакет на <code>A:5000</code>, вы можете получить ответ только от этого же хоста и порта. Если <code>A:5001</code> попытается отправить пакет на этот маппинг, он будет проигнорирован.</p><h3 id=обновление-маппинга>Обновление маппинга
<a class=anchor href=#%d0%be%d0%b1%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h3><p>Рекомендуется, чтобы если маппинг не использовался в течение 5 минут, он должен быть уничтожен. Это полностью зависит от ISP или производителя оборудования.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (Session Traversal Utilities for NAT) - это протокол, созданный специально для работы с NAT. Это еще одна технология, которая предшествует WebRTC (и ICE!). Он определен в <a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>, который также определяет структуру STUN-пакета. Протокол STUN также используется ICE/TURN.</p><p>STUN полезен, потому что он позволяет программному созданию NAT-маппингов. До STUN мы могли создать NAT-маппинг, но у нас не было ни малейшего представления о том, какой у него IP-адрес и порт! STUN не только дает вам возможность создать маппинг, но и предоставляет детали, чтобы вы могли поделиться ими с другими, так что они могут отправить трафик обратно к вам через маппинг, который вы только что создали.</p><p>Давайте начнем с базового описания STUN. Позже мы расширим TURN и использование ICE. На данный момент мы просто опишем поток запрос/ответ для создания маппинга. Затем мы поговорим о том, как получить детали, чтобы поделиться ими. Это процесс, который происходит, когда у вас есть <code>stun:</code> сервер в ваших ICE-URL для WebRTC PeerConnection. В сущности, STUN помогает конечной точке за NAT определить, какой маппинг был создан, запрашивая STUN-сервер за пределами NAT, чтобы сообщить, что он наблюдает.</p><h3 id=структура-пакета>Структура пакета
<a class=anchor href=#%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b0-%d0%bf%d0%b0%d0%ba%d0%b5%d1%82%d0%b0>#</a></h3><p>Каждый STUN-пакет имеет следующую структуру:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=тип-stun-сообщения>Тип STUN-сообщения
<a class=anchor href=#%d1%82%d0%b8%d0%bf-stun-%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h4><p>Каждый STUN-пакет имеет тип. На данный момент нам важно следующее:</p><ul><li>Запрос привязки - <code>0x0001</code></li><li>Ответ привязки - <code>0x0101</code></li></ul><p>Чтобы создать NAT-маппинг, мы делаем <code>Запрос привязки</code>. Затем сервер отвечает с <code>Ответ привязки</code>.</p><h4 id=длина-сообщения>Длина сообщения
<a class=anchor href=#%d0%b4%d0%bb%d0%b8%d0%bd%d0%b0-%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h4><p>Это длина секции <code>Данные</code>. Эта секция содержит произвольные данные, определяемые <code>Тип сообщения</code>.</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>Фиксированное значение <code>0x2112A442</code> в сетевом порядке байтов, оно помогает отличить трафик STUN от других протоколов.</p><h4 id=transaction-id>Transaction ID
<a class=anchor href=#transaction-id>#</a></h4><p>96-битный идентификатор, который уникально идентифицирует запрос/ответ. Это помогает вам сопоставить ваши запросы и ответы.</p><h4 id=данные>Данные
<a class=anchor href=#%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5>#</a></h4><p>Данные будут содержать список STUN-атрибутов. STUN-атрибут имеет следующую структуру:</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p><code>STUN Запрос привязки</code> не использует атрибуты. Это означает, что <code>STUN Запрос привязки</code> содержит только заголовок.</p><p><code>STUN Ответ привязки</code> использует атрибут <code>XOR-MAPPED-ADDRESS (0x0020)</code>. Этот атрибут содержит IP и порт. Это IP и порт NAT-маппинга, который создается!</p><h3 id=создание-nat-маппинга>Создание NAT-маппинга
<a class=anchor href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-nat-%d0%bc%d0%b0%d0%bf%d0%bf%d0%b8%d0%bd%d0%b3%d0%b0>#</a></h3><p>Создание NAT-маппинга с использованием STUN - это просто отправка одного запроса! Вы отправляете <code>STUN Запрос привязки</code> на STUN-сервер. STUN-сервер затем отвечает с <code>STUN Ответ привязки</code>.
Этот <code>STUN Ответ привязки</code> будет содержать <code>Mapped Address</code>. <code>Mapped Address</code> - это как STUN-сервер видит вас и является вашим <code>NAT-маппингом</code>.
<code>Mapped Address</code> - это то, что вы бы поделились, если хотели, чтобы кто-то отправил пакеты к вам.</p><p>Люди также называют <code>Mapped Address</code> вашим <code>Общественным IP</code> или <code>Серверный рефлексивный кандидат</code>.</p><h3 id=определение-типа-nat>Определение типа NAT
<a class=anchor href=#%d0%be%d0%bf%d1%80%d0%b5%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%82%d0%b8%d0%bf%d0%b0-nat>#</a></h3><p>К сожалению, <code>Mapped Address</code> может быть бесполезен во всех случаях. Если это <code>Адрес, зависимый</code>, только STUN-сервер может отправить трафик обратно к вам. Если вы поделились им и другой пир попытался отправить сообщения, они будут отброшены. Это делает его бесполезным для общения с другими. Возможно, вы обнаружите, что случай <code>Адрес, зависимый</code> на самом деле решаем, если хост, который запускает STUN-сервер, также может передавать пакеты для вас к пиру! Это приводит нас к решению, использующему TURN ниже.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a> определяет метод для запуска теста, чтобы определить ваш тип NAT. Это полезно, потому что вы бы знали заранее, возможно ли прямое подключение.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (Traversal Using Relays around NAT) определен в <a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a> является решением, когда прямое подключение невозможно. Это может быть из-за того, что у вас два несовместимых типа NAT, или, возможно, они не могут говорить на одном и том же протоколе! TURN также может использоваться для целей конфиденциальности. Запуская все ваше общение через TURN, вы скрываете фактический адрес клиента.</p><p>TURN использует отдельный сервер. Этот сервер действует как прокси для клиента. Клиент подключается к TURN-серверу и создает <code>Allocation</code>. Создание <code>Allocation</code> позволяет клиенту получить временный IP/Port/Протокол, который может использоваться для отправки трафика обратно к клиенту. Этот новый слушатель известен как <code>Relayed Transport Address</code>. Думайте об этом как о пересылаемом адресе, вы его раздаете, чтобы другие могли отправить вам трафик через TURN! Для каждого пира вы даете <code>Relay Transport Address</code>, вы должны создать новую <code>Permission</code>, чтобы разрешить общение с вами.</p><p>Когда вы отправляете исходящий трафик через TURN, он отправляется через <code>Relayed Transport Address</code>. Когда удаленный пир получает трафик, он видит, что он приходит от TURN-сервера.</p><h3 id=жизненный-цикл-turn>Жизненный цикл TURN
<a class=anchor href=#%d0%b6%d0%b8%d0%b7%d0%bd%d0%b5%d0%bd%d0%bd%d1%8b%d0%b9-%d1%86%d0%b8%d0%ba%d0%bb-turn>#</a></h3><p>Следующее - это все, что должен сделать клиент, который хочет создать TURN-allocation. Общение с кем-то, кто использует TURN, не требует изменений. Другой пир получает IP и порт, и они общаются с ним, как с любым другим хостом.</p><h4 id=allocation>Allocation
<a class=anchor href=#allocation>#</a></h4><p>Allocation - это ядро TURN. <code>Allocation</code> - это по сути &ldquo;TURN-сессия&rdquo;. Чтобы создать TURN-allocation, вы общаетесь с TURN <code>Server Transport Address</code> (обычно порт <code>3478</code>).</p><p>При создании <code>Allocation</code> вам нужно предоставить следующее:</p><ul><li>Имя пользователя/Пароль - Создание TURN-allocation требует аутентификации.</li><li>Transport Allocation - Транспортный протокол между сервером (<code>Relayed Transport Address</code>) и пирами, может быть UDP или TCP.</li><li>Even-Port - Вы можете запросить последовательные порты для нескольких allocation, не относящихся к WebRTC.</li></ul><p>Если запрос выполнен, вы получаете ответ от TURN-сервера со следующими STUN-атрибутами в секции <code>Данные</code>:</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>Mapped Address</code> <code>TURN Client</code>. Когда кто-то отправляет данные на <code>Relayed Transport Address</code>, это куда они перенаправляются.</li><li><code>RELAYED-ADDRESS</code> - Это адрес, который вы выдаете другим клиентам. Если кто-то отправляет пакет на этот адрес, он передается TURN-клиенту.</li><li><code>LIFETIME</code> - Через сколько времени эта TURN-allocation уничтожается. Вы можете продлить срок действия, отправив запрос <code>Refresh</code>.</li></ul><h4 id=permissions>Permissions
<a class=anchor href=#permissions>#</a></h4><p>Удаленный хост не может отправить в ваш <code>Relayed Transport Address</code>, пока вы не создадите для него разрешение. Когда вы создаете разрешение, вы говорите TURN-серверу, что этот IP и порт разрешен для отправки входящего трафика.</p><p>Удаленный хост должен отправить <code>STUN Binding Request</code> на TURN-сервер. Обычная ошибка - это то, что удаленный хост отправит <code>STUN Binding Request</code> на другой сервер. Они затем попросят вас создать разрешение для этого IP.</p><p>Предположим, вы хотите создать разрешение для хоста за <code>Адрес, зависимым маппингом</code>. Если вы сгенерируете <code>Mapped Address</code> от другого TURN-сервера, все входящие трафик будет отброшен. Каждый раз, когда они общаются с разным хостом, генерируется новый маппинг. Разрешения истекают через 5 минут, если они не обновляются.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>Эти два сообщения предназначены для TURN-клиента, чтобы отправить сообщения удаленному пиру.</p><p>SendIndication - это самодостаточное сообщение. В нем находится данные, которые вы хотите отправить, и кто вы хотите отправить их. Это бесполезно, если вы отправляете много сообщений удаленному пиру. Если вы отправите 1,000 сообщений, вы повторите их IP-адрес 1,000 раз!</p><p>ChannelData позволяет вам отправлять данные, но не повторять IP-адрес. Вы создаете Channel с IP и портом. Затем вы отправляете с ChannelId, и IP и порт будут заполнены с серверной стороны. Это лучший выбор, если вы отправляете много сообщений.</p><h4 id=обновление>Обновление
<a class=anchor href=#%d0%be%d0%b1%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5>#</a></h4><p>Allocation уничтожаются автоматически. TURN-клиент должен обновлять их раньше, чем <code>LIFETIME</code>, указанный при создании allocation.</p><h3 id=использование-turn>Использование TURN
<a class=anchor href=#%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-turn>#</a></h3><p>Использование TURN существует в двух формах. Обычно один пир действует как &ldquo;TURN-клиент&rdquo;, а другой - как прямое общение. В некоторых случаях у вас может быть использование TURN с обеих сторон, например, потому что оба клиента находятся в сетях, которые блокируют UDP, и, следовательно, подключение к соответствующим TURN-серверам происходит через TCP.</p><p>Эти диаграммы помогают проиллюстрировать, как это может выглядеть.</p><h4 id=одна-turn-allocation-для-общения>Одна TURN-allocation для общения
<a class=anchor href=#%d0%be%d0%b4%d0%bd%d0%b0-turn-allocation-%d0%b4%d0%bb%d1%8f-%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h4><p><img src=../images/03-one-turn-allocation.png alt="Одна TURN-allocation" title="Одна TURN-allocation"></p><h4 id=две-turn-allocations-для-общения>Две TURN-allocations для общения
<a class=anchor href=#%d0%b4%d0%b2%d0%b5-turn-allocations-%d0%b4%d0%bb%d1%8f-%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h4><p><img src=../images/03-two-turn-allocations.png alt="Две TURN-allocations" title="Две TURN-allocations"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Interactive Connectivity Establishment) - это как WebRTC подключает два агента. Определен в <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>, это еще одна технология, которая предшествует WebRTC! ICE - это протокол для установления связи. Он определяет все возможные маршруты между двумя пирами и затем обеспечивает, что вы остаетесь подключенными.</p><p>Эти маршруты известны как <code>Candidate Pairs</code>, которые являются парой локального и удаленного транспортного адреса. Это где STUN и TURN вступают в игру с ICE. Эти адреса могут быть ваш локальный IP-адрес плюс порт, <code>NAT-маппинг</code>, или <code>Relayed Transport Address</code>. Каждая сторона собирает все адреса, которые хотят использовать, обмениваются ими и затем пытаются подключиться!</p><p>Два ICE-агента общаются с помощью пакетов ICE ping (или формально называемых проверками связности) для установления связи. После установления связи они могут отправлять все, что хотят. Это будет как использование обычного сокета. Эти проверки используют протокол STUN.</p><h3 id=создание-ice-агента>Создание ICE-агента
<a class=anchor href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-ice-%d0%b0%d0%b3%d0%b5%d0%bd%d1%82%d0%b0>#</a></h3><p>ICE-агент либо <code>Controlling</code> или <code>Controlled</code>. <code>Controlling</code> Agent - это тот, кто решает выбранную <code>Candidate Pair</code>. Обычно пир, отправляющий офер, является контролирующей стороной.</p><p>Каждая сторона должна иметь <code>user fragment</code> и <code>password</code>. Эти два значения должны быть обменены перед началом проверки связности. <code>User fragment</code> отправляется в открытом виде и полезен для демультиплексирования нескольких ICE-сессий. <code>Password</code> используется для генерации атрибута <code>MESSAGE-INTEGRITY</code>. В конце каждого STUN-пакета есть атрибут, который является хэшем всего пакета с использованием <code>Password</code> в качестве ключа. Это используется для аутентификации пакета и обеспечения того, что он не был изменен.</p><p>Для WebRTC все эти значения распределяются через <code>Session Description</code>, как описано в предыдущей главе.</p><h3 id=сбор-кандидатов>Сбор кандидатов
<a class=anchor href=#%d1%81%d0%b1%d0%be%d1%80-%d0%ba%d0%b0%d0%bd%d0%b4%d0%b8%d0%b4%d0%b0%d1%82%d0%be%d0%b2>#</a></h3><p>Теперь нам нужно собрать все возможные адреса, которые мы достижимы. Эти адреса известны как кандидаты.</p><h4 id=хост>Хост
<a class=anchor href=#%d1%85%d0%be%d1%81%d1%82>#</a></h4><p>Хост-кандидат слушает непосредственно на локальном интерфейсе. Это может быть UDP или TCP.</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>mDNS-кандидат похож на хост-кандидат, но IP-адрес скрыт. Вместо того, чтобы сообщать другой стороне ваш IP-адрес, вы даете им UUID как имя хоста. Затем вы устанавливаете многоадресный слушатель и отвечаете, если кто-то запросит UUID, который вы опубликовали.</p><p>Если вы находитесь в той же сети, что и агент, вы можете найти друг друга через Multicast. Если вы не находитесь в той же сети, вы не сможете подключиться (если сетевой администратор явно настроил сеть, чтобы разрешить пакеты Multicast для прохождения).</p><p>Это полезно для целей конфиденциальности. Пользователь мог бы узнать ваш локальный IP-адрес через WebRTC с хост-кандидатом (без даже пытаясь подключиться к вам), но с mDNS-кандидатом, теперь они получают случайный UUID.</p><h4 id=серверный-рефлексивный>Серверный рефлексивный
<a class=anchor href=#%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%bd%d1%8b%d0%b9-%d1%80%d0%b5%d1%84%d0%bb%d0%b5%d0%ba%d1%81%d0%b8%d0%b2%d0%bd%d1%8b%d0%b9>#</a></h4><p>Серверный рефлексивный кандидат генерируется путем выполнения <code>STUN Binding Request</code> к STUN-серверу.</p><p>Когда вы получаете <code>STUN Binding Response</code>, <code>XOR-MAPPED-ADDRESS</code> является вашим серверным рефлексивным кандидатом.</p><h4 id=пир-рефлексивный>Пир-рефлексивный
<a class=anchor href=#%d0%bf%d0%b8%d1%80-%d1%80%d0%b5%d1%84%d0%bb%d0%b5%d0%ba%d1%81%d0%b8%d0%b2%d0%bd%d1%8b%d0%b9>#</a></h4><p>Пир-рефлексивный кандидат создается, когда удаленный пир получает ваш запрос от адреса, который ранее был неизвестен для пира. При получении он сообщает (отражает) этот адрес обратно к вам. Пир знает, что запрос был отправлен вами, а не кем-то другим, потому что ICE - это аутентифицированный протокол.</p><p>Это обычно происходит, когда <code>Хост-кандидат</code> общается с <code>Серверный рефлексивный кандидат</code>, который находится в другой подсети, что приводит к созданию нового <code>NAT-маппинга</code>. Помните, мы сказали, что проверки связности на самом деле STUN-пакеты? Формат ответа STUN естественным образом позволяет пиру сообщить обратно пир-рефлексивный адрес.</p><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><p>Relay-кандидат генерируется путем использования TURN-сервера.</p><p>После начального рукопожатия с TURN-сервером вам дается <code>RELAYED-ADDRESS</code>, это ваш Relay-кандидат.</p><h3 id=проверка-связности>Проверка связности
<a class=anchor href=#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d1%81%d0%b2%d1%8f%d0%b7%d0%bd%d0%be%d1%81%d1%82%d0%b8>#</a></h3><p>Теперь мы знаем <code>user fragment</code>, <code>password</code> удаленного агента и кандидаты. Мы можем теперь попытаться подключиться! Каждый кандидат связывается с каждым другим. Так что если у вас 3 кандидата с каждой стороны, теперь у вас 9 пар кандидатов.</p><p>Визуально это выглядит так:</p><p><img src=../images/03-connectivity-checks.png alt="Проверка связности" title="Проверка связности"></p><h3 id=выбор-кандидата>Выбор кандидата
<a class=anchor href=#%d0%b2%d1%8b%d0%b1%d0%be%d1%80-%d0%ba%d0%b0%d0%bd%d0%b4%d0%b8%d0%b4%d0%b0%d1%82%d0%b0>#</a></h3><p>Контролирующий и контролируемый агенты начинают отправлять трафик на каждой паре. Это необходимо, если один агент находится за <code>Адрес, зависимым маппингом</code>, это приведет к созданию <code>Пир-рефлексивного кандидата</code>.</p><p>Каждая <code>Candidate Pair</code>, которая видела сетевой трафик, затем повышается до <code>Valid Candidate</code> пары. Контролирующий агент затем выбирает одну <code>Valid Candidate</code> пару и номинирует ее. Это становится <code>Nominated Pair</code>. Контролирующий и контролируемый агенты затем пытаются установить один последний раунд двунаправленной связи. Если это удается, <code>Nominated Pair</code> становится <code>Selected Candidate Pair</code>! Эта пара используется для остальной части сессии.</p><h3 id=перезапуски>Перезапуски
<a class=anchor href=#%d0%bf%d0%b5%d1%80%d0%b5%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d0%ba%d0%b8>#</a></h3><p>Если <code>Selected Candidate Pair</code> перестает работать по какой-либо причине (NAT-маппинг истек, TURN-сервер упал) ICE-агент переходит в состояние <code>Failed</code>. Оба агента могут быть перезапущены, и процесс будет повторен полностью.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/b681d97e3677abfc2947fb0eda8ad4b2842029ef title='Последнее изменение от comerc | сентября 13, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>сентября 13, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Редактировать эту страницу</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#почему-webrtc-нужна-выделенная-подсистема-для-подключения>Почему WebRTC нужна выделенная подсистема для подключения?</a><ul><li><a href=#уменьшенные-затраты-на-пропускную-способность>Уменьшенные затраты на пропускную способность</a></li><li><a href=#нижняя-задержка>Нижняя задержка</a></li><li><a href=#безопасная-e2e-связь>Безопасная E2E-связь</a></li></ul></li><li><a href=#как-это-работает>Как это работает?</a></li><li><a href=#сетевые-реальные-ограничения>Сетевые реальные ограничения</a><ul><li><a href=#не-в-одной-сети>Не в одной сети</a></li><li><a href=#протокольные-ограничения>Протокольные ограничения</a></li><li><a href=#правила-брандмауэраids>Правила брандмауэра/IDS</a></li></ul></li><li><a href=#nat-маппинг>NAT-маппинг</a><ul><li><a href=#создание-маппинга>Создание маппинга</a></li><li><a href=#поведение-создания-маппинга>Поведение создания маппинга</a></li><li><a href=#поведение-фильтрации-маппинга>Поведение фильтрации маппинга</a></li><li><a href=#обновление-маппинга>Обновление маппинга</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#структура-пакета>Структура пакета</a></li><li><a href=#создание-nat-маппинга>Создание NAT-маппинга</a></li><li><a href=#определение-типа-nat>Определение типа NAT</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#жизненный-цикл-turn>Жизненный цикл TURN</a></li><li><a href=#использование-turn>Использование TURN</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#создание-ice-агента>Создание ICE-агента</a></li><li><a href=#сбор-кандидатов>Сбор кандидатов</a></li><li><a href=#проверка-связности>Проверка связности</a></li><li><a href=#выбор-кандидата>Выбор кандидата</a></li><li><a href=#перезапуски>Перезапуски</a></li></ul></li></ul></nav></div></aside></main></body></html>