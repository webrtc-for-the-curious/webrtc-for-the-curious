<!doctype html><html lang=ru dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Защита # Какую безопасность имеет WebRTC? # Каждое WebRTC-соединение аутентифицировано и зашифровано. Вы можете быть уверены, что третья сторона не может видеть, что вы отправляете, или вставлять поддельные сообщения. Вы также можете быть уверены, что WebRTC-агент, который сгенерировал Session Description, - тот, с кем вы общаетесь.
Очень важно, чтобы никто не изменял эти сообщения. Нормально, если третья сторона читает Session Description в транзите. Однако WebRTC не защищает от его изменения."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ru/docs/04-securing/"><meta property="og:site_name" content="WebRTC для любопытных"><meta property="og:title" content="Защита"><meta property="og:description" content="Защита # Какую безопасность имеет WebRTC? # Каждое WebRTC-соединение аутентифицировано и зашифровано. Вы можете быть уверены, что третья сторона не может видеть, что вы отправляете, или вставлять поддельные сообщения. Вы также можете быть уверены, что WebRTC-агент, который сгенерировал Session Description, - тот, с кем вы общаетесь.
Очень важно, чтобы никто не изменял эти сообщения. Нормально, если третья сторона читает Session Description в транзите. Однако WebRTC не защищает от его изменения."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-13T15:58:02+03:00"><title>Защита | WebRTC для любопытных</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ru/docs/04-securing/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/04-securing/ title=安全性><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/04-securing/ title=امنیت><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/04-securing/ title=Securing><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/04-securing/ title=Securing><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/04-securing/ title=Securing><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/04-securing/ title=Güvenlik><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/04-securing/ title=보안><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ru.search.min.6405c2eee678bba77211860cbe0852ac3c3d10eac7c7a2510b23161024e8c31c.js integrity="sha256-ZAXC7uZ4u6dyEYYMvghSrDw9EOrHx6JRCyMWECTowxw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ru/><span>WebRTC для любопытных</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Поиск aria-label=Поиск maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Русский</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/04-securing/>English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/04-securing/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/04-securing/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/04-securing/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/04-securing/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/04-securing/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/04-securing/>한국어</a></li></ul></li></ul><ul><li><a href=/ru/docs/01-what-why-and-how/>Что, Зачем и Как</a></li><li><a href=/ru/docs/02-signaling/>Сигнализация</a></li><li><a href=/ru/docs/03-connecting/>Подключение</a></li><li><a href=/ru/docs/04-securing/ class=active>Защита</a></li><li><a href=/ru/docs/05-real-time-networking/>Сетевое взаимодействие в реальном времени</a></li><li><a href=/ru/docs/06-media-communication/>Медиа-коммуникация</a></li><li><a href=/ru/docs/07-data-communication/>Коммуникация данных</a></li><li><a href=/ru/docs/08-applied-webrtc/>Прикладной WebRTC</a></li><li><a href=/ru/docs/09-debugging/>Отладка</a></li><li><a href=/ru/docs/10-history-of-webrtc/>История</a></li><li><a href=/ru/docs/11-faq/>Часто задаваемые вопросы</a></li><li><a href=/ru/docs/12-glossary/>Глоссарий</a></li><li><a href=/ru/docs/13-reference/>Справочник</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Защита</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#какую-безопасность-имеет-webrtc>Какую безопасность имеет WebRTC?</a></li><li><a href=#как-это-работает>Как это работает?</a></li><li><a href=#безопасность-101>Безопасность 101</a><ul><li><a href=#открытый-текст-и-шифротекст>Открытый текст и шифротекст</a></li><li><a href=#шифр>Шифр</a></li><li><a href=#хеш-функции>Хеш-функции</a></li><li><a href=#криптография-с-открытымзакрытым-ключом>Криптография с открытым/закрытым ключом</a></li><li><a href=#обмен-диффи-хеллмана>Обмен Диффи-Хеллмана</a></li><li><a href=#псевдослучайная-функция>Псевдослучайная функция</a></li><li><a href=#функция-генерации-ключа>Функция генерации ключа</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#код-аутентификации-сообщения>Код аутентификации сообщения</a></li><li><a href=#ротация-ключа>Ротация ключа</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#формат-пакета>Формат пакета</a></li><li><a href=#конечный-автомат-рукопожатия>Конечный автомат рукопожатия</a></li><li><a href=#генерация-ключа>Генерация ключа</a></li><li><a href=#обмен-applicationdata>Обмен ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#создание-сессии>Создание сессии</a></li><li><a href=#обмен-медиа>Обмен медиа</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=защита>Защита
<a class=anchor href=#%d0%b7%d0%b0%d1%89%d0%b8%d1%82%d0%b0>#</a></h1><h2 id=какую-безопасность-имеет-webrtc>Какую безопасность имеет WebRTC?
<a class=anchor href=#%d0%ba%d0%b0%d0%ba%d1%83%d1%8e-%d0%b1%d0%b5%d0%b7%d0%be%d0%bf%d0%b0%d1%81%d0%bd%d0%be%d1%81%d1%82%d1%8c-%d0%b8%d0%bc%d0%b5%d0%b5%d1%82-webrtc>#</a></h2><p>Каждое WebRTC-соединение аутентифицировано и зашифровано. Вы можете быть уверены, что третья сторона не может видеть, что вы отправляете, или вставлять поддельные сообщения. Вы также можете быть уверены, что WebRTC-агент, который сгенерировал Session Description, - тот, с кем вы общаетесь.</p><p>Очень важно, чтобы никто не изменял эти сообщения. Нормально, если третья сторона читает Session Description в транзите. Однако WebRTC не защищает от его изменения. Злоумышленник может выполнить атаку &ldquo;человек посередине&rdquo;, изменив ICE-кандидаты и обновив отпечаток сертификата.</p><h2 id=как-это-работает>Как это работает?
<a class=anchor href=#%d0%ba%d0%b0%d0%ba-%d1%8d%d1%82%d0%be-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d0%b5%d1%82>#</a></h2><p>WebRTC использует два существующих протокола: Datagram Transport Layer Security (<a href=https://tools.ietf.org/html/rfc6347>DTLS</a>) и Secure Real-time Transport Protocol (<a href=https://tools.ietf.org/html/rfc3711>SRTP</a>).</p><p>DTLS позволяет согласовать сеанс и затем безопасно обмениваться данными между двумя пирами. Это родственник TLS, той же технологии, которая работает в HTTPS, но DTLS использует UDP вместо TCP в качестве транспортного уровня. Это означает, что протокол должен справляться с ненадежной доставкой. SRTP специально разработан для безопасного обмена медиа. Есть некоторые оптимизации, которые мы можем сделать, используя его вместо DTLS.</p><p>Сначала используется DTLS. Он выполняет рукопожатие поверх соединения, предоставленного ICE. DTLS - это клиент/серверный протокол, поэтому одна сторона должна начать рукопожатие. Роли клиента/сервера выбираются во время сигнализации. Во время DTLS-рукопожатия обе стороны предлагают сертификат.
После завершения рукопожатия этот сертификат сравнивается с хешем сертификата в Session Description. Это делается для обеспечения того, что рукопожатие произошло с ожидаемым WebRTC-агентом. DTLS-соединение затем становится доступным для использования в коммуникации DataChannel.</p><p>Чтобы создать SRTP-сессию, мы инициализируем ее, используя ключи, сгенерированные DTLS. У SRTP нет механизма рукопожатия, поэтому он должен быть загружен с внешними ключами. После этого медиа могут обмениваться, будучи зашифрованными с помощью SRTP!</p><h2 id=безопасность-101>Безопасность 101
<a class=anchor href=#%d0%b1%d0%b5%d0%b7%d0%be%d0%bf%d0%b0%d1%81%d0%bd%d0%be%d1%81%d1%82%d1%8c-101>#</a></h2><p>Чтобы понять технологию, представленную в этой главе, вам сначала нужно понять эти термины. Криптография - сложный предмет, поэтому было бы полезно проконсультироваться и с другими источниками!</p><h3 id=открытый-текст-и-шифротекст>Открытый текст и шифротекст
<a class=anchor href=#%d0%be%d1%82%d0%ba%d1%80%d1%8b%d1%82%d1%8b%d0%b9-%d1%82%d0%b5%d0%ba%d1%81%d1%82-%d0%b8-%d1%88%d0%b8%d1%84%d1%80%d0%be%d1%82%d0%b5%d0%ba%d1%81%d1%82>#</a></h3><p>Открытый текст - это вход для шифра. Шифротекст - это выход шифра.</p><h3 id=шифр>Шифр
<a class=anchor href=#%d1%88%d0%b8%d1%84%d1%80>#</a></h3><p>Шифр - это серия шагов, которая преобразует открытый текст в шифротекст. Шифр затем может быть обращен, так что вы можете преобразовать свой шифротекст обратно в открытый текст. У шифра обычно есть ключ для изменения его поведения. Другой термин для этого - шифрование и дешифрование.</p><p>Простой шифр - ROT13. Каждая буква перемещается на 13 символов вперед. Чтобы отменить шифр, вы перемещаете 13 символов назад. Открытый текст <code>HELLO</code> станет шифротекстом <code>URYYB</code>. В этом случае шифр - ROT, а ключ - 13.</p><h3 id=хеш-функции>Хеш-функции
<a class=anchor href=#%d1%85%d0%b5%d1%88-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8>#</a></h3><p>Криптографическая хеш-функция - это необратимый процесс, который генерирует дайджест. При заданном входе она генерирует один и тот же выход каждый раз. Важно, чтобы выход <em>не</em> был обратимым. Имея выход, вы не должны иметь возможность определить его вход. Хеширование полезно, когда вы хотите убедиться, что сообщение не было изменено.</p><p>Простая (хотя и явно не подходящая для реальной криптографии) хеш-функция будет заключаться в том, чтобы брать только каждую вторую букву. <code>HELLO</code> станет <code>HLO</code>. Вы не можете предположить, что <code>HELLO</code> был входом, но можете подтвердить, что <code>HELLO</code> будет соответствовать хеш-дайджесту.</p><h3 id=криптография-с-открытымзакрытым-ключом>Криптография с открытым/закрытым ключом
<a class=anchor href=#%d0%ba%d1%80%d0%b8%d0%bf%d1%82%d0%be%d0%b3%d1%80%d0%b0%d1%84%d0%b8%d1%8f-%d1%81-%d0%be%d1%82%d0%ba%d1%80%d1%8b%d1%82%d1%8b%d0%bc%d0%b7%d0%b0%d0%ba%d1%80%d1%8b%d1%82%d1%8b%d0%bc-%d0%ba%d0%bb%d1%8e%d1%87%d0%be%d0%bc>#</a></h3><p>Криптография с открытым/закрытым ключом описывает тип шифров, которые использует DTLS и SRTP. В этой системе у вас есть два ключа: открытый и закрытый. Открытый ключ предназначен для шифрования сообщений и безопасен для обмена.
Закрытый ключ предназначен для дешифрования и никогда не должен быть раскрыт. Это единственный ключ, который может дешифровать сообщения, зашифрованные открытым ключом.</p><h3 id=обмен-диффи-хеллмана>Обмен Диффи-Хеллмана
<a class=anchor href=#%d0%be%d0%b1%d0%bc%d0%b5%d0%bd-%d0%b4%d0%b8%d1%84%d1%84%d0%b8-%d1%85%d0%b5%d0%bb%d0%bb%d0%bc%d0%b0%d0%bd%d0%b0>#</a></h3><p>Обмен Диффи-Хеллмана позволяет двум пользователям, которые никогда не встречались, безопасно создать общий секрет через интернет. Пользователь <code>A</code> может отправить секрет пользователю <code>B</code> без беспокойства о перехвате. Это зависит от сложности решения проблемы дискретного логарифма.
Вам не нужно полностью понимать, как это работает, но полезно знать, что именно это делает DTLS-рукопожатие возможным.</p><p>Wikipedia имеет пример этого в действии <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>здесь</a>.</p><h3 id=псевдослучайная-функция>Псевдослучайная функция
<a class=anchor href=#%d0%bf%d1%81%d0%b5%d0%b2%d0%b4%d0%be%d1%81%d0%bb%d1%83%d1%87%d0%b0%d0%b9%d0%bd%d0%b0%d1%8f-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f>#</a></h3><p>Псевдослучайная функция (PRF) - это предопределенная функция для генерации значения, которое выглядит случайным. Она может принимать несколько входов и генерировать один выход.</p><h3 id=функция-генерации-ключа>Функция генерации ключа
<a class=anchor href=#%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d1%8f-%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d0%b8-%d0%ba%d0%bb%d1%8e%d1%87%d0%b0>#</a></h3><p>Генерация ключа - это тип псевдослучайной функции. Генерация ключа - это функция, используемая для усиления ключа. Один распространенный шаблон - растяжение ключа.</p><p>Допустим, вам дан ключ размером 8 байт. Вы могли бы использовать KDF, чтобы сделать его сильнее.</p><h3 id=nonce>Nonce
<a class=anchor href=#nonce>#</a></h3><p>Nonce - это дополнительный вход в шифр. Это используется для того, чтобы получить разный выход от шифра, даже если вы шифруете одно и то же сообщение несколько раз.</p><p>Если вы зашифруете одно и то же сообщение 10 раз, шифр даст вам один и тот же шифротекст 10 раз. Используя nonce, вы можете получить разный выход, все еще используя тот же ключ. Важно использовать разный nonce для каждого сообщения! В противном случае это сводит на нет большую часть ценности.</p><h3 id=код-аутентификации-сообщения>Код аутентификации сообщения
<a class=anchor href=#%d0%ba%d0%be%d0%b4-%d0%b0%d1%83%d1%82%d0%b5%d0%bd%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d0%b8-%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h3><p>Код аутентификации сообщения - это хеш, который помещается в конец сообщения. MAC доказывает, что сообщение исходит от ожидаемого пользователя.</p><p>Если вы не используете MAC, злоумышленник может вставлять недопустимые сообщения. После дешифрования у вас будет просто мусор, потому что они не знают ключ.</p><h3 id=ротация-ключа>Ротация ключа
<a class=anchor href=#%d1%80%d0%be%d1%82%d0%b0%d1%86%d0%b8%d1%8f-%d0%ba%d0%bb%d1%8e%d1%87%d0%b0>#</a></h3><p>Ротация ключа - это практика смены ключа через интервал. Это делает украденный ключ менее значимым. Если ключ украден или утек, можно расшифровать меньше данных.</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS (Datagram Transport Layer Security) позволяет двум пирам устанавливать безопасную связь без предварительной конфигурации. Даже если кто-то подслушивает разговор, он не сможет расшифровать сообщения.</p><p>Для связи DTLS-клиента и сервера им нужно согласовать шифр и ключ. Они определяют эти значения, выполняя DTLS-рукопожатие. Во время рукопожатия сообщения находятся в открытом тексте.
Когда DTLS-клиент/сервер обменялся достаточным количеством деталей для начала шифрования, он отправляет <code>Change Cipher Spec</code>. После этого сообщения каждое последующее сообщение будет зашифровано!</p><h3 id=формат-пакета>Формат пакета
<a class=anchor href=#%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82-%d0%bf%d0%b0%d0%ba%d0%b5%d1%82%d0%b0>#</a></h3><p>Каждый DTLS-пакет начинается с заголовка.</p><h4 id=тип-содержимого>Тип содержимого
<a class=anchor href=#%d1%82%d0%b8%d0%bf-%d1%81%d0%be%d0%b4%d0%b5%d1%80%d0%b6%d0%b8%d0%bc%d0%be%d0%b3%d0%be>#</a></h4><p>Вы можете ожидать следующие типы:</p><ul><li><code>20</code> - Change Cipher Spec</li><li><code>22</code> - Рукопожатие</li><li><code>23</code> - Прикладные данные</li></ul><p><code>Рукопожатие</code> используется для обмена деталями для запуска сеанса. <code>Change Cipher Spec</code> используется для уведомления другой стороны, что все будет зашифровано. <code>Прикладные данные</code> - это зашифрованные сообщения.</p><h4 id=версия>Версия
<a class=anchor href=#%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f>#</a></h4><p>Версия может быть <code>0x0000feff</code> (DTLS v1.0) или <code>0x0000fefd</code> (DTLS v1.2), версии v1.1 не существует.</p><h4 id=эпоха>Эпоха
<a class=anchor href=#%d1%8d%d0%bf%d0%be%d1%85%d0%b0>#</a></h4><p>Эпоха начинается с <code>0</code>, но становится <code>1</code> после <code>Change Cipher Spec</code>. Любое сообщение с ненулевой эпохой зашифровано.</p><h4 id=порядковый-номер>Порядковый номер
<a class=anchor href=#%d0%bf%d0%be%d1%80%d1%8f%d0%b4%d0%ba%d0%be%d0%b2%d1%8b%d0%b9-%d0%bd%d0%be%d0%bc%d0%b5%d1%80>#</a></h4><p>Порядковый номер используется для сохранения сообщений в порядке. Каждое сообщение увеличивает порядковый номер. Когда эпоха увеличивается, порядковый номер начинается заново.</p><h4 id=длина-и-полезная-нагрузка>Длина и полезная нагрузка
<a class=anchor href=#%d0%b4%d0%bb%d0%b8%d0%bd%d0%b0-%d0%b8-%d0%bf%d0%be%d0%bb%d0%b5%d0%b7%d0%bd%d0%b0%d1%8f-%d0%bd%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b0>#</a></h4><p>Полезная нагрузка зависит от <code>Типа содержимого</code>. Для <code>Прикладных данных</code> <code>Полезная нагрузка</code> - это зашифрованные данные. Для <code>Рукопожатия</code> она будет разной в зависимости от сообщения. Длина указывает, насколько большой <code>Полезная нагрузка</code>.</p><h3 id=конечный-автомат-рукопожатия>Конечный автомат рукопожатия
<a class=anchor href=#%d0%ba%d0%be%d0%bd%d0%b5%d1%87%d0%bd%d1%8b%d0%b9-%d0%b0%d0%b2%d1%82%d0%be%d0%bc%d0%b0%d1%82-%d1%80%d1%83%d0%ba%d0%be%d0%bf%d0%be%d0%b6%d0%b0%d1%82%d0%b8%d1%8f>#</a></h3><p>Во время рукопожатия клиент/сервер обмениваются серией сообщений. Эти сообщения сгруппированы в полеты. Каждый полет может содержать несколько сообщений (или только одно).
Полет не считается завершенным, пока не будут получены все сообщения в полете. Мы подробнее опишем цель каждого сообщения ниже.</p><p><img src=../images/04-handshake.png alt=Рукопожатие title=Рукопожатие></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello - это начальное сообщение, отправляемое клиентом. Оно содержит список атрибутов. Эти атрибуты сообщают серверу о шифрах и функциях, которые поддерживает клиент. Для WebRTC это также способ выбрать SRTP-шифр. Он также содержит случайные данные, которые будут использованы для генерации ключей для сеанса.</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>HelloVerifyRequest отправляется сервером клиенту. Это делается для того, чтобы убедиться, что клиент намеревался отправить запрос. Затем клиент повторно отправляет ClientHello, но с токеном, предоставленным в HelloVerifyRequest.</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello - это ответ сервера для конфигурации этого сеанса. Он содержит, какой шифр будет использоваться, когда этот сеанс закончится. Он также содержит случайные данные сервера.</p><h4 id=сертификат>Сертификат
<a class=anchor href=#%d1%81%d0%b5%d1%80%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82>#</a></h4><p>Сертификат содержит сертификат для клиента или сервера. Это используется для уникальной идентификации, с кем мы общались. После завершения рукопожатия мы убедимся, что этот сертификат при хешировании соответствует отпечатку в <code>SessionDescription</code>.</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>Эти сообщения используются для передачи открытого ключа. При запуске клиент и сервер генерируют пару ключей. После рукопожатия эти значения будут использованы для генерации <code>Pre-Master Secret</code>.</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>CertificateRequest отправляется сервером, уведомляя клиента, что он хочет сертификат. Сервер может либо запросить, либо потребовать сертификат.</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone уведомляет клиента, что сервер закончил рукопожатие.</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>CertificateVerify - это способ, которым отправитель доказывает, что у него есть закрытый ключ, отправленный в сообщении Certificate.</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec информирует получателя, что все, отправленное после этого сообщения, будет зашифровано.</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished зашифрован и содержит хеш всех сообщений. Это утверждение, что рукопожатие не было изменено.</p><h3 id=генерация-ключа>Генерация ключа
<a class=anchor href=#%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d1%8f-%d0%ba%d0%bb%d1%8e%d1%87%d0%b0>#</a></h3><p>После завершения рукопожатия вы можете начать отправлять зашифрованные данные. Шифр был выбран сервером и находится в ServerHello. Как был выбран ключ?</p><p>Сначала мы генерируем <code>Pre-Master Secret</code>. Чтобы получить это значение, используется Диффи-Хеллман на ключах, обмененных <code>ServerKeyExchange</code> и <code>ClientKeyExchange</code>. Детали различаются в зависимости от выбранного шифра.</p><p>Затем генерируется <code>Master Secret</code>. Каждая версия DTLS имеет определенную <code>Псевдослучайную функцию</code>. Для DTLS 1.2 функция принимает <code>Pre-Master Secret</code> и случайные значения в <code>ClientHello</code> и <code>ServerHello</code>.
Выход от запуска <code>Псевдослучайной функции</code> - это <code>Master Secret</code>. <code>Master Secret</code> - это значение, используемое для шифра.</p><h3 id=обмен-applicationdata>Обмен ApplicationData
<a class=anchor href=#%d0%be%d0%b1%d0%bc%d0%b5%d0%bd-applicationdata>#</a></h3><p>Основной движитель DTLS - <code>ApplicationData</code>. Теперь, когда у нас инициализирован шифр, мы можем начать шифровать и отправлять значения.</p><p>Сообщения <code>ApplicationData</code> используют заголовок DTLS, как описано ранее. <code>Полезная нагрузка</code> заполняется шифротекстом. Теперь у вас есть работающий DTLS-сеанс, и вы можете общаться безопасно.</p><p>DTLS имеет много других интересных функций, таких как повторные переговоры. Они не используются WebRTC, поэтому здесь не будут рассмотрены.</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP - это протокол, специально разработанный для шифрования RTP-пакетов. Чтобы начать SRTP-сессию, вы указываете свои ключи и шифр. В отличие от DTLS, у него нет механизма рукопожатия. Вся конфигурация и ключи были сгенерированы во время DTLS-рукопожатия.</p><p>DTLS предоставляет выделенный API для экспорта ключей, которые будут использоваться другим процессом. Это определено в <a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>.</p><h3 id=создание-сессии>Создание сессии
<a class=anchor href=#%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%bd%d0%b8%d0%b5-%d1%81%d0%b5%d1%81%d1%81%d0%b8%d0%b8>#</a></h3><p>SRTP определяет функцию генерации ключа, которая используется на входах. При создании SRTP-сессии входы проходят через нее для генерации ключей для нашего SRTP-шифра. После этого вы можете перейти к обработке медиа.</p><h3 id=обмен-медиа>Обмен медиа
<a class=anchor href=#%d0%be%d0%b1%d0%bc%d0%b5%d0%bd-%d0%bc%d0%b5%d0%b4%d0%b8%d0%b0>#</a></h3><p>Каждый RTP-пакет имеет 16-битный порядковый номер. Эти порядковые номера используются для сохранения пакетов в порядке, как первичный ключ. Во время вызова они будут переполняться. SRTP отслеживает это и называет это счетчиком переполнения.</p><p>При шифровании пакета SRTP использует счетчик переполнения и порядковый номер в качестве nonce. Это для обеспечения того, что даже если вы отправите одни и те же данные дважды, шифротекст будет разным. Это важно для предотвращения возможности атакующего идентифицировать шаблоны или попытаться выполнить атаку повторного воспроизведения.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/b681d97e3677abfc2947fb0eda8ad4b2842029ef title='Последнее изменение от comerc | сентября 13, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>сентября 13, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Редактировать эту страницу</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#какую-безопасность-имеет-webrtc>Какую безопасность имеет WebRTC?</a></li><li><a href=#как-это-работает>Как это работает?</a></li><li><a href=#безопасность-101>Безопасность 101</a><ul><li><a href=#открытый-текст-и-шифротекст>Открытый текст и шифротекст</a></li><li><a href=#шифр>Шифр</a></li><li><a href=#хеш-функции>Хеш-функции</a></li><li><a href=#криптография-с-открытымзакрытым-ключом>Криптография с открытым/закрытым ключом</a></li><li><a href=#обмен-диффи-хеллмана>Обмен Диффи-Хеллмана</a></li><li><a href=#псевдослучайная-функция>Псевдослучайная функция</a></li><li><a href=#функция-генерации-ключа>Функция генерации ключа</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#код-аутентификации-сообщения>Код аутентификации сообщения</a></li><li><a href=#ротация-ключа>Ротация ключа</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#формат-пакета>Формат пакета</a></li><li><a href=#конечный-автомат-рукопожатия>Конечный автомат рукопожатия</a></li><li><a href=#генерация-ключа>Генерация ключа</a></li><li><a href=#обмен-applicationdata>Обмен ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#создание-сессии>Создание сессии</a></li><li><a href=#обмен-медиа>Обмен медиа</a></li></ul></li></ul></nav></div></aside></main></body></html>