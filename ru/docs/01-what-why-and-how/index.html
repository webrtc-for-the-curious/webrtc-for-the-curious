<!doctype html><html lang=ru dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Что, Зачем и Как # Что такое WebRTC? # WebRTC, сокращение от Web Real-Time Communication, это одновременно и API, и Протокол. Протокол WebRTC - это набор правил для двух агентов WebRTC для согласования двунаправленной безопасной связи в реальном времени. API WebRTC позволяет разработчикам использовать протокол WebRTC. API WebRTC определен только для JavaScript.
Похожие отношения можно провести между HTTP и Fetch API. WebRTC как протокол будет HTTP, а WebRTC как API будет Fetch API."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/"><meta property="og:site_name" content="WebRTC для любопытных"><meta property="og:title" content="Что, Зачем и Как"><meta property="og:description" content="Что, Зачем и Как # Что такое WebRTC? # WebRTC, сокращение от Web Real-Time Communication, это одновременно и API, и Протокол. Протокол WebRTC - это набор правил для двух агентов WebRTC для согласования двунаправленной безопасной связи в реальном времени. API WebRTC позволяет разработчикам использовать протокол WebRTC. API WebRTC определен только для JavaScript.
Похожие отношения можно провести между HTTP и Fetch API. WebRTC как протокол будет HTTP, а WebRTC как API будет Fetch API."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-13T15:58:02+03:00"><title>Что, Зачем и Как | WebRTC для любопытных</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ title="Vad, varför och hur"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/ title="Quoi, Pourquoi et Comment"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ title="Apa, Mengapa, dan Bagaimana"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ title="¿Qué, Por qué y Cómo?"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ title="Ne, Neden ve Nasıl"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/ title="무엇, 왜, 어떻게?"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ru.search.min.6405c2eee678bba77211860cbe0852ac3c3d10eac7c7a2510b23161024e8c31c.js integrity="sha256-ZAXC7uZ4u6dyEYYMvghSrDw9EOrHx6JRCyMWECTowxw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ru/><span>WebRTC для любопытных</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Поиск aria-label=Поиск maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Русский</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/>English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/>한국어</a></li></ul></li></ul><ul><li><a href=/ru/docs/01-what-why-and-how/ class=active>Что, Зачем и Как</a></li><li><a href=/ru/docs/02-signaling/>Сигнализация</a></li><li><a href=/ru/docs/03-connecting/>Подключение</a></li><li><a href=/ru/docs/04-securing/>Защита</a></li><li><a href=/ru/docs/05-real-time-networking/>Сетевое взаимодействие в реальном времени</a></li><li><a href=/ru/docs/06-media-communication/>Медиа-коммуникация</a></li><li><a href=/ru/docs/07-data-communication/>Коммуникация данных</a></li><li><a href=/ru/docs/08-applied-webrtc/>Прикладной WebRTC</a></li><li><a href=/ru/docs/09-debugging/>Отладка</a></li><li><a href=/ru/docs/10-history-of-webrtc/>История</a></li><li><a href=/ru/docs/11-faq/>Часто задаваемые вопросы</a></li><li><a href=/ru/docs/12-glossary/>Глоссарий</a></li><li><a href=/ru/docs/13-reference/>Справочник</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Что, Зачем и Как</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#что-такое-webrtc>Что такое WebRTC?</a></li><li><a href=#почему-я-должен-изучать-webrtc>Почему я должен изучать WebRTC?</a></li><li><a href=#протокол-webrtc---это-набор-других-технологий>Протокол WebRTC - это набор других технологий</a><ul><li><a href=#сигнализация-как-пиры-находят-друг-друга-в-webrtc>Сигнализация: Как пиры находят друг друга в WebRTC</a></li><li><a href=#подключение-и-обход-nat-с-помощью-stunturn>Подключение и обход NAT с помощью STUN/TURN</a></li><li><a href=#защита-транспортного-уровня-с-помощью-dtls-и-srtp>Защита транспортного уровня с помощью DTLS и SRTP</a></li><li><a href=#коммуникация-с-пирами-через-rtp-и-sctp>Коммуникация с пирами через RTP и SCTP</a></li></ul></li><li><a href=#webrtc---набор-протоколов>WebRTC - набор протоколов</a></li><li><a href=#как-работает-api-webrtc>Как работает API WebRTC?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=что-зачем-и-как>Что, Зачем и Как
<a class=anchor href=#%d1%87%d1%82%d0%be-%d0%b7%d0%b0%d1%87%d0%b5%d0%bc-%d0%b8-%d0%ba%d0%b0%d0%ba>#</a></h1><h2 id=что-такое-webrtc>Что такое WebRTC?
<a class=anchor href=#%d1%87%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-webrtc>#</a></h2><p>WebRTC, сокращение от Web Real-Time Communication, это одновременно и API, и Протокол. Протокол WebRTC - это набор правил для двух агентов WebRTC для согласования двунаправленной безопасной связи в реальном времени. API WebRTC позволяет разработчикам использовать протокол WebRTC. API WebRTC определен только для JavaScript.</p><p>Похожие отношения можно провести между HTTP и Fetch API. WebRTC как протокол будет HTTP, а WebRTC как API будет Fetch API.</p><p>Протокол WebRTC доступен в других API и языках помимо JavaScript. Вы также можете найти серверы и специализированные инструменты для WebRTC. Все эти реализации используют протокол WebRTC, чтобы они могли взаимодействовать друг с другом.</p><p>Протокол WebRTC поддерживается в IETF в рабочей группе <a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a>. API WebRTC документирован в W3C как <a href=https://www.w3.org/TR/webrtc/>webrtc</a>.</p><h2 id=почему-я-должен-изучать-webrtc>Почему я должен изучать WebRTC?
<a class=anchor href=#%d0%bf%d0%be%d1%87%d0%b5%d0%bc%d1%83-%d1%8f-%d0%b4%d0%be%d0%bb%d0%b6%d0%b5%d0%bd-%d0%b8%d0%b7%d1%83%d1%87%d0%b0%d1%82%d1%8c-webrtc>#</a></h2><p>Вот некоторые вещи, которые даст вам WebRTC:</p><ul><li>Открытый стандарт</li><li>Множество реализаций</li><li>Доступность в браузерах</li><li>Обязательное шифрование</li><li>Обход NAT</li><li>Повторное использование существующих технологий</li><li>Контроль перегрузки</li><li>Задержка менее секунды</li></ul><p>Этот список не исчерпывающий, а всего лишь пример некоторых вещей, которые вы можете оценить в процессе изучения. Не волнуйтесь, если вы пока не знаете всех этих терминов, эта книга научит вас им по мере прочтения.</p><h2 id=протокол-webrtc---это-набор-других-технологий>Протокол WebRTC - это набор других технологий
<a class=anchor href=#%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb-webrtc---%d1%8d%d1%82%d0%be-%d0%bd%d0%b0%d0%b1%d0%be%d1%80-%d0%b4%d1%80%d1%83%d0%b3%d0%b8%d1%85-%d1%82%d0%b5%d1%85%d0%bd%d0%be%d0%bb%d0%be%d0%b3%d0%b8%d0%b9>#</a></h2><p>Протокол WebRTC - это огромная тема, которая потребовала бы целой книги для объяснения. Однако, для начала мы разделим его на четыре шага:</p><ol><li>Сигнализация</li><li>Подключение</li><li>Защита</li><li>Коммуникация</li></ol><p>Эти шаги последовательны, что означает, что предыдущий шаг должен быть на 100% успешным, прежде чем начнется следующий.</p><p>Любопытный факт о WebRTC заключается в том, что каждый шаг на самом деле состоит из многих других протоколов! Чтобы создать WebRTC, мы объединяем многие существующие технологии. В этом смысле, вы можете думать о WebRTC скорее как о комбинации и конфигурации хорошо понятных технологий, восходящих к началу 2000-х, чем как о совершенно новом процессе.</p><p>Каждому из этих шагов посвящена отдельная глава, но сначала полезно понять их на высоком уровне. Поскольку они зависят друг от друга, это поможет объяснить далее цель каждого из этих шагов.</p><h3 id=сигнализация-как-пиры-находят-друг-друга-в-webrtc>Сигнализация: Как пиры находят друг друга в WebRTC
<a class=anchor href=#%d1%81%d0%b8%d0%b3%d0%bd%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f-%d0%ba%d0%b0%d0%ba-%d0%bf%d0%b8%d1%80%d1%8b-%d0%bd%d0%b0%d1%85%d0%be%d0%b4%d1%8f%d1%82-%d0%b4%d1%80%d1%83%d0%b3-%d0%b4%d1%80%d1%83%d0%b3%d0%b0-%d0%b2-webrtc>#</a></h3><p>Когда агент WebRTC начинает работу, он не знает, с кем будет общаться и о чем. Шаг <em>Сигнализации</em> решает эту проблему! Сигнализация используется для начальной загрузки вызова, позволяя двум независимым агентам WebRTC начать общение.</p><p>Сигнализация использует существующий текстовый протокол SDP (Session Description Protocol). Каждое SDP-сообщение состоит из пар &ldquo;ключ-значение&rdquo; и содержит список &ldquo;медиа-секций&rdquo;. SDP, который обмениваются два агента WebRTC, содержит такие детали как:</p><ul><li>IP-адреса и порты, на которых агент доступен (кандидаты).</li><li>Количество аудио- и видеотреков, которые агент хочет отправить.</li><li>Аудио- и видеокодеки, поддерживаемые каждым агентом.</li><li>Значения, используемые при подключении (<code>uFrag</code>/<code>uPwd</code>).</li><li>Значения, используемые при защите (отпечаток сертификата).</li></ul><p>Очень важно отметить, что сигнализация обычно происходит &ldquo;вне полосы&rdquo;, что означает, что приложения обычно не используют сам WebRTC для обмена сигнальными сообщениями. Должен существовать другой канал связи между двумя сторонами перед началом подключения WebRTC. Тип используемого канала не является заботой WebRTC. Любая архитектура, подходящая для отправки сообщений, может передавать SDP между подключающимися пирами, и многие приложения просто используют свою существующую инфраструктуру (например, REST-эндпоинты, WebSocket-соединения или прокси-серверы аутентификации) для обмена SDP между соответствующими клиентами.</p><h3 id=подключение-и-обход-nat-с-помощью-stunturn>Подключение и обход NAT с помощью STUN/TURN
<a class=anchor href=#%d0%bf%d0%be%d0%b4%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8-%d0%be%d0%b1%d1%85%d0%be%d0%b4-nat-%d1%81-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d1%8c%d1%8e-stunturn>#</a></h3><p>После того, как два агента WebRTC обменялись SDP, у них есть достаточно информации для попытки подключения друг к другу. Для осуществления этого подключения WebRTC использует другую устоявшуюся технологию, называемую ICE (Interactive Connectivity Establishment).</p><p>ICE - это протокол, который существует до WebRTC и позволяет установить прямое соединение между двумя агентами без центрального сервера. Эти два агента могут находиться в одной сети или на противоположных концах земного шара.</p><p>ICE обеспечивает прямое подключение, но настоящая магия процесса подключения заключается в концепции &ldquo;обхода NAT&rdquo; и использовании STUN/TURN-серверов. Эти две концепции, которые мы подробнее исследуем позже, - все, что вам нужно для связи с ICE-агентом в другой подсети.</p><p>Когда два агента успешно установили ICE-соединение, WebRTC переходит к следующему шагу: установлению зашифрованного транспорта для обмена аудио, видео и данными между ними.</p><h3 id=защита-транспортного-уровня-с-помощью-dtls-и-srtp>Защита транспортного уровня с помощью DTLS и SRTP
<a class=anchor href=#%d0%b7%d0%b0%d1%89%d0%b8%d1%82%d0%b0-%d1%82%d1%80%d0%b0%d0%bd%d1%81%d0%bf%d0%be%d1%80%d1%82%d0%bd%d0%be%d0%b3%d0%be-%d1%83%d1%80%d0%be%d0%b2%d0%bd%d1%8f-%d1%81-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d1%8c%d1%8e-dtls-%d0%b8-srtp>#</a></h3><p>Теперь, когда у нас есть двунаправленная связь (через ICE), нам нужно сделать нашу коммуникацию безопасной! Это делается с помощью еще двух протоколов, которые также существовали до WebRTC: DTLS (Datagram Transport Layer Security) и SRTP (Secure Real-Time Transport Protocol). Первый протокол, DTLS, - это просто TLS поверх UDP (TLS - криптографический протокол, используемый для защиты связи через HTTPS). Второй протокол, SRTP, используется для обеспечения шифрования пакетов данных RTP (Real-time Transport Protocol).</p><p>Сначала WebRTC подключается, выполняя DTLS-рукопожатие поверх соединения, установленного ICE. В отличие от HTTPS, WebRTC не использует центральный орган для сертификатов. Он просто утверждает, что сертификат, обмененный через DTLS, соответствует отпечатку, предоставленному через сигнализацию. Это DTLS-соединение затем используется для сообщений DataChannel.</p><p>Далее, WebRTC использует протокол RTP, защищенный с помощью SRTP, для передачи аудио/видео. Мы инициализируем нашу SRTP-сессию, извлекая ключи из согласованной DTLS-сессии.</p><p>Мы обсудим, почему передача медиа и данных имеют свои собственные протоколы, в следующей главе, но пока достаточно знать, что они обрабатываются отдельно.</p><h3 id=коммуникация-с-пирами-через-rtp-и-sctp>Коммуникация с пирами через RTP и SCTP
<a class=anchor href=#%d0%ba%d0%be%d0%bc%d0%bc%d1%83%d0%bd%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d1%8f-%d1%81-%d0%bf%d0%b8%d1%80%d0%b0%d0%bc%d0%b8-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-rtp-%d0%b8-sctp>#</a></h3><p>Теперь, когда у нас есть два WebRTC-агента, подключенные и защищенные, с установленной двунаправленной связью, давайте начнем общаться! Снова WebRTC будет использовать два существующих протокола: RTP (Real-time Transport Protocol) и SCTP (Stream Control Transmission Protocol). Мы используем RTP для обмена медиа, зашифрованными с помощью SRTP, и SCTP для отправки и получения сообщений DataChannel, зашифрованных с помощью DTLS.</p><p>RTP - это довольно минимальный протокол, но он предоставляет необходимые инструменты для реализации потоковой передачи в реальном времени. Самое важное в RTP - это гибкость для разработчика, позволяющая обрабатывать задержку, потерю пакетов и перегрузки по своему усмотрению. Мы обсудим это подробнее в главе о медиа.</p><p>Последний протокол в стеке - SCTP. Важная особенность SCTP заключается в том, что вы можете отключить надежную и упорядоченную доставку сообщений (среди многих других опций). Это позволяет разработчикам обеспечить необходимую задержку для систем реального времени.</p><p>Теперь мы закончили! Мы успешно установили двунаправленную и безопасную связь. Если у вас есть стабильное соединение между вашими WebRTC-агентами, это вся сложность, которая вам нужна. В следующем разделе мы обсудим, как WebRTC справляется с реальными проблемами потери пакетов и ограничениями пропускной способности.</p><h2 id=webrtc---набор-протоколов>WebRTC - набор протоколов
<a class=anchor href=#webrtc---%d0%bd%d0%b0%d0%b1%d0%be%d1%80-%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb%d0%be%d0%b2>#</a></h2><p>WebRTC решает множество проблем. На первый взгляд технология может показаться чрезмерно сложной, но гениальность WebRTC заключается в его скромности. Он был создан не с предположением, что сможет решить все лучше. Вместо этого он объединил многие существующие технологии с единственной целью в единый, широко применимый пакет.</p><p>Это позволяет нам изучать и исследовать каждую часть индивидуально, не испытывая перегрузки. Хороший способ визуализировать это - &lsquo;WebRTC-агент&rsquo; на самом деле является просто оркестратором многих различных протоколов.</p><p><img src=../images/01-webrtc-agent.png alt="WebRTC Agent" title="Диаграмма WebRTC Agent"></p><h2 id=как-работает-api-webrtc>Как работает API WebRTC?
<a class=anchor href=#%d0%ba%d0%b0%d0%ba-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d0%b5%d1%82-api-webrtc>#</a></h2><p>Этот раздел описывает, как JavaScript API WebRTC соотносится с протоколом WebRTC, описанным выше. Он не предназначен для подробной демонстрации API WebRTC, а скорее для создания ментальной модели того, как все связано.
Если вы не знакомы ни с протоколом, ни с API, не волнуйтесь. Этот раздел будет интересно перечитать, когда вы узнаете больше!</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p><code>RTCPeerConnection</code> - это верхнеуровневый &ldquo;сеанс WebRTC&rdquo;. Он содержит все упомянутые выше протоколы. Подсистемы все выделены, но пока ничего не происходит.</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code> создает новый RTP-поток. Для этого потока будет сгенерирован случайный Synchronization Source (SSRC). Этот поток будет находиться внутри Session Description, сгенерированной <code>createOffer</code> в медиа-секции. Каждый вызов <code>addTrack</code> создаст новый SSRC и медиа-секцию.</p><p>Сразу после установления SRTP-сессии эти медиа-пакеты начнут шифроваться с помощью SRTP и отправляться через ICE.</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p><code>createDataChannel</code> создает новый SCTP-поток, если SCTP-ассоциация не существует. SCTP не включен по умолчанию. Он запускается только когда одна сторона запрашивает канал данных.</p><p>Сразу после установления DTLS-сессии SCTP-ассоциация начнет отправлять пакеты, зашифрованные с помощью DTLS через ICE.</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code> генерирует Session Description локального состояния для обмена с удаленным пиром.</p><p>Акт вызова <code>createOffer</code> не меняет ничего для локального пира.</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code> фиксирует все запрошенные изменения. Вызовы <code>addTrack</code>, <code>createDataChannel</code> и подобные являются временными до этого вызова. <code>setLocalDescription</code> вызывается со значением, сгенерированным <code>createOffer</code>.</p><p>Обычно после этого вызова вы отправите предложение удаленному пиру, который будет использовать его для вызова <code>setRemoteDescription</code>.</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p><code>setRemoteDescription</code> - это способ информирования локального агента о состоянии удаленных кандидатов. Так акт &lsquo;Сигнализации&rsquo; выполняется с помощью JavaScript API.</p><p>Когда <code>setRemoteDescription</code> был вызван на обеих сторонах, WebRTC-агенты теперь имеют достаточно информации для начала связи &ldquo;Peer-To-Peer&rdquo; (P2P)!</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code> позволяет WebRTC-агенту добавлять дополнительные удаленные ICE-кандидаты в любое время. Этот API отправляет ICE-кандидата прямо в подсистему ICE и не имеет другого эффекта для большего WebRTC-соединения.</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code> - это обратный вызов, срабатывающий при получении RTP-пакета от удаленного пира. Входящие пакеты были объявлены в Session Description, переданном через <code>setRemoteDescription</code>.</p><p>WebRTC использует SSRC и ищет связанный <code>MediaStream</code> и <code>MediaStreamTrack</code>, и вызывает этот обратный вызов с этими деталями.</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code> - это обратный вызов, который срабатывает при изменении состояния ICE-агента. Когда происходит изменение сетевой связности, вы получаете об этом уведомление.</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code> - это комбинация состояний ICE-агента и DTLS-агента. Вы можете наблюдать за этим, чтобы быть уведомленным, когда ICE и DTLS успешно завершены.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/b681d97e3677abfc2947fb0eda8ad4b2842029ef title='Последнее изменение от comerc | сентября 13, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>сентября 13, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Редактировать эту страницу</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#что-такое-webrtc>Что такое WebRTC?</a></li><li><a href=#почему-я-должен-изучать-webrtc>Почему я должен изучать WebRTC?</a></li><li><a href=#протокол-webrtc---это-набор-других-технологий>Протокол WebRTC - это набор других технологий</a><ul><li><a href=#сигнализация-как-пиры-находят-друг-друга-в-webrtc>Сигнализация: Как пиры находят друг друга в WebRTC</a></li><li><a href=#подключение-и-обход-nat-с-помощью-stunturn>Подключение и обход NAT с помощью STUN/TURN</a></li><li><a href=#защита-транспортного-уровня-с-помощью-dtls-и-srtp>Защита транспортного уровня с помощью DTLS и SRTP</a></li><li><a href=#коммуникация-с-пирами-через-rtp-и-sctp>Коммуникация с пирами через RTP и SCTP</a></li></ul></li><li><a href=#webrtc---набор-протоколов>WebRTC - набор протоколов</a></li><li><a href=#как-работает-api-webrtc>Как работает API WebRTC?</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>