<!doctype html><html lang=ru dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Отладка # Отладка WebRTC может быть сложной задачей. Существует много подвижных частей, и они могут ломаться независимо. Если вы не будете осторожны, вы можете потерять недели, глядя не на те вещи. Когда вы наконец найдете сломанную часть, вам придется кое-что изучить, чтобы понять почему.
Эта глава поможет вам настроиться на отладку WebRTC. Она покажет, как разбить проблему на составляющие. После того, как мы поймем проблему, мы быстро обзорно рассмотрим популярные инструменты отладки."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ru/docs/09-debugging/"><meta property="og:site_name" content="WebRTC для любопытных"><meta property="og:title" content="Отладка"><meta property="og:description" content="Отладка # Отладка WebRTC может быть сложной задачей. Существует много подвижных частей, и они могут ломаться независимо. Если вы не будете осторожны, вы можете потерять недели, глядя не на те вещи. Когда вы наконец найдете сломанную часть, вам придется кое-что изучить, чтобы понять почему.
Эта глава поможет вам настроиться на отладку WebRTC. Она покажет, как разбить проблему на составляющие. После того, как мы поймем проблему, мы быстро обзорно рассмотрим популярные инструменты отладки."><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-13T15:58:02+03:00"><title>Отладка | WebRTC для любопытных</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ru/docs/09-debugging/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/09-debugging/ title=Felsökning><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/09-debugging/ title=调试><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/09-debugging/ title=デバッグ><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/09-debugging/ title="اشکال زدایی"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/09-debugging/ title=Débogage><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/09-debugging/ title=Debugging><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/09-debugging/ title=Depuración><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/09-debugging/ title="Hata Ayıklama"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/09-debugging/ title=디버깅><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ru.search.min.6405c2eee678bba77211860cbe0852ac3c3d10eac7c7a2510b23161024e8c31c.js integrity="sha256-ZAXC7uZ4u6dyEYYMvghSrDw9EOrHx6JRCyMWECTowxw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ru/><span>WebRTC для любопытных</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Поиск aria-label=Поиск maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Русский</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/09-debugging/>English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/09-debugging/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/09-debugging/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/09-debugging/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/09-debugging/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/09-debugging/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/09-debugging/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/09-debugging/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/09-debugging/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/09-debugging/>한국어</a></li></ul></li></ul><ul><li><a href=/ru/docs/01-what-why-and-how/>Что, Зачем и Как</a></li><li><a href=/ru/docs/02-signaling/>Сигнализация</a></li><li><a href=/ru/docs/03-connecting/>Подключение</a></li><li><a href=/ru/docs/04-securing/>Защита</a></li><li><a href=/ru/docs/05-real-time-networking/>Сетевое взаимодействие в реальном времени</a></li><li><a href=/ru/docs/06-media-communication/>Медиа-коммуникация</a></li><li><a href=/ru/docs/07-data-communication/>Коммуникация данных</a></li><li><a href=/ru/docs/08-applied-webrtc/>Прикладной WebRTC</a></li><li><a href=/ru/docs/09-debugging/ class=active>Отладка</a></li><li><a href=/ru/docs/10-history-of-webrtc/>История</a></li><li><a href=/ru/docs/11-faq/>Часто задаваемые вопросы</a></li><li><a href=/ru/docs/12-glossary/>Глоссарий</a></li><li><a href=/ru/docs/13-reference/>Справочник</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Отладка</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#изолируйте-проблему>Изолируйте проблему</a><ul><li><a href=#проверка-stun-сервера-с-помощью-netcat>Проверка STUN-сервера с помощью netcat:</a></li><li><a href=#сбой-безопасности>Сбой безопасности</a></li><li><a href=#сбой-медиа>Сбой медиа</a></li><li><a href=#сбой-данных>Сбой данных</a></li></ul></li><li><a href=#инструменты-профессионала>Инструменты профессионала</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>Wireshark</a></li><li><a href=#инструменты-webrtc-в-браузерах>Инструменты WebRTC в браузерах</a></li></ul></li><li><a href=#задержка>Задержка</a><ul><li><a href=#ручное-измерение-задержки-от-конца-до-конца>Ручное измерение задержки от конца до конца</a></li><li><a href=#автоматическое-измерение-задержки-от-конца-до-конца>Автоматическое измерение задержки от конца до конца</a></li><li><a href=#советы-по-отладке-задержки>Советы по отладке задержки</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=отладка>Отладка
<a class=anchor href=#%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b0>#</a></h1><p>Отладка WebRTC может быть сложной задачей. Существует много подвижных частей, и они могут ломаться независимо. Если вы не будете осторожны, вы можете потерять недели, глядя не на те вещи. Когда вы наконец найдете сломанную часть, вам придется кое-что изучить, чтобы понять почему.</p><p>Эта глава поможет вам настроиться на отладку WebRTC. Она покажет, как разбить проблему на составляющие. После того, как мы поймем проблему, мы быстро обзорно рассмотрим популярные инструменты отладки.</p><h2 id=изолируйте-проблему>Изолируйте проблему
<a class=anchor href=#%d0%b8%d0%b7%d0%be%d0%bb%d0%b8%d1%80%d1%83%d0%b9%d1%82%d0%b5-%d0%bf%d1%80%d0%be%d0%b1%d0%bb%d0%b5%d0%bc%d1%83>#</a></h2><p>При отладке вам нужно изолировать источник проблемы. Начните с самого начала&mldr;</p><h3 id=проверка-stun-сервера-с-помощью-netcat>Проверка STUN-сервера с помощью netcat:
<a class=anchor href=#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-stun-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%b0-%d1%81-%d0%bf%d0%be%d0%bc%d0%be%d1%89%d1%8c%d1%8e-netcat>#</a></h3><ol><li><p>Подготовьте <strong>20-байтный</strong> пакет binding-запроса:</p><pre tabindex=0><code>00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 54 45 53 54
</code></pre><p>Интерпретация:</p><ul><li><code>00 01</code> - тип сообщения.</li><li><code>00 00</code> - длина раздела данных.</li><li><code>21 12 a4 42</code> - магический cookie.</li><li><code>54 45 53 54 54 45 53 54 54 45 53 54</code> (декодируется в ASCII как <code>TESTTESTTEST</code>) - 12-байтный идентификатор транзакции.</li></ul></li><li><p>Отправьте запрос и ждите <strong>32-байтный</strong> ответ:</p><pre tabindex=0><code>echo -ne &#39;\x00\x01\x00\x00\x21\x12\xa4\x42\x54\x45\x53\x54\x54\x45\x53\x54\x54\x45\x53\x54&#39; | nc -u stun.l.google.com 19302 | xxd
</code></pre><p>Интерпретация:</p><ul><li><code>01 01</code> - тип сообщения</li><li><code>00 0c</code> - длина раздела данных, декодируется в 12 в десятичной системе</li><li><code>21 12 a4 42</code> - магический cookie</li><li><code>54 45 53 54 54 45 53 54 54 45 53 54</code> (декодируется в ASCII как <code>TESTTESTTEST</code>) - 12-байтный идентификатор транзакции.</li><li><code>00 20 00 08 00 01 6f 32 7f 36 de 89</code> - 12-байтные данные, интерпретация:<ul><li><code>00 20</code> - тип: <code>XOR-MAPPED-ADDRESS</code></li><li><code>00 08</code> - длина раздела значений, декодируется в 8 в десятичной системе</li><li><code>00 01 6f 32 7f 36 de 89</code> - значение данных, интерпретация:<ul><li><code>00 01</code> - тип адреса (IPv4)</li><li><code>6f 32</code> - XOR-mapped порт</li><li><code>7f 36 de 89</code> - XOR-mapped IP-адрес</li></ul></li></ul></li></ul></li></ol><p>Декодирование XOR-mapped раздела громоздко, но мы можем заставить STUN-сервер выполнить фиктивное XOR-маскирование, предоставив (недопустимый) фиктивный магический cookie, установленный в <code>00 00 00 00</code>:</p><pre tabindex=0><code>echo -ne &#39;\x00\x01\x00\x00\x00\x00\x00\x00\x54\x45\x53\x54\x54\x45\x53\x54\x54\x45\x53\x54&#39; | nc -u stun.l.google.com 19302 | xxd
</code></pre><p>XOR с фиктивным магическим cookie идемпотентен, поэтому порт и адрес будут в открытом виде в ответе. Это не сработает во всех ситуациях, потому что некоторые маршрутизаторы манипулируют проходящими пакетами, жульничая с IP-адресом. Если мы посмотрим на возвращаемое значение данных (последние восемь байт):</p><ul><li><code>00 01 4e 20 5e 24 7a cb</code> - значение данных, интерпретация:<ul><li><code>00 01</code> - тип адреса (IPv4)</li><li><code>4e 20</code> - mapped порт, который декодируется в 20000 в десятичной системе</li><li><code>5e 24 7a cb</code> - IP-адрес, который декодируется в <code>94.36.122.203</code> в точечно-десятичной нотации.</li></ul></li></ul><h3 id=сбой-безопасности>Сбой безопасности
<a class=anchor href=#%d1%81%d0%b1%d0%be%d0%b9-%d0%b1%d0%b5%d0%b7%d0%be%d0%bf%d0%b0%d1%81%d0%bd%d0%be%d1%81%d1%82%d0%b8>#</a></h3><h3 id=сбой-медиа>Сбой медиа
<a class=anchor href=#%d1%81%d0%b1%d0%be%d0%b9-%d0%bc%d0%b5%d0%b4%d0%b8%d0%b0>#</a></h3><h3 id=сбой-данных>Сбой данных
<a class=anchor href=#%d1%81%d0%b1%d0%be%d0%b9-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85>#</a></h3><h2 id=инструменты-профессионала>Инструменты профессионала
<a class=anchor href=#%d0%b8%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b-%d0%bf%d1%80%d0%be%d1%84%d0%b5%d1%81%d1%81%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d0%b0>#</a></h2><h3 id=netcat-nc>netcat (nc)
<a class=anchor href=#netcat-nc>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Netcat>netcat</a> - это утилита командной строки для чтения и записи сетевых подключений с использованием TCP или UDP. Обычно доступна как команда <code>nc</code>.</p><h3 id=tcpdump>tcpdump
<a class=anchor href=#tcpdump>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Tcpdump>tcpdump</a> - анализатор сетевых пакетов из командной строки.</p><p>Распространенные команды:</p><ul><li><p>Захватить UDP-пакеты к и от порта 19302, вывести шестнадцатеричный дамп содержимого пакета:</p><p><code>sudo tcpdump 'udp port 19302' -xx</code></p></li><li><p>То же самое, но сохранить пакеты в файл PCAP (packet capture) для последующего осмотра:</p><p><code>sudo tcpdump 'udp port 19302' -w stun.pcap</code></p><p>Файл PCAP можно открыть в приложении Wireshark: <code>wireshark stun.pcap</code></p></li></ul><h3 id=wireshark>Wireshark
<a class=anchor href=#wireshark>#</a></h3><p><a href=https://www.wireshark.org>Wireshark</a> - широко используемый анализатор сетевых протоколов.</p><h3 id=инструменты-webrtc-в-браузерах>Инструменты WebRTC в браузерах
<a class=anchor href=#%d0%b8%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82%d1%8b-webrtc-%d0%b2-%d0%b1%d1%80%d0%b0%d1%83%d0%b7%d0%b5%d1%80%d0%b0%d1%85>#</a></h3><p>Браузеры имеют встроенные инструменты, которые можно использовать для проверки устанавливаемых подключений. Chrome имеет <a href=chrome://webrtc-internals><code>chrome://webrtc-internals</code></a> и <a href=chrome://webrtc-logs><code>chrome://webrtc-logs</code></a>. Firefox имеет <a href=about:webrtc><code>about:webrtc</code></a>.</p><h2 id=задержка>Задержка
<a class=anchor href=#%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b0>#</a></h2><p>Задержка от конца до конца не является простой суммой задержек каждого компонента.</p><p>Хотя теоретически можно измерить задержку компонентов конвейера передачи живого видео по отдельности, а затем сложить их, на практике по крайней мере некоторые компоненты будут либо недоступны для инструментирования, либо будут давать значительно отличающиеся результаты при измерении вне конвейера. Переменные глубины очередей между этапами конвейера, топология сети и изменения экспозиции камеры - лишь несколько примеров компонентов, влияющих на задержку от конца до конца.</p><p>Внутренняя задержка каждого компонента в системе потоковой передачи может меняться и влиять на последующие компоненты. Даже содержимое захваченного видео влияет на задержку. Например, для высокочастотных элементов, таких как ветви деревьев, требуется гораздо больше битов по сравнению с низкочастотным чистым голубым небом. Камера с включенной автоэкспозицией может захватывать кадр гораздо дольше ожидаемых 33 миллисекунд, даже если частота съемки установлена на 30 кадров в секунду. Передача по сети, особенно сотовой, также очень динамична из-за меняющегося спроса. Больше пользователей означает больше трафика в эфире. Ваше физическое местоположение (известные зоны слабого сигнала) и множество других факторов увеличивают потери пакетов и задержку.</p><h3 id=ручное-измерение-задержки-от-конца-до-конца>Ручное измерение задержки от конца до конца
<a class=anchor href=#%d1%80%d1%83%d1%87%d0%bd%d0%be%d0%b5-%d0%b8%d0%b7%d0%bc%d0%b5%d1%80%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b8-%d0%be%d1%82-%d0%ba%d0%be%d0%bd%d1%86%d0%b0-%d0%b4%d0%be-%d0%ba%d0%be%d0%bd%d1%86%d0%b0>#</a></h3><p>Когда мы говорим о задержке от конца до конца, мы подразумеваем время между происходящим событием и его наблюдением, то есть появлением видеокадров на экране.</p><pre tabindex=0><code>EndToEndLatency = T(observe) - T(happen)
</code></pre><p>Наивный подход - зафиксировать время происходящего события и вычесть из времени наблюдения. Однако при уточнении до миллисекунд синхронизация времени становится проблемой. Попытки синхронизировать часы в распределенных системах в основном бесполезны, даже небольшая ошибка синхронизации времени приводит к недостоверному измерению задержки.</p><p>Простой обходной путь для проблем синхронизации часов - использовать один и тот же clock. Поместите отправителя и получателя в одну систему отсчета.</p><p>Представьте, что у вас есть тикающие миллисекундные часы или любой другой источник событий. Вы хотите измерить задержку в системе, которая транслирует часы на удаленный экран, наведя на них камеру. Очевидный способ измерить время между тиканием миллисекундного таймера (T<sub><code>happen</code></sub>) и появлением видеокадров часов на экране (T<sub><code>observe</code></sub>) следующий:</p><ul><li>Наведите камеру на миллисекундные часы.</li><li>Отправьте видеокадры получателю, находящемуся в том же физическом месте.</li><li>Сфотографируйте (используйте телефон) миллисекундный таймер и полученное видео на экране.</li><li>Вычтите два времени.</li></ul><p>Это самое правдивое измерение задержки от конца до конца. Оно учитывает задержки всех компонентов (камера, кодировщик, сеть, декодер) и не полагается на синхронизацию часов.</p><p><img src=../images/09-diy-latency.png alt="DIY Latency" title="Измерение задержки своими руками">.
<img src=../images/09-diy-latency-happen-observe.png alt="DIY Latency Example" title="Пример измерения задержки своими руками"></p><p>На фото выше измеренная задержка от конца до конца составляет 101 мс. Событие происходит прямо сейчас в 10:16:02.862, но наблюдатель системы потоковой передачи видит 10:16:02.761.</p><h3 id=автоматическое-измерение-задержки-от-конца-до-конца>Автоматическое измерение задержки от конца до конца
<a class=anchor href=#%d0%b0%d0%b2%d1%82%d0%be%d0%bc%d0%b0%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%b8%d0%b7%d0%bc%d0%b5%d1%80%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b8-%d0%be%d1%82-%d0%ba%d0%be%d0%bd%d1%86%d0%b0-%d0%b4%d0%be-%d0%ba%d0%be%d0%bd%d1%86%d0%b0>#</a></h3><p>На момент написания (май 2021 года) стандарт WebRTC для задержки от конца до конца активно <a href=https://github.com/w3c/webrtc-stats/issues/537>обсуждается</a>. Firefox реализовал набор API для создания автоматических измерений задержки поверх стандартных WebRTC API. Однако в этом параграфе мы обсудим наиболее совместимый способ автоматического измерения задержки.</p><p><img src=../images/09-ntp-latency.png alt="Измерение задержки в стиле NTP" title="Измерение задержки в стиле NTP"></p><p>Время кругового обхода вкратце: я отправляю вам свое время <code>tR1</code>, когда я получаю обратно мой <code>tR1</code> во время <code>tR2</code>, я знаю, что время кругового обхода равно <code>tR2 - tR1</code>.</p><p>При наличии канала связи между отправителем и получателем (например, <a href=https://webrtc.org/getting-started/data-channels>DataChannel</a>) получатель может смоделировать монотонные часы отправителя, выполнив следующие шаги:</p><ol><li>Во время <code>tR1</code> получатель отправляет сообщение со своей локальной меткой времени монотонных часов.</li><li>Когда оно принимается отправителем с локальным временем <code>tS1</code>, отправитель отвечает копией <code>tR1</code>, а также своим <code>tS1</code> и временем видеодорожки отправителя <code>tSV1</code>.</li><li>Во время <code>tR2</code> на стороне получателя время кругового обхода вычисляется путем вычитания времени отправки и получения сообщения: <code>RTT = tR2 - tR1</code>.</li><li>Время кругового обхода <code>RTT</code> вместе с локальной меткой времени отправителя <code>tS1</code> достаточно для создания оценки монотонных часов отправителя. Текущее время на отправителе во время <code>tR2</code> будет равно <code>tS1</code> плюс половина времени кругового обхода.</li><li>Локальная метка времени отправителя <code>tS1</code>, сопоставленная с меткой времени видеодорожки <code>tSV1</code> вместе со временем кругового обхода <code>RTT</code>, достаточна для синхронизации времени видеодорожки получателя со временем видеодорожки отправителя.</li></ol><p>Теперь, когда мы знаем, сколько времени прошло с момента последнего известного времени видеокадра отправителя <code>tSV1</code>, мы можем приблизительно оценить задержку, вычтя время текущего отображаемого видеокадра (<code>actual_video_time</code>) из ожидаемого времени:</p><pre tabindex=0><code>expected_video_time = tSV1 + time_since(tSV1)
latency = expected_video_time - actual_video_time
</code></pre><p>Недостаток этого метода заключается в том, что он не включает внутреннюю задержку камеры. Большинство видеосистем считают метку времени захвата кадра временем доставки кадра с камеры в основную память, что происходит через несколько мгновений после фактического происходящего события.</p><h4 id=пример-оценки-задержки>Пример оценки задержки
<a class=anchor href=#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80-%d0%be%d1%86%d0%b5%d0%bd%d0%ba%d0%b8-%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b8>#</a></h4><p>Образец реализации открывает канал данных <code>latency</code> на получателе и периодически отправляет метки времени монотонного таймера получателя отправителю. Отправитель отвечает JSON-сообщением, и получатель вычисляет задержку на основе сообщения.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;received_time&#34;</span>: <span style=color:#ae81ff>64714</span>,       <span style=color:#75715e>// Метка времени, отправленная получателем, отражается отправителем. 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;delay_since_received&#34;</span>: <span style=color:#ae81ff>46</span>,   <span style=color:#75715e>// Время, прошедшее с момента последнего полученного `received_time` на отправителе.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;local_clock&#34;</span>: <span style=color:#ae81ff>1597366470336</span>, <span style=color:#75715e>// Текущее время монотонных часов отправителя.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>&#34;track_times_msec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;myvideo_track1&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>13100</span>,        <span style=color:#75715e>// Метка времени RTP видеокадра (в миллисекундах).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>1597366470289</span> <span style=color:#75715e>// Метка времени монотонных часов видеокадра.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Откройте канал данных на получателе:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>createDataChannel</span>(<span style=color:#e6db74>&#39;latency&#39;</span>);
</span></span></code></pre></div><p>Отправляйте время получателя <code>tR1</code> периодически. В этом примере используется 2 секунды без особой причины:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>setInterval</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>tR1</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span></code></pre></div><p>Обработайте входящее сообщение от получателя на отправителе:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Предполагаем, что event.data - строка вида &#34;1234567&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span><span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>42000</span>; <span style=color:#75715e>// Текущая метка времени RTP кадра, преобразованная в миллисекундный масштаб.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tS1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1597366470289</span>; <span style=color:#75715e>// Текущая метка времени монотонных часов кадра.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>msg</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;received_time&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>tR1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;delay_since_received&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;local_clock&#34;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>now</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;track_times_msec&#34;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;myvideo_track1&#34;</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>dataChannel</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>msg</span>));
</span></span></code></pre></div><p>Обработайте входящее сообщение от отправителя и выведите оценку задержки в <code>console</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>performance</span>.<span style=color:#a6e22e>now</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>fromSender</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>tR1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;received_time&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;delay_since_received&#39;</span>]; <span style=color:#75715e>// Сколько времени прошло между получением и отправкой ответа отправителем.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;local_clock&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tR2</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>networkLatency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rtt</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>senderTimeFromResponse</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>delay</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>networkLatency</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>VIDEO</span>.<span style=color:#a6e22e>requestVideoFrameCallback</span>((<span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>framemeta</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Оценить текущее время отправителя.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tR2</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delaySinceVideoCallbackRequested</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> [<span style=color:#a6e22e>tSV1</span>, <span style=color:#a6e22e>tS1</span>] <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>entries</span>(<span style=color:#a6e22e>fromSender</span>[<span style=color:#e6db74>&#39;track_times_msec&#39;</span>])[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>senderTime</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>tS1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tSV1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>timeSinceLastKnownFrame</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>actualVideoTimeMsec</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>trunc</span>(<span style=color:#a6e22e>framemeta</span>.<span style=color:#a6e22e>rtpTimestamp</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>90</span>); <span style=color:#75715e>// Преобразование базы времени RTP (90000) в миллисекундную базу.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>latency</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>expectedVideoTimeMsec</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>actualVideoTimeMsec</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;latency&#39;</span>, <span style=color:#a6e22e>latency</span>, <span style=color:#e6db74>&#39;msec&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=фактическое-время-видео-в-браузере>Фактическое время видео в браузере
<a class=anchor href=#%d1%84%d0%b0%d0%ba%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%b2%d1%80%d0%b5%d0%bc%d1%8f-%d0%b2%d0%b8%d0%b4%d0%b5%d0%be-%d0%b2-%d0%b1%d1%80%d0%b0%d1%83%d0%b7%d0%b5%d1%80%d0%b5>#</a></h4><blockquote><p><code>&lt;video>.requestVideoFrameCallback()</code> позволяет веб-авторам получать уведомления о представлении кадра для компоновки.</p></blockquote><p>До недавнего времени (до мая 2020 года) было практически невозможно надежно получить метку времени текущего отображаемого видеокадра в браузерах. Существовали обходные методы на основе <code>video.currentTime</code>, но они были не особенно точными.</p><p>Разработчики браузеров Chrome и Mozilla <a href=https://github.com/mozilla/standards-positions/issues/250>поддержали</a> введение нового стандарта W3C, <a href=https://wicg.github.io/video-rvfc/><code>HTMLVideoElement.requestVideoFrameCallback()</code></a>, который добавляет API-обратный вызов для доступа к текущему времени видеокадра.</p><p>Хотя дополнение кажется тривиальным, оно позволило создать множество сложных медиаприложений в Интернете, требующих синхронизации аудио и видео.</p><p>Специально для WebRTC обратный вызов будет включать поле <code>rtpTimestamp</code>, метку времени RTP, связанную с текущим видеокадром. Это должно быть присутствующим для приложений WebRTC, но отсутствовать в других случаях.</p><h3 id=советы-по-отладке-задержки>Советы по отладке задержки
<a class=anchor href=#%d1%81%d0%be%d0%b2%d0%b5%d1%82%d1%8b-%d0%bf%d0%be-%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b5-%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b8>#</a></h3><p>Поскольку отладка, вероятно, повлияет на измеряемую задержку, общее правило - упростить вашу настройку до наименьшего возможного размера, который все еще может воспроизвести проблему. Чем больше компонентов вы сможете удалить, тем легче будет определить, какой компонент вызывает проблему с задержкой.</p><h4 id=задержка-камеры>Задержка камеры
<a class=anchor href=#%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b0-%d0%ba%d0%b0%d0%bc%d0%b5%d1%80%d1%8b>#</a></h4><p>В зависимости от настроек камеры ее задержка может варьироваться. Проверьте настройки автоэкспозиции, автофокуса и автоматического баланса белого. Все &ldquo;автоматические&rdquo; функции веб-камер занимают дополнительное время для анализа захваченного изображения перед его передачей в стек WebRTC.</p><p>Если вы используете Linux, вы можете использовать инструмент командной строки <code>v4l2-ctl</code> для управления настройками камеры:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Отключить автофокус:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_auto<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Установить фокус на бесконечность:</span>
</span></span><span style=display:flex><span>v4l2-ctl -d /dev/video0 -c focus_absolute<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Вы также можете использовать графический инструмент <code>guvcview</code> для быстрой проверки и настройки параметров камеры.</p><h4 id=задержка-кодировщика>Задержка кодировщика
<a class=anchor href=#%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b0-%d0%ba%d0%be%d0%b4%d0%b8%d1%80%d0%be%d0%b2%d1%89%d0%b8%d0%ba%d0%b0>#</a></h4><p>Большинство современных кодировщиков будут буферизовать некоторые кадры перед выводом закодированного. Их первый приоритет - баланс между качеством создаваемой картинки и битрейтом. Многопроходное кодирование - крайний пример пренебрежения кодировщика к выходной задержке. Во время первого прохода кодировщик полностью поглощает все видео и только после этого начинает выводить кадры.</p><p>Однако с правильной настройкой люди достигали субкадровых задержек. Убедитесь, что ваш кодировщик не использует чрезмерное количество эталонных кадров и не полагается на B-кадры. Настройки задержки каждого кодека различаются, но для x264 мы рекомендуем использовать <code>tune=zerolatency</code> и <code>profile=baseline</code> для минимальной задержки вывода кадров.</p><h4 id=сетевая-задержка>Сетевая задержка
<a class=anchor href=#%d1%81%d0%b5%d1%82%d0%b5%d0%b2%d0%b0%d1%8f-%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b0>#</a></h4><p>Сетевой задержкой вы можете arguably сделать меньше всего, кроме как обновить сетевое подключение. Сетевая задержка очень похожа на погоду - вы не можете остановить дождь, но можете посмотреть прогноз и взять зонт. WebRTC измеряет сетевые условия с точностью до миллисекунд.</p><p>Важные метрики:</p><ul><li>Время кругового обхода.</li><li>Потеря пакетов и повторные передачи пакетов.</li></ul><p><strong>Время кругового обхода</strong></p><p>Стек WebRTC имеет встроенный механизм измерения времени кругового обхода сети (RTT) <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime>механизм</a>. Достаточно хорошее приближение задержки - половина RTT. Предполагается, что отправка и получение пакета занимают одинаковое время, что не всегда так. RTT устанавливает нижнюю границу задержки от конца до конца. Ваши видеокадры не могут достичь получателя быстрее, чем <code>RTT/2</code>, независимо от того, насколько оптимизирован ваш конвейер от камеры до кодировщика.</p><p>Встроенный механизм RTT основан на специальных RTCP-пакетах, называемых отчетами отправителя/получателя. Отправитель отправляет свое показание времени получателю, получатель в свою очередь отражает тот же временной штамп обратно отправителю. Таким образом, отправитель знает, сколько времени заняла передача пакета получателю и обратно. Обратитесь к главе <a href=../06-media-communication/#senderreceiver-reports>Отчеты отправителя/получателя</a> для более подробной информации об измерении RTT.</p><p><strong>Потеря пакетов и повторные передачи</strong></p><p>Как RTP, так и RTCP - это протоколы на основе UDP, которые не гарантируют упорядочивания, успешной доставки или отсутствия дублирования. Все вышеперечисленное может и происходит в реальных приложениях WebRTC.</p><p>Несложная реализация декодера ожидает, что все пакеты кадра будут доставлены, чтобы декодер мог успешно восстановить изображение. При наличии потери пакетов могут появиться артефакты декодирования, если теряются пакеты <a href=../06-media-communication/#inter-frame-types>P-кадра</a>. Если теряются пакеты I-кадра, то все зависимые кадры либо получат серьезные артефакты, либо вообще не будут декодированы. Скорее всего, это приведет к &ldquo;замораживанию&rdquo; видео на мгновение.</p><p>Чтобы избежать (точнее, попытаться избежать) замораживания видео или артефактов декодирования, WebRTC использует сообщения отрицательного подтверждения (<a href=../06-media-communication/#negative-acknowledgment>NACK</a>). Когда получатель не получает ожидаемый RTP-пакет, он возвращает сообщение NACK, чтобы сообщить отправителю отправить отсутствующий пакет снова. Получатель <em>ждет</em> повторной передачи пакета. Такие повторные передачи вызывают увеличение задержки. Количество отправленных и полученных пакетов NACK записывается во встроенных статистических полях WebRTC <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcoutboundrtpstreamstats-nackcount>outbound stream nackCount</a> и <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-nackcount>inbound stream nackCount</a>.</p><p>Вы можете увидеть красивые графики входящего и исходящего <code>nackCount</code> на <a href=#webrtc-browser-tools>странице внутренних данных WebRTC</a>. Если вы видите, что <code>nackCount</code> увеличивается, это означает, что сеть испытывает высокую потерю пакетов, и стек WebRTC делает все возможное, чтобы создать гладкое видео/аудио-взаимодействие, несмотря на это.</p><p>Когда потеря пакетов настолько высока, что декодер не может создать изображение, или последующие зависимые изображения, как в случае полностью потерянного I-кадра, все будущие P-кадры не будут декодированы. Получатель попытается смягчить это, отправив специальное сообщение Picture Loss Indication (<a href=../06-media-communication/#full-intra-frame-request-fir-and-picture-loss-indication-pli>PLI</a>). Как только отправитель получает <code>PLI</code>, он создаст новый I-кадр, чтобы помочь декодеру получателя. I-кадры обычно больше по размеру, чем P-кадры. Это увеличивает количество пакетов, которые необходимо передать. Как и с сообщениями NACK, получателю придется ждать нового I-кадра, что введет дополнительную задержку.</p><p>Следите за <code>pliCount</code> на <a href=#webrtc-browser-tools>странице внутренних данных WebRTC</a>. Если он увеличивается, настройте кодировщик для создания меньшего количества пакетов или включите более устойчивый к ошибкам режим.</p><h4 id=задержка-на-стороне-получателя>Задержка на стороне получателя
<a class=anchor href=#%d0%b7%d0%b0%d0%b4%d0%b5%d1%80%d0%b6%d0%ba%d0%b0-%d0%bd%d0%b0-%d1%81%d1%82%d0%be%d1%80%d0%be%d0%bd%d0%b5-%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b0%d1%82%d0%b5%d0%bb%d1%8f>#</a></h4><p>Задержка будет зависеть от пакетов, приходящих не по порядку. Если нижняя часть пакета изображения придет раньше верхней, вам придется ждать верхнюю часть перед декодированием. Это подробно объясняется в главе <a href=../05-real-time-networking/#solving-jitter>Решение джиттера</a>.</p><p>Вы также можете обратиться к встроенной метрике <a href=https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-jitterbufferdelay>jitterBufferDelay</a>, чтобы увидеть, как долго кадр удерживался в приемном буфере в ожидании всех его пакетов, прежде чем был передан декодеру.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/b681d97e3677abfc2947fb0eda8ad4b2842029ef title='Последнее изменение от comerc | сентября 13, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>сентября 13, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/09-debugging.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Редактировать эту страницу</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#изолируйте-проблему>Изолируйте проблему</a><ul><li><a href=#проверка-stun-сервера-с-помощью-netcat>Проверка STUN-сервера с помощью netcat:</a></li><li><a href=#сбой-безопасности>Сбой безопасности</a></li><li><a href=#сбой-медиа>Сбой медиа</a></li><li><a href=#сбой-данных>Сбой данных</a></li></ul></li><li><a href=#инструменты-профессионала>Инструменты профессионала</a><ul><li><a href=#netcat-nc>netcat (nc)</a></li><li><a href=#tcpdump>tcpdump</a></li><li><a href=#wireshark>Wireshark</a></li><li><a href=#инструменты-webrtc-в-браузерах>Инструменты WebRTC в браузерах</a></li></ul></li><li><a href=#задержка>Задержка</a><ul><li><a href=#ручное-измерение-задержки-от-конца-до-конца>Ручное измерение задержки от конца до конца</a></li><li><a href=#автоматическое-измерение-задержки-от-конца-до-конца>Автоматическое измерение задержки от конца до конца</a></li><li><a href=#советы-по-отладке-задержки>Советы по отладке задержки</a></li></ul></li></ul></nav></div></aside></main></body></html>