<!doctype html><html lang=ru dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Коммуникация данных # Что я получаю от коммуникации данных WebRTC? # WebRTC предоставляет каналы данных для обмена данными. Между двумя пирами вы можете открыть 65 534 канала данных. Канал данных основан на датаграммах, и у каждого есть свои настройки надежности. По умолчанию каждый канал данных имеет гарантированную упорядоченную доставку.
Если вы подходите к WebRTC с точки зрения медиа, каналы данных могут показаться бесполезными. Зачем вам вся эта подсистема, когда вы могли бы просто использовать HTTP или WebSocket?"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/ru/docs/07-data-communication/"><meta property="og:site_name" content="WebRTC для любопытных"><meta property="og:title" content="Коммуникация данных"><meta property="og:description" content="Коммуникация данных # Что я получаю от коммуникации данных WebRTC? # WebRTC предоставляет каналы данных для обмена данными. Между двумя пирами вы можете открыть 65 534 канала данных. Канал данных основан на датаграммах, и у каждого есть свои настройки надежности. По умолчанию каждый канал данных имеет гарантированную упорядоченную доставку.
Если вы подходите к WebRTC с точки зрения медиа, каналы данных могут показаться бесполезными. Зачем вам вся эта подсистема, когда вы могли бы просто использовать HTTP или WebSocket?"><meta property="og:locale" content="ru"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-09-13T15:58:02+03:00"><title>Коммуникация данных | WebRTC для любопытных</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/ru/docs/07-data-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/07-data-communication/ title=Datakommunikation><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/07-data-communication/ title=数据通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/07-data-communication/ title=データ・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/07-data-communication/ title="ارتباط داده ای"><link rel=alternate hreflang=fr href=https://webrtcforthecurious.com/fr/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/07-data-communication/ title="Comunicación de Datos"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/07-data-communication/ title="Veri İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/07-data-communication/ title="데이터 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/ru.search.min.6405c2eee678bba77211860cbe0852ac3c3d10eac7c7a2510b23161024e8c31c.js integrity="sha256-ZAXC7uZ4u6dyEYYMvghSrDw9EOrHx6JRCyMWECTowxw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/ru/><span>WebRTC для любопытных</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Поиск aria-label=Поиск maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Русский</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/07-data-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/07-data-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/fr/docs/07-data-communication/>Français</a></li><li><a href=https://webrtcforthecurious.com/id/docs/07-data-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/07-data-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/07-data-communication/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/07-data-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/ru/docs/01-what-why-and-how/>Что, Зачем и Как</a></li><li><a href=/ru/docs/02-signaling/>Сигнализация</a></li><li><a href=/ru/docs/03-connecting/>Подключение</a></li><li><a href=/ru/docs/04-securing/>Защита</a></li><li><a href=/ru/docs/05-real-time-networking/>Сетевое взаимодействие в реальном времени</a></li><li><a href=/ru/docs/06-media-communication/>Медиа-коммуникация</a></li><li><a href=/ru/docs/07-data-communication/ class=active>Коммуникация данных</a></li><li><a href=/ru/docs/08-applied-webrtc/>Прикладной WebRTC</a></li><li><a href=/ru/docs/09-debugging/>Отладка</a></li><li><a href=/ru/docs/10-history-of-webrtc/>История</a></li><li><a href=/ru/docs/11-faq/>Часто задаваемые вопросы</a></li><li><a href=/ru/docs/12-glossary/>Глоссарий</a></li><li><a href=/ru/docs/13-reference/>Справочник</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Коммуникация данных</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#что-я-получаю-от-коммуникации-данных-webrtc>Что я получаю от коммуникации данных WebRTC?</a></li><li><a href=#как-это-работает>Как это работает?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#stream-control-transmission-protocol>Stream Control Transmission Protocol</a></li><li><a href=#концепции>Концепции</a><ul><li><a href=#ассоциация>Ассоциация</a></li><li><a href=#потоки>Потоки</a></li><li><a href=#датаграмма>Датаграмма</a></li><li><a href=#части>Части</a></li><li><a href=#номер-последовательности-передачи>Номер последовательности передачи</a></li><li><a href=#идентификатор-потока>Идентификатор потока</a></li><li><a href=#идентификатор-протокола-полезной-нагрузки>Идентификатор протокола полезной нагрузки</a></li></ul></li><li><a href=#протокол-1>Протокол</a><ul><li><a href=#части-data>Части DATA</a></li><li><a href=#init-chunk>INIT Chunk</a></li><li><a href=#sack-chunk>SACK Chunk</a></li><li><a href=#heartbeat-chunk>HEARTBEAT Chunk</a></li><li><a href=#abort-chunk>ABORT Chunk</a></li><li><a href=#shutdown-chunk>SHUTDOWN Chunk</a></li><li><a href=#error-chunk>ERROR Chunk</a></li><li><a href=#forward-tsn-chunk>FORWARD TSN Chunk</a></li></ul></li><li><a href=#state-machine>State Machine</a><ul><li><a href=#flow-установления-соединения>Flow установления соединения</a></li><li><a href=#flow-разрыва-соединения>Flow разрыва соединения</a></li><li><a href=#keep-alive-mechanism>Keep-Alive Mechanism</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=коммуникация-данных>Коммуникация данных
<a class=anchor href=#%d0%ba%d0%be%d0%bc%d0%bc%d1%83%d0%bd%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d1%8f-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85>#</a></h1><h2 id=что-я-получаю-от-коммуникации-данных-webrtc>Что я получаю от коммуникации данных WebRTC?
<a class=anchor href=#%d1%87%d1%82%d0%be-%d1%8f-%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b0%d1%8e-%d0%be%d1%82-%d0%ba%d0%be%d0%bc%d0%bc%d1%83%d0%bd%d0%b8%d0%ba%d0%b0%d1%86%d0%b8%d0%b8-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-webrtc>#</a></h2><p>WebRTC предоставляет каналы данных для обмена данными. Между двумя пирами вы можете открыть 65 534 канала данных.
Канал данных основан на датаграммах, и у каждого есть свои настройки надежности. По умолчанию каждый канал данных имеет гарантированную упорядоченную доставку.</p><p>Если вы подходите к WebRTC с точки зрения медиа, каналы данных могут показаться бесполезными. Зачем вам вся эта подсистема, когда вы могли бы просто использовать HTTP или WebSocket?</p><p>Реальная сила каналов данных заключается в том, что вы можете настроить их так, чтобы они работали как UDP с неупорядоченной/потерянной доставкой.
Это необходимо для ситуаций с низкой задержкой и высокой производительностью. Вы можете измерять обратное давление и убеждаться, что отправляете только то, что поддерживает ваша сеть.</p><h2 id=как-это-работает>Как это работает?
<a class=anchor href=#%d0%ba%d0%b0%d0%ba-%d1%8d%d1%82%d0%be-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d0%b5%d1%82>#</a></h2><p>WebRTC использует протокол управления потоком передачи (Stream Control Transmission Protocol, SCTP), определенный в <a href=https://tools.ietf.org/html/rfc4960>RFC 4960</a>. SCTP - это
транспортный протокол, который был задуман как альтернатива TCP или UDP. Для WebRTC мы используем его как протокол прикладного уровня, работающий поверх нашего DTLS-соединения.</p><p>SCTP дает вам потоки, и каждый поток может быть настроен независимо. Каналы данных WebRTC - это просто тонкие абстракции поверх них. Настройки
надежности и упорядочивания просто передаются прямо в SCTP-агент.</p><p>Каналы данных имеют некоторые функции, которые SCTP не может выразить, например, метки каналов. Для решения этого WebRTC использует протокол установления канала данных (Data Channel Establishment Protocol, DCEP),
который определен в <a href=https://tools.ietf.org/html/rfc8832>RFC 8832</a>. DCEP определяет сообщение для обмена меткой канала и протоколом.</p><h2 id=dcep>DCEP
<a class=anchor href=#dcep>#</a></h2><p>DCEP только имеет два сообщения <code>DATA_CHANNEL_OPEN</code> и <code>DATA_CHANNEL_ACK</code>. Для каждого открытого канала данных удаленный должен ответить с подтверждением.</p><h3 id=data_channel_open>DATA_CHANNEL_OPEN
<a class=anchor href=#data_channel_open>#</a></h3><p>Это сообщение отправляется WebRTC-агентом, который хочет открыть канал.</p><h4 id=формат-пакета>Формат пакета
<a class=anchor href=#%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82-%d0%bf%d0%b0%d0%ba%d0%b5%d1%82%d0%b0>#</a></h4><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |  Channel Type |            Priority           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Reliability Parameter                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Label Length          |       Protocol Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                             Label                             /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                            Protocol                           /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=тип-сообщения>Тип сообщения
<a class=anchor href=#%d1%82%d0%b8%d0%bf-%d1%81%d0%be%d0%be%d0%b1%d1%89%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h4><p>Тип сообщения является статическим значением <code>0x03</code>.</p><h4 id=тип-канала>Тип канала
<a class=anchor href=#%d1%82%d0%b8%d0%bf-%d0%ba%d0%b0%d0%bd%d0%b0%d0%bb%d0%b0>#</a></h4><p>Тип канала контролирует атрибуты надежности/упорядочивания канала. Он может иметь следующие значения:</p><ul><li><code>DATA_CHANNEL_RELIABLE</code> (<code>0x00</code>) - Сообщения не теряются и приходят в порядке</li><li><code>DATA_CHANNEL_RELIABLE_UNORDERED</code> (<code>0x80</code>) - Сообщения не теряются, но они могут приходить в неправильном порядке.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT</code> (<code>0x01</code>) - Сообщения могут теряться после попытки запрошенного количества раз, но они приходят в порядке.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED</code> (<code>0x81</code>) - Сообщения могут теряться после попытки запрошенного количества раз и могут приходить в неправильном порядке.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED</code> (<code>0x02</code>) - Сообщения могут теряться, если они не приходят в запрошенное количество времени, но они приходят в порядке.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED</code> (<code>0x82</code>) - Сообщения могут теряться, если они не приходят в запрошенное количество времени и могут приходить в неправильном порядке.</li></ul><h4 id=приоритет>Приоритет
<a class=anchor href=#%d0%bf%d1%80%d0%b8%d0%be%d1%80%d0%b8%d1%82%d0%b5%d1%82>#</a></h4><p>Приоритет канала данных. Каналы данных с более высоким приоритетом будут запускаться первыми. Большие сообщения пользователя с низким приоритетом не будут задерживать отправку сообщений с более высоким приоритетом.</p><h4 id=параметр-надежности>Параметр надежности
<a class=anchor href=#%d0%bf%d0%b0%d1%80%d0%b0%d0%bc%d0%b5%d1%82%d1%80-%d0%bd%d0%b0%d0%b4%d0%b5%d0%b6%d0%bd%d0%be%d1%81%d1%82%d0%b8>#</a></h4><p>Если тип канала данных <code>DATA_CHANNEL_PARTIAL_RELIABLE</code>, суффиксы конфигурируют поведение:</p><ul><li><code>REXMIT</code> - Определяет, сколько раз отправитель будет передавать сообщение перед отказом.</li><li><code>TIMED</code> - Определяет, сколько времени (в мс) отправитель будет передавать сообщение перед отказом.</li></ul><h4 id=метка>Метка
<a class=anchor href=#%d0%bc%d0%b5%d1%82%d0%ba%d0%b0>#</a></h4><p>UTF-8-кодированная строка, содержащая имя канала данных. Эта строка может быть пустой.</p><h4 id=протокол>Протокол
<a class=anchor href=#%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb>#</a></h4><p>Если это пустая строка, протокол не указан. Если это непустая строка, она должна указывать на зарегистрированный протокол в &ldquo;WebSocket Subprotocol Name Registry&rdquo;, определенном в <a href=https://tools.ietf.org/html/rfc6455#page-61>RFC 6455</a>.</p><h3 id=data_channel_ack>DATA_CHANNEL_ACK
<a class=anchor href=#data_channel_ack>#</a></h3><p>Это сообщение отправляется WebRTC-агентом для подтверждения того, что этот канал данных открыт.</p><h4 id=формат-пакета-1>Формат пакета
<a class=anchor href=#%d1%84%d0%be%d1%80%d0%bc%d0%b0%d1%82-%d0%bf%d0%b0%d0%ba%d0%b5%d1%82%d0%b0-1>#</a></h4><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |
+-+-+-+-+-+-+-+-+
</code></pre><h2 id=stream-control-transmission-protocol>Stream Control Transmission Protocol
<a class=anchor href=#stream-control-transmission-protocol>#</a></h2><p>SCTP является реальной силой каналов данных WebRTC. Он предоставляет все эти функции канала данных:</p><ul><li>Мультиплексирование</li><li>Надежная доставка с использованием механизма передачи TCP-подобной передачи</li><li>Опции частичной надежности</li><li>Предотвращение перегрузки</li><li>Управление потоком</li></ul><p>Чтобы понять SCTP, мы рассмотрим его в трех частях. Цель состоит в том, чтобы вы узнали достаточно, чтобы отладить и изучить глубокие детали SCTP самостоятельно после этой главы.</p><h2 id=концепции>Концепции
<a class=anchor href=#%d0%ba%d0%be%d0%bd%d1%86%d0%b5%d0%bf%d1%86%d0%b8%d0%b8>#</a></h2><p>SCTP является протоколом с богатыми функциями. Этот раздел будет охватывать только части SCTP, используемые WebRTC. Функции в SCTP, которые не используются WebRTC, включают мультихостинг и выбор пути.</p><p>С более чем двадцатилетним развитием SCTP может быть сложно полностью понять.</p><h3 id=ассоциация>Ассоциация
<a class=anchor href=#%d0%b0%d1%81%d1%81%d0%be%d1%86%d0%b8%d0%b0%d1%86%d0%b8%d1%8f>#</a></h3><p>Ассоциация - это термин для SCTP-сессии. Это состояние, которое разделяется
между двумя SCTP-агентами, когда они общаются.</p><h3 id=потоки>Потоки
<a class=anchor href=#%d0%bf%d0%be%d1%82%d0%be%d0%ba%d0%b8>#</a></h3><p>Поток - это однонаправленная последовательность данных пользователя. Когда вы создаете канал данных, вы фактически создаете SCTP-поток. Каждая SCTP-ассоциация содержит список потоков. Каждый поток может быть настроен с разными типами надежности.</p><p>WebRTC позволяет вам настраивать только один поток при создании, но SCTP фактически позволяет изменять конфигурацию в любое время.</p><h3 id=датаграмма>Датаграмма
<a class=anchor href=#%d0%b4%d0%b0%d1%82%d0%b0%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b0>#</a></h3><p>SCTP передает данные как датаграммы, а не как байтовый поток. Отправка и получение данных напоминает использование UDP вместо TCP.
Вам не нужно добавлять дополнительный код для передачи нескольких файлов по одному потоку.</p><p>SCTP-сообщения не имеют ограничений по размеру, как UDP. Одно SCTP-сообщение может быть размером в несколько гигабайт.</p><h3 id=части>Части
<a class=anchor href=#%d1%87%d0%b0%d1%81%d1%82%d0%b8>#</a></h3><p>Протокол SCTP состоит из частей. Существует множество различных типов частей. Эти части используются для всех коммуникаций.
Данные пользователя, инициализация соединения, управление перегрузкой, и многое другое делается через части.</p><p>Каждый SCTP-пакет содержит список частей. Таким образом, в одном UDP-пакете можно иметь несколько частей, несущих сообщения из разных потоков.</p><h3 id=номер-последовательности-передачи>Номер последовательности передачи
<a class=anchor href=#%d0%bd%d0%be%d0%bc%d0%b5%d1%80-%d0%bf%d0%be%d1%81%d0%bb%d0%b5%d0%b4%d0%be%d0%b2%d0%b0%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%bf%d0%b5%d1%80%d0%b5%d0%b4%d0%b0%d1%87%d0%b8>#</a></h3><p>Номер последовательности передачи (TSN) является глобальным уникальным идентификатором для частей DATA. Части DATA несут все сообщения, которые пользователь хочет отправить. TSN важен, потому что он помогает получателю определить, являются ли пакеты потерянными или неправильными.</p><p>Если получатель замечает отсутствующий TSN, он не передает данные пользователю до тех пор, пока он не будет выполнен.</p><h3 id=идентификатор-потока>Идентификатор потока
<a class=anchor href=#%d0%b8%d0%b4%d0%b5%d0%bd%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80-%d0%bf%d0%be%d1%82%d0%be%d0%ba%d0%b0>#</a></h3><p>Каждый поток имеет уникальный идентификатор. Когда вы создаете канал данных с явным ID, он фактически передается прямо в SCTP как идентификатор потока. Если вы не передаете ID, идентификатор потока выбирается для вас.</p><h3 id=идентификатор-протокола-полезной-нагрузки>Идентификатор протокола полезной нагрузки
<a class=anchor href=#%d0%b8%d0%b4%d0%b5%d0%bd%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%be%d1%80-%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb%d0%b0-%d0%bf%d0%be%d0%bb%d0%b5%d0%b7%d0%bd%d0%be%d0%b9-%d0%bd%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b8>#</a></h3><p>Каждая часть DATA также имеет Идентификатор протокола полезной нагрузки (PPID). Это используется для уникальной идентификации типа данных, который обменивается. SCTP имеет много PPIDs, но WebRTC использует только следующие пять:</p><ul><li><code>WebRTC DCEP</code> (<code>50</code>) - Сообщения DCEP.</li><li><code>WebRTC String</code> (<code>51</code>) - Сообщения канала данных String.</li><li><code>WebRTC Binary</code> (<code>53</code>) - Сообщения канала данных Binary.</li><li><code>WebRTC String Empty</code> (<code>56</code>) - Сообщения канала данных String с длиной 0.</li><li><code>WebRTC Binary Empty</code> (<code>57</code>) - Сообщения канала данных Binary с длиной 0.</li></ul><h2 id=протокол-1>Протокол
<a class=anchor href=#%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb-1>#</a></h2><p>Следующие некоторые из частей, используемых протоколом SCTP. Это
не является исчерпывающим представлением. Это обеспечивает достаточные структуры для
состояние машины для понимания.</p><p>Каждая часть начинается с поля <code>type</code>. Перед списком частей также
имеется заголовок.</p><h3 id=части-data>Части DATA
<a class=anchor href=#%d1%87%d0%b0%d1%81%d1%82%d0%b8-data>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0    | Reserved|U|B|E|    Length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TSN                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Stream Identifier        |   Stream Sequence Number      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Payload Protocol Identifier                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                            User Data                          /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Части DATA являются способом обмена всеми данными пользователя. Когда вы
отправляете что-либо по каналу данных, это как это происходит.</p><p><code>U</code> бит установлен, если это неупорядоченный пакет. Мы можем игнорировать
Номер последовательности потока.</p><p><code>B</code> и <code>E</code> - это биты начала и конца. Если вы хотите отправить сообщение, которое слишком велико для одной части DATA, оно должно быть фрагментировано на несколько частей DATA, отправленных в отдельных пакетах.
С битами <code>B</code> и <code>E</code> и номерами последовательностей SCTP может выразить
это.</p><ul><li><code>B=1</code>, <code>E=0</code> - Первая часть фрагментированного сообщения пользователя.</li><li><code>B=0</code>, <code>E=0</code> - Средняя часть фрагментированного сообщения пользователя.</li><li><code>B=0</code>, <code>E=1</code> - Последняя часть фрагментированного сообщения пользователя.</li><li><code>B=1</code>, <code>E=1</code> - Нефрагментированное сообщение.</li></ul><p><code>TSN</code> - это номер последовательности передачи. Это глобальный уникальный
идентификатор для этой части DATA. После 4,294,967,295 частей это обернется к 0.
TSN увеличивается для каждой части фрагментированного сообщения пользователя, чтобы получатель знал, как упорядочить полученные части для восстановления исходного сообщения.</p><p><code>Идентификатор потока</code> - это уникальный идентификатор потока, к которому принадлежит эта данные.</p><p><code>Номер последовательности потока</code> - это 16-битное число, увеличивающееся с каждым сообщением пользователя и включаемое в заголовок части DATA-сообщения. После 65535 сообщений это обернется к 0. Это число используется для определения порядка доставки сообщений получателю, если <code>U</code> установлен в 0. Подобно TSN, за исключением того, что Номер последовательности потока увеличивается только для целого сообщения, а не для каждой отдельной части DATA.</p><p><code>Идентификатор протокола полезной нагрузки</code> - это тип данных, который течет
через этот поток. Для WebRTC это будет DCEP, String или Binary.</p><p><code>Данные пользователя</code> - это то, что вы отправляете. Все данные, которые вы отправляете по каналу данных WebRTC
передаются через часть DATA.</p><h3 id=init-chunk>INIT Chunk
<a class=anchor href=#init-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 1    |  Chunk Flags  |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Initiate Tag                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Advertised Receiver Window Credit (a_rwnd)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Number of Outbound Streams   |  Number of Inbound Streams    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Initial TSN                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/              Optional/Variable-Length Parameters              /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть INIT начинает процесс создания ассоциации.</p><p><code>Initiate Tag</code> используется для генерации файла cookie. Файлы cookie используются для Man-In-The-Middle
и защиты от DoS-атак. Они описываются более подробно в разделе
состояние машины.</p><p><code>Advertised Receiver Window Credit</code> используется для управления перегрузкой SCTP. Это
сообщает, насколько большой буфер имеется у получателя для этой ассоциации.</p><p><code>Число исходящих/входящих потоков</code> уведомляет удаленный о том, сколько потоков поддерживает
этот агент.</p><p><code>Initial TSN</code> - это случайный <code>uint32</code> для запуска локального TSN.</p><p><code>Опциональные параметры</code> позволяют SCTP вводить новые функции в протокол.</p><h3 id=sack-chunk>SACK Chunk
<a class=anchor href=#sack-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 3    |Chunk  Flags   |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Advertised Receiver Window Credit (a_rwnd)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Gap Ack Block #N Start      |  Gap Ack Block #N End         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Duplicate TSN 1                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Duplicate TSN X                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть SACK (Selective Acknowledgment) уведомляет
отправитель о том, что он получил пакет. Пока отправитель не получит SACK для TSN
он будет передавать часть DATA в вопрос. SACK делает больше, чем просто
обновление TSN.</p><p><code>Cumulative TSN ACK</code> - это самый высокий TSN, который был получен.</p><p><code>Advertised Receiver Window Credit</code> - размер буфера получателя. Получатель
может изменить это во время сессии, если становится доступно больше памяти.</p><p><code>Ack Blocks</code> TSNs, которые были получены после <code>Cumulative TSN ACK</code>.
Это используется, если есть разрыв в доставленных пакетах. Скажем, части DATA с TSNs
<code>100</code>, <code>102</code>, <code>103</code> и <code>104</code> доставлены. <code>Cumulative TSN ACK</code> был бы <code>100</code>, но
<code>Ack Blocks</code> мог бы сказать отправителю, что ему не нужно передавать <code>102</code>, <code>103</code> или <code>104</code>.</p><p><code>Duplicate TSN</code> информирует отправителя о том, что он получил следующие части DATA более одного раза.</p><h3 id=heartbeat-chunk>HEARTBEAT Chunk
<a class=anchor href=#heartbeat-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 4    | Chunk  Flags  |      Heartbeat Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/            Heartbeat Information TLV (Variable-Length)        /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть HEARTBEAT используется для утверждения, что удаленный все еще отвечает.
Полезно, если вы не отправляете частей DATA и вам нужно поддерживать NAT
карту открытой.</p><h3 id=abort-chunk>ABORT Chunk
<a class=anchor href=#abort-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 6    |Reserved     |T|           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\               Zero or more Error Causes                       \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть ABORT резко завершает ассоциацию. Используется, когда
одна сторона входит в состояние ошибки. Завершение соединения использует
часть SHUTDOWN.</p><h3 id=shutdown-chunk>SHUTDOWN Chunk
<a class=anchor href=#shutdown-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 7    | Chunk  Flags  |      Length = 8               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть SHUTDOWN начинает грациозное завершение SCTP-ассоциации.
Каждый агент информирует удаленный о последнем TSN, который он отправил. Это гарантирует,
что никакие пакеты не будут потеряны. WebRTC не выполняет грациозное завершение
SCTP-ассоциации. Вам нужно самостоятельно разорвать каждый канал данных, чтобы обработать его грациозно.</p><p><code>Cumulative TSN ACK</code> - это последний TSN, который был отправлен. Каждая сторона знает
не отключаться, пока они не получат часть DATA с этим TSN.</p><h3 id=error-chunk>ERROR Chunk
<a class=anchor href=#error-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 9    | Chunk  Flags  |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                    One or more Error Causes                   /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть ERROR используется для уведомления удаленного SCTP-агента о нефатальной
ошибке.</p><h3 id=forward-tsn-chunk>FORWARD TSN Chunk
<a class=anchor href=#forward-tsn-chunk>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 192  |  Flags = 0x00 |        Length = Variable      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      New Cumulative TSN                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Stream-1              |       Stream Sequence-1       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               /
/                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Stream-N              |       Stream Sequence-N       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Часть <code>FORWARD TSN</code> перемещает глобальный TSN вперед. SCTP делает это,
так что вы можете пропустить некоторые пакеты, которые вам больше не нужны. Скажем,
вы отправляете <code>10 11 12 13 14 15</code> и эти пакеты действительны только если
все они приходят. Эти данные также чувствительны к реальному времени, поэтому, если они
приходят поздно, они не полезны.</p><p>Если вы теряете <code>12</code> и <code>13</code>, нет причин отправлять <code>14</code> и <code>15</code>! SCTP использует
часть <code>FORWARD TSN</code> для достижения этого. Он говорит получателю, что <code>14</code> и <code>15</code>
не будут доставлены.</p><p><code>New Cumulative TSN</code> - это новый TSN соединения. Все пакеты
до этого TSN не будут сохранены.</p><p><code>Stream</code> и <code>Stream Sequence</code> используются для перехода <code>Номер последовательности потока</code>
вперед. См. часть DATA для значения этого поля.</p><h2 id=state-machine>State Machine
<a class=anchor href=#state-machine>#</a></h2><p>Это некоторые интересные части состояния машины SCTP. WebRTC не использует все
функции состояния машины SCTP, поэтому мы исключили эти части. Мы также упростили некоторые компоненты, чтобы сделать их понятными самостоятельно.</p><h3 id=flow-установления-соединения>Flow установления соединения
<a class=anchor href=#flow-%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f-%d1%81%d0%be%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h3><p>Части <code>INIT</code> и <code>INIT ACK</code> используются для обмена возможностями и конфигурациями
каждого пира. SCTP использует файл cookie во время рукопожатия для проверки пира, с которым он общается.
Это гарантирует, что рукопожатие не перехватывается и предотвращает DoS-атаки.</p><p>Часть <code>INIT ACK</code> содержит файл cookie. Файл cookie затем возвращается его создателю
с помощью <code>COOKIE ECHO</code>. Если проверка файла cookie успешна, <code>COOKIE ACK</code> отправляется, и
части DATA готовы к обмену.</p><p><img src=../images/07-connection-establishment.png alt="Connection establishment" title="Connection establishment"></p><h3 id=flow-разрыва-соединения>Flow разрыва соединения
<a class=anchor href=#flow-%d1%80%d0%b0%d0%b7%d1%80%d1%8b%d0%b2%d0%b0-%d1%81%d0%be%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h3><p>SCTP использует часть <code>SHUTDOWN</code>. Когда агент получает часть <code>SHUTDOWN</code>, он будет ждать, пока
он не получит запрошенный <code>Cumulative TSN ACK</code>. Это позволяет пользователю убедиться, что все данные
доставлены, даже если соединение потеряно.</p><h3 id=keep-alive-mechanism>Keep-Alive Mechanism
<a class=anchor href=#keep-alive-mechanism>#</a></h3><p>SCTP использует части <code>HEARTBEAT REQUEST</code> и <code>HEARTBEAT ACK</code> для поддержания соединения. Эти отправляются
на настраиваемом интервале. SCTP также выполняет экспоненциальную задержку, если пакет не пришел.</p><p>Часть <code>HEARTBEAT</code> также содержит временное значение. Это позволяет двум ассоциациям вычислить время поездки между двумя агентами.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/b681d97e3677abfc2947fb0eda8ad4b2842029ef title='Последнее изменение от comerc | сентября 13, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>сентября 13, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/07-data-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Редактировать эту страницу</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#что-я-получаю-от-коммуникации-данных-webrtc>Что я получаю от коммуникации данных WebRTC?</a></li><li><a href=#как-это-работает>Как это работает?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#stream-control-transmission-protocol>Stream Control Transmission Protocol</a></li><li><a href=#концепции>Концепции</a><ul><li><a href=#ассоциация>Ассоциация</a></li><li><a href=#потоки>Потоки</a></li><li><a href=#датаграмма>Датаграмма</a></li><li><a href=#части>Части</a></li><li><a href=#номер-последовательности-передачи>Номер последовательности передачи</a></li><li><a href=#идентификатор-потока>Идентификатор потока</a></li><li><a href=#идентификатор-протокола-полезной-нагрузки>Идентификатор протокола полезной нагрузки</a></li></ul></li><li><a href=#протокол-1>Протокол</a><ul><li><a href=#части-data>Части DATA</a></li><li><a href=#init-chunk>INIT Chunk</a></li><li><a href=#sack-chunk>SACK Chunk</a></li><li><a href=#heartbeat-chunk>HEARTBEAT Chunk</a></li><li><a href=#abort-chunk>ABORT Chunk</a></li><li><a href=#shutdown-chunk>SHUTDOWN Chunk</a></li><li><a href=#error-chunk>ERROR Chunk</a></li><li><a href=#forward-tsn-chunk>FORWARD TSN Chunk</a></li></ul></li><li><a href=#state-machine>State Machine</a><ul><li><a href=#flow-установления-соединения>Flow установления соединения</a></li><li><a href=#flow-разрыва-соединения>Flow разрыва соединения</a></li><li><a href=#keep-alive-mechanism>Keep-Alive Mechanism</a></li></ul></li></ul></nav></div></aside></main></body></html>