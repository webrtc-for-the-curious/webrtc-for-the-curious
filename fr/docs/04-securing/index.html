<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Sécurisation # Quelle sécurité offre WebRTC ? # Chaque connexion WebRTC est authentifiée et chiffrée. Vous pouvez être sûr qu&rsquo;un tiers ne peut pas voir ce que vous envoyez ou insérer de faux messages. Vous pouvez également être sûr que l&rsquo;agent WebRTC qui a généré la description de session est celui avec lequel vous communiquez.
Il est très important que personne ne modifie ces messages. Il est acceptable qu&rsquo;un tiers lise la description de session en transit."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/fr/docs/04-securing/"><meta property="og:site_name" content="WebRTC pour les curieux"><meta property="og:title" content="Sécurisation"><meta property="og:description" content="Sécurisation # Quelle sécurité offre WebRTC ? # Chaque connexion WebRTC est authentifiée et chiffrée. Vous pouvez être sûr qu’un tiers ne peut pas voir ce que vous envoyez ou insérer de faux messages. Vous pouvez également être sûr que l’agent WebRTC qui a généré la description de session est celui avec lequel vous communiquez.
Il est très important que personne ne modifie ces messages. Il est acceptable qu’un tiers lise la description de session en transit."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-04T08:46:52-05:00"><title>Sécurisation | WebRTC pour les curieux</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/fr/docs/04-securing/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/04-securing/ title=Защита><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/04-securing/ title=安全性><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/04-securing/ title=امنیت><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/04-securing/ title=Securing><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/04-securing/ title=Seguridad><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/04-securing/ title=Güvenlik><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/04-securing/ title=보안><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fr.search.min.c070e4b38914a2ce1aaa387751c1c4892529691a7708de55c3b3b27b63942d68.js integrity="sha256-wHDks4kUos4aqjh3UcHEiSUpaRp3CN5Vw7Oye2OULWg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/fr/><span>WebRTC pour les curieux</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Français</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/04-securing/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/04-securing/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/04-securing/>Persian</a></li><li><a href=https://webrtcforthecurious.com/id/docs/04-securing/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/04-securing/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/04-securing/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/04-securing/>한국어</a></li></ul></li></ul><ul><li><a href=/fr/docs/01-what-why-and-how/>Quoi, Pourquoi et Comment</a></li><li><a href=/fr/docs/02-signaling/>Signalisation</a></li><li><a href=/fr/docs/03-connecting/>Connexion</a></li><li><a href=/fr/docs/04-securing/ class=active>Sécurisation</a></li><li><a href=/fr/docs/05-real-time-networking/>Réseau en temps réel</a></li><li><a href=/fr/docs/06-media-communication/>Communication média</a></li><li><a href=/fr/docs/07-data-communication/>Communication de données</a></li><li><a href=/fr/docs/08-applied-webrtc/>WebRTC appliqué</a></li><li><a href=/fr/docs/09-debugging/>Débogage</a></li><li><a href=/fr/docs/10-history-of-webrtc/>Histoire</a></li><li><a href=/fr/docs/11-faq/>FAQ</a></li><li><a href=/fr/docs/12-glossary/>Glossaire</a></li><li><a href=/fr/docs/13-reference/>Référence</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Sécurisation</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#quelle-sécurité-offre-webrtc->Quelle sécurité offre WebRTC ?</a></li><li><a href=#comment-cela-fonctionne-t-il->Comment cela fonctionne-t-il ?</a></li><li><a href=#sécurité-101>Sécurité 101</a><ul><li><a href=#texte-en-clair-et-texte-chiffré>Texte en clair et texte chiffré</a></li><li><a href=#chiffrement>Chiffrement</a></li><li><a href=#fonctions-de-hachage>Fonctions de hachage</a></li><li><a href=#cryptographie-à-clé-publiqueprivée>Cryptographie à clé publique/privée</a></li><li><a href=#échange-diffiehellman>Échange Diffie–Hellman</a></li><li><a href=#fonction-pseudo-aléatoire>Fonction pseudo-aléatoire</a></li><li><a href=#fonction-de-dérivation-de-clé>Fonction de dérivation de clé</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#code-dauthentification-de-message>Code d&rsquo;authentification de message</a></li><li><a href=#rotation-de-clé>Rotation de clé</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#format-de-paquet>Format de paquet</a></li><li><a href=#machine-à-états-de-négociation>Machine à états de négociation</a></li><li><a href=#génération-de-clé>Génération de clé</a></li><li><a href=#échange-dapplicationdata>Échange d&rsquo;ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#création-de-session>Création de session</a></li><li><a href=#échange-de-médias>Échange de médias</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=sécurisation>Sécurisation
<a class=anchor href=#s%c3%a9curisation>#</a></h1><h2 id=quelle-sécurité-offre-webrtc->Quelle sécurité offre WebRTC ?
<a class=anchor href=#quelle-s%c3%a9curit%c3%a9-offre-webrtc->#</a></h2><p>Chaque connexion WebRTC est authentifiée et chiffrée. Vous pouvez être sûr qu&rsquo;un tiers ne peut pas voir ce que vous envoyez ou insérer de faux messages. Vous pouvez également être sûr que l&rsquo;agent WebRTC qui a généré la description de session est celui avec lequel vous communiquez.</p><p>Il est très important que personne ne modifie ces messages. Il est acceptable qu&rsquo;un tiers lise la description de session en transit. Cependant, WebRTC n&rsquo;a aucune protection contre sa modification. Un attaquant pourrait effectuer une attaque de l&rsquo;homme du milieu sur vous en changeant les candidats ICE et en mettant à jour l&rsquo;empreinte du certificat.</p><h2 id=comment-cela-fonctionne-t-il->Comment cela fonctionne-t-il ?
<a class=anchor href=#comment-cela-fonctionne-t-il->#</a></h2><p>WebRTC utilise deux protocoles préexistants, Datagram Transport Layer Security (<a href=https://tools.ietf.org/html/rfc6347>DTLS</a>) et le Secure Real-time Transport Protocol (<a href=https://tools.ietf.org/html/rfc3711>SRTP</a>).</p><p>DTLS vous permet de négocier une session puis d&rsquo;échanger des données en toute sécurité entre deux pairs. C&rsquo;est un frère de TLS, la même technologie qui alimente HTTPS, mais DTLS utilise UDP au lieu de TCP comme couche de transport. Cela signifie que le protocole doit gérer la livraison non fiable. SRTP est spécifiquement conçu pour échanger des médias de manière sécurisée. Il y a quelques optimisations que nous pouvons faire en l&rsquo;utilisant au lieu de DTLS.</p><p>DTLS est utilisé en premier. Il effectue une négociation sur la connexion fournie par ICE. DTLS est un protocole client/serveur, donc un côté doit démarrer la négociation. Les rôles Client/Serveur sont choisis lors de la signalisation. Pendant la négociation DTLS, les deux côtés offrent un certificat.
Une fois la négociation terminée, ce certificat est comparé au hachage du certificat dans la description de session. Ceci est pour s&rsquo;assurer que la négociation s&rsquo;est produite avec l&rsquo;agent WebRTC attendu. La connexion DTLS est ensuite disponible pour être utilisée pour la communication DataChannel.</p><p>Pour créer une session SRTP, nous l&rsquo;initialisons en utilisant les clés générées par DTLS. SRTP n&rsquo;a pas de mécanisme de négociation, donc il doit être amorcé avec des clés externes. Une fois cela fait, les médias peuvent être échangés en étant chiffrés en utilisant SRTP !</p><h2 id=sécurité-101>Sécurité 101
<a class=anchor href=#s%c3%a9curit%c3%a9-101>#</a></h2><p>Pour comprendre la technologie présentée dans ce chapitre, vous devrez d&rsquo;abord comprendre ces termes. La cryptographie est un sujet délicat, il vaudrait donc la peine de consulter d&rsquo;autres sources également !</p><h3 id=texte-en-clair-et-texte-chiffré>Texte en clair et texte chiffré
<a class=anchor href=#texte-en-clair-et-texte-chiffr%c3%a9>#</a></h3><p>Le texte en clair est l&rsquo;entrée d&rsquo;un chiffrement. Le texte chiffré est la sortie d&rsquo;un chiffrement.</p><h3 id=chiffrement>Chiffrement
<a class=anchor href=#chiffrement>#</a></h3><p>Le chiffrement est une série d&rsquo;étapes qui prend du texte en clair pour le transformer en texte chiffré. Le chiffrement peut ensuite être inversé, de sorte que vous puissiez ramener votre texte chiffré en texte en clair. Un chiffrement a généralement une clé pour changer son comportement. Un autre terme pour cela est le chiffrement et le déchiffrement.</p><p>Un chiffrement simple est ROT13. Chaque lettre est déplacée de 13 caractères en avant. Pour annuler le chiffrement, vous déplacez 13 caractères en arrière. Le texte en clair <code>HELLO</code> deviendrait le texte chiffré <code>URYYB</code>. Dans ce cas, le chiffrement est ROT, et la clé est 13.</p><h3 id=fonctions-de-hachage>Fonctions de hachage
<a class=anchor href=#fonctions-de-hachage>#</a></h3><p>Une fonction de hachage cryptographique est un processus à sens unique qui génère un condensé. Étant donné une entrée, elle génère la même sortie à chaque fois. Il est important que la sortie ne soit <em>pas</em> réversible. Si vous avez une sortie, vous ne devriez pas être capable de déterminer son entrée. Le hachage est utile lorsque vous voulez confirmer qu&rsquo;un message n&rsquo;a pas été altéré.</p><p>Une fonction de hachage simple (bien que certainement pas adaptée à la cryptographie réelle) serait de ne prendre qu&rsquo;une lettre sur deux. <code>HELLO</code> deviendrait <code>HLO</code>. Vous ne pouvez pas supposer que <code>HELLO</code> était l&rsquo;entrée, mais vous pouvez confirmer que <code>HELLO</code> correspondrait au condensé de hachage.</p><h3 id=cryptographie-à-clé-publiqueprivée>Cryptographie à clé publique/privée
<a class=anchor href=#cryptographie-%c3%a0-cl%c3%a9-publiquepriv%c3%a9e>#</a></h3><p>La cryptographie à clé publique/privée décrit le type de chiffrements que DTLS et SRTP utilisent. Dans ce système, vous avez deux clés, une clé publique et une clé privée. La clé publique est pour chiffrer les messages et peut être partagée en toute sécurité.
La clé privée est pour déchiffrer, et ne doit jamais être partagée. C&rsquo;est la seule clé qui peut déchiffrer les messages chiffrés avec la clé publique.</p><h3 id=échange-diffiehellman>Échange Diffie–Hellman
<a class=anchor href=#%c3%a9change-diffiehellman>#</a></h3><p>L&rsquo;échange Diffie–Hellman permet à deux utilisateurs qui ne se sont jamais rencontrés auparavant de créer un secret partagé en toute sécurité sur Internet. L&rsquo;utilisateur <code>A</code> peut envoyer un secret à l&rsquo;utilisateur <code>B</code> sans se soucier de l&rsquo;écoute clandestine. Cela dépend de la difficulté de casser le problème du logarithme discret.
Vous n&rsquo;avez pas besoin de comprendre pleinement comment cela fonctionne, mais il est utile de savoir que c&rsquo;est ce qui rend possible la négociation DTLS.</p><p>Wikipédia a un exemple de ceci en action <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>ici</a>.</p><h3 id=fonction-pseudo-aléatoire>Fonction pseudo-aléatoire
<a class=anchor href=#fonction-pseudo-al%c3%a9atoire>#</a></h3><p>Une fonction pseudo-aléatoire (PRF) est une fonction prédéfinie pour générer une valeur qui semble aléatoire. Elle peut prendre plusieurs entrées et générer une seule sortie.</p><h3 id=fonction-de-dérivation-de-clé>Fonction de dérivation de clé
<a class=anchor href=#fonction-de-d%c3%a9rivation-de-cl%c3%a9>#</a></h3><p>La dérivation de clé est un type de fonction pseudo-aléatoire. La dérivation de clé est une fonction utilisée pour rendre une clé plus forte. Un modèle courant est l&rsquo;étirement de clé.</p><p>Disons que vous recevez une clé de 8 octets. Vous pourriez utiliser une KDF pour la rendre plus forte.</p><h3 id=nonce>Nonce
<a class=anchor href=#nonce>#</a></h3><p>Un nonce est une entrée supplémentaire à un chiffrement. Ceci est utilisé pour que vous puissiez obtenir une sortie différente du chiffrement, même si vous chiffrez le même message plusieurs fois.</p><p>Si vous chiffrez le même message 10 fois, le chiffrement vous donnera le même texte chiffré 10 fois. En utilisant un nonce, vous pouvez obtenir une sortie différente, tout en utilisant la même clé. Il est important d&rsquo;utiliser un nonce différent pour chaque message ! Sinon, cela annule une grande partie de la valeur.</p><h3 id=code-dauthentification-de-message>Code d&rsquo;authentification de message
<a class=anchor href=#code-dauthentification-de-message>#</a></h3><p>Un code d&rsquo;authentification de message est un hachage qui est placé à la fin d&rsquo;un message. Un MAC prouve que le message provient de l&rsquo;utilisateur attendu.</p><p>Si vous n&rsquo;utilisez pas de MAC, un attaquant pourrait insérer des messages invalides. Après déchiffrement, vous n&rsquo;auriez que des ordures car ils ne connaissent pas la clé.</p><h3 id=rotation-de-clé>Rotation de clé
<a class=anchor href=#rotation-de-cl%c3%a9>#</a></h3><p>La rotation de clé est la pratique de changer votre clé à intervalles réguliers. Cela rend une clé volée moins impactante. Si une clé est volée ou divulguée, moins de données peuvent être déchiffrées.</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS (Datagram Transport Layer Security) permet à deux pairs d&rsquo;établir une communication sécurisée sans aucune configuration préexistante. Même si quelqu&rsquo;un écoute la conversation, il ne pourra pas déchiffrer les messages.</p><p>Pour qu&rsquo;un client DTLS et un serveur communiquent, ils doivent se mettre d&rsquo;accord sur un chiffrement et la clé. Ils déterminent ces valeurs en effectuant une négociation DTLS. Pendant la négociation, les messages sont en texte clair.
Lorsqu&rsquo;un client/serveur DTLS a échangé suffisamment de détails pour commencer à chiffrer, il envoie un <code>Change Cipher Spec</code>. Après ce message, chaque message suivant sera chiffré !</p><h3 id=format-de-paquet>Format de paquet
<a class=anchor href=#format-de-paquet>#</a></h3><p>Chaque paquet DTLS commence par un en-tête.</p><h4 id=type-de-contenu>Type de contenu
<a class=anchor href=#type-de-contenu>#</a></h4><p>Vous pouvez vous attendre aux types suivants :</p><ul><li><code>20</code> - Change Cipher Spec</li><li><code>22</code> - Handshake</li><li><code>23</code> - Application Data</li></ul><p><code>Handshake</code> est utilisé pour échanger les détails pour démarrer la session. <code>Change Cipher Spec</code> est utilisé pour notifier l&rsquo;autre côté que tout sera chiffré. <code>Application Data</code> sont les messages chiffrés.</p><h4 id=version>Version
<a class=anchor href=#version>#</a></h4><p>La version peut être soit <code>0x0000feff</code> (DTLS v1.0) soit <code>0x0000fefd</code> (DTLS v1.2), il n&rsquo;y a pas de v1.1.</p><h4 id=époque>Époque
<a class=anchor href=#%c3%a9poque>#</a></h4><p>L&rsquo;époque commence à <code>0</code>, mais devient <code>1</code> après un <code>Change Cipher Spec</code>. Tout message avec une époque non nulle est chiffré.</p><h4 id=numéro-de-séquence>Numéro de séquence
<a class=anchor href=#num%c3%a9ro-de-s%c3%a9quence>#</a></h4><p>Le numéro de séquence est utilisé pour garder les messages dans l&rsquo;ordre. Chaque message augmente le numéro de séquence. Lorsque l&rsquo;époque est incrémentée, le numéro de séquence recommence.</p><h4 id=longueur-et-charge-utile>Longueur et charge utile
<a class=anchor href=#longueur-et-charge-utile>#</a></h4><p>La charge utile est spécifique au <code>Type de contenu</code>. Pour un <code>Application Data</code>, la <code>Charge utile</code> est les données chiffrées. Pour <code>Handshake</code>, ce sera différent selon le message. La longueur indique la taille de la <code>Charge utile</code>.</p><h3 id=machine-à-états-de-négociation>Machine à états de négociation
<a class=anchor href=#machine-%c3%a0-%c3%a9tats-de-n%c3%a9gociation>#</a></h3><p>Pendant la négociation, le client/serveur échange une série de messages. Ces messages sont regroupés en vols. Chaque vol peut avoir plusieurs messages (ou juste un).
Un vol n&rsquo;est pas complet tant que tous les messages du vol n&rsquo;ont pas été reçus. Nous décrirons le but de chaque message plus en détail ci-dessous.</p><p><img src=../images/04-handshake.png alt=Négociation title=Négociation></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello est le message initial envoyé par le client. Il contient une liste d&rsquo;attributs. Ces attributs indiquent au serveur les chiffrements et fonctionnalités que le client prend en charge. Pour WebRTC, c&rsquo;est ainsi que nous choisissons également le chiffrement SRTP. Il contient également des données aléatoires qui seront utilisées pour générer les clés de la session.</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>HelloVerifyRequest est envoyé par le serveur au client. C&rsquo;est pour s&rsquo;assurer que le client avait l&rsquo;intention d&rsquo;envoyer la requête. Le client renvoie ensuite le ClientHello, mais avec un jeton fourni dans le HelloVerifyRequest.</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello est la réponse du serveur pour la configuration de cette session. Il contient quel chiffrement sera utilisé lorsque cette session sera terminée. Il contient également les données aléatoires du serveur.</p><h4 id=certificate>Certificate
<a class=anchor href=#certificate>#</a></h4><p>Certificate contient le certificat pour le client ou le serveur. Ceci est utilisé pour identifier de manière unique avec qui nous communiquions. Après la fin de la négociation, nous nous assurerons que ce certificat, lorsqu&rsquo;il est haché, correspond à l&rsquo;empreinte dans la <code>SessionDescription</code>.</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>Ces messages sont utilisés pour transmettre la clé publique. Au démarrage, le client et le serveur génèrent tous deux une paire de clés. Après la négociation, ces valeurs seront utilisées pour générer le <code>Pre-Master Secret</code>.</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>Un CertificateRequest est envoyé par le serveur notifiant le client qu&rsquo;il veut un certificat. Le serveur peut soit demander soit exiger un certificat.</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone notifie le client que le serveur a terminé avec la négociation.</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>CertificateVerify est la façon dont l&rsquo;expéditeur prouve qu&rsquo;il a la clé privée envoyée dans le message Certificate.</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec informe le récepteur que tout ce qui est envoyé après ce message sera chiffré.</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished est chiffré et contient un hachage de tous les messages. Ceci est pour affirmer que la négociation n&rsquo;a pas été altérée.</p><h3 id=génération-de-clé>Génération de clé
<a class=anchor href=#g%c3%a9n%c3%a9ration-de-cl%c3%a9>#</a></h3><p>Après la fin de la négociation, vous pouvez commencer à envoyer des données chiffrées. Le chiffrement a été choisi par le serveur et se trouve dans le ServerHello. Comment la clé a-t-elle été choisie cependant ?</p><p>D&rsquo;abord, nous générons le <code>Pre-Master Secret</code>. Pour obtenir cette valeur, Diffie–Hellman est utilisé sur les clés échangées par le <code>ServerKeyExchange</code> et le <code>ClientKeyExchange</code>. Les détails diffèrent selon le chiffrement choisi.</p><p>Ensuite, le <code>Master Secret</code> est généré. Chaque version de DTLS a une <code>fonction pseudo-aléatoire</code> définie. Pour DTLS 1.2, la fonction prend le <code>Pre-Master Secret</code> et les valeurs aléatoires dans le <code>ClientHello</code> et le <code>ServerHello</code>.
La sortie de l&rsquo;exécution de la <code>fonction pseudo-aléatoire</code> est le <code>Master Secret</code>. Le <code>Master Secret</code> est la valeur qui est utilisée pour le chiffrement.</p><h3 id=échange-dapplicationdata>Échange d&rsquo;ApplicationData
<a class=anchor href=#%c3%a9change-dapplicationdata>#</a></h3><p>Le cheval de bataille de DTLS est <code>ApplicationData</code>. Maintenant que nous avons un chiffrement initialisé, nous pouvons commencer à chiffrer et à envoyer des valeurs.</p><p>Les messages <code>ApplicationData</code> utilisent un en-tête DTLS comme décrit précédemment. La <code>Charge utile</code> est remplie avec du texte chiffré. Vous avez maintenant une session DTLS fonctionnelle et pouvez communiquer en toute sécurité.</p><p>DTLS a beaucoup plus de fonctionnalités intéressantes comme la renégociation. Elles ne sont pas utilisées par WebRTC, donc elles ne seront pas couvertes ici.</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP est un protocole conçu spécifiquement pour chiffrer les paquets RTP. Pour démarrer une session SRTP, vous spécifiez vos clés et votre chiffrement. Contrairement à DTLS, il n&rsquo;a pas de mécanisme de négociation. Toute la configuration et les clés ont été générées pendant la négociation DTLS.</p><p>DTLS fournit une API dédiée pour exporter les clés à utiliser par un autre processus. Ceci est défini dans la <a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>.</p><h3 id=création-de-session>Création de session
<a class=anchor href=#cr%c3%a9ation-de-session>#</a></h3><p>SRTP définit une fonction de dérivation de clé qui est utilisée sur les entrées. Lors de la création d&rsquo;une session SRTP, les entrées sont passées à travers cela pour générer nos clés pour notre chiffrement SRTP. Après cela, vous pouvez passer au traitement des médias.</p><h3 id=échange-de-médias>Échange de médias
<a class=anchor href=#%c3%a9change-de-m%c3%a9dias>#</a></h3><p>Chaque paquet RTP a un numéro de séquence de 16 bits. Ces numéros de séquence sont utilisés pour garder les paquets dans l&rsquo;ordre, comme une clé primaire. Pendant un appel, ceux-ci déborderont. SRTP garde une trace de cela et l&rsquo;appelle le compteur de débordement.</p><p>Lors du chiffrement d&rsquo;un paquet, SRTP utilise le compteur de débordement et le numéro de séquence comme nonce. Ceci est pour garantir que même si vous envoyez les mêmes données deux fois, le texte chiffré sera différent. Ceci est important pour empêcher un attaquant d&rsquo;identifier des modèles ou de tenter une attaque par rejeu.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/09eb4c1bd1c41fb4d6940cd568c2f26cc2428fdb title='Dernière modification par Claes Mogren | novembre 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>novembre 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Modifier cette page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#quelle-sécurité-offre-webrtc->Quelle sécurité offre WebRTC ?</a></li><li><a href=#comment-cela-fonctionne-t-il->Comment cela fonctionne-t-il ?</a></li><li><a href=#sécurité-101>Sécurité 101</a><ul><li><a href=#texte-en-clair-et-texte-chiffré>Texte en clair et texte chiffré</a></li><li><a href=#chiffrement>Chiffrement</a></li><li><a href=#fonctions-de-hachage>Fonctions de hachage</a></li><li><a href=#cryptographie-à-clé-publiqueprivée>Cryptographie à clé publique/privée</a></li><li><a href=#échange-diffiehellman>Échange Diffie–Hellman</a></li><li><a href=#fonction-pseudo-aléatoire>Fonction pseudo-aléatoire</a></li><li><a href=#fonction-de-dérivation-de-clé>Fonction de dérivation de clé</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#code-dauthentification-de-message>Code d&rsquo;authentification de message</a></li><li><a href=#rotation-de-clé>Rotation de clé</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#format-de-paquet>Format de paquet</a></li><li><a href=#machine-à-états-de-négociation>Machine à états de négociation</a></li><li><a href=#génération-de-clé>Génération de clé</a></li><li><a href=#échange-dapplicationdata>Échange d&rsquo;ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#création-de-session>Création de session</a></li><li><a href=#échange-de-médias>Échange de médias</a></li></ul></li></ul></nav></div></aside></main></body></html>