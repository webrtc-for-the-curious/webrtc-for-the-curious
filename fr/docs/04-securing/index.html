<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Securing # What security does WebRTC have? # Every WebRTC connection is authenticated and encrypted. You can be confident that a 3rd party can&rsquo;t see what you are sending or insert bogus messages. You can also be sure that the WebRTC Agent that generated the Session Description is the one you are communicating with.
It is very important that no one tampers with those messages. It is ok if a 3rd party reads the Session Description in transit."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/fr/docs/04-securing/"><meta property="og:site_name" content="WebRTC pour les curieux"><meta property="og:title" content="Securing"><meta property="og:description" content="Securing # What security does WebRTC have? # Every WebRTC connection is authenticated and encrypted. You can be confident that a 3rd party can’t see what you are sending or insert bogus messages. You can also be sure that the WebRTC Agent that generated the Session Description is the one you are communicating with.
It is very important that no one tampers with those messages. It is ok if a 3rd party reads the Session Description in transit."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-10T18:30:03+02:00"><title>Securing | WebRTC pour les curieux</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/fr/docs/04-securing/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/04-securing/ title=Securing><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/04-securing/ title=Securing><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/04-securing/ title=Säkerhet><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/04-securing/ title=安全性><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/04-securing/ title=セキュリティ対策><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/04-securing/ title=امنیت><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/04-securing/ title=Securing><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/04-securing/ title=Securing><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/04-securing/ title=Güvenlik><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/04-securing/ title=보안><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fr.search.min.c30a101858a70882f9a94a242d30197d4bb6c755b880f9f7aaaf47ab85f21843.js integrity="sha256-wwoQGFinCIL5qUokLTAZfUu2x1W4gPn3qq9Hq4XyGEM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/fr/><span>WebRTC pour les curieux</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Français</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/04-securing/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/04-securing/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/04-securing/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/04-securing/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/04-securing/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/04-securing/>Persian</a></li><li><a href=https://webrtcforthecurious.com/id/docs/04-securing/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/04-securing/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/04-securing/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/04-securing/>한국어</a></li></ul></li></ul><ul><li><a href=/fr/docs/01-what-why-and-how/>Quoi, Pourquoi et Comment</a></li><li><a href=/fr/docs/02-signaling/>Signaling</a></li><li><a href=/fr/docs/03-connecting/>Connecting</a></li><li><a href=/fr/docs/04-securing/ class=active>Securing</a></li><li><a href=/fr/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/fr/docs/06-media-communication/>Media Communication</a></li><li><a href=/fr/docs/07-data-communication/>Data Communication</a></li><li><a href=/fr/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/fr/docs/09-debugging/>Debugging</a></li><li><a href=/fr/docs/10-history-of-webrtc/>History</a></li><li><a href=/fr/docs/11-faq/>FAQ</a></li><li><a href=/fr/docs/12-glossary/>Glossary</a></li><li><a href=/fr/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Securing</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-security-does-webrtc-have>What security does WebRTC have?</a></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#security-101>Security 101</a><ul><li><a href=#plaintext-and-ciphertext>Plaintext and Ciphertext</a></li><li><a href=#cipher>Cipher</a></li><li><a href=#hash-functions>Hash functions</a></li><li><a href=#publicprivate-key-cryptography>Public/Private Key Cryptography</a></li><li><a href=#diffiehellman-exchange>Diffie–Hellman exchange</a></li><li><a href=#pseudorandom-function>Pseudorandom Function</a></li><li><a href=#key-derivation-function>Key Derivation Function</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#message-authentication-code>Message Authentication Code</a></li><li><a href=#key-rotation>Key Rotation</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#packet-format>Packet Format</a></li><li><a href=#handshake-state-machine>Handshake State Machine</a></li><li><a href=#key-generation>Key Generation</a></li><li><a href=#exchanging-applicationdata>Exchanging ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#session-creation>Session Creation</a></li><li><a href=#exchanging-media>Exchanging Media</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=securing>Securing
<a class=anchor href=#securing>#</a></h1><h2 id=what-security-does-webrtc-have>What security does WebRTC have?
<a class=anchor href=#what-security-does-webrtc-have>#</a></h2><p>Every WebRTC connection is authenticated and encrypted. You can be confident that a 3rd party can&rsquo;t see what you are sending or insert bogus messages. You can also be sure that the WebRTC Agent that generated the Session Description is the one you are communicating with.</p><p>It is very important that no one tampers with those messages. It is ok if a 3rd party reads the Session Description in transit. However, WebRTC has no protection against it being modified. An attacker could perform a man-in-the-middle attack on you by changing the ICE Candidates and update the Certificate Fingerprint.</p><h2 id=how-does-it-work>How does it work?
<a class=anchor href=#how-does-it-work>#</a></h2><p>WebRTC uses two pre-existing protocols, Datagram Transport Layer Security (<a href=https://tools.ietf.org/html/rfc6347>DTLS</a>) and the Secure Real-time Transport Protocol (<a href=https://tools.ietf.org/html/rfc3711>SRTP</a>).</p><p>DTLS allows you to negotiate a session and then exchange data securely between two peers. It is a sibling of TLS, the same technology that powers HTTPS, but DTLS uses UDP instead of TCP as the transport layer. That means the protocol has to handle unreliable delivery. SRTP is specifically designed for exchanging media securely. There are some optimizations we can make by using it instead of DTLS.</p><p>DTLS is used first. It does a handshake over the connection provided by ICE. DTLS is a client/server protocol, so one side needs to start the handshake. The Client/Server roles are chosen during signaling. During the DTLS handshake, both sides offer a certificate.
After the handshake is complete, this certificate is compared to the certificate hash in the Session Description. This is to ensure that the handshake happened with the WebRTC Agent you expected. The DTLS connection is then available to be used for DataChannel communication.</p><p>To create an SRTP session we initialize it using the keys generated by DTLS. SRTP does not have a handshake mechanism, so has to be bootstrapped with external keys. Once this is done, media can be exchanged that is encrypted using SRTP!</p><h2 id=security-101>Security 101
<a class=anchor href=#security-101>#</a></h2><p>To understand the technology presented in this chapter you will need to understand these terms first. Cryptography is a tricky subject, so it would be worth consulting other sources as well!</p><h3 id=plaintext-and-ciphertext>Plaintext and Ciphertext
<a class=anchor href=#plaintext-and-ciphertext>#</a></h3><p>Plaintext is the input to a cipher. Ciphertext is the output of a cipher.</p><h3 id=cipher>Cipher
<a class=anchor href=#cipher>#</a></h3><p>Cipher is a series of steps that takes plaintext to ciphertext. The cipher can then be reversed, so you can take your ciphertext back to plaintext. A cipher usually has a key to change its behavior. Another term for this is encrypting and decrypting.</p><p>A simple cipher is ROT13. Each letter is moved 13 characters forward. To undo the cipher you move 13 characters backward. The plaintext <code>HELLO</code> would become the ciphertext <code>URYYB</code>. In this case, the Cipher is ROT, and the key is 13.</p><h3 id=hash-functions>Hash functions
<a class=anchor href=#hash-functions>#</a></h3><p>A hash function is a one-way process that generates a digest. Given an input, it generates the same output every time. It is important that the output is <em>not</em> reversible. If you have an output, you should not be able to determine its input. Hashing is useful when you want to confirm that a message hasn&rsquo;t been tampered with.</p><p>A simple hash function would be to only take every other letter. <code>HELLO</code> would become <code>HLO</code>. You can&rsquo;t assume <code>HELLO</code> was the input, but you can confirm that <code>HELLO</code> would be a match to the hash digest.</p><h3 id=publicprivate-key-cryptography>Public/Private Key Cryptography
<a class=anchor href=#publicprivate-key-cryptography>#</a></h3><p>Public/Private Key Cryptography describes the type of ciphers that DTLS and SRTP uses. In this system, you have two keys, a public and private key. The public key is for encrypting messages and is safe to share.
The private key is for decrypting, and should never be shared. It is the only key that can decrypt the messages encrypted with the public key.</p><h3 id=diffiehellman-exchange>Diffie–Hellman exchange
<a class=anchor href=#diffiehellman-exchange>#</a></h3><p>Diffie–Hellman exchange allows two users who have never met before to create a shared secret securely over the internet. User <code>A</code> can send a secret to User <code>B</code> without worrying about eavesdropping. This depends on the difficulty of breaking the discrete logarithm problem.
You don&rsquo;t need to fully understand how this works, but it helps to know this is what makes the DTLS handshake possible.</p><p>Wikipedia has an example of this in action <a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation>here</a>.</p><h3 id=pseudorandom-function>Pseudorandom Function
<a class=anchor href=#pseudorandom-function>#</a></h3><p>A Pseudorandom Function (PRF) is a pre-defined function to generate a value that appears random. It may take multiple inputs and generate a single output.</p><h3 id=key-derivation-function>Key Derivation Function
<a class=anchor href=#key-derivation-function>#</a></h3><p>Key Derivation is a type of Pseudorandom Function. Key Derivation is a function that is used to make a key stronger. One common pattern is key stretching.</p><p>Let&rsquo;s say you are given a key that is 8 bytes. You could use a KDF to make it stronger.</p><h3 id=nonce>Nonce
<a class=anchor href=#nonce>#</a></h3><p>A nonce is an additional input to a cipher. This is used so that you can get different output from the cipher, even if you are encrypting the same message multiple times.</p><p>If you encrypt the same message 10 times, the cipher will give you the same ciphertext 10 times. By using a nonce you can get different output, while still using the same key. It is important you use a different nonce for each message! Otherwise, it negates much of the value.</p><h3 id=message-authentication-code>Message Authentication Code
<a class=anchor href=#message-authentication-code>#</a></h3><p>A Message Authentication Code is a hash that is placed at the end of a message. A MAC proves that the message comes from the user you expected.</p><p>If you don&rsquo;t use a MAC, an attacker could insert invalid messages. After decrypting you would just have garbage because they don&rsquo;t know the key.</p><h3 id=key-rotation>Key Rotation
<a class=anchor href=#key-rotation>#</a></h3><p>Key Rotation is the practice of changing your key on an interval. This makes a stolen key less impactful. If a key is stolen or leaked, fewer data can be decrypted.</p><h2 id=dtls>DTLS
<a class=anchor href=#dtls>#</a></h2><p>DTLS (Datagram Transport Layer Security) allows two peers to establish secure communication with no pre-existing configuration. Even if someone is eavesdropping on the conversation, they will not be able to decrypt the messages.</p><p>For a DTLS Client and a Server to communicate, they need to agree on a cipher and the key. They determine these values by doing a DTLS handshake. During the handshake, the messages are in plaintext.
When a DTLS Client/Server has exchanged enough details to start encrypting it sends a <code>Change Cipher Spec</code>. After this message, each subsequent message will be encrypted!</p><h3 id=packet-format>Packet Format
<a class=anchor href=#packet-format>#</a></h3><p>Every DTLS packet starts with a header.</p><h4 id=content-type>Content Type
<a class=anchor href=#content-type>#</a></h4><p>You can expect the following types:</p><ul><li><code>20</code> - Change Cipher Spec</li><li><code>22</code> - Handshake</li><li><code>23</code> - Application Data</li></ul><p><code>Handshake</code> is used to exchange the details to start the session. <code>Change Cipher Spec</code> is used to notify the other side that everything will be encrypted. <code>Application Data</code> are the encrypted messages.</p><h4 id=version>Version
<a class=anchor href=#version>#</a></h4><p>Version can either be <code>0x0000feff</code> (DTLS v1.0) or <code>0x0000fefd</code> (DTLS v1.2) there is no v1.1.</p><h4 id=epoch>Epoch
<a class=anchor href=#epoch>#</a></h4><p>The epoch starts at <code>0</code>, but becomes <code>1</code> after a <code>Change Cipher Spec</code>. Any message with a non-zero epoch is encrypted.</p><h4 id=sequence-number>Sequence Number
<a class=anchor href=#sequence-number>#</a></h4><p>Sequence Number is used to keep messages in order. Each message increases the Sequence Number. When the epoch is incremented, the Sequence Number starts over.</p><h4 id=length-and-payload>Length and Payload
<a class=anchor href=#length-and-payload>#</a></h4><p>The Payload is <code>Content Type</code> specific. For a <code>Application Data</code> the <code>Payload</code> is the encrypted data. For <code>Handshake</code> it will be different depending on the message. The length is for how big the <code>Payload</code> is.</p><h3 id=handshake-state-machine>Handshake State Machine
<a class=anchor href=#handshake-state-machine>#</a></h3><p>During the handshake, the Client/Server exchanges a series of messages. These messages are grouped into flights. Each flight may have multiple messages in it (or just one).
A Flight is not complete until all the messages in the flight have been received. We will describe the purpose of each message in greater detail below.</p><p><img src=../images/04-handshake.png alt=Handshake title=Handshake></p><h4 id=clienthello>ClientHello
<a class=anchor href=#clienthello>#</a></h4><p>ClientHello is the initial message sent by the client. It contains a list of attributes. These attributes tell the server the ciphers and features the client supports. For WebRTC this is how we choose the SRTP Cipher as well. It also contains random data that will be used to generate the keys for the session.</p><h4 id=helloverifyrequest>HelloVerifyRequest
<a class=anchor href=#helloverifyrequest>#</a></h4><p>HelloVerifyRequest is sent by the server to the client. It is to make sure that the client intended to send the request. The Client then re-sends the ClientHello, but with a token provided in the HelloVerifyRequest.</p><h4 id=serverhello>ServerHello
<a class=anchor href=#serverhello>#</a></h4><p>ServerHello is the response by the server for the configuration of this session. It contains what cipher will be used when this session is over. It also contains the server random data.</p><h4 id=certificate>Certificate
<a class=anchor href=#certificate>#</a></h4><p>Certificate contains the certificate for the Client or Server. This is used to uniquely identify who we were communicating with. After the handshake is over we will make sure this certificate when hashed matches the fingerprint in the <code>SessionDescription</code>.</p><h4 id=serverkeyexchangeclientkeyexchange>ServerKeyExchange/ClientKeyExchange
<a class=anchor href=#serverkeyexchangeclientkeyexchange>#</a></h4><p>These messages are used to transmit the public key. On startup, the client and server both generate a keypair. After the handshake these values will be used to generate the <code>Pre-Master Secret</code>.</p><h4 id=certificaterequest>CertificateRequest
<a class=anchor href=#certificaterequest>#</a></h4><p>A CertificateRequest is sent by the server notifying the client that it wants a certificate. The server can either Request or Require a certificate.</p><h4 id=serverhellodone>ServerHelloDone
<a class=anchor href=#serverhellodone>#</a></h4><p>ServerHelloDone notifies the client that the server is done with the handshake.</p><h4 id=certificateverify>CertificateVerify
<a class=anchor href=#certificateverify>#</a></h4><p>CertificateVerify is how the sender proves that it has the private key sent in the Certificate message.</p><h4 id=changecipherspec>ChangeCipherSpec
<a class=anchor href=#changecipherspec>#</a></h4><p>ChangeCipherSpec informs the receiver that everything sent after this message will be encrypted.</p><h4 id=finished>Finished
<a class=anchor href=#finished>#</a></h4><p>Finished is encrypted and contains a hash of all messages. This is to assert that the handshake was not tampered with.</p><h3 id=key-generation>Key Generation
<a class=anchor href=#key-generation>#</a></h3><p>After the Handshake is complete, you can start sending encrypted data. The Cipher was chosen by the server and is in the ServerHello. How was the key chosen though?</p><p>First we generate the <code>Pre-Master Secret</code>. To obtain this value Diffie–Hellman is used on the keys exchanged by the <code>ServerKeyExchange</code> and <code>ClientKeyExchange</code>. The details differ depending on the chosen Cipher.</p><p>Next the <code>Master Secret</code> is generated. Each version of DTLS has a defined <code>Pseudorandom function</code>. For DTLS 1.2 the function takes the <code>Pre-Master Secret</code> and random values in the <code>ClientHello</code> and <code>ServerHello</code>.
The output from running the <code>Pseudorandom Function</code> is the <code>Master Secret</code>. The <code>Master Secret</code> is the value that is used for the Cipher.</p><h3 id=exchanging-applicationdata>Exchanging ApplicationData
<a class=anchor href=#exchanging-applicationdata>#</a></h3><p>The workhorse of DTLS is <code>ApplicationData</code>. Now that we have an initialized cipher, we can start encrypting and sending values.</p><p><code>ApplicationData</code> messages use a DTLS header as described earlier. The <code>Payload</code> is populated with ciphertext. You now have a working DTLS Session and can communicate securely.</p><p>DTLS has many more interesting features like renegotiation. They are not used by WebRTC, so they will not be covered here.</p><h2 id=srtp>SRTP
<a class=anchor href=#srtp>#</a></h2><p>SRTP is a protocol designed specifically for encrypting RTP packets. To start an SRTP session you specify your keys and cipher. Unlike DTLS it has no handshake mechanism. All the configuration and keys were generated during the DTLS handshake.</p><p>DTLS provides a dedicated API to export the keys to be used by another process. This is defined in <a href=https://tools.ietf.org/html/rfc5705>RFC 5705</a>.</p><h3 id=session-creation>Session Creation
<a class=anchor href=#session-creation>#</a></h3><p>SRTP defines a Key Derivation Function that is used on the inputs. When creating an SRTP Session the inputs are run through this to generate our keys for our SRTP Cipher. After this you can move on to processing media.</p><h3 id=exchanging-media>Exchanging Media
<a class=anchor href=#exchanging-media>#</a></h3><p>Each RTP packet has a 16 bit SequenceNumber. These Sequence Numbers are used to keep packets in order, like a Primary Key. During a call these will rollover. SRTP keeps track of it and calls this the rollover counter.</p><p>When encrypting a packet SRTP uses the rollover counter and sequence number as a nonce. This is to ensure that even if you send the same data twice, the ciphertext will be different. This is important to prevent an attacker from identifying patterns or attempting a replay attack.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/87b27153f007cc050b3758ef1a6642eae9ed74f1 title='Dernière modification par Damien Fetis | juin 10, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>juin 10, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/04-securing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Modifier cette page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-security-does-webrtc-have>What security does WebRTC have?</a></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#security-101>Security 101</a><ul><li><a href=#plaintext-and-ciphertext>Plaintext and Ciphertext</a></li><li><a href=#cipher>Cipher</a></li><li><a href=#hash-functions>Hash functions</a></li><li><a href=#publicprivate-key-cryptography>Public/Private Key Cryptography</a></li><li><a href=#diffiehellman-exchange>Diffie–Hellman exchange</a></li><li><a href=#pseudorandom-function>Pseudorandom Function</a></li><li><a href=#key-derivation-function>Key Derivation Function</a></li><li><a href=#nonce>Nonce</a></li><li><a href=#message-authentication-code>Message Authentication Code</a></li><li><a href=#key-rotation>Key Rotation</a></li></ul></li><li><a href=#dtls>DTLS</a><ul><li><a href=#packet-format>Packet Format</a></li><li><a href=#handshake-state-machine>Handshake State Machine</a></li><li><a href=#key-generation>Key Generation</a></li><li><a href=#exchanging-applicationdata>Exchanging ApplicationData</a></li></ul></li><li><a href=#srtp>SRTP</a><ul><li><a href=#session-creation>Session Creation</a></li><li><a href=#exchanging-media>Exchanging Media</a></li></ul></li></ul></nav></div></aside></main></body></html>