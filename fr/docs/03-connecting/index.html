<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Connecting # Why does WebRTC need a dedicated subsystem for connecting? # Most applications deployed today establish client/server connections. A client/server connection requires the server to have a stable well-known transport address. A client contacts a server, and the server responds.
WebRTC doesn&rsquo;t use a client/server model, it establishes peer-to-peer (P2P) connections. In a P2P connection the task of creating a connection is equally distributed to both peers. This is because a transport address (IP and port) in WebRTC can not be assumed, and may even change during the session."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/fr/docs/03-connecting/"><meta property="og:site_name" content="WebRTC pour les curieux"><meta property="og:title" content="Connecting"><meta property="og:description" content="Connecting # Why does WebRTC need a dedicated subsystem for connecting? # Most applications deployed today establish client/server connections. A client/server connection requires the server to have a stable well-known transport address. A client contacts a server, and the server responds.
WebRTC doesn’t use a client/server model, it establishes peer-to-peer (P2P) connections. In a P2P connection the task of creating a connection is equally distributed to both peers. This is because a transport address (IP and port) in WebRTC can not be assumed, and may even change during the session."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-10T18:30:03+02:00"><title>Connecting | WebRTC pour les curieux</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/fr/docs/03-connecting/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/03-connecting/ title=Anslutning><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/03-connecting/ title=连接><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/03-connecting/ title=接続><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/03-connecting/ title=اتصال><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/03-connecting/ title=Connecting><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/03-connecting/ title=Bağlanma><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/03-connecting/ title=연결><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fr.search.min.c30a101858a70882f9a94a242d30197d4bb6c755b880f9f7aaaf47ab85f21843.js integrity="sha256-wwoQGFinCIL5qUokLTAZfUu2x1W4gPn3qq9Hq4XyGEM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/fr/><span>WebRTC pour les curieux</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Français</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/03-connecting/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/03-connecting/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/03-connecting/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/03-connecting/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/03-connecting/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/03-connecting/>Persian</a></li><li><a href=https://webrtcforthecurious.com/id/docs/03-connecting/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/03-connecting/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/03-connecting/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/03-connecting/>한국어</a></li></ul></li></ul><ul><li><a href=/fr/docs/01-what-why-and-how/>Quoi, Pourquoi et Comment</a></li><li><a href=/fr/docs/02-signaling/>Signaling</a></li><li><a href=/fr/docs/03-connecting/ class=active>Connecting</a></li><li><a href=/fr/docs/04-securing/>Securing</a></li><li><a href=/fr/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/fr/docs/06-media-communication/>Media Communication</a></li><li><a href=/fr/docs/07-data-communication/>Data Communication</a></li><li><a href=/fr/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/fr/docs/09-debugging/>Debugging</a></li><li><a href=/fr/docs/10-history-of-webrtc/>History</a></li><li><a href=/fr/docs/11-faq/>FAQ</a></li><li><a href=/fr/docs/12-glossary/>Glossary</a></li><li><a href=/fr/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Connecting</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#why-does-webrtc-need-a-dedicated-subsystem-for-connecting>Why does WebRTC need a dedicated subsystem for connecting?</a><ul><li><a href=#reduced-bandwidth-costs>Reduced Bandwidth Costs</a></li><li><a href=#lower-latency>Lower Latency</a></li><li><a href=#secure-e2e-communication>Secure E2E Communication</a></li></ul></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#networking-real-world-constraints>Networking real-world constraints</a><ul><li><a href=#not-in-the-same-network>Not in the same network</a></li><li><a href=#protocol-restrictions>Protocol Restrictions</a></li><li><a href=#firewallids-rules>Firewall/IDS Rules</a></li></ul></li><li><a href=#nat-mapping>NAT Mapping</a><ul><li><a href=#creating-a-mapping>Creating a mapping</a></li><li><a href=#mapping-creation-behaviors>Mapping Creation Behaviors</a></li><li><a href=#mapping-filtering-behaviors>Mapping Filtering Behaviors</a></li><li><a href=#mapping-refresh>Mapping Refresh</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protocol-structure>Protocol Structure</a></li><li><a href=#create-a-nat-mapping>Create a NAT Mapping</a></li><li><a href=#determining-nat-type>Determining NAT Type</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-lifecycle>TURN Lifecycle</a></li><li><a href=#turn-usage>TURN Usage</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#creating-an-ice-agent>Creating an ICE Agent</a></li><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li><li><a href=#restarts>Restarts</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=connecting>Connecting
<a class=anchor href=#connecting>#</a></h1><h2 id=why-does-webrtc-need-a-dedicated-subsystem-for-connecting>Why does WebRTC need a dedicated subsystem for connecting?
<a class=anchor href=#why-does-webrtc-need-a-dedicated-subsystem-for-connecting>#</a></h2><p>Most applications deployed today establish client/server connections. A client/server connection requires the server to have a stable well-known transport address. A client contacts a server, and the server responds.</p><p>WebRTC doesn&rsquo;t use a client/server model, it establishes peer-to-peer (P2P) connections. In a P2P connection the task of creating a connection is equally distributed to both peers. This is because a transport address (IP and port) in WebRTC can not be assumed, and may even change during the session. WebRTC will gather all the information it can and will go to great lengths to achieve bi-directional communication between two WebRTC Agents.</p><p>Establishing peer-to-peer connectivity can be difficult though. These agents could be in different networks with no direct connectivity. In situations where direct connectivity does exist you can still have other issues. In some cases, your clients don&rsquo;t speak the same network protocols (UDP &lt;-> TCP) or maybe use different IP Versions (IPv4 &lt;-> IPv6).</p><p>Despite these difficulties in setting up a P2P connection, you get advantages over traditional Client/Server technology because of the following attributes that WebRTC offers.</p><h3 id=reduced-bandwidth-costs>Reduced Bandwidth Costs
<a class=anchor href=#reduced-bandwidth-costs>#</a></h3><p>Since media communication happens directly between peers you don&rsquo;t have to pay for, or host a separate server to relay media.</p><h3 id=lower-latency>Lower Latency
<a class=anchor href=#lower-latency>#</a></h3><p>Communication is faster when it is direct! When a user has to run everything through your server, it makes transmissions slower.</p><h3 id=secure-e2e-communication>Secure E2E Communication
<a class=anchor href=#secure-e2e-communication>#</a></h3><p>Direct Communication is more secure. Since users aren&rsquo;t routing data through your server, they don&rsquo;t even need to trust you won&rsquo;t decrypt it.</p><h2 id=how-does-it-work>How does it work?
<a class=anchor href=#how-does-it-work>#</a></h2><p>The process described above is called Interactive Connectivity Establishment (<a href=https://tools.ietf.org/html/rfc8445>ICE</a>). Another protocol that pre-dates WebRTC.</p><p>ICE is a protocol that tries to find the best way to communicate between two ICE Agents. Each ICE Agent publishes the ways it is reachable, these are known as candidates. A candidate is essentially a transport address of the agent that it believes the other peer can reach. ICE then determines the best pairing of candidates.</p><p>The actual ICE process is described in greater detail later in this chapter. To understand why ICE exists, it is useful to understand what network behaviors we are overcoming.</p><h2 id=networking-real-world-constraints>Networking real-world constraints
<a class=anchor href=#networking-real-world-constraints>#</a></h2><p>ICE is all about overcoming the constraints of real-world networks. Before we explore the solution, let&rsquo;s talk about the actual problems.</p><h3 id=not-in-the-same-network>Not in the same network
<a class=anchor href=#not-in-the-same-network>#</a></h3><p>Most of the time the other WebRTC Agent will not even be in the same network. A typical call is usually between two WebRTC Agents in different networks with no direct connectivity.</p><p>Below is a graph of two distinct networks, connected over public internet. In each network you have two hosts.</p><p><img src=../images/03-two-networks.png alt="Two networks" title="Two networks"></p><p>For the hosts in the same network it is very easy to connect. Communication between <code>192.168.0.1 -> 192.168.0.2</code> is easy to do! These two hosts can connect to each other without any outside help.</p><p>However, a host using <code>Router B</code> has no way to directly access anything behind <code>Router A</code>. How would you tell the difference between <code>192.168.0.1</code> behind <code>Router A</code> and the same IP behind <code>Router B</code>? They are private IPs! A host using <code>Router B</code> could send traffic directly to <code>Router A</code>, but the request would end there. How does <code>Router A</code> know which host it should forward the message to?</p><h3 id=protocol-restrictions>Protocol Restrictions
<a class=anchor href=#protocol-restrictions>#</a></h3><p>Some networks don&rsquo;t allow UDP traffic at all, or maybe they don&rsquo;t allow TCP. Some networks may have a very low MTU (Maximum Transmission Unit). There are lots of variables that network administrators can change that can make communication difficult.</p><h3 id=firewallids-rules>Firewall/IDS Rules
<a class=anchor href=#firewallids-rules>#</a></h3><p>Another is &ldquo;Deep Packet Inspection&rdquo; and other intelligent filtering. Some network administrators will run software that tries to process every packet. Many times this software doesn&rsquo;t understand WebRTC, so it blocks it because it doesn&rsquo;t know what to do, e.g. treating WebRTC packets as suspicious UDP packets on an arbitrary port that is not whitelisted.</p><h2 id=nat-mapping>NAT Mapping
<a class=anchor href=#nat-mapping>#</a></h2><p>NAT (Network Address Translation) mapping is the magic that makes the connectivity of WebRTC possible. This is how WebRTC allows two peers in completely different subnets to communicate, addressing the &ldquo;not in the same network&rdquo; problem above. While it creates new challenges, let&rsquo;s explain how NAT mapping works in the first place.</p><p>It doesn&rsquo;t use a relay, proxy, or server. Again we have <code>Agent 1</code> and <code>Agent 2</code> and they are in different networks. However, traffic is flowing completely through. Visualized it looks like this:</p><p><img src=../images/03-nat-mapping.png alt="NAT mapping" title="NAT mapping"></p><p>To make this communication happen you establish a NAT mapping. Agent 1 uses port 7000 to establish a WebRTC connection with Agent 2. This creates a binding of <code>192.168.0.1:7000</code> to <code>5.0.0.1:7000</code>. This then allows Agent 2 to reach Agent 1 by sending packets to <code>5.0.0.1:7000</code>. Creating a NAT mapping like in this example is like an automated version of doing port forwarding in your router.</p><p>The downside to NAT mapping is that there isn&rsquo;t a single form of mapping (e.g. static port forwarding), and the behavior is inconsistent between networks. ISPs and hardware manufacturers may do it in different ways. In some cases, network administrators may even disable it.</p><p>The good news is the full range of behaviors is understood and observable, so an ICE Agent is able to confirm it created a NAT mapping, and the attributes of the mapping.</p><p>The document that describes these behaviors is <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a>.</p><h3 id=creating-a-mapping>Creating a mapping
<a class=anchor href=#creating-a-mapping>#</a></h3><p>Creating a mapping is the easiest part. When you send a packet to an address outside your network, a mapping is created! A NAT mapping is just a temporary public IP and port that is allocated by your NAT. The outbound message will be rewritten to have its source address given by the newly mapping address. If a message is sent to the mapping, it will be automatically routed back to the host inside the NAT that created it. The details around mappings is where it gets complicated.</p><h3 id=mapping-creation-behaviors>Mapping Creation Behaviors
<a class=anchor href=#mapping-creation-behaviors>#</a></h3><p>Mapping creation falls into three different categories:</p><h4 id=endpoint-independent-mapping>Endpoint-Independent Mapping
<a class=anchor href=#endpoint-independent-mapping>#</a></h4><p>One mapping is created for each sender inside the NAT. If you send two packets to two different remote addresses, the NAT mapping will be re-used. Both remote hosts would see the same source IP and port. If the remote hosts respond, it would be sent back to the same local listener.</p><p>This is the best-case scenario. For a call to work, at least one side MUST be of this type.</p><h4 id=address-dependent-mapping>Address Dependent Mapping
<a class=anchor href=#address-dependent-mapping>#</a></h4><p>A new mapping is created every time you send a packet to a new address. If you send two packets to different hosts, two mappings will be created. If you send two packets to the same remote host but different destination ports, a new mapping will NOT be created.</p><h4 id=address-and-port-dependent-mapping>Address and Port Dependent Mapping
<a class=anchor href=#address-and-port-dependent-mapping>#</a></h4><p>A new mapping is created if the remote IP or port is different. If you send two packets to the same remote host, but different destination ports, a new mapping will be created.</p><h3 id=mapping-filtering-behaviors>Mapping Filtering Behaviors
<a class=anchor href=#mapping-filtering-behaviors>#</a></h3><p>Mapping filtering is the rules around who is allowed to use the mapping. They fall into three similar classifications:</p><h4 id=endpoint-independent-filtering>Endpoint-Independent Filtering
<a class=anchor href=#endpoint-independent-filtering>#</a></h4><p>Anyone can use the mapping. You can share the mapping with multiple other peers, and they could all send traffic to it.</p><h4 id=address-dependent-filtering>Address Dependent Filtering
<a class=anchor href=#address-dependent-filtering>#</a></h4><p>Only the host the mapping was created for can use the mapping. If you send a packet to host <code>A</code> it can respond with as many packets as it wants. If host <code>B</code> attempts to send a packet to that mapping, it will be ignored.</p><h4 id=address-and-port-dependent-filtering>Address and Port Dependent Filtering
<a class=anchor href=#address-and-port-dependent-filtering>#</a></h4><p>Only the host and port for which the mapping was created for can use that mapping. If you send a packet to host <code>A:5000</code> it can respond with as many packets as it wants. If host <code>A:5001</code> attempts to send a packet to that mapping, it will be ignored.</p><h3 id=mapping-refresh>Mapping Refresh
<a class=anchor href=#mapping-refresh>#</a></h3><p>It is recommended that if a mapping is unused for 5 minutes it should be destroyed. This is entirely up to the ISP or hardware manufacturer.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN (Session Traversal Utilities for NAT) is a protocol that was created just for working with NATs. This is another technology that pre-dates WebRTC (and ICE!). It is defined by <a href=https://tools.ietf.org/html/rfc8489>RFC 8489</a>, which also defines the STUN packet structure. The STUN protocol is also used by ICE/TURN.</p><p>STUN is useful because it allows the programmatic creation of NAT Mappings. Before STUN, we were able to create a NAT mapping, but we had no idea what the IP and port of it was! STUN not only gives you the ability to create a mapping, but also gives you the details so that you can share them with others, so they can send traffic back to you via the mapping you just created.</p><p>Let&rsquo;s start with a basic description of STUN. Later, we will expand on TURN and ICE usage. For now, we are just going to describe the Request/Response flow to create a mapping. Then we will talk about how to get the details of it to share with others. This is the process that happens when you have a <code>stun:</code> server in your ICE URLs for a WebRTC PeerConnection. In a nutshell, STUN helps an endpoint behind a NAT figure out what mapping was created by asking a STUN server outside NAT to report what it observes.</p><h3 id=protocol-structure>Protocol Structure
<a class=anchor href=#protocol-structure>#</a></h3><p>Every STUN packet has the following structure:</p><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-message-type>STUN Message Type
<a class=anchor href=#stun-message-type>#</a></h4><p>Each STUN packet has a type. For now, we only care about the following:</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><p>To create a NAT mapping we make a <code>Binding Request</code>. Then the server responds with a <code>Binding Response</code>.</p><h4 id=message-length>Message Length
<a class=anchor href=#message-length>#</a></h4><p>This is how long the <code>Data</code> section is. This section contains arbitrary data that is defined by the <code>Message Type</code>.</p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>The fixed value <code>0x2112A442</code> in network byte order, it helps distinguish STUN traffic from other protocols.</p><h4 id=transaction-id>Transaction ID
<a class=anchor href=#transaction-id>#</a></h4><p>A 96-bit identifier that uniquely identifies a request/response. This helps you pair up your requests and responses.</p><h4 id=data>Data
<a class=anchor href=#data>#</a></h4><p>Data will contain a list of STUN attributes. A STUN Attribute has the following structure:</p><pre tabindex=0><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>The <code>STUN Binding Request</code> uses no attributes. This means a <code>STUN Binding Request</code> contains only the header.</p><p>The <code>STUN Binding Response</code> uses a <code>XOR-MAPPED-ADDRESS (0x0020)</code>. This attribute contains an IP and port. This is the IP and port of the NAT mapping that is created!</p><h3 id=create-a-nat-mapping>Create a NAT Mapping
<a class=anchor href=#create-a-nat-mapping>#</a></h3><p>Creating a NAT mapping using STUN just takes sending one request! You send a <code>STUN Binding Request</code> to the STUN Server. The STUN Server then responds with a <code>STUN Binding Response</code>.
This <code>STUN Binding Response</code> will contain the <code>Mapped Address</code>. The <code>Mapped Address</code> is how the STUN Server sees you and is your <code>NAT mapping</code>.
The <code>Mapped Address</code> is what you would share if you wanted someone to send packets to you.</p><p>People will also call the <code>Mapped Address</code> your <code>Public IP</code> or <code>Server Reflexive Candidate</code>.</p><h3 id=determining-nat-type>Determining NAT Type
<a class=anchor href=#determining-nat-type>#</a></h3><p>Unfortunately, the <code>Mapped Address</code> might not be useful in all cases. If it is <code>Address Dependent</code>, only the STUN server can send traffic back to you. If you shared it and another peer tried to send messages in they will be dropped. This makes it useless for communicating with others. You may find the <code>Address Dependent</code> case is in fact solvable, if the STUN server can also forward packets for you to the peer! This leads us to the solution using TURN below.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC 5780</a> defines a method for running a test to determine your NAT Type. This is useful because you would know ahead of time if direct connectivity is possible.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (Traversal Using Relays around NAT) is defined in <a href=https://tools.ietf.org/html/rfc8656>RFC 8656</a> is the solution when direct connectivity isn&rsquo;t possible. It could be because you have two NAT Types that are incompatible, or maybe can&rsquo;t speak the same protocol! TURN can also be used for privacy purposes. By running all your communication through TURN you obscure the client&rsquo;s actual address.</p><p>TURN uses a dedicated server. This server acts as a proxy for a client. The client connects to a TURN Server and creates an <code>Allocation</code>. By creating an allocation, a client gets a temporary IP/Port/Protocol that can be used to send traffic back to the client. This new listener is known as the <code>Relayed Transport Address</code>. Think of it as a forwarding address, you give this out so that others can send you traffic via TURN! For each peer you give the <code>Relay Transport Address</code> to, you must create a new <code>Permission</code> to allow communication with you.</p><p>When you send outbound traffic via TURN it is sent via the <code>Relayed Transport Address</code>. When a remote peer gets traffic they see it coming from the TURN Server.</p><h3 id=turn-lifecycle>TURN Lifecycle
<a class=anchor href=#turn-lifecycle>#</a></h3><p>The following is everything that a client who wishes to create a TURN allocation has to do. Communicating with someone who is using TURN requires no changes. The other peer gets an IP and port, and they communicate with it like any other host.</p><h4 id=allocations>Allocations
<a class=anchor href=#allocations>#</a></h4><p>Allocations are at the core of TURN. An <code>allocation</code> is basically a &ldquo;TURN Session&rdquo;. To create a TURN allocation you communicate with the TURN <code>Server Transport Address</code> (usually port <code>3478</code>).</p><p>When creating an allocation, you need to provide the following:</p><ul><li>Username/Password - Creating TURN allocations require authentication.</li><li>Allocation Transport - The transport protocol between the server (<code>Relayed Transport Address</code>) and the peers, can be UDP or TCP.</li><li>Even-Port - You can request sequential ports for multiple allocations, not relevant for WebRTC.</li></ul><p>If the request succeeded, you get a response with the TURN Server with the following STUN Attributes in the Data section:</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>Mapped Address</code> of the <code>TURN Client</code>. When someone sends data to the <code>Relayed Transport Address</code> this is where it is forwarded to.</li><li><code>RELAYED-ADDRESS</code> - This is the address that you give out to other clients. If someone sends a packet to this address, it is relayed to the TURN client.</li><li><code>LIFETIME</code> - How long until this TURN Allocation is destroyed. You can extend the lifetime by sending a <code>Refresh</code> request.</li></ul><h4 id=permissions>Permissions
<a class=anchor href=#permissions>#</a></h4><p>A remote host can&rsquo;t send into your <code>Relayed Transport Address</code> until you create a permission for them. When you create a permission, you are telling the TURN server that this IP and port is allowed to send inbound traffic.</p><p>The remote host needs to give you the IP and port as it appears to the TURN server. This means it should send a <code>STUN Binding Request</code> to the TURN Server. A common error case is that a remote host will send a <code>STUN Binding Request</code> to a different server. They will then ask you to create a permission for this IP.</p><p>Let&rsquo;s say you want to create a permission for a host behind a <code>Address Dependent Mapping</code>. If you generate the <code>Mapped Address</code> from a different TURN server, all inbound traffic will be dropped. Every time they communicate with a different host it generates a new mapping. Permissions expire after 5 minutes if they are not refreshed.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>These two messages are for the TURN Client to send messages to a remote peer.</p><p>SendIndication is a self-contained message. Inside it is the data you wish to send, and who you wish to send it to. This is wasteful if you are sending a lot of messages to a remote peer. If you send 1,000 messages you will repeat their IP Address 1,000 times!</p><p>ChannelData allows you to send data, but not repeat an IP Address. You create a Channel with an IP and port. You then send with the ChannelId, and the IP and port will be populated server side. This is the better choice if you are sending a lot of messages.</p><h4 id=refreshing>Refreshing
<a class=anchor href=#refreshing>#</a></h4><p>Allocations will destroy themselves automatically. The TURN Client must refresh them sooner than the <code>LIFETIME</code> given when creating the allocation.</p><h3 id=turn-usage>TURN Usage
<a class=anchor href=#turn-usage>#</a></h3><p>TURN Usage exists in two forms. Usually, you have one peer acting as a &ldquo;TURN Client&rdquo; and the other side communicating directly. In some cases you might have TURN usage on both sides, for example because both clients are in networks that block UDP and therefore the connection to the respective TURN servers happens via TCP.</p><p>These diagrams help illustrate what that would look like.</p><h4 id=one-turn-allocation-for-communication>One TURN Allocation for Communication
<a class=anchor href=#one-turn-allocation-for-communication>#</a></h4><p><img src=../images/03-one-turn-allocation.png alt="One TURN allocation" title="One TURN allocation"></p><h4 id=two-turn-allocations-for-communication>Two TURN Allocations for Communication
<a class=anchor href=#two-turn-allocations-for-communication>#</a></h4><p><img src=../images/03-two-turn-allocations.png alt="Two TURN allocations" title="Two TURN allocations"></p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Interactive Connectivity Establishment) is how WebRTC connects two Agents. Defined in <a href=https://tools.ietf.org/html/rfc8445>RFC 8445</a>, this is another technology that pre-dates WebRTC! ICE is a protocol for establishing connectivity. It determines all the possible routes between the two peers and then ensures you stay connected.</p><p>These routes are known as <code>Candidate Pairs</code>, which is a pairing of a local and remote transport address. This is where STUN and TURN come into play with ICE. These addresses can be your local IP Address plus a port, <code>NAT mapping</code>, or <code>Relayed Transport Address</code>. Each side gathers all the addresses they want to use, exchanges them, and then attempts to connect!</p><p>Two ICE Agents communicate using ICE ping packets (or formally called the connectivity checks) to establish connectivity. After connectivity is established, they can send whatever data they want. It will be like using a normal socket. These checks use the STUN protocol.</p><h3 id=creating-an-ice-agent>Creating an ICE Agent
<a class=anchor href=#creating-an-ice-agent>#</a></h3><p>An ICE Agent is either <code>Controlling</code> or <code>Controlled</code>. The <code>Controlling</code> Agent is the one that decides the selected <code>Candidate Pair</code>. Usually, the peer sending the offer is the controlling side.</p><p>Each side must have a <code>user fragment</code> and a <code>password</code>. These two values must be exchanged before connectivity checks can even begin. The <code>user fragment</code> is sent in plain text and is useful for demuxing multiple ICE Sessions.
The <code>password</code> is used to generate a <code>MESSAGE-INTEGRITY</code> attribute. At the end of each STUN packet, there is an attribute that is a hash of the entire packet using the <code>password</code> as a key. This is used to authenticate the packet and ensure it hasn&rsquo;t been tampered with.</p><p>For WebRTC, all these values are distributed via the <code>Session Description</code> as described in the previous chapter.</p><h3 id=candidate-gathering>Candidate Gathering
<a class=anchor href=#candidate-gathering>#</a></h3><p>We now need to gather all the possible addresses we are reachable at. These addresses are known as candidates.</p><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><p>A Host candidate is listening directly on a local interface. This can either be UDP or TCP.</p><h4 id=mdns>mDNS
<a class=anchor href=#mdns>#</a></h4><p>An mDNS candidate is similar to a host candidate, but the IP address is obscured. Instead of informing the other side about your IP address, you give them a UUID as the hostname. You then set up a multicast listener, and respond if anyone requests the UUID you published.</p><p>If you are in the same network as the agent, you can find each other via Multicast. If you are not in the same network, you will be unable to connect (unless the network administrator explicitly configured the network to allow Multicast packets to traverse).</p><p>This is useful for privacy purposes. A user could find out your local IP address via WebRTC with a Host candidate (without even trying to connect to you), but with an mDNS candidate, now they only get a random UUID.</p><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><p>A Server Reflexive candidate is generated by doing a <code>STUN Binding Request</code> to a STUN Server.</p><p>When you get the <code>STUN Binding Response</code>, the <code>XOR-MAPPED-ADDRESS</code> is your Server Reflexive Candidate.</p><h4 id=peer-reflexive>Peer Reflexive
<a class=anchor href=#peer-reflexive>#</a></h4><p>A Peer Reflexive candidate is when you get an inbound request from an address that isn&rsquo;t known to you. Since ICE is an authenticated protocol, you know the traffic is valid. This just means the remote peer is communicating with you from an address it didn&rsquo;t know about.</p><p>This commonly happens when a <code>Host Candidate</code> communicates with a <code>Server Reflexive Candidate</code>. A new <code>NAT mapping</code> was created because you are communicating outside your subnet. Remember we said the connectivity checks are in fact STUN packets? The format of STUN response naturally allows a peer to report back the peer-reflexive address.</p><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><p>A Relay Candidate is generated by using a TURN Server.</p><p>After the initial handshake with the TURN Server you are given a <code>RELAYED-ADDRESS</code>, this is your Relay Candidate.</p><h3 id=connectivity-checks>Connectivity Checks
<a class=anchor href=#connectivity-checks>#</a></h3><p>We now know the remote agent&rsquo;s <code>user fragment</code>, <code>password</code>, and candidates. We can now attempt to connect! Every candidate is paired with each other. So if you have 3 candidates on each side, you now have 9 candidate pairs.</p><p>Visually it looks like this:</p><p><img src=../images/03-connectivity-checks.png alt="Connectivity checks" title="Connectivity checks"></p><h3 id=candidate-selection>Candidate Selection
<a class=anchor href=#candidate-selection>#</a></h3><p>The Controlling and Controlled Agent both start sending traffic on each pair. This is needed if one Agent is behind an <code>Address Dependent Mapping</code>, this will cause a <code>Peer Reflexive Candidate</code> to be created.</p><p>Each <code>Candidate Pair</code> that saw network traffic is then promoted to a <code>Valid Candidate</code> pair. The Controlling Agent then takes one <code>Valid Candidate</code> pair and nominates it. This becomes the <code>Nominated Pair</code>. The Controlling and Controlled Agent then attempt one more round of bi-directional communication. If that succeeds, the <code>Nominated Pair</code> becomes the <code>Selected Candidate Pair</code>! This pair is then used for the rest of the session.</p><h3 id=restarts>Restarts
<a class=anchor href=#restarts>#</a></h3><p>If the <code>Selected Candidate Pair</code> stops working for any reason (NAT mapping expires, TURN Server crashes) the ICE Agent will go to <code>Failed</code> state. Both agents can be restarted and will do the whole process all over again.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/87b27153f007cc050b3758ef1a6642eae9ed74f1 title='Dernière modification par Damien Fetis | juin 10, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>juin 10, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Modifier cette page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#why-does-webrtc-need-a-dedicated-subsystem-for-connecting>Why does WebRTC need a dedicated subsystem for connecting?</a><ul><li><a href=#reduced-bandwidth-costs>Reduced Bandwidth Costs</a></li><li><a href=#lower-latency>Lower Latency</a></li><li><a href=#secure-e2e-communication>Secure E2E Communication</a></li></ul></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#networking-real-world-constraints>Networking real-world constraints</a><ul><li><a href=#not-in-the-same-network>Not in the same network</a></li><li><a href=#protocol-restrictions>Protocol Restrictions</a></li><li><a href=#firewallids-rules>Firewall/IDS Rules</a></li></ul></li><li><a href=#nat-mapping>NAT Mapping</a><ul><li><a href=#creating-a-mapping>Creating a mapping</a></li><li><a href=#mapping-creation-behaviors>Mapping Creation Behaviors</a></li><li><a href=#mapping-filtering-behaviors>Mapping Filtering Behaviors</a></li><li><a href=#mapping-refresh>Mapping Refresh</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protocol-structure>Protocol Structure</a></li><li><a href=#create-a-nat-mapping>Create a NAT Mapping</a></li><li><a href=#determining-nat-type>Determining NAT Type</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-lifecycle>TURN Lifecycle</a></li><li><a href=#turn-usage>TURN Usage</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#creating-an-ice-agent>Creating an ICE Agent</a></li><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li><li><a href=#restarts>Restarts</a></li></ul></li></ul></nav></div></aside></main></body></html>