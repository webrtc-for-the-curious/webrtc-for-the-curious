<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Quoi, Pourquoi et Comment # Qu’est-ce que le WebRTC ? # WebRTC, raccourci pour Web Real-Time Communication, est une API et un protocole. Le protocole WebRTC est un ensemble de règles pour que deux agents WebRTC négocient une communication temps réel, bidirectionnelle et sécurisée. L’API WebRTC permet au développeur d’utiliser le protocole WebRTC. L’API WebRTC est seulement spécifiée pour le JavaScript.
Une relation similaire serait celle entre HTTP et l’API Fetch."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/"><meta property="og:site_name" content="WebRTC pour les curieux"><meta property="og:title" content="Quoi, Pourquoi et Comment"><meta property="og:description" content="Quoi, Pourquoi et Comment # Qu’est-ce que le WebRTC ? # WebRTC, raccourci pour Web Real-Time Communication, est une API et un protocole. Le protocole WebRTC est un ensemble de règles pour que deux agents WebRTC négocient une communication temps réel, bidirectionnelle et sécurisée. L’API WebRTC permet au développeur d’utiliser le protocole WebRTC. L’API WebRTC est seulement spécifiée pour le JavaScript.
Une relation similaire serait celle entre HTTP et l’API Fetch."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-10T18:30:03+02:00"><title>Quoi, Pourquoi et Comment | WebRTC pour les curieux</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/fr/docs/01-what-why-and-how/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/01-what-why-and-how/ title="What, Why and How"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/ title="Vad, varför och hur"><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/ title="Что, Зачем и Как"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/ title=是什么，为什么，如何使用><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/ title=何を、なぜ、どのように><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/ title="چه چیزی، چرا و چگونه"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/ title="Apa, Mengapa, dan Bagaimana"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/ title="¿Qué, Por qué y Cómo?"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ title="Ne, Neden ve Nasıl"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/ title="무엇, 왜, 어떻게?"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fr.search.min.c30a101858a70882f9a94a242d30197d4bb6c755b880f9f7aaaf47ab85f21843.js integrity="sha256-wwoQGFinCIL5qUokLTAZfUu2x1W4gPn3qq9Hq4XyGEM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/fr/><span>WebRTC pour les curieux</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Français</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/01-what-why-and-how/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/01-what-why-and-how/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/01-what-why-and-how/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/01-what-why-and-how/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/01-what-why-and-how/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/01-what-why-and-how/>Persian</a></li><li><a href=https://webrtcforthecurious.com/id/docs/01-what-why-and-how/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/01-what-why-and-how/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/01-what-why-and-how/>한국어</a></li></ul></li></ul><ul><li><a href=/fr/docs/01-what-why-and-how/ class=active>Quoi, Pourquoi et Comment</a></li><li><a href=/fr/docs/02-signaling/>Signaling</a></li><li><a href=/fr/docs/03-connecting/>Connecting</a></li><li><a href=/fr/docs/04-securing/>Securing</a></li><li><a href=/fr/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/fr/docs/06-media-communication/>Media Communication</a></li><li><a href=/fr/docs/07-data-communication/>Data Communication</a></li><li><a href=/fr/docs/08-applied-webrtc/>Applied WebRTC</a></li><li><a href=/fr/docs/09-debugging/>Debugging</a></li><li><a href=/fr/docs/10-history-of-webrtc/>History</a></li><li><a href=/fr/docs/11-faq/>FAQ</a></li><li><a href=/fr/docs/12-glossary/>Glossary</a></li><li><a href=/fr/docs/13-reference/>Reference</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Quoi, Pourquoi et Comment</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#quest-ce-que-le-webrtc->Qu’est-ce que le WebRTC ?</a></li><li><a href=#pourquoi-devrais-je-apprendre-le-webrtc->Pourquoi devrais-je apprendre le WebRTC ?</a></li><li><a href=#le-protocole-webrtc-est-une-collection-dautres-technologies>Le Protocole WebRTC est une collection d’autres technologies</a><ul><li><a href=#la-signalisation--comment-les-agents-se-trouvent-dans-le-webrtc>La signalisation : Comment les agents se trouvent dans le WebRTC</a></li><li><a href=#connexion-est-traversée-des-nats-avec-stunturn>Connexion est traversée des NATs avec STUN/TURN</a></li><li><a href=#sécuriser-la-couche-de-transport-avec-dtls-et-srtp>Sécuriser la couche de transport avec DTLS et SRTP</a></li><li><a href=#communiquer-entre-agents-via-le-rtp-et-le-sctp>Communiquer entre agents via le RTP et le SCTP</a></li></ul></li><li><a href=#le-webrtc-une-collection-de-protocole>Le WebRTC, une collection de protocole</a></li><li><a href=#comment-marche-le-webrtc-lapi>Comment marche le WebRTC (l’API)</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=quoi-pourquoi-et-comment>Quoi, Pourquoi et Comment
<a class=anchor href=#quoi-pourquoi-et-comment>#</a></h1><h2 id=quest-ce-que-le-webrtc->Qu’est-ce que le WebRTC ?
<a class=anchor href=#quest-ce-que-le-webrtc->#</a></h2><p>WebRTC, raccourci pour Web Real-Time Communication, est une API et un protocole. Le protocole WebRTC est un ensemble de règles pour que deux agents WebRTC négocient une communication temps réel, bidirectionnelle et sécurisée. L’API WebRTC permet au développeur d’utiliser le protocole WebRTC. L’API WebRTC est seulement spécifiée pour le JavaScript.</p><p>Une relation similaire serait celle entre HTTP et l’API Fetch. Le protocole WebRTC serait HTTP, et l’API WebRTC serait l’API Fetch.</p><p>Le protocole WebRTC est disponible dans d’autres API et langages en plus du JavaScript. Vous pouvez aussi trouver des serveurs et des outils spécifiques au domaine du WebRTC. Toutes les implémentations utilisent le protocole WebRTC et peuvent donc interagir entre elles.</p><p>Le protocole WebRTC est maintenue au sein de l’IETF par le groupe de travail <a href=https://datatracker.ietf.org/wg/rtcweb/documents/>rtcweb</a>. L’API WebRTC est documentée par le W3C en tant que <a href=https://www.w3.org/TR/webrtc/>webrtc</a>.</p><h2 id=pourquoi-devrais-je-apprendre-le-webrtc->Pourquoi devrais-je apprendre le WebRTC ?
<a class=anchor href=#pourquoi-devrais-je-apprendre-le-webrtc->#</a></h2><p>Il y a des choses que le WebRTC peut vous apporter. Cette liste n’est pas exhaustive, c’est juste un exemple de choses que vous pourriez apprécier dans votre voyage. Ne vous inquiétez pas si vous ne connaissez pas encore tous ces termes, ce livre va vous les apprendre en cours de lecture.</p><ul><li>Standards ouverts</li><li>Implémentations multiples</li><li>Disponible dans le navigateur</li><li>Chiffrement obligatoire</li><li>Traversé des NAT</li><li>Repositionnement de technologies existantes</li><li>Contrôle de congestion</li><li>Latence inférieure à la seconde</li></ul><h2 id=le-protocole-webrtc-est-une-collection-dautres-technologies>Le Protocole WebRTC est une collection d’autres technologies
<a class=anchor href=#le-protocole-webrtc-est-une-collection-dautres-technologies>#</a></h2><p>C’est un sujet qui demanderait un livre entier pour l’expliquer. Cependant, pour démarrer, nous l’avons divisé en quatre étapes.</p><ul><li>La signalisation</li><li>La connexion</li><li>La sécurité</li><li>La communication</li></ul><p>Ces quatre étapes se déroulent séquentiellement. L’étape précédente doit être finalisée avec succès à 100 % avant d’entamer la suivante.</p><p>Un des aspects particulier du WebRTC est que chacune des étapes est réellement constituée des nombreux autres protocoles ! Pour faire le WebRTC, nous devons assembler un grand nombre de technologies déjà existantes. En ce sens, le WebRTC est plus une combinaison et une configuration de technologies bien connues qui nous entourent depuis le début des années 2000.</p><p>Chacune de ces étapes possède un chapitre dédié, mais cela aide de les comprendre à un haut niveau pour commencer. Et comme elles dépendent les unes des autres, cela va aider à expliquer un peu plus le but de chacune de ces étapes.</p><h3 id=la-signalisation--comment-les-agents-se-trouvent-dans-le-webrtc>La signalisation : Comment les agents se trouvent dans le WebRTC
<a class=anchor href=#la-signalisation--comment-les-agents-se-trouvent-dans-le-webrtc>#</a></h3><p>Quand un agent WebRTC démarre, il n’a aucune idée avec qui il va communiquer et en quoi va consister cette communication. La signalisation résout ce problème ! La signalisation est utilisée pour amorcer l’appel pour que deux agents WebRTC puissent commencer à communiquer.</p><p>La signalisation utilise un protocole déjà existant appelé SDP (Session Description Protocol). Le SDP est un protocole en texte brut. Chaque message SDP est constitué de paire Clé/Valeur et contient une liste de “section média”. Les SDP que deux agents WebRTC échangent contiennent des détails tels que :</p><ul><li>IPs et Ports sur lesquels l’agent est joignable (les candidats);</li><li>Combien de flux audio et vidéo l’agent désire recevoir;</li><li>Quel codec audio et vidéo les agents supportent;</li><li>Des valeurs utiles à la connexion (<code>uFrag</code>/<code>uPwd</code>);</li><li>Des valeurs utiles à la sécurisation (la signature des certificats).</li></ul><p>Il est à noter que normalement la signalisation se réalise “out-of-band”, c&rsquo;est-à-dire que les applications n’utilisent pas le WebRTC lui-même pour échanger les messages de signalisation. Toute architecture appropriée pour l’échange de message peut être utilisée pour relayer les SDP entre les agents. Bon nombre d’applications vont utiliser leur infrastructure déjà en place (comme des endpoints REST, connexion WebSocket ou autre proxy d’authentification) pour faciliter l’échange des SDP entre leurs propres clients.</p><h3 id=connexion-est-traversée-des-nats-avec-stunturn>Connexion est traversée des NATs avec STUN/TURN
<a class=anchor href=#connexion-est-travers%c3%a9e-des-nats-avec-stunturn>#</a></h3><p>Les deux agents WebRTC connaissent maintenant suffisamment de détails pour tenter de se connecter l’un l’autre. Le WebRTC va alors utiliser une autre technologie bien rodée appelée ICE.
L’ICE (Interactive Connectivity Establishement) est un protocole antérieur au WebRTC. L’ICE permet l’établissement d’une connexion entre deux agents. Ces agents peuvent être sur le même réseau, ou à l’autre bout du monde. L’ICE est la solution pour établir une connexion directe sans serveur central.</p><p>La véritable magie repose ici porte sur la traversée des NATs avec les serveurs STUN/TURN. Ces deux concepts sont tout ce dont vous avez besoin pour communiquer avec un agent ICE sur un autre sous réseau. Nous allons explorer ce sujet en profondeur plus loin.</p><p>Une fois la connexion ICE établie, le WebRTC va alors passer à l’établissement d’un canal de transport chiffré des données. Ce canal de transport est utilisé pour l’audio, la vidéo et les données.</p><h3 id=sécuriser-la-couche-de-transport-avec-dtls-et-srtp>Sécuriser la couche de transport avec DTLS et SRTP
<a class=anchor href=#s%c3%a9curiser-la-couche-de-transport-avec-dtls-et-srtp>#</a></h3><p>Maintenant que nous avons une communication bidirectionnelle (avec ICE), nous devons établir une connexion sécurisée. Ceci est fait au travers de deux protocoles antérieurs au WebRTC. Le premier protocole est le DTLS (Datagram Transport Layer Security) qui est juste du TLS sur UDP. Le TLS est le protocole cryptographique utilisé pour sécuriser les communications du HTTPS. Le second protocole est le SRTP (Secure Real-Time Transport Protocol).</p><p>Tout d&rsquo;abord, le WebRTC se connecte par un HandCheck DTLS sur la connexion établie par ICE. À la différence du HTTPS, le WebRTC n’utilise pas une autorité centrale de gestion des certificats. À la place, le WebRTC s’assure juste que l’échange de certificat via DTLS correspond bien au Fingerprint partagé par l’étape de signalisation. Cette connexion DTLS est ensuite utilisée pour les messages du DataChannel.</p><p>Le WebRTC utilise ensuite un protocole différent pour la transmission audio/vidéo appelé RTP (RealTime Transport Protocol). Nous sécurisons nos paquets RTP en utilisant SRTP. La session SRTP est initialisée par l’extraction des clés de la négociation de la session DTLS. Dans un chapitre ultérieur, nous discuterons pourquoi la transmission média à son propre protocole.</p><p>Maintenant, nous avons réussi ! Vous avez une communication bidirectionnelle et sécurisée entre deux agents. Si vous avez une connexion stable entre vos deux agents WebRTC, c’est toute la complexité dont vous avez besoin.
Malheureusement, le monde réel a des pertes de paquet et des limites de bande passante, nous allons voir comment traiter cela dans la prochaine section.</p><h3 id=communiquer-entre-agents-via-le-rtp-et-le-sctp>Communiquer entre agents via le RTP et le SCTP
<a class=anchor href=#communiquer-entre-agents-via-le-rtp-et-le-sctp>#</a></h3><p>Nous avons maintenant deux agents WebRTC avec un canal de communication bidirectionnel et sécurisé. Commençons à communiquer ! Encore une fois, nous utilisons deux protocoles préexistants : RTP (RealTime Transport Protocol) et SCTP (Stream Control Transmission Protocol). Le SRTP, pour RTP encrypté, est utilisé pour l’échange de média et le SCTP pour recevoir et envoyer des messages de donnée cryptée via le DTLS.</p><p>Le RTP est assez minimaliste, mais fournit ce qu’il faut pour du streaming temps réel. La chose importante est que le RTP donne de la flexibilité aux développeurs, ils peuvent donc traiter la latence, la perte de paquets et la congestion comme ils le veulent. Nous discuterons de cela dans le chapitre sur les médias.</p><p>Le dernier protocole dans la stack est le SCTP. Le SCTP autorise un grand nombre d’options dans la transmission des messages. Vous pouvez choisir d’avoir une transmission non fiable, désordonnée, ce qui permet d’attendre la latence nécessaire aux systèmes temps-réel.</p><h2 id=le-webrtc-une-collection-de-protocole>Le WebRTC, une collection de protocole
<a class=anchor href=#le-webrtc-une-collection-de-protocole>#</a></h2><p>Le WebRTC résout un grand nombre de problèmes. Premièrement, cela peut sembler trop complexe. Le génie du WebRTC est en réalité son humilité. Il ne prétendait pas qu’il pouvait tout résoudre mieux que les autres. À la place, il reprend un grand nombre de technologies existantes ciblant un domaine précis et les rassemble dans un protocole unique.</p><p>Cela nous permet d’examiner et d’apprendre chaque partie de façon individuelle sans être submergé. Une bonne manière de visualiser un “Agent WebRTC” est de le voir comme un orchestrateur d’un ensemble de différents protocoles.</p><p><img src=../images/01-webrtc-agent.png alt="WebRTC Agent" title="WebRTC Agent Diagram"></p><h2 id=comment-marche-le-webrtc-lapi>Comment marche le WebRTC (l’API)
<a class=anchor href=#comment-marche-le-webrtc-lapi>#</a></h2><p>Cette section montre comment l’API Javascript WebRTC se calque sur le protocole. Il ne s’agit pas de montrer une démo détaillée de l’API WebRTC, mais plus de créer une représentation mentale de la manière dont tout cela est lié. Si vous n’êtes pas familier avec cela, tout va bien. Cela pourra être une section intéressante à regarder une fois que vous en aurez appris un peu plus.</p><h3 id=new-rtcpeerconnection><code>new RTCPeerConnection</code>
<a class=anchor href=#new-rtcpeerconnection>#</a></h3><p>La <code>RTCPeerConnection</code> est le niveau le plus haut d’une session WebRTC. Elle contient tous les protocoles mentionnés jusqu’ici. Les sous-systèmes sont tous initialisés, mais rien n’a encore commencé.</p><h3 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h3><p><code>addTrack</code> crée un nouveau flux RTP. Une source de synchronisation aléatoire (ssrc) sera générée pour ce flux. Ce flux sera ensuite ajouté dans dans la section média du SDP généré par <code>createOffer</code>. Chaque appel à <code>addTrack</code> va créer une nouvelle SSRC et une section média.</p><p>Immédiatement après l’établissement d’une session SRTP, les paquets média vont commencer à être envoyés via ICE en étant chiffrés par le SRTP.</p><h3 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h3><p><code>createDataChannel</code> crée un nouveau flux SCTP si aucune association SCTP n’existe. Par défaut, SCTP n’est pas activé, mais juste démarré quand un agent demande un canal de données.</p><p>Immédiatement après l’établissement de la session DTLS, l’association SCTP va commencer à envoyer des paquets via ICE en étant chiffré par DTLS.</p><h3 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h3><p><code>createOffer</code> génère la description de session de l’état de l’agent local afin de la partager avec l’autre agent.
Le fait d’appeler <code>createOffer</code> ne change rien sur l’agent local.</p><h3 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h3><p><code>setLocalDescription</code> applique n’importe quelle demande de changement. <code>addTrack</code>, <code>CreateDataChannel</code> et les appels similaires sont tous temporaires avant cet appel. <code>setLocalDescription</code> est appelé avec la valeur générée par <code>createOffer</code>.</p><p>Habituellement, après cet appel, vous allez envoyer cette description de session à l’agent distant, et il va appeler <code>setRemoteDescription</code> avec celle-ci.</p><h3 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h3><p><code>setRemoteDescription</code> sert à informer l’agent local sur l’état des candidats distants. C’est de cette façon que la “Signalisation” est réalisée du côté de l&rsquo;API Javascript.</p><p>Quand <code>setRemoteDescription</code> est appelé des deux cotés, les agents WebRTC ont suffisamment d’information pour commencer leur communication paire à paire (P2P) !</p><h3 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h3><p><code>addIceCandidate</code> permet à un agent WebRTC d’ajouter plus de candidats ICE distants quand il le veut. Cette API envoie le candidat ICE directement dans le sous-système ICE et n’a aucun autre effet dans la grande connexion WebRTC.</p><h3 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h3><p><code>ontrack</code> est un callback appelé lorsqu’un paquet RTP est reçu de l’agent distant. Les paquets entrants doivent avoir été déclarés dans la description de session (SDP) qui a été passée à <code>setRemoteDescription</code>.</p><p>Le WebRTC utilise le SSRC et regarde les <code>MediaStream</code> et <code>MediaStreamTrack</code> associé, il lance le callback quand tous les détails du flux sont récupérés.</p><h3 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h3><p><code>oniceconnectionstatechange</code> est un callback qui est appelé quand l’état de l’agent ICE est modifié. Quand vous avez une nouvelle connexion réseau ou bien lorsque vous êtes déconnecté, c’est comme cela que vous êtes notifié.</p><h3 id=onconnectionstatechange><code>onconnectionstatechange</code>
<a class=anchor href=#onconnectionstatechange>#</a></h3><p><code>onconnectionstatechange</code> est une combinaison de l’état de l’agent ICE et de l’agent DTLS. Vous pouvez regarder ce callback pour être notifié lorsque ICE et DTLS ont tous les deux été connectés avec succès.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/87b27153f007cc050b3758ef1a6642eae9ed74f1 title='Dernière modification par Damien Fetis | juin 10, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>juin 10, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Modifier cette page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#quest-ce-que-le-webrtc->Qu’est-ce que le WebRTC ?</a></li><li><a href=#pourquoi-devrais-je-apprendre-le-webrtc->Pourquoi devrais-je apprendre le WebRTC ?</a></li><li><a href=#le-protocole-webrtc-est-une-collection-dautres-technologies>Le Protocole WebRTC est une collection d’autres technologies</a><ul><li><a href=#la-signalisation--comment-les-agents-se-trouvent-dans-le-webrtc>La signalisation : Comment les agents se trouvent dans le WebRTC</a></li><li><a href=#connexion-est-traversée-des-nats-avec-stunturn>Connexion est traversée des NATs avec STUN/TURN</a></li><li><a href=#sécuriser-la-couche-de-transport-avec-dtls-et-srtp>Sécuriser la couche de transport avec DTLS et SRTP</a></li><li><a href=#communiquer-entre-agents-via-le-rtp-et-le-sctp>Communiquer entre agents via le RTP et le SCTP</a></li></ul></li><li><a href=#le-webrtc-une-collection-de-protocole>Le WebRTC, une collection de protocole</a></li><li><a href=#comment-marche-le-webrtc-lapi>Comment marche le WebRTC (l’API)</a><ul><li><a href=#new-rtcpeerconnection><code>new RTCPeerConnection</code></a></li><li><a href=#addtrack><code>addTrack</code></a></li><li><a href=#createdatachannel><code>createDataChannel</code></a></li><li><a href=#createoffer><code>createOffer</code></a></li><li><a href=#setlocaldescription><code>setLocalDescription</code></a></li><li><a href=#setremotedescription><code>setRemoteDescription</code></a></li><li><a href=#addicecandidate><code>addIceCandidate</code></a></li><li><a href=#ontrack><code>ontrack</code></a></li><li><a href=#oniceconnectionstatechange><code>oniceconnectionstatechange</code></a></li><li><a href=#onconnectionstatechange><code>onconnectionstatechange</code></a></li></ul></li></ul></nav></div></aside></main></body></html>