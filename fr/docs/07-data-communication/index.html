<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Communication de données # Que m&rsquo;apporte la communication de données de WebRTC ? # WebRTC fournit des canaux de données pour la communication de données. Entre deux pairs, vous pouvez ouvrir 65 534 canaux de données. Un canal de données est basé sur des datagrammes, et chacun a ses propres paramètres de durabilité. Par défaut, chaque canal de données garantit une livraison ordonnée.
Si vous abordez WebRTC à partir d&rsquo;un contexte média, les canaux de données peuvent sembler gaspilleurs."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://webrtcforthecurious.com/fr/docs/07-data-communication/"><meta property="og:site_name" content="WebRTC pour les curieux"><meta property="og:title" content="Communication de données"><meta property="og:description" content="Communication de données # Que m’apporte la communication de données de WebRTC ? # WebRTC fournit des canaux de données pour la communication de données. Entre deux pairs, vous pouvez ouvrir 65 534 canaux de données. Un canal de données est basé sur des datagrammes, et chacun a ses propres paramètres de durabilité. Par défaut, chaque canal de données garantit une livraison ordonnée.
Si vous abordez WebRTC à partir d’un contexte média, les canaux de données peuvent sembler gaspilleurs."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-11-04T08:46:52-05:00"><title>Communication de données | WebRTC pour les curieux</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://webrtcforthecurious.com/fr/docs/07-data-communication/><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=sv href=https://webrtcforthecurious.com/sv/docs/07-data-communication/ title=Datakommunikation><link rel=alternate hreflang=ru href=https://webrtcforthecurious.com/ru/docs/07-data-communication/ title="Коммуникация данных"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/07-data-communication/ title=数据通信><link rel=alternate hreflang=ja href=https://webrtcforthecurious.com/ja/docs/07-data-communication/ title=データ・コミュニケーション><link rel=alternate hreflang=fa href=https://webrtcforthecurious.com/fa/docs/07-data-communication/ title="ارتباط داده ای"><link rel=alternate hreflang=id href=https://webrtcforthecurious.com/id/docs/07-data-communication/ title="Data Communication"><link rel=alternate hreflang=es href=https://webrtcforthecurious.com/es/docs/07-data-communication/ title="Comunicación de Datos"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/07-data-communication/ title="Veri İletişimi"><link rel=alternate hreflang=ko href=https://webrtcforthecurious.com/ko/docs/07-data-communication/ title="데이터 통신"><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fr.search.min.c070e4b38914a2ce1aaa387751c1c4892529691a7708de55c3b3b27b63942d68.js integrity="sha256-wHDks4kUos4aqjh3UcHEiSUpaRp3CN5Vw7Oye2OULWg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/fr/><span>WebRTC pour les curieux</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Français</a></label><ul><li><a href=https://webrtcforthecurious.com/docs/07-data-communication/>English</a></li><li><a href=https://webrtcforthecurious.com/ru/docs/07-data-communication/>Русский</a></li><li><a href=https://webrtcforthecurious.com/sv/docs/07-data-communication/>Svenska</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/07-data-communication/>简体中文</a></li><li><a href=https://webrtcforthecurious.com/ja/docs/07-data-communication/>日本語</a></li><li><a href=https://webrtcforthecurious.com/fa/docs/07-data-communication/>Persian</a></li><li><a href=https://webrtcforthecurious.com/id/docs/07-data-communication/>Bahasa Indonesia</a></li><li><a href=https://webrtcforthecurious.com/es/docs/07-data-communication/>Español</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/07-data-communication/>Türkçe</a></li><li><a href=https://webrtcforthecurious.com/ko/docs/07-data-communication/>한국어</a></li></ul></li></ul><ul><li><a href=/fr/docs/01-what-why-and-how/>Quoi, Pourquoi et Comment</a></li><li><a href=/fr/docs/02-signaling/>Signalisation</a></li><li><a href=/fr/docs/03-connecting/>Connexion</a></li><li><a href=/fr/docs/04-securing/>Sécurisation</a></li><li><a href=/fr/docs/05-real-time-networking/>Réseau en temps réel</a></li><li><a href=/fr/docs/06-media-communication/>Communication média</a></li><li><a href=/fr/docs/07-data-communication/ class=active>Communication de données</a></li><li><a href=/fr/docs/08-applied-webrtc/>WebRTC appliqué</a></li><li><a href=/fr/docs/09-debugging/>Débogage</a></li><li><a href=/fr/docs/10-history-of-webrtc/>Histoire</a></li><li><a href=/fr/docs/11-faq/>FAQ</a></li><li><a href=/fr/docs/12-glossary/>Glossaire</a></li><li><a href=/fr/docs/13-reference/>Référence</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Communication de données</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#que-mapporte-la-communication-de-données-de-webrtc->Que m&rsquo;apporte la communication de données de WebRTC ?</a></li><li><a href=#comment-cela-fonctionne-t-il->Comment cela fonctionne-t-il ?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#stream-control-transmission-protocol>Stream Control Transmission Protocol</a></li><li><a href=#concepts>Concepts</a><ul><li><a href=#association>Association</a></li><li><a href=#flux>Flux</a></li><li><a href=#basé-sur-les-datagrammes>Basé sur les datagrammes</a></li><li><a href=#morceaux>Morceaux</a></li><li><a href=#numéro-de-séquence-de-transmission>Numéro de séquence de transmission</a></li><li><a href=#identifiant-de-flux>Identifiant de flux</a></li><li><a href=#identifiant-de-protocole-de-charge-utile>Identifiant de protocole de charge utile</a></li></ul></li><li><a href=#protocole-1>Protocole</a><ul><li><a href=#morceau-data>Morceau DATA</a></li><li><a href=#morceau-init>Morceau INIT</a></li><li><a href=#morceau-sack>Morceau SACK</a></li><li><a href=#morceau-heartbeat>Morceau HEARTBEAT</a></li><li><a href=#morceau-abort>Morceau ABORT</a></li><li><a href=#morceau-shutdown>Morceau SHUTDOWN</a></li><li><a href=#morceau-error>Morceau ERROR</a></li><li><a href=#morceau-forward-tsn>Morceau FORWARD TSN</a></li></ul></li><li><a href=#machine-à-états>Machine à états</a><ul><li><a href=#flux-détablissement-de-connexion>Flux d&rsquo;établissement de connexion</a></li><li><a href=#flux-de-démontage-de-connexion>Flux de démontage de connexion</a></li><li><a href=#mécanisme-de-maintien-en-vie>Mécanisme de maintien en vie</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=communication-de-données>Communication de données
<a class=anchor href=#communication-de-donn%c3%a9es>#</a></h1><h2 id=que-mapporte-la-communication-de-données-de-webrtc->Que m&rsquo;apporte la communication de données de WebRTC ?
<a class=anchor href=#que-mapporte-la-communication-de-donn%c3%a9es-de-webrtc->#</a></h2><p>WebRTC fournit des canaux de données pour la communication de données. Entre deux pairs, vous pouvez ouvrir 65 534 canaux de données.
Un canal de données est basé sur des datagrammes, et chacun a ses propres paramètres de durabilité. Par défaut, chaque canal de données garantit une livraison ordonnée.</p><p>Si vous abordez WebRTC à partir d&rsquo;un contexte média, les canaux de données peuvent sembler gaspilleurs. Pourquoi ai-je besoin de tout ce sous-système alors que je pourrais simplement utiliser HTTP ou WebSockets ?</p><p>Le véritable pouvoir des canaux de données est que vous pouvez les configurer pour qu&rsquo;ils se comportent comme UDP avec une livraison non ordonnée/avec perte.
Ceci est nécessaire pour les situations de faible latence et de haute performance. Vous pouvez mesurer la contre-pression et vous assurer que vous n&rsquo;envoyez que ce que votre réseau prend en charge.</p><h2 id=comment-cela-fonctionne-t-il->Comment cela fonctionne-t-il ?
<a class=anchor href=#comment-cela-fonctionne-t-il->#</a></h2><p>WebRTC utilise le Stream Control Transmission Protocol (SCTP), défini dans la <a href=https://tools.ietf.org/html/rfc4960>RFC 4960</a>. SCTP est un
protocole de couche transport qui était destiné comme alternative à TCP ou UDP. Pour WebRTC, nous l&rsquo;utilisons comme protocole de couche application qui s&rsquo;exécute sur notre connexion DTLS.</p><p>SCTP vous donne des flux et chaque flux peut être configuré indépendamment. Les canaux de données WebRTC ne sont que de minces abstractions autour d&rsquo;eux. Les paramètres
concernant la durabilité et l&rsquo;ordonnancement sont simplement transmis directement à l&rsquo;agent SCTP.</p><p>Les canaux de données ont certaines fonctionnalités que SCTP ne peut pas exprimer, comme les étiquettes de canal. Pour résoudre cela, WebRTC utilise le Data Channel Establishment Protocol (DCEP)
qui est défini dans la <a href=https://tools.ietf.org/html/rfc8832>RFC 8832</a>. DCEP définit un message pour communiquer l&rsquo;étiquette et le protocole du canal.</p><h2 id=dcep>DCEP
<a class=anchor href=#dcep>#</a></h2><p>DCEP n&rsquo;a que deux messages <code>DATA_CHANNEL_OPEN</code> et <code>DATA_CHANNEL_ACK</code>. Pour chaque canal de données ouvert, le distant doit répondre avec un accusé de réception.</p><h3 id=data_channel_open>DATA_CHANNEL_OPEN
<a class=anchor href=#data_channel_open>#</a></h3><p>Ce message est envoyé par l&rsquo;agent WebRTC qui souhaite ouvrir un canal.</p><h4 id=format-de-paquet>Format de paquet
<a class=anchor href=#format-de-paquet>#</a></h4><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |  Channel Type |            Priority           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Reliability Parameter                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Label Length          |       Protocol Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                             Label                             /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                            Protocol                           /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=type-de-message>Type de message
<a class=anchor href=#type-de-message>#</a></h4><p>Le type de message est une valeur statique de <code>0x03</code>.</p><h4 id=type-de-canal>Type de canal
<a class=anchor href=#type-de-canal>#</a></h4><p>Le type de canal contrôle les attributs de durabilité/ordonnancement du canal. Il peut avoir les valeurs suivantes :</p><ul><li><code>DATA_CHANNEL_RELIABLE</code> (<code>0x00</code>) - Aucun message n&rsquo;est perdu et arrivera dans l&rsquo;ordre</li><li><code>DATA_CHANNEL_RELIABLE_UNORDERED</code> (<code>0x80</code>) - Aucun message n&rsquo;est perdu, mais ils peuvent arriver dans le désordre.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT</code> (<code>0x01</code>) - Les messages peuvent être perdus après avoir essayé le nombre de fois demandé, mais ils arriveront dans l&rsquo;ordre.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED</code> (<code>0x81</code>) - Les messages peuvent être perdus après avoir essayé le nombre de fois demandé et peuvent arriver dans le désordre.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED</code> (<code>0x02</code>) - Les messages peuvent être perdus s&rsquo;ils n&rsquo;arrivent pas dans le délai demandé, mais ils arriveront dans l&rsquo;ordre.</li><li><code>DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED</code> (<code>0x82</code>) - Les messages peuvent être perdus s&rsquo;ils n&rsquo;arrivent pas dans le délai demandé et peuvent arriver dans le désordre.</li></ul><h4 id=priorité>Priorité
<a class=anchor href=#priorit%c3%a9>#</a></h4><p>La priorité du canal de données. Les canaux de données ayant une priorité plus élevée seront planifiés en premier. Les messages utilisateur volumineux de priorité inférieure ne retarderont pas l&rsquo;envoi de messages utilisateur de priorité plus élevée.</p><h4 id=paramètre-de-fiabilité>Paramètre de fiabilité
<a class=anchor href=#param%c3%a8tre-de-fiabilit%c3%a9>#</a></h4><p>Si le type de canal de données est <code>DATA_CHANNEL_PARTIAL_RELIABLE</code>, les suffixes configurent le comportement :</p><ul><li><code>REXMIT</code> - Définit combien de fois l&rsquo;expéditeur renverra le message avant d&rsquo;abandonner.</li><li><code>TIMED</code> - Définit pendant combien de temps (en ms) l&rsquo;expéditeur renverra le message avant d&rsquo;abandonner.</li></ul><h4 id=étiquette>Étiquette
<a class=anchor href=#%c3%a9tiquette>#</a></h4><p>Une chaîne encodée UTF-8 contenant le nom du canal de données. Cette chaîne peut être vide.</p><h4 id=protocole>Protocole
<a class=anchor href=#protocole>#</a></h4><p>Si c&rsquo;est une chaîne vide, le protocole n&rsquo;est pas spécifié. Si c&rsquo;est une chaîne non vide, elle devrait spécifier un protocole enregistré dans le &ldquo;WebSocket Subprotocol Name Registry&rdquo;, défini dans la <a href=https://tools.ietf.org/html/rfc6455#page-61>RFC 6455</a>.</p><h3 id=data_channel_ack>DATA_CHANNEL_ACK
<a class=anchor href=#data_channel_ack>#</a></h3><p>Ce message est envoyé par l&rsquo;agent WebRTC pour accuser réception que ce canal de données a été ouvert.</p><h4 id=format-de-paquet-1>Format de paquet
<a class=anchor href=#format-de-paquet-1>#</a></h4><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |
+-+-+-+-+-+-+-+-+
</code></pre><h2 id=stream-control-transmission-protocol>Stream Control Transmission Protocol
<a class=anchor href=#stream-control-transmission-protocol>#</a></h2><p>SCTP est le véritable pouvoir derrière les canaux de données WebRTC. Il fournit toutes ces fonctionnalités du canal de données :</p><ul><li>Multiplexage</li><li>Livraison fiable utilisant un mécanisme de retransmission similaire à TCP</li><li>Options de fiabilité partielle</li><li>Évitement de la congestion</li><li>Contrôle de flux</li></ul><p>Pour comprendre SCTP, nous l&rsquo;explorerons en trois parties. L&rsquo;objectif est que vous en sachiez assez pour déboguer et apprendre les détails profonds de SCTP par vous-même après ce chapitre.</p><h2 id=concepts>Concepts
<a class=anchor href=#concepts>#</a></h2><p>SCTP est un protocole riche en fonctionnalités. Cette section ne couvrira que les parties de SCTP utilisées par WebRTC.
Les fonctionnalités de SCTP qui ne sont pas utilisées par WebRTC incluent le multi-homing et la sélection de chemin.</p><p>Avec plus de vingt ans de développement, SCTP peut être difficile à saisir pleinement.</p><h3 id=association>Association
<a class=anchor href=#association>#</a></h3><p>L&rsquo;association est le terme utilisé pour une session SCTP. C&rsquo;est l&rsquo;état qui est partagé
entre deux agents SCTP pendant qu&rsquo;ils communiquent.</p><h3 id=flux>Flux
<a class=anchor href=#flux>#</a></h3><p>Un flux est une séquence bidirectionnelle de données utilisateur. Lorsque vous créez un canal de données, vous ne créez en fait qu&rsquo;un flux SCTP. Chaque association SCTP contient une liste de flux. Chaque flux peut être configuré avec différents types de fiabilité.</p><p>WebRTC vous permet uniquement de configurer lors de la création du flux, mais SCTP permet en réalité de changer la configuration à tout moment.</p><h3 id=basé-sur-les-datagrammes>Basé sur les datagrammes
<a class=anchor href=#bas%c3%a9-sur-les-datagrammes>#</a></h3><p>SCTP encadre les données comme des datagrammes et non comme un flux d&rsquo;octets. L&rsquo;envoi et la réception de données ressemblent à l&rsquo;utilisation d&rsquo;UDP plutôt que de TCP.
Vous n&rsquo;avez pas besoin d&rsquo;ajouter de code supplémentaire pour transférer plusieurs fichiers sur un seul flux.</p><p>Les messages SCTP n&rsquo;ont pas de limites de taille comme UDP. Un seul message SCTP peut faire plusieurs gigaoctets de taille.</p><h3 id=morceaux>Morceaux
<a class=anchor href=#morceaux>#</a></h3><p>Le protocole SCTP est composé de morceaux. Il existe de nombreux types différents de morceaux. Ces morceaux sont utilisés pour toute communication.
Les données utilisateur, l&rsquo;initialisation de connexion, le contrôle de congestion, et plus encore sont tous effectués via des morceaux.</p><p>Chaque paquet SCTP contient une liste de morceaux. Donc, dans un paquet UDP, vous pouvez avoir plusieurs morceaux transportant des messages de différents flux.</p><h3 id=numéro-de-séquence-de-transmission>Numéro de séquence de transmission
<a class=anchor href=#num%c3%a9ro-de-s%c3%a9quence-de-transmission>#</a></h3><p>Le numéro de séquence de transmission (TSN) est un identifiant unique global pour les morceaux DATA. Un morceau DATA est ce qui transporte tous les messages qu&rsquo;un utilisateur souhaite envoyer. Le TSN est important car il aide un récepteur à déterminer si des paquets sont perdus ou dans le désordre.</p><p>Si le récepteur remarque un TSN manquant, il ne donne pas les données à l&rsquo;utilisateur tant qu&rsquo;il n&rsquo;est pas satisfait.</p><h3 id=identifiant-de-flux>Identifiant de flux
<a class=anchor href=#identifiant-de-flux>#</a></h3><p>Chaque flux a un identifiant unique. Lorsque vous créez un canal de données avec un ID explicite, il est en fait simplement passé directement à SCTP comme identifiant de flux. Si vous ne passez pas d&rsquo;ID, l&rsquo;identifiant de flux est choisi pour vous.</p><h3 id=identifiant-de-protocole-de-charge-utile>Identifiant de protocole de charge utile
<a class=anchor href=#identifiant-de-protocole-de-charge-utile>#</a></h3><p>Chaque morceau DATA a également un identifiant de protocole de charge utile (PPID). Ceci est utilisé pour identifier de manière unique quel type de données est échangé.
SCTP a de nombreux PPID, mais WebRTC n&rsquo;utilise que les cinq suivants :</p><ul><li><code>WebRTC DCEP</code> (<code>50</code>) - Messages DCEP.</li><li><code>WebRTC String</code> (<code>51</code>) - Messages de chaîne DataChannel.</li><li><code>WebRTC Binary</code> (<code>53</code>) - Messages binaires DataChannel.</li><li><code>WebRTC String Empty</code> (<code>56</code>) - Messages de chaîne DataChannel de longueur 0.</li><li><code>WebRTC Binary Empty</code> (<code>57</code>) - Messages binaires DataChannel de longueur 0.</li></ul><h2 id=protocole-1>Protocole
<a class=anchor href=#protocole-1>#</a></h2><p>Voici quelques-uns des morceaux utilisés par le protocole SCTP. Ce n&rsquo;est
pas une démonstration exhaustive. Cela fournit suffisamment de structures pour que la
machine à états ait du sens.</p><p>Chaque morceau commence par un champ <code>type</code>. Avant une liste de morceaux, vous aurez
également un en-tête.</p><h3 id=morceau-data>Morceau DATA
<a class=anchor href=#morceau-data>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0    | Reserved|U|B|E|    Length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TSN                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Stream Identifier        |   Stream Sequence Number      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Payload Protocol Identifier                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                            User Data                          /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Le morceau DATA est la façon dont toutes les données utilisateur sont échangées. Lorsque vous envoyez
quoi que ce soit sur le canal de données, c&rsquo;est ainsi qu&rsquo;il est échangé.</p><p>Le bit <code>U</code> est défini si c&rsquo;est un paquet non ordonné. Nous pouvons ignorer le
numéro de séquence de flux.</p><p><code>B</code> et <code>E</code> sont les bits de début et de fin. Si vous voulez envoyer un
message trop grand pour un morceau DATA, il doit être fragmenté en plusieurs morceaux DATA envoyés dans des paquets séparés.
Avec le bit <code>B</code> et <code>E</code> et les numéros de séquence, SCTP est capable d&rsquo;exprimer
cela.</p><ul><li><code>B=1</code>, <code>E=0</code> - Première pièce d&rsquo;un message utilisateur fragmenté.</li><li><code>B=0</code>, <code>E=0</code> - Pièce intermédiaire d&rsquo;un message utilisateur fragmenté.</li><li><code>B=0</code>, <code>E=1</code> - Dernière pièce d&rsquo;un message utilisateur fragmenté.</li><li><code>B=1</code>, <code>E=1</code> - Message non fragmenté.</li></ul><p><code>TSN</code> est le numéro de séquence de transmission. C&rsquo;est l&rsquo;identifiant unique
global pour ce morceau DATA. Après 4 294 967 295 morceaux, cela reviendra à 0.
Le TSN est incrémenté pour chaque morceau dans un message utilisateur fragmenté afin que le récepteur sache comment ordonner les morceaux reçus pour reconstruire le message original.</p><p><code>Identifiant de flux</code> est l&rsquo;identifiant unique pour le flux auquel ces données appartiennent.</p><p><code>Numéro de séquence de flux</code> est un nombre de 16 bits incrémenté à chaque message utilisateur et inclus dans l&rsquo;en-tête du morceau de message DATA. Après 65 535 messages, cela reviendra à 0. Ce nombre est utilisé pour décider l&rsquo;ordre de livraison des messages au récepteur si <code>U</code> est défini à 0. Semblable au TSN, sauf que le numéro de séquence de flux n&rsquo;est incrémenté que pour chaque message dans son ensemble et non pour chaque morceau DATA individuel.</p><p><code>Identifiant de protocole de charge utile</code> est le type de données qui circule à travers
ce flux. Pour WebRTC, ce sera DCEP, String ou Binary.</p><p><code>Données utilisateur</code> est ce que vous envoyez. Toutes les données que vous envoyez via un canal de données WebRTC
sont transmises via un morceau DATA.</p><h3 id=morceau-init>Morceau INIT
<a class=anchor href=#morceau-init>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 1    |  Chunk Flags  |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Initiate Tag                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Advertised Receiver Window Credit (a_rwnd)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Number of Outbound Streams   |  Number of Inbound Streams    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Initial TSN                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/              Optional/Variable-Length Parameters              /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Le morceau INIT démarre le processus de création d&rsquo;une association.</p><p><code>Initiate Tag</code> est utilisé pour la génération de cookies. Les cookies sont utilisés pour la protection contre l&rsquo;homme du milieu
et le déni de service. Ils sont décrits plus en détail dans la section de la machine
à états.</p><p><code>Advertised Receiver Window Credit</code> est utilisé pour le contrôle de congestion de SCTP. Cela
communique la taille du tampon que le récepteur a alloué pour cette association.</p><p><code>Nombre de flux sortants/entrants</code> notifie le distant du nombre de flux que cet
agent prend en charge.</p><p><code>TSN initial</code> est un <code>uint32</code> aléatoire pour démarrer le TSN local.</p><p><code>Paramètres optionnels</code> permet à SCTP d&rsquo;introduire de nouvelles fonctionnalités dans le protocole.</p><h3 id=morceau-sack>Morceau SACK
<a class=anchor href=#morceau-sack>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 3    |Chunk  Flags   |      Chunk Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Advertised Receiver Window Credit (a_rwnd)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Gap Ack Block #N Start      |  Gap Ack Block #N End         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Duplicate TSN 1                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                              ...                              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Duplicate TSN X                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Le morceau SACK (Accusé de réception sélectif) est la façon dont un récepteur notifie
un expéditeur qu&rsquo;il a reçu un paquet. Jusqu&rsquo;à ce qu&rsquo;un expéditeur reçoive un SACK pour un TSN,
il renverra le morceau DATA en question. Un SACK fait plus que simplement
mettre à jour le TSN.</p><p><code>TSN cumulatif ACK</code> le TSN le plus élevé qui a été reçu.</p><p><code>Crédit de fenêtre de récepteur annoncé</code> taille du tampon du récepteur. Le récepteur
peut changer cela pendant la session si plus de mémoire devient disponible.</p><p><code>Blocs Ack</code> TSN qui ont été reçus après le <code>TSN cumulatif ACK</code>.
Ceci est utilisé s&rsquo;il y a un écart dans les paquets livrés. Disons que des morceaux DATA avec des TSN
<code>100</code>, <code>102</code>, <code>103</code> et <code>104</code> sont livrés. Le <code>TSN cumulatif ACK</code> serait <code>100</code>, mais
<code>Blocs Ack</code> pourrait être utilisé pour dire à l&rsquo;expéditeur qu&rsquo;il n&rsquo;a pas besoin de renvoyer <code>102</code>, <code>103</code> ou <code>104</code>.</p><p><code>TSN dupliqué</code> informe l&rsquo;expéditeur qu&rsquo;il a reçu les morceaux DATA suivants plus d&rsquo;une fois.</p><h3 id=morceau-heartbeat>Morceau HEARTBEAT
<a class=anchor href=#morceau-heartbeat>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 4    | Chunk  Flags  |      Heartbeat Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/            Heartbeat Information TLV (Variable-Length)        /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Le morceau HEARTBEAT est utilisé pour affirmer que le distant répond toujours.
Utile si vous n&rsquo;envoyez aucun morceau DATA et devez maintenir un
mappage NAT ouvert.</p><h3 id=morceau-abort>Morceau ABORT
<a class=anchor href=#morceau-abort>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 6    |Reserved     |T|           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\               Zero or more Error Causes                       \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Un morceau ABORT ferme brusquement l&rsquo;association. Utilisé lorsque
un côté entre dans un état d&rsquo;erreur. La fin gracieuse de la connexion utilise
le morceau SHUTDOWN.</p><h3 id=morceau-shutdown>Morceau SHUTDOWN
<a class=anchor href=#morceau-shutdown>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 7    | Chunk  Flags  |      Length = 8               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Cumulative TSN Ack                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Le morceau SHUTDOWN démarre une fermeture gracieuse de l&rsquo;association SCTP.
Chaque agent informe le distant du dernier TSN qu&rsquo;il a envoyé. Cela garantit
qu&rsquo;aucun paquet n&rsquo;est perdu. WebRTC n&rsquo;effectue pas de fermeture gracieuse de
l&rsquo;association SCTP. Vous devez démonter chaque canal de données vous-même
pour le gérer gracieusement.</p><p><code>TSN cumulatif ACK</code> est le dernier TSN qui a été envoyé. Chaque côté sait
ne pas terminer jusqu&rsquo;à ce qu&rsquo;il ait reçu le morceau DATA avec ce TSN.</p><h3 id=morceau-error>Morceau ERROR
<a class=anchor href=#morceau-error>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 9    | Chunk  Flags  |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               \
/                    One or more Error Causes                   /
\                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Un morceau ERROR est utilisé pour notifier l&rsquo;agent SCTP distant qu&rsquo;une erreur non fatale
s&rsquo;est produite.</p><h3 id=morceau-forward-tsn>Morceau FORWARD TSN
<a class=anchor href=#morceau-forward-tsn>#</a></h3><pre tabindex=0><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 192  |  Flags = 0x00 |        Length = Variable      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      New Cumulative TSN                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Stream-1              |       Stream Sequence-1       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\                                                               /
/                                                               \
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Stream-N              |       Stream Sequence-N       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Le morceau <code>FORWARD TSN</code> déplace le TSN global vers l&rsquo;avant. SCTP fait cela,
pour que vous puissiez sauter certains paquets qui ne vous intéressent plus. Disons
que vous envoyez <code>10 11 12 13 14 15</code> et que ces paquets ne sont valides que s&rsquo;ils
arrivent tous. Ces données sont également sensibles au temps réel, donc si elles arrivent
tard, elles ne sont pas utiles.</p><p>Si vous perdez <code>12</code> et <code>13</code>, il n&rsquo;y a aucune raison d&rsquo;envoyer <code>14</code> et <code>15</code> !
SCTP utilise le morceau <code>FORWARD TSN</code> pour y parvenir. Il dit au récepteur
que <code>14</code> et <code>15</code> ne seront plus livrés.</p><p><code>Nouveau TSN cumulatif</code> c&rsquo;est le nouveau TSN de la connexion. Tous les paquets
avant ce TSN ne seront pas conservés.</p><p><code>Flux</code> et <code>Séquence de flux</code> sont utilisés pour faire avancer le <code>numéro de séquence de flux</code>
en avant. Reportez-vous au morceau DATA pour la signification de ce champ.</p><h2 id=machine-à-états>Machine à états
<a class=anchor href=#machine-%c3%a0-%c3%a9tats>#</a></h2><p>Voici quelques parties intéressantes de la machine à états SCTP. WebRTC n&rsquo;utilise pas toutes
les fonctionnalités de la machine à états SCTP, nous avons donc exclu ces parties. Nous avons également simplifié certains composants pour les rendre compréhensibles par eux-mêmes.</p><h3 id=flux-détablissement-de-connexion>Flux d&rsquo;établissement de connexion
<a class=anchor href=#flux-d%c3%a9tablissement-de-connexion>#</a></h3><p>Les morceaux <code>INIT</code> et <code>INIT ACK</code> sont utilisés pour échanger les capacités et configurations
de chaque pair. SCTP utilise un cookie pendant la négociation pour valider le pair avec lequel il communique.
Cela garantit que la négociation n&rsquo;est pas interceptée et pour prévenir les attaques DoS.</p><p>Le morceau <code>INIT ACK</code> contient le cookie. Le cookie est ensuite renvoyé à son créateur
en utilisant le <code>COOKIE ECHO</code>. Si la vérification du cookie réussit, le <code>COOKIE ACK</code> est
envoyé et les morceaux DATA sont prêts à être échangés.</p><p><img src=../images/07-connection-establishment.png alt="Établissement de connexion" title="Établissement de connexion"></p><h3 id=flux-de-démontage-de-connexion>Flux de démontage de connexion
<a class=anchor href=#flux-de-d%c3%a9montage-de-connexion>#</a></h3><p>SCTP utilise le morceau <code>SHUTDOWN</code>. Lorsqu&rsquo;un agent reçoit un morceau <code>SHUTDOWN</code>, il attendra jusqu&rsquo;à ce qu&rsquo;il
reçoive le <code>TSN cumulatif ACK</code> demandé. Cela permet à un utilisateur de s&rsquo;assurer que toutes les données
sont livrées même si la connexion a des pertes.</p><h3 id=mécanisme-de-maintien-en-vie>Mécanisme de maintien en vie
<a class=anchor href=#m%c3%a9canisme-de-maintien-en-vie>#</a></h3><p>SCTP utilise les morceaux <code>HEARTBEAT REQUEST</code> et <code>HEARTBEAT ACK</code> pour maintenir la connexion en vie. Ceux-ci sont envoyés
à un intervalle configurable. SCTP effectue également un backoff exponentiel si le paquet n&rsquo;est pas arrivé.</p><p>Le morceau <code>HEARTBEAT</code> contient également une valeur temporelle. Cela permet à deux associations de calculer le temps de trajet entre deux agents.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/09eb4c1bd1c41fb4d6940cd568c2f26cc2428fdb title='Dernière modification par Claes Mogren | novembre 4, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>novembre 4, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/docs/07-data-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Modifier cette page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#que-mapporte-la-communication-de-données-de-webrtc->Que m&rsquo;apporte la communication de données de WebRTC ?</a></li><li><a href=#comment-cela-fonctionne-t-il->Comment cela fonctionne-t-il ?</a></li><li><a href=#dcep>DCEP</a><ul><li><a href=#data_channel_open>DATA_CHANNEL_OPEN</a></li><li><a href=#data_channel_ack>DATA_CHANNEL_ACK</a></li></ul></li><li><a href=#stream-control-transmission-protocol>Stream Control Transmission Protocol</a></li><li><a href=#concepts>Concepts</a><ul><li><a href=#association>Association</a></li><li><a href=#flux>Flux</a></li><li><a href=#basé-sur-les-datagrammes>Basé sur les datagrammes</a></li><li><a href=#morceaux>Morceaux</a></li><li><a href=#numéro-de-séquence-de-transmission>Numéro de séquence de transmission</a></li><li><a href=#identifiant-de-flux>Identifiant de flux</a></li><li><a href=#identifiant-de-protocole-de-charge-utile>Identifiant de protocole de charge utile</a></li></ul></li><li><a href=#protocole-1>Protocole</a><ul><li><a href=#morceau-data>Morceau DATA</a></li><li><a href=#morceau-init>Morceau INIT</a></li><li><a href=#morceau-sack>Morceau SACK</a></li><li><a href=#morceau-heartbeat>Morceau HEARTBEAT</a></li><li><a href=#morceau-abort>Morceau ABORT</a></li><li><a href=#morceau-shutdown>Morceau SHUTDOWN</a></li><li><a href=#morceau-error>Morceau ERROR</a></li><li><a href=#morceau-forward-tsn>Morceau FORWARD TSN</a></li></ul></li><li><a href=#machine-à-états>Machine à états</a><ul><li><a href=#flux-détablissement-de-connexion>Flux d&rsquo;établissement de connexion</a></li><li><a href=#flux-de-démontage-de-connexion>Flux de démontage de connexion</a></li><li><a href=#mécanisme-de-maintien-en-vie>Mécanisme de maintien en vie</a></li></ul></li></ul></nav></div></aside></main></body></html>