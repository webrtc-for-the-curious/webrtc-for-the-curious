[{"id":0,"href":"/id/docs/01-what-why-and-how/","title":"Apa, Mengapa, dan Bagaimana","section":"Docs","content":" Apa, Mengapa, dan Bagaimana # Apa itu WebRTC? # WebRTC, singkatan dari Web Real-Time Communication, pada dasarnya adalah gabungan API dan Protokol. Protokol WebRTC merupakan sekumpulan aturan bagi dua klien WebRTC untuk saling berkomunikasi secara dua arah melalui jalur komunikasi langsung yang aman. Sedangkan API WebRTC memungkinkan para pengembang aplikasi untuk menggunakan protokol WebRTC. API WebRTC yang dimaksud di sini hanya diperuntukkan bagi JavaScript.\nSalah satu contoh yang mungkin setara adalah relasi antara HTTP dan API Fetch. Di mana WebRTC sebagai protokol sama seperti HTTP, dan API WebRTC sama seperti API Fetch.\nProkotol WebRTC juga tersedia dalam bentuk API lainnya dan bahasa selain JavaScript. Anda dapat menemukan banyak server dan perangkat lunak spesifik lainnya untuk WebRTC. Semuanya menggunakan protokol WebRTC, dan seharusnya dapat saling berkomunikasi satu sama lain.\nProtokol WebRTC diampu oleh IETF dalam kelompok kerja rtcweb. Sedangkan API WebRTC didokumentasikan di dalam W3C sebagai webrtc.\nMengapa saya harus mempelajari WebRTC? # Ada beberapa hal yang akan Anda pelajari mengenai WebRTC di sini. Daftar di bawah ini mungkin tidak lengkap, hanya sebagian contoh dari apa yang akan Anda dapat selama membaca buku ini. Jangan khawatir jika Anda belum paham mengenai istilah-istilah berikut, karena buku ini akan menjelaskannya kepada Anda.\nStandar terbuka Beragam implementasi WebRTC Penggunaan di peramban web Enkripsi wajib NAT Traversal Penggunaan teknologi terdahulu Congestion control Sub-second latency Protokol WebRTC merupakan sekumpulan dari teknologi lain # Ada banyak teknologi yang akan dibahas oleh buku ini secara keseluruhan. Namun jangan khawatir, kita akan membaginya ke dalam empat tahap.\nSignaling Connecting Securing Communicating Keempat tahap tersebut harus berjalan secara berurutan. Setiap tahapan harus berhasil 100% agar tahap selanjunya dapat dijalakan.\nFakta menarik tentang WebRTC adalah setiap tahapan di atas sebenarnya tersusun atas banyak protokol lainnya! Untuk membuat aplikasi WebRTC, kita harus menyusun banyak teknologi lain yang sebenarnya sudah ada sebelumnya. Itu artinya, WebRTC lebih merupakan kombinasi dan konfigurasi dari beberapa teknologi terdahulu sejak awal tahun 2000-an.\nSetiap tahapan ditulis dalam masing-masing bab, tetapi akan sangat membantu untuk memahaminya secara berurutan. Karena setiap tahapan bergantung satu sama lain, tentu ini akan membantu ketika memahami lebih lanjut.\nSignaling: Bagaimana setiap peer saling berinteraksi di WebRTC # Pada dasarnya setiap klien WebRTC tidak tahu bagaimana cara berkomunikasi dan apa yang akan dikomunikasikan dengan klien lainnya. Untuk itulah signaling hadir untuk memecahkan masalah tersebut! Signaling digunakan untuk membangun komunikasi sehingga dua atau lebih klien WebRTC dapat saling berinteraksi.\nSignaling menggunakan protokol SDP yang sudah ada sebelumnya. SDP merupakan protokol berbasis teks. Setiap pesan SDP disusun atas pasangan key/value dan berisi sekumpulan daftar \u0026ldquo;informasi media\u0026rdquo;. SDP yang digunakan oleh dua klien WebRTC untuk saling berkomunikasi biasanya terdiri dari:\nDaftar alamat IP dan port di mana klient tersebut dapat dihubungi (candidates). Berapa banyak track audio dan video yang akan dikirimkan. Apa codec dari audio dan video yang klien tersebut gunakan. Parameter yang digunakan ketika proses connecting (uFrag/uPwd). Parameter yang digunakan ketika proses securing (certificate fingerprint). Perlu dicatat bahwa proses signaling biasanya terjadi \u0026ldquo;out of band\u0026rdquo;; artinya aplikasi umumnya tidak menggunakan WebRTC itu sendiri dalam proses signaling. Beberapa arsitektur yang bisa digunakan untuk mengirim data dapat juga digunakan untuk bertukar SDP antar peer, serta banyak aplikasi yang menggunakan infrastruktur bawaan mereka (contohnya REST, WebSocket, dan lain sebagainya) yang digunaan dalam proses pertukaran SDP antar klien.\nConnecting dan NAT Traversal dengan STUN/TURN # Pada tahap ini dua klien WebRTC sudah saling mengetahui cara untuk saling berkomunikasi satu sama lain. Selanjutya WebRTC memanfaatkan teknologi lain yang disebutkan ICE.\nICE (Interactive Connectivity Establishment) merupakan protokol yang sudah ada sejak lama. ICE memungkinkan terbentuknya sambungan antara dua klien. Kedua klien ini bisa jadi berada dalam satu jaringan yang sama, atau di jaringan yang berbeda di belahan dunia lain. ICE merupakan cara untuk membangun sambungan langsung tanpa server perantara.\nHal yang paling penting di sini adalah NAT Traversal dan STUN/TURN Server. Kedua teknologi ini yang akan Anda butuhkan dalam proses komunikasi antar klien ICE di dalam subnet yang berbeda. Kita akan ulas lebih lengkap kedua konsep ini nanti.\nKetika ICE berhasil tersambung, WebRTC kemudian akan mencoba membangun jalur transpor yang aman. Jalur transpor ini digunakan untuk audio, video, dan data.\nSecuring jalur transpor dengan DTLS dan SRTP # Setelah kita telah memiliki jalur komunikasi dua arah (menggunakan ICE), tahap selanjutnya kita perlu membangun jalur komunikasi yang aman. Ini juga memanfatkan protokol yang sudah ada sebelum WebRTC. Protokol pertama adala DTLS (Datagram Transport Layer Security), yang merupakan protokol TLS melalui UDP. TLS adalah protokol kriptografi yang digunakan untuk mengamankan komunikasi melalui HTTPS. Protokol kedua adalah SRTP (Secure Real-time Transport).\nPertama, WebRTC tersambung dengan melakukan DTLS handshake melalui sambungan yang dibentuk oleh ICE. Tidak seperti HTTPS, WebRTC tidak menggunakan sertifikat authority terpusat. Melainkan, WebRTC melakukan pertukaran sertifikat melalui pencocokan DTLS fingerprint pada saat proses signaling. DTLS ini kemudian akan digunakan untuk DataChannel.\nKemudian WebRTC menggunakan protokol lainnya untuk mengirimkan audio dan video yang dikenal dengan RTP. Kita perlu mengamankan paket RTP kita menggunakan SRTP. Proses inisiasi sesi SRTP terjadi dengan cara mendapatkan kunci/sertifikat di dalam sesi DTLS sebelumnya. Pada tahapan berikutnya, kita akan membahas mengapa pengiriman audio dan video ini harus menggunakan protokol tersendiri.\nSelesai! Sekarang kita telah memiliki jalur komunikasi dua arah yang aman. Jika Anda memiliki jaringan yang stabil di antara dua klien WebRTC Anda, semua proses rumit yang perlu dilalui telah selesai. Namun sayangnya, pada kenyataannya sering terjadi packet loss dan keterbatasan bandwith, dan di bab selanjutnya kita akan membahas bagaimana mengatasinya.\nCommunicating antar peer melalui RTP dan SCTP # Kini kita telah memiliki dua klien WebRTC yang telah bisa berkomunikasi dua arah secara aman. Selanjutnya mari berinteraksi! Sama seperti sebelumnya, kita akan menggunakan dua protokol yang sudah ada sebelumnya: RTP (Real-time Transport Protocol) dan SCTP (Stream Control Transmission Protocol). Kita meggunakan RTP untuk bertukar media terenkripsi dengan SRTP, dan menggunakan SCTP unuk menggirim dan menerima pesan DataChannel yang terenkripsi dengan DTLS.\nProtokol RTP cukup sederhana, namun menyediakan apa yang dibutuhkan dalam implementasi video streaming. Hal yang paling penting adalah adalah RTC memberikan keleluasaan bagi para pengembang, sehingga mereka dapat menangani latency, loss, dan _congestion sesuai dengan apa yang diinginkan. Kita akan membahas lebih lanjut mengenai ini pada bab media.\nProtokol terakhir adalah SCTP. SCTP memungkinkan banyak opsi pengiriman data. Anda bisa memilih opsi unreliable, pengiriman dengan urutan acak, agar Anda dapat mengurangi latency pada aplikasi yang real-time.\nWebRTC, sekumpulan protokol # WebRTC dapat menyelesaikan banyak masalah. Mungkin ini tampak berlebihan. Namun kelebihan dari WebRTC adalah kesederhanaannya. Ia tidak menyatakan bahwa ia dapat menyelesaikan semua permasalahan dengan lebih baik. Sebaliknya, ia memanfaatkan banyak terknologi terdahulu dan menggabungkannya bersama-sama.\nIni memungkinkan kita untuk mempelajari masing-masing bagian secara terpisah tanpa perlu membuat kewalahan. Cara yang benar untuk menggambarkannya adalah WebRTC sebenarnya hanyalah sekumpulan dari banyak protokol yang berbeda.\nBagaimana WebRTC (API) bekerja # Bagian ini akan menjelaskan kepada Anda bagaimana API JavaScript pada WebRTC. Ini bukan dimaksudkan untuk menunjukkan demo dari API WebRTC, namun sebatas menunjukkan contoh bagaimana API tersebut saling bekerja sama.\nJika Anda belum familier, tidak ada masalah. Ini akan menjadi bagian yang yang menyenangkan!\nnew RTCPeerConnection # RTCPeerConnection adalah level teratas dari \u0026ldquo;WebRTC Session\u0026rdquo;. Ini berisi semua protokol yang telah disebutkan sebelumnya. Semua subsistem yang bekerja di dalamnya telah dialokasikan, namun belum terjadi apa-apa.\naddTrack # addTrack berfungsi untuk membuat RTP stream baru. Sebuah Synchronization Source (SSRC) acak akan dibuat pada stream tersebut. Stream ini kemudian akan dimasukkan ke dalam Session Description yang dibuat oleh createOffer. Setiap pemanggilan addTrack akan selalu membuat SSRC dan media baru.\nSegera setelah sesi SRTP terbentuk, paket media ini akan dikirimkan melalui ICE setelah dienkripsi menggunakan SRTP.\ncreateDataChannel # createDataChannel berfungsi untuk membuat SCTP stream baru jika tidak ada SCTP yang tersedia sebelumnya. Pada dasarnya SCTP tidak akan diinisiasi secara otomatis, kecuali salah satu pihak melakukan permintaan data channel.\nSegera setelah sesi DTLS terbentuk, SCTP yang telah diinisiasi akan mulai mengirimkan paket melalui ICE dan dienkripsi menggunakan DTLS.\ncreateOffer # createOffer digunakan untuk membuat Session Description di lokal yang kemudian akan dikirim ke remote peer tujuan.\nPemanggilan createOffer tidak akan mengubah apapun di sisi local peer.\nsetLocalDescription # setLocalDescription bertugas untuk melakukan perubahan yang dilakukan. addTrack, createDataChannel, dan fungsi lainnya tidak akan berlaku sampai fungsi ini dipanggil. setLocalDescription biasanya dipanggil dengan memuat SDP yang dihasilkan createOffer.\nBiasanya setelah memanggil fungsi ini, Anda akan mengirimkan SDP offer kepada remote peer tujuan, dan mereka akan membalasnya dengan memanggil setRemoteDescription.\nsetRemoteDescription # setRemoteDescription digunakan untuk menginformasikan local peer mengenai SDP remote peer. Ini adalah bagaimana proses signaling dilakukan dengan API JavaScript.\nKetika setRemoteDescription telah dipanggil pada kedua sisi, kedua klien WebRTC kini telah memiliki informasi yang cukup untuk saling berkomunikasi secara Peer-To-Peer (P2P)!\naddIceCandidate # addIceCandidate memungkinkan klien WebRTC untuk menambahkan remote ICE Candidate kapanpun. API ini akan mengirimkan ICE Candidate langsung ke dalam subsistem ICE dan tidak berpengaruh apapun terkait dengan sambungan WebRTC.\nontrack # ontrack merupakan sebuah callback yang dipanggil ketika ada sebuah paket RTP yang diterima dari remote peer. Paket yang datang telah didefinisikan sebelumnya pada Session Description yang dikirimkan melalui setRemoteDescription.\nWebRTC menggunakan SSRC dan akan mencari MediaStream dan MediaStreamTrack terkait, yang kemudian akan memanggil callback ini dengan informasi tersebut.\noniceconnectionstatechange # oniceconnectionstatechange merupakan sebuah callback yang merupakan status dari ICE. Ketika Anda memiliki perubahan status dari jaringan atau terputus dari jaringan, ini merupakan cara Anda mengetahuinya.\nonconnectionstatechange # onconnectionstatechange adalah sebuah callback yang merupakan gabungan dari status ICE dan DTLS. Anda bisa memanggil ini untuk mengetahui ketika ICE dan DTLS telah selesai diproses.\n"},{"id":1,"href":"/id/docs/02-signaling/","title":"Signaling","section":"Docs","content":" Signaling # Apa itu Signaling pada WebRTC? # Ketika Anda membuat klien WebRTC, pada dasarnya klien tersebut tidak mengetahui apapun tentang peer lainnya. Ia tidak tahu dengan siapa ia akan terhubung dan apa yang akan mereka kirimkan! Signaling adalah proses awal yang memungkinkan sebuah panggilan terjadi. Setelah nilai-nilai ini dipertukarkan, klien WebRTC dapat berkomunikasi langsung satu sama lain.\nPesan signaling hanyalah teks biasa. Klien WebRTC tidak peduli bagaimana pesan tersebut dikirimkan. Pesan ini umumnya dikirim melalui WebSocket, namun itu bukan keharusan.\nBagaimana signaling WebRTC bekerja? # WebRTC menggunakan protokol yang sudah ada sebelumnya yang disebut Session Description Protocol. Melalui protokol ini, dua klien WebRTC akan berbagi semua informasi yang diperlukan untuk membangun sebuah koneksi. Protokol ini sendiri cukup sederhana untuk dibaca dan dipahami. Kompleksitasnya datang dari memahami semua nilai yang diisi oleh WebRTC ke dalamnya.\nProtokol ini tidak spesifik untuk WebRTC saja. Kita akan mempelajari Session Description Protocol terlebih dahulu tanpa membahas WebRTC. WebRTC sebenarnya hanya memanfaatkan sebagian kecil dari protokol ini, jadi kita hanya akan membahas apa yang kita butuhkan. Setelah kita memahami protokolnya, kita akan beralih ke penggunaannya dalam WebRTC.\nApa itu Session Description Protocol (SDP)? # Session Description Protocol didefinisikan dalam RFC 8866. Ini adalah protokol key/value dengan baris baru setelah setiap nilai. Terasa mirip dengan file INI. Sebuah Session Description berisi nol atau lebih Media Description. Secara mental Anda dapat memodelkannya sebagai Session Description yang berisi array dari Media Description.\nSebuah Media Description biasanya dipetakan ke satu stream media tunggal. Jadi jika Anda ingin menggambarkan panggilan dengan tiga stream video dan dua track audio, Anda akan memiliki lima Media Description.\nCara membaca SDP # Setiap baris dalam Session Description akan dimulai dengan satu karakter, ini adalah key Anda. Kemudian akan diikuti dengan tanda sama dengan. Semua yang ada setelah tanda sama dengan adalah nilainya. Setelah nilai selesai, akan ada baris baru.\nSession Description Protocol mendefinisikan semua key yang valid. Anda hanya dapat menggunakan huruf untuk key sebagaimana didefinisikan dalam protokol. Key ini semuanya memiliki arti penting, yang akan dijelaskan nanti.\nPerhatikan cuplikan Session Description berikut:\na=my-sdp-value a=second-value Anda memiliki dua baris. Masing-masing dengan key a. Baris pertama memiliki nilai my-sdp-value, baris kedua memiliki nilai second-value.\nWebRTC hanya menggunakan beberapa key SDP # Tidak semua nilai key yang didefinisikan oleh Session Description Protocol digunakan oleh WebRTC. Hanya key yang digunakan dalam JavaScript Session Establishment Protocol (JSEP), yang didefinisikan dalam RFC 8829, yang penting. Tujuh key berikut adalah satu-satunya yang perlu Anda pahami saat ini:\nv - Version, harus sama dengan 0. o - Origin, berisi ID unik yang berguna untuk renegosiasi. s - Session Name, harus sama dengan -. t - Timing, harus sama dengan 0 0. m - Media Description (m=\u0026lt;media\u0026gt; \u0026lt;port\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;fmt\u0026gt; ...), dijelaskan secara detail di bawah. a - Attribute, sebuah field teks bebas. Ini adalah baris yang paling umum dalam WebRTC. c - Connection Data, harus sama dengan IN IP4 0.0.0.0. Media Description dalam Session Description # Sebuah Session Description dapat berisi jumlah Media Description yang tidak terbatas.\nDefinisi Media Description berisi daftar format. Format ini dipetakan ke RTP Payload Type. Codec sebenarnya kemudian didefinisikan oleh Attribute dengan nilai rtpmap dalam Media Description. Pentingnya RTP dan RTP Payload Type dibahas kemudian dalam bab Media. Setiap Media Description dapat berisi jumlah atribut yang tidak terbatas.\nPerhatikan cuplikan Session Description sebagai contoh:\nv=0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4000 RTP/AVP 96 a=rtpmap:96 VP8/90000 a=my-sdp-value Anda memiliki dua Media Description, satu berjenis audio dengan fmt 111 dan satu berjenis video dengan format 96. Media Description pertama hanya memiliki satu atribut. Atribut ini memetakan Payload Type 111 ke Opus. Media Description kedua memiliki dua atribut. Atribut pertama memetakan Payload Type 96 menjadi VP8, dan atribut kedua hanyalah my-sdp-value.\nContoh Lengkap # Berikut ini menggabungkan semua konsep yang telah kita bicarakan. Ini adalah semua fitur Session Description Protocol yang digunakan WebRTC. Jika Anda dapat membaca ini, Anda dapat membaca Session Description WebRTC apapun!\nv=0 o=- 0 0 IN IP4 127.0.0.1 s=- c=IN IP4 127.0.0.1 t=0 0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4002 RTP/AVP 96 a=rtpmap:96 VP8/90000 v, o, s, c, t didefinisikan, tetapi tidak mempengaruhi sesi WebRTC. Anda memiliki dua Media Description. Satu berjenis audio dan satu berjenis video. Masing-masing memiliki satu atribut. Atribut ini mengonfigurasi detail pipeline RTP, yang dibahas dalam bab \u0026ldquo;Media Communication\u0026rdquo;. Bagaimana Session Description Protocol dan WebRTC bekerja bersama # Bagian selanjutnya dari teka-teki adalah memahami bagaimana WebRTC menggunakan Session Description Protocol.\nApa itu Offer dan Answer? # WebRTC menggunakan model offer/answer. Artinya, satu klien WebRTC membuat \u0026ldquo;Offer\u0026rdquo; untuk memulai panggilan, dan klien WebRTC lainnya \u0026ldquo;Answer\u0026rdquo; jika bersedia menerima apa yang ditawarkan.\nIni memberi penjawab kesempatan untuk menolak codec yang tidak didukung dalam Media Description. Inilah cara dua peer dapat memahami format apa yang bersedia mereka pertukarkan.\nTransceiver untuk mengirim dan menerima # Transceiver adalah konsep khusus WebRTC yang akan Anda lihat di API. Ini mengekspos \u0026ldquo;Media Description\u0026rdquo; ke API JavaScript. Setiap Media Description menjadi Transceiver. Setiap kali Anda membuat Transceiver, Media Description baru akan ditambahkan ke Session Description lokal.\nSetiap Media Description dalam WebRTC akan memiliki atribut arah. Ini memungkinkan klien WebRTC untuk menyatakan \u0026ldquo;Saya akan mengirimkan codec ini kepada Anda, tetapi saya tidak bersedia menerima apapun kembali\u0026rdquo;. Ada empat nilai yang valid:\nsend recv sendrecv inactive Nilai SDP yang digunakan oleh WebRTC # Ini adalah daftar beberapa atribut umum yang akan Anda lihat dalam Session Description dari klien WebRTC. Banyak dari nilai ini mengontrol subsistem yang belum kita bahas.\ngroup:BUNDLE # Bundling adalah tindakan menjalankan beberapa jenis traffic melalui satu koneksi. Beberapa implementasi WebRTC menggunakan koneksi khusus per media stream. Bundling harus lebih diutamakan.\nfingerprint:sha-256 # Ini adalah hash dari sertifikat yang digunakan peer untuk DTLS. Setelah handshake DTLS selesai, Anda membandingkannya dengan sertifikat sebenarnya untuk mengonfirmasi bahwa Anda berkomunikasi dengan siapa yang Anda harapkan.\nsetup: # Ini mengontrol perilaku DTLS Agent. Ini menentukan apakah ia berjalan sebagai client atau server setelah ICE terhubung. Nilai yang mungkin adalah:\nsetup:active - Berjalan sebagai DTLS Client. setup:passive - Berjalan sebagai DTLS Server. setup:actpass - Minta klien WebRTC lainnya untuk memilih. mid # Atribut \u0026ldquo;mid\u0026rdquo; digunakan untuk mengidentifikasi media stream dalam session description.\nice-ufrag # Ini adalah nilai user fragment untuk ICE Agent. Digunakan untuk autentikasi traffic ICE.\nice-pwd # Ini adalah password untuk ICE Agent. Digunakan untuk autentikasi traffic ICE.\nrtpmap # Nilai ini digunakan untuk memetakan codec tertentu ke RTP Payload Type. Payload Type tidak statis, jadi untuk setiap panggilan, pemberi offer memutuskan Payload Type untuk setiap codec.\nfmtp # Mendefinisikan nilai tambahan untuk satu Payload Type. Ini berguna untuk mengkomunikasikan video profile tertentu atau pengaturan encoder.\ncandidate # Ini adalah ICE Candidate yang berasal dari ICE Agent. Ini adalah satu alamat yang mungkin di mana klien WebRTC tersedia. Ini dijelaskan sepenuhnya di bab berikutnya.\nssrc # Synchronization Source (SSRC) mendefinisikan satu media stream track tunggal.\nlabel adalah ID untuk stream individual ini. mslabel adalah ID untuk kontainer yang dapat memiliki beberapa stream di dalamnya.\nContoh Session Description WebRTC # Berikut adalah Session Description lengkap yang dihasilkan oleh klien WebRTC:\nv=0 o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0 s=- t=0 0 a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E a=group:BUNDLE 0 1 m=audio 9 UDP/TLS/RTP/SAVPF 111 c=IN IP4 0.0.0.0 a=setup:active a=mid:0 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:111 opus/48000/2 a=fmtp:111 minptime=10;useinbandfec=1 a=ssrc:350842737 cname:yvKPspsHcYcwGFTw a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw a=ssrc:350842737 label:DfQnKjQQuwceLFdV a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates m=video 9 UDP/TLS/RTP/SAVPF 96 c=IN IP4 0.0.0.0 a=setup:active a=mid:1 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:96 VP8/90000 a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=sendrecv Inilah yang kita ketahui dari pesan ini:\nKita memiliki dua media section, satu audio dan satu video. Keduanya adalah transceiver sendrecv. Kita menerima dua stream, dan kita dapat mengirim dua kembali. Kita memiliki ICE Candidate dan detail autentikasi, jadi kita dapat mencoba untuk terhubung. Kita memiliki fingerprint sertifikat, jadi kita dapat melakukan panggilan yang aman. Topik Lebih Lanjut # Dalam versi selanjutnya dari buku ini, topik berikut juga akan dibahas:\nRenegotiation Simulcast "},{"id":2,"href":"/id/docs/03-connecting/","title":"Connecting","section":"Docs","content":" Connecting # Mengapa WebRTC membutuhkan subsistem khusus untuk tersambung? # Sebagian besar aplikasi yang digunakan saat ini membangun koneksi client/server. Koneksi client/server mengharuskan server memiliki alamat transpor yang stabil dan diketahui. Client menghubungi server, dan server merespons.\nWebRTC tidak menggunakan model client/server, melainkan membangun koneksi peer-to-peer (P2P). Dalam koneksi P2P, tugas membuat koneksi didistribusikan secara merata ke kedua peer. Ini karena alamat transpor (IP dan port) di WebRTC tidak dapat diasumsikan, dan bahkan mungkin berubah selama sesi. WebRTC akan mengumpulkan semua informasi yang bisa didapat dan akan berusaha keras untuk mencapai komunikasi dua arah antara dua klien WebRTC.\nMembangun konektivitas peer-to-peer bisa sulit. Klien-klien ini bisa berada di jaringan yang berbeda tanpa konektivitas langsung. Dalam situasi di mana konektivitas langsung memang ada, Anda masih bisa menghadapi masalah lain. Dalam beberapa kasus, klien Anda tidak menggunakan protokol jaringan yang sama (UDP \u0026lt;-\u0026gt; TCP) atau mungkin menggunakan Versi IP yang berbeda (IPv4 \u0026lt;-\u0026gt; IPv6).\nTerlepas dari kesulitan dalam mengatur koneksi P2P, Anda mendapatkan keuntungan dibanding teknologi Client/Server tradisional karena atribut berikut yang ditawarkan WebRTC.\nPengurangan Biaya Bandwidth # Karena komunikasi media terjadi langsung antar peer, Anda tidak perlu membayar atau meng-host server terpisah untuk meneruskan media.\nLatensi Lebih Rendah # Komunikasi lebih cepat ketika langsung! Ketika pengguna harus menjalankan semua melalui server Anda, itu membuat transmisi lebih lambat.\nKomunikasi E2E yang Aman # Komunikasi langsung lebih aman. Karena pengguna tidak merutekan data melalui server Anda, mereka bahkan tidak perlu mempercayai Anda untuk tidak mendekripsinya.\nBagaimana cara kerjanya? # Proses yang dijelaskan di atas disebut Interactive Connectivity Establishment (ICE). Protokol lain yang sudah ada sebelum WebRTC.\nICE adalah protokol yang mencoba menemukan cara terbaik untuk berkomunikasi antara dua ICE Agent. Setiap ICE Agent mempublikasikan cara-cara ia dapat dijangkau, ini dikenal sebagai candidate. Candidate pada dasarnya adalah alamat transpor dari agent yang ia yakini dapat dijangkau oleh peer lainnya. ICE kemudian menentukan pasangan candidate terbaik.\nProses ICE yang sebenarnya dijelaskan lebih detail nanti di bab ini. Untuk memahami mengapa ICE ada, berguna untuk memahami perilaku jaringan apa yang kita atasi.\nKendala jaringan di dunia nyata # ICE adalah tentang mengatasi kendala jaringan di dunia nyata. Sebelum kita mengeksplorasi solusinya, mari kita bicarakan masalah sebenarnya.\nTidak dalam jaringan yang sama # Sebagian besar waktu, klien WebRTC lainnya bahkan tidak akan berada dalam jaringan yang sama. Panggilan khas biasanya terjadi antara dua klien WebRTC di jaringan yang berbeda tanpa konektivitas langsung.\nBerikut adalah grafik dari dua jaringan yang berbeda, terhubung melalui internet publik. Di setiap jaringan Anda memiliki dua host.\nUntuk host dalam jaringan yang sama, sangat mudah untuk terhubung. Komunikasi antara 192.168.0.1 -\u0026gt; 192.168.0.2 mudah dilakukan! Kedua host ini dapat terhubung satu sama lain tanpa bantuan luar.\nNamun, host yang menggunakan Router B tidak memiliki cara untuk langsung mengakses apapun di belakang Router A. Bagaimana Anda membedakan antara 192.168.0.1 di belakang Router A dan IP yang sama di belakang Router B? Mereka adalah IP pribadi! Host yang menggunakan Router B dapat mengirim traffic langsung ke Router A, tetapi permintaan akan berakhir di situ. Bagaimana Router A tahu host mana yang harus ia teruskan pesannya?\nPembatasan Protokol # Beberapa jaringan tidak mengizinkan traffic UDP sama sekali, atau mungkin mereka tidak mengizinkan TCP. Beberapa jaringan mungkin memiliki MTU (Maximum Transmission Unit) yang sangat rendah. Ada banyak variabel yang dapat diubah oleh administrator jaringan yang dapat menyulitkan komunikasi.\nAturan Firewall/IDS # Lainnya adalah \u0026ldquo;Deep Packet Inspection\u0026rdquo; dan penyaringan cerdas lainnya. Beberapa administrator jaringan akan menjalankan perangkat lunak yang mencoba memproses setiap paket. Seringkali perangkat lunak ini tidak memahami WebRTC, jadi ia memblokirnya karena tidak tahu harus berbuat apa, misalnya memperlakukan paket WebRTC sebagai paket UDP yang mencurigakan pada port acak yang tidak masuk whitelist.\nPemetaan NAT # Pemetaan NAT (Network Address Translation) adalah keajaiban yang membuat konektivitas WebRTC mungkin. Inilah cara WebRTC memungkinkan dua peer di subnet yang benar-benar berbeda untuk berkomunikasi, menangani masalah \u0026ldquo;tidak dalam jaringan yang sama\u0026rdquo; di atas. Meskipun ini menciptakan tantangan baru, mari kita jelaskan bagaimana pemetaan NAT bekerja pada awalnya.\nIni tidak menggunakan relay, proxy, atau server. Sekali lagi kita memiliki Agent 1 dan Agent 2 dan mereka berada di jaringan yang berbeda. Namun, traffic mengalir sepenuhnya. Divisualisasikan terlihat seperti ini:\nUntuk membuat komunikasi ini terjadi, Anda membentuk pemetaan NAT. Agent 1 menggunakan port 7000 untuk membangun koneksi WebRTC dengan Agent 2. Ini menciptakan pengikatan dari 192.168.0.1:7000 ke 5.0.0.1:7000. Ini kemudian memungkinkan Agent 2 untuk mencapai Agent 1 dengan mengirimkan paket ke 5.0.0.1:7000. Membuat pemetaan NAT seperti dalam contoh ini seperti versi otomatis dari melakukan port forwarding di router Anda.\nKelemahan pemetaan NAT adalah bahwa tidak ada satu bentuk pemetaan tunggal (misalnya port forwarding statis), dan perilakunya tidak konsisten antar jaringan. ISP dan produsen perangkat keras mungkin melakukannya dengan cara berbeda. Dalam beberapa kasus, administrator jaringan bahkan mungkin menonaktifkannya.\nKabar baiknya adalah rentang lengkap perilaku dipahami dan dapat diamati, sehingga ICE Agent mampu mengonfirmasi ia telah membuat pemetaan NAT, dan atribut pemetaan.\nDokumen yang menjelaskan perilaku ini adalah RFC 4787.\nMembuat pemetaan # Membuat pemetaan adalah bagian paling mudah. Ketika Anda mengirim paket ke alamat di luar jaringan Anda, pemetaan dibuat! Pemetaan NAT hanyalah IP publik sementara dan port yang dialokasikan oleh NAT Anda. Pesan keluar akan ditulis ulang agar alamat sumbernya diberikan oleh alamat pemetaan yang baru. Jika pesan dikirim ke pemetaan, itu akan secara otomatis dirutekan kembali ke host di dalam NAT yang membuatnya. Detail seputar pemetaan adalah di mana ia menjadi rumit.\nPerilaku Pembuatan Pemetaan # Pembuatan pemetaan terbagi dalam tiga kategori berbeda:\nEndpoint-Independent Mapping # Satu pemetaan dibuat untuk setiap pengirim di dalam NAT. Jika Anda mengirim dua paket ke dua alamat remote yang berbeda, pemetaan NAT akan digunakan kembali. Kedua host remote akan melihat IP dan port sumber yang sama. Jika host remote merespons, itu akan dikirim kembali ke pendengar lokal yang sama.\nIni adalah skenario terbaik. Agar panggilan berfungsi, setidaknya satu sisi HARUS dari tipe ini.\nAddress Dependent Mapping # Pemetaan baru dibuat setiap kali Anda mengirim paket ke alamat baru. Jika Anda mengirim dua paket ke host yang berbeda, dua pemetaan akan dibuat. Jika Anda mengirim dua paket ke host remote yang sama tetapi port tujuan yang berbeda, pemetaan baru TIDAK akan dibuat.\nAddress and Port Dependent Mapping # Pemetaan baru dibuat jika IP atau port remote berbeda. Jika Anda mengirim dua paket ke host remote yang sama, tetapi port tujuan yang berbeda, pemetaan baru akan dibuat.\nPerilaku Penyaringan Pemetaan # Penyaringan pemetaan adalah aturan tentang siapa yang diizinkan menggunakan pemetaan. Mereka terbagi dalam tiga klasifikasi serupa:\nEndpoint-Independent Filtering # Siapa saja dapat menggunakan pemetaan. Anda dapat membagikan pemetaan dengan beberapa peer lain, dan mereka semua dapat mengirim traffic ke sana.\nAddress Dependent Filtering # Hanya host untuk siapa pemetaan dibuat yang dapat menggunakan pemetaan. Jika Anda mengirim paket ke host A Anda hanya dapat mendapat respons dari host yang sama. Jika host B mencoba mengirim paket ke pemetaan itu, itu akan diabaikan.\nAddress and Port Dependent Filtering # Hanya host dan port untuk siapa pemetaan dibuat yang dapat menggunakan pemetaan itu. Jika Anda mengirim paket ke A:5000 Anda hanya dapat mendapat respons dari host dan port yang sama. Jika A:5001 mencoba mengirim paket ke pemetaan itu, itu akan diabaikan.\nPenyegaran Pemetaan # Disarankan agar jika pemetaan tidak digunakan selama 5 menit, pemetaan harus dihancurkan. Ini sepenuhnya tergantung pada ISP atau produsen perangkat keras.\nSTUN # STUN (Session Traversal Utilities for NAT) adalah protokol yang dibuat khusus untuk bekerja dengan NAT. Ini adalah teknologi lain yang sudah ada sebelum WebRTC (dan ICE!). Ini didefinisikan oleh RFC 8489, yang juga mendefinisikan struktur paket STUN. Protokol STUN juga digunakan oleh ICE/TURN.\nSTUN berguna karena memungkinkan pembuatan pemetaan NAT secara programatik. Sebelum STUN, kita dapat membuat pemetaan NAT, tetapi kita tidak tahu apa IP dan port-nya! STUN tidak hanya memberi Anda kemampuan untuk membuat pemetaan, tetapi juga memberi Anda detailnya sehingga Anda dapat membagikannya dengan orang lain, sehingga mereka dapat mengirim traffic kembali kepada Anda melalui pemetaan yang baru saja Anda buat.\nMari kita mulai dengan deskripsi dasar STUN. Nanti, kita akan memperluas penggunaan TURN dan ICE. Untuk saat ini, kita hanya akan menjelaskan alur Request/Response untuk membuat pemetaan. Kemudian kita akan membicarakan cara mendapatkan detailnya untuk dibagikan dengan orang lain. Ini adalah proses yang terjadi ketika Anda memiliki server stun: dalam ICE URL Anda untuk WebRTC PeerConnection. Singkatnya, STUN membantu endpoint di belakang NAT mengetahui pemetaan apa yang dibuat dengan meminta server STUN di luar NAT untuk melaporkan apa yang diamatinya.\nStruktur Protokol # Setiap paket STUN memiliki struktur berikut:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN Message Type # Setiap paket STUN memiliki tipe. Untuk saat ini, kita hanya peduli tentang yang berikut:\nBinding Request - 0x0001 Binding Response - 0x0101 Untuk membuat pemetaan NAT kita membuat Binding Request. Kemudian server merespons dengan Binding Response.\nMessage Length # Ini adalah panjang bagian Data. Bagian ini berisi data sembarang yang didefinisikan oleh Message Type.\nMagic Cookie # Nilai tetap 0x2112A442 dalam urutan byte jaringan, ini membantu membedakan traffic STUN dari protokol lain.\nTransaction ID # Pengenal 96-bit yang secara unik mengidentifikasi request/response. Ini membantu Anda memasangkan request dan response Anda.\nData # Data akan berisi daftar atribut STUN. Atribut STUN memiliki struktur berikut:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Value (variable) .... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN Binding Request tidak menggunakan atribut. Ini berarti STUN Binding Request hanya berisi header.\nSTUN Binding Response menggunakan XOR-MAPPED-ADDRESS (0x0020). Atribut ini berisi IP dan port. Ini adalah IP dan port dari pemetaan NAT yang dibuat!\nMembuat Pemetaan NAT # Membuat pemetaan NAT menggunakan STUN hanya memerlukan pengiriman satu request! Anda mengirim STUN Binding Request ke STUN Server. STUN Server kemudian merespons dengan STUN Binding Response. STUN Binding Response ini akan berisi Mapped Address. Mapped Address adalah bagaimana STUN Server melihat Anda dan merupakan pemetaan NAT Anda. Mapped Address adalah yang akan Anda bagikan jika Anda ingin seseorang mengirimkan paket kepada Anda.\nOrang juga akan menyebut Mapped Address sebagai Public IP atau Server Reflexive Candidate Anda.\nMenentukan Tipe NAT # Sayangnya, Mapped Address mungkin tidak berguna dalam semua kasus. Jika itu adalah Address Dependent, hanya server STUN yang dapat mengirim traffic kembali kepada Anda. Jika Anda membagikannya dan peer lain mencoba mengirim pesan masuk, mereka akan dijatuhkan. Ini membuatnya tidak berguna untuk berkomunikasi dengan orang lain. Anda mungkin menemukan kasus Address Dependent sebenarnya dapat dipecahkan, jika host yang menjalankan server STUN juga dapat meneruskan paket untuk Anda ke peer! Ini membawa kita ke solusi menggunakan TURN di bawah ini.\nRFC 5780 mendefinisikan metode untuk menjalankan tes untuk menentukan Tipe NAT Anda. Ini berguna karena Anda akan tahu sebelumnya apakah konektivitas langsung mungkin.\nTURN # TURN (Traversal Using Relays around NAT) didefinisikan dalam RFC 8656 adalah solusi ketika konektivitas langsung tidak mungkin. Ini bisa karena Anda memiliki dua Tipe NAT yang tidak kompatibel, atau mungkin tidak dapat berbicara dengan protokol yang sama! TURN juga dapat digunakan untuk tujuan privasi. Dengan menjalankan semua komunikasi Anda melalui TURN Anda menyembunyikan alamat sebenarnya klien.\nTURN menggunakan server khusus. Server ini bertindak sebagai proxy untuk klien. Klien terhubung ke TURN Server dan membuat Allocation. Dengan membuat alokasi, klien mendapatkan IP/Port/Protokol sementara yang dapat digunakan untuk mengirim traffic kembali ke klien. Pendengar baru ini dikenal sebagai Relayed Transport Address. Anggap itu sebagai alamat penerusan, Anda memberikan ini sehingga orang lain dapat mengirimkan traffic kepada Anda melalui TURN! Untuk setiap peer yang Anda berikan Relay Transport Address, Anda harus membuat Permission baru untuk mengizinkan komunikasi dengan Anda.\nKetika Anda mengirim traffic keluar melalui TURN, itu dikirim melalui Relayed Transport Address. Ketika peer remote mendapat traffic, mereka melihatnya datang dari TURN Server.\nSiklus Hidup TURN # Berikut adalah semua yang harus dilakukan oleh klien yang ingin membuat alokasi TURN. Berkomunikasi dengan seseorang yang menggunakan TURN tidak memerlukan perubahan. Peer lain mendapat IP dan port, dan mereka berkomunikasi dengannya seperti host lainnya.\nAllocations # Allocation adalah inti dari TURN. Allocation pada dasarnya adalah \u0026ldquo;TURN Session\u0026rdquo;. Untuk membuat alokasi TURN, Anda berkomunikasi dengan TURN Server Transport Address (biasanya port 3478).\nSaat membuat alokasi, Anda perlu memberikan yang berikut:\nUsername/Password - Membuat alokasi TURN memerlukan autentikasi. Allocation Transport - Protokol transpor antara server (Relayed Transport Address) dan peer, bisa UDP atau TCP. Even-Port - Anda dapat meminta port berurutan untuk beberapa alokasi, tidak relevan untuk WebRTC. Jika request berhasil, Anda mendapat respons dengan TURN Server dengan Atribut STUN berikut di bagian Data:\nXOR-MAPPED-ADDRESS - Mapped Address dari TURN Client. Ketika seseorang mengirim data ke Relayed Transport Address ini adalah tempat ia diteruskan. RELAYED-ADDRESS - Ini adalah alamat yang Anda berikan kepada klien lain. Jika seseorang mengirim paket ke alamat ini, itu diteruskan ke klien TURN. LIFETIME - Berapa lama sampai Alokasi TURN ini dihancurkan. Anda dapat memperpanjang masa hidup dengan mengirim request Refresh. Permissions # Host remote tidak dapat mengirim ke Relayed Transport Address Anda sampai Anda membuat izin untuk mereka. Ketika Anda membuat izin, Anda memberi tahu server TURN bahwa IP dan port ini diizinkan untuk mengirim traffic masuk.\nHost remote perlu memberi Anda IP dan port seperti yang terlihat oleh server TURN. Ini berarti ia harus mengirim STUN Binding Request ke TURN Server. Kasus kesalahan umum adalah bahwa host remote akan mengirim STUN Binding Request ke server yang berbeda. Mereka kemudian akan meminta Anda untuk membuat izin untuk IP ini.\nKatakanlah Anda ingin membuat izin untuk host di belakang Address Dependent Mapping. Jika Anda menghasilkan Mapped Address dari server TURN yang berbeda, semua traffic masuk akan dijatuhkan. Setiap kali mereka berkomunikasi dengan host yang berbeda, itu menghasilkan pemetaan baru. Izin kedaluwarsa setelah 5 menit jika tidak disegarkan.\nSendIndication/ChannelData # Kedua pesan ini adalah untuk TURN Client mengirim pesan ke peer remote.\nSendIndication adalah pesan yang berdiri sendiri. Di dalamnya adalah data yang ingin Anda kirim, dan kepada siapa Anda ingin mengirimnya. Ini boros jika Anda mengirim banyak pesan ke peer remote. Jika Anda mengirim 1.000 pesan, Anda akan mengulangi Alamat IP mereka 1.000 kali!\nChannelData memungkinkan Anda mengirim data, tetapi tidak mengulangi Alamat IP. Anda membuat Channel dengan IP dan port. Anda kemudian mengirim dengan ChannelId, dan IP serta port akan diisi di sisi server. Ini adalah pilihan yang lebih baik jika Anda mengirim banyak pesan.\nRefreshing # Alokasi akan menghancurkan diri mereka sendiri secara otomatis. TURN Client harus menyegarkannya lebih cepat dari LIFETIME yang diberikan saat membuat alokasi.\nPenggunaan TURN # Penggunaan TURN ada dalam dua bentuk. Biasanya, Anda memiliki satu peer yang bertindak sebagai \u0026ldquo;TURN Client\u0026rdquo; dan sisi lain berkomunikasi langsung. Dalam beberapa kasus Anda mungkin memiliki penggunaan TURN di kedua sisi, misalnya karena kedua klien berada di jaringan yang memblokir UDP dan oleh karena itu koneksi ke server TURN masing-masing terjadi melalui TCP.\nDiagram ini membantu menggambarkan seperti apa itu.\nSatu Alokasi TURN untuk Komunikasi # Dua Alokasi TURN untuk Komunikasi # ICE # ICE (Interactive Connectivity Establishment) adalah bagaimana WebRTC menghubungkan dua Agent. Didefinisikan dalam RFC 8445, ini adalah teknologi lain yang sudah ada sebelum WebRTC! ICE adalah protokol untuk membangun konektivitas. Ini menentukan semua rute yang mungkin antara kedua peer dan kemudian memastikan Anda tetap terhubung.\nRute-rute ini dikenal sebagai Candidate Pair, yang merupakan pasangan alamat transpor lokal dan remote. Di sinilah STUN dan TURN ikut bermain dengan ICE. Alamat ini dapat berupa Alamat IP lokal Anda plus port, pemetaan NAT, atau Relayed Transport Address. Setiap sisi mengumpulkan semua alamat yang ingin mereka gunakan, menukarnya, dan kemudian mencoba untuk terhubung!\nDua ICE Agent berkomunikasi menggunakan paket ping ICE (atau secara resmi disebut pemeriksaan konektivitas) untuk membangun konektivitas. Setelah konektivitas terbentuk, mereka dapat mengirim data apa pun yang mereka inginkan. Ini akan seperti menggunakan socket normal. Pemeriksaan ini menggunakan protokol STUN.\nMembuat ICE Agent # ICE Agent adalah Controlling atau Controlled. Controlling Agent adalah yang memutuskan Candidate Pair yang dipilih. Biasanya, peer yang mengirim offer adalah sisi controlling.\nSetiap sisi harus memiliki user fragment dan password. Kedua nilai ini harus ditukar sebelum pemeriksaan konektivitas bahkan dapat dimulai. user fragment dikirim dalam teks biasa dan berguna untuk demuxing beberapa Sesi ICE. password digunakan untuk menghasilkan atribut MESSAGE-INTEGRITY. Di akhir setiap paket STUN, ada atribut yang merupakan hash dari seluruh paket menggunakan password sebagai kunci. Ini digunakan untuk mengautentikasi paket dan memastikan itu tidak dirusak.\nUntuk WebRTC, semua nilai ini didistribusikan melalui Session Description seperti dijelaskan di bab sebelumnya.\nPengumpulan Candidate # Kita sekarang perlu mengumpulkan semua alamat yang mungkin di mana kita dapat dijangkau. Alamat ini dikenal sebagai candidate.\nHost # Candidate Host mendengarkan langsung pada antarmuka lokal. Ini dapat berupa UDP atau TCP.\nmDNS # Candidate mDNS mirip dengan candidate host, tetapi alamat IP-nya disamarkan. Alih-alih memberi tahu sisi lain tentang alamat IP Anda, Anda memberi mereka UUID sebagai hostname. Anda kemudian menyiapkan pendengar multicast, dan merespons jika ada yang meminta UUID yang Anda publikasikan.\nJika Anda berada di jaringan yang sama dengan agent, Anda dapat menemukan satu sama lain melalui Multicast. Jika Anda tidak berada di jaringan yang sama, Anda tidak akan dapat terhubung (kecuali administrator jaringan secara eksplisit mengonfigurasi jaringan untuk mengizinkan paket Multicast melewati).\nIni berguna untuk tujuan privasi. Pengguna dapat mengetahui alamat IP lokal Anda melalui WebRTC dengan candidate Host (tanpa bahkan mencoba terhubung kepada Anda), tetapi dengan candidate mDNS, sekarang mereka hanya mendapat UUID acak.\nServer Reflexive # Candidate Server Reflexive dihasilkan dengan melakukan STUN Binding Request ke STUN Server.\nKetika Anda mendapat STUN Binding Response, XOR-MAPPED-ADDRESS adalah Candidate Server Reflexive Anda.\nPeer Reflexive # Candidate Peer Reflexive dibuat ketika peer remote menerima request Anda dari alamat yang sebelumnya tidak diketahui oleh peer. Setelah menerima, peer melaporkan (memantulkan) alamat yang disebutkan kembali kepada Anda. Peer tahu bahwa request dikirim oleh Anda dan bukan orang lain karena ICE adalah protokol yang terautentikasi.\nIni umumnya terjadi ketika Host Candidate berkomunikasi dengan Server Reflexive Candidate yang berada di subnet yang berbeda, yang menghasilkan pemetaan NAT baru yang dibuat. Ingat kita mengatakan pemeriksaan konektivitas sebenarnya adalah paket STUN? Format respons STUN secara alami memungkinkan peer untuk melaporkan kembali alamat peer-reflexive.\nRelay # Candidate Relay dihasilkan dengan menggunakan TURN Server.\nSetelah handshake awal dengan TURN Server, Anda diberi RELAYED-ADDRESS, ini adalah Candidate Relay Anda.\nPemeriksaan Konektivitas # Kita sekarang tahu user fragment, password, dan candidate dari agent remote. Kita sekarang dapat mencoba untuk terhubung! Setiap candidate dipasangkan satu sama lain. Jadi jika Anda memiliki 3 candidate di setiap sisi, Anda sekarang memiliki 9 pasangan candidate.\nSecara visual terlihat seperti ini:\nPemilihan Candidate # Controlling dan Controlled Agent keduanya mulai mengirim traffic pada setiap pasangan. Ini diperlukan jika satu Agent berada di belakang Address Dependent Mapping, ini akan menyebabkan Peer Reflexive Candidate dibuat.\nSetiap Candidate Pair yang melihat traffic jaringan kemudian dipromosikan ke pasangan Valid Candidate. Controlling Agent kemudian mengambil satu pasangan Valid Candidate dan menominasikannya. Ini menjadi Nominated Pair. Controlling dan Controlled Agent kemudian mencoba satu putaran lagi komunikasi dua arah. Jika itu berhasil, Nominated Pair menjadi Selected Candidate Pair! Pasangan ini kemudian digunakan untuk sisa sesi.\nRestart # Jika Selected Candidate Pair berhenti bekerja karena alasan apa pun (pemetaan NAT kedaluwarsa, TURN Server crash) ICE Agent akan masuk ke status Failed. Kedua agent dapat di-restart dan akan melakukan seluruh proses lagi.\n"},{"id":3,"href":"/id/docs/04-securing/","title":"Securing","section":"Docs","content":" Securing # Keamanan apa yang dimiliki WebRTC? # Setiap koneksi WebRTC diautentikasi dan dienkripsi. Anda dapat yakin bahwa pihak ketiga tidak dapat melihat apa yang Anda kirim atau menyisipkan pesan palsu. Anda juga dapat yakin bahwa klien WebRTC yang membuat Session Description adalah yang Anda komunikasikan dengannya.\nSangat penting bahwa tidak ada yang merusak pesan-pesan tersebut. Tidak apa-apa jika pihak ketiga membaca Session Description saat transit. Namun, WebRTC tidak memiliki perlindungan terhadap modifikasinya. Penyerang dapat melakukan serangan man-in-the-middle pada Anda dengan mengubah ICE Candidate dan memperbarui Certificate Fingerprint.\nBagaimana cara kerjanya? # WebRTC menggunakan dua protokol yang sudah ada sebelumnya, Datagram Transport Layer Security (DTLS) dan Secure Real-time Transport Protocol (SRTP).\nDTLS memungkinkan Anda untuk menegosiasikan sesi dan kemudian bertukar data secara aman antara dua peer. Ini adalah saudara dari TLS, teknologi yang sama yang mendukung HTTPS, tetapi DTLS menggunakan UDP alih-alih TCP sebagai transport layer. Itu berarti protokol harus menangani pengiriman yang tidak andal. SRTP dirancang khusus untuk bertukar media secara aman. Ada beberapa optimisasi yang dapat kita lakukan dengan menggunakannya daripada DTLS.\nDTLS digunakan terlebih dahulu. Ia melakukan handshake melalui koneksi yang disediakan oleh ICE. DTLS adalah protokol client/server, jadi satu sisi perlu memulai handshake. Peran Client/Server dipilih selama signaling. Selama handshake DTLS, kedua sisi menawarkan sertifikat. Setelah handshake selesai, sertifikat ini dibandingkan dengan hash sertifikat di Session Description. Ini untuk memastikan bahwa handshake terjadi dengan klien WebRTC yang Anda harapkan. Koneksi DTLS kemudian tersedia untuk digunakan untuk komunikasi DataChannel.\nUntuk membuat sesi SRTP kita menginisialisasinya menggunakan kunci yang dihasilkan oleh DTLS. SRTP tidak memiliki mekanisme handshake, jadi harus di-bootstrap dengan kunci eksternal. Setelah ini selesai, media dapat dipertukarkan yang dienkripsi menggunakan SRTP!\nSecurity 101 # Untuk memahami teknologi yang disajikan dalam bab ini, Anda perlu memahami istilah-istilah ini terlebih dahulu. Kriptografi adalah subjek yang rumit, jadi akan bermanfaat untuk berkonsultasi dengan sumber lain juga!\nPlaintext dan Ciphertext # Plaintext adalah input ke cipher. Ciphertext adalah output dari cipher.\nCipher # Cipher adalah serangkaian langkah yang mengubah plaintext menjadi ciphertext. Cipher kemudian dapat dibalik, sehingga Anda dapat mengubah ciphertext Anda kembali ke plaintext. Cipher biasanya memiliki kunci untuk mengubah perilakunya. Istilah lain untuk ini adalah enkripsi dan dekripsi.\nCipher sederhana adalah ROT13. Setiap huruf dipindahkan 13 karakter ke depan. Untuk membatalkan cipher Anda memindahkan 13 karakter ke belakang. Plaintext HELLO akan menjadi ciphertext URYYB. Dalam hal ini, Cipher adalah ROT, dan kuncinya adalah 13.\nFungsi Hash # Fungsi hash kriptografi adalah proses satu arah yang menghasilkan digest. Diberikan input, ia menghasilkan output yang sama setiap kali. Penting bahwa outputnya tidak dapat dibalik. Jika Anda memiliki output, Anda seharusnya tidak dapat menentukan inputnya. Hashing berguna ketika Anda ingin mengonfirmasi bahwa pesan tidak dirusak.\nFungsi hash sederhana (walaupun tentu tidak cocok untuk kriptografi nyata) adalah hanya mengambil setiap huruf lainnya. HELLO akan menjadi HLO. Anda tidak dapat mengasumsikan HELLO adalah inputnya, tetapi Anda dapat mengonfirmasi bahwa HELLO akan cocok dengan digest hash.\nKriptografi Public/Private Key # Kriptografi Public/Private Key menggambarkan jenis cipher yang digunakan DTLS dan SRTP. Dalam sistem ini, Anda memiliki dua kunci, kunci publik dan pribadi. Kunci publik untuk mengenkripsi pesan dan aman untuk dibagikan. Kunci pribadi untuk mendekripsi, dan tidak boleh dibagikan. Ini adalah satu-satunya kunci yang dapat mendekripsi pesan yang dienkripsi dengan kunci publik.\nPertukaran Diffie–Hellman # Pertukaran Diffie–Hellman memungkinkan dua pengguna yang tidak pernah bertemu sebelumnya untuk membuat shared secret secara aman melalui internet. Pengguna A dapat mengirim rahasia ke Pengguna B tanpa khawatir tentang penyadapan. Ini bergantung pada kesulitan memecahkan masalah logaritma diskrit. Anda tidak perlu sepenuhnya memahami bagaimana ini bekerja, tetapi ini membantu untuk mengetahui inilah yang membuat handshake DTLS mungkin.\nWikipedia memiliki contoh ini dalam tindakan di sini.\nFungsi Pseudorandom # Fungsi Pseudorandom (PRF) adalah fungsi yang telah ditentukan untuk menghasilkan nilai yang tampak acak. Ini mungkin mengambil beberapa input dan menghasilkan satu output.\nFungsi Derivasi Kunci # Derivasi Kunci adalah jenis Fungsi Pseudorandom. Derivasi Kunci adalah fungsi yang digunakan untuk membuat kunci lebih kuat. Satu pola umum adalah key stretching.\nKatakanlah Anda diberi kunci yang berukuran 8 byte. Anda dapat menggunakan KDF untuk membuatnya lebih kuat.\nNonce # Nonce adalah input tambahan ke cipher. Ini digunakan sehingga Anda bisa mendapatkan output yang berbeda dari cipher, bahkan jika Anda mengenkripsi pesan yang sama beberapa kali.\nJika Anda mengenkripsi pesan yang sama 10 kali, cipher akan memberi Anda ciphertext yang sama 10 kali. Dengan menggunakan nonce Anda dapat mendapatkan output yang berbeda, sambil tetap menggunakan kunci yang sama. Penting Anda menggunakan nonce yang berbeda untuk setiap pesan! Jika tidak, itu meniadakan banyak nilainya.\nMessage Authentication Code # Message Authentication Code adalah hash yang ditempatkan di akhir pesan. MAC membuktikan bahwa pesan berasal dari pengguna yang Anda harapkan.\nJika Anda tidak menggunakan MAC, penyerang dapat menyisipkan pesan yang tidak valid. Setelah mendekripsi Anda hanya akan mendapatkan sampah karena mereka tidak tahu kuncinya.\nRotasi Kunci # Rotasi Kunci adalah praktik mengubah kunci Anda pada interval. Ini membuat kunci yang dicuri kurang berdampak. Jika kunci dicuri atau bocor, lebih sedikit data yang dapat didekripsi.\nDTLS # DTLS (Datagram Transport Layer Security) memungkinkan dua peer untuk membangun komunikasi yang aman tanpa konfigurasi yang sudah ada sebelumnya. Bahkan jika seseorang menguping percakapan, mereka tidak akan dapat mendekripsi pesan.\nUntuk DTLS Client dan Server berkomunikasi, mereka perlu menyetujui cipher dan kunci. Mereka menentukan nilai-nilai ini dengan melakukan handshake DTLS. Selama handshake, pesan dalam plaintext. Ketika DTLS Client/Server telah bertukar cukup detail untuk mulai mengenkripsi, ia mengirim Change Cipher Spec. Setelah pesan ini, setiap pesan berikutnya akan dienkripsi!\nFormat Paket # Setiap paket DTLS dimulai dengan header.\nContent Type # Anda dapat mengharapkan tipe berikut:\n20 - Change Cipher Spec 22 - Handshake 23 - Application Data Handshake digunakan untuk bertukar detail untuk memulai sesi. Change Cipher Spec digunakan untuk memberi tahu sisi lain bahwa semuanya akan dienkripsi. Application Data adalah pesan yang dienkripsi.\nVersion # Version dapat berupa 0x0000feff (DTLS v1.0) atau 0x0000fefd (DTLS v1.2) tidak ada v1.1.\nEpoch # Epoch dimulai dari 0, tetapi menjadi 1 setelah Change Cipher Spec. Pesan apa pun dengan epoch non-nol dienkripsi.\nSequence Number # Sequence Number digunakan untuk menjaga pesan tetap teratur. Setiap pesan meningkatkan Sequence Number. Ketika epoch bertambah, Sequence Number dimulai dari awal.\nLength dan Payload # Payload adalah Content Type spesifik. Untuk Application Data, Payload adalah data yang dienkripsi. Untuk Handshake akan berbeda tergantung pada pesannya. Panjang adalah untuk seberapa besar Payload.\nHandshake State Machine # Selama handshake, Client/Server bertukar serangkaian pesan. Pesan-pesan ini dikelompokkan ke dalam flight. Setiap flight mungkin memiliki beberapa pesan di dalamnya (atau hanya satu). Flight tidak lengkap sampai semua pesan dalam flight telah diterima. Kami akan menjelaskan tujuan setiap pesan lebih detail di bawah ini.\nClientHello # ClientHello adalah pesan awal yang dikirim oleh client. Ini berisi daftar atribut. Atribut ini memberi tahu server cipher dan fitur yang didukung client. Untuk WebRTC ini adalah bagaimana kita memilih SRTP Cipher juga. Ini juga berisi data acak yang akan digunakan untuk menghasilkan kunci untuk sesi.\nHelloVerifyRequest # HelloVerifyRequest dikirim oleh server ke client. Ini untuk memastikan bahwa client bermaksud mengirim permintaan. Client kemudian mengirim ulang ClientHello, tetapi dengan token yang disediakan dalam HelloVerifyRequest.\nServerHello # ServerHello adalah respons oleh server untuk konfigurasi sesi ini. Ini berisi cipher apa yang akan digunakan ketika sesi ini selesai. Ini juga berisi data acak server.\nCertificate # Certificate berisi sertifikat untuk Client atau Server. Ini digunakan untuk mengidentifikasi secara unik dengan siapa kita berkomunikasi. Setelah handshake selesai, kita akan memastikan sertifikat ini ketika di-hash cocok dengan fingerprint di SessionDescription.\nServerKeyExchange/ClientKeyExchange # Pesan ini digunakan untuk mengirimkan kunci publik. Saat startup, client dan server keduanya menghasilkan keypair. Setelah handshake nilai-nilai ini akan digunakan untuk menghasilkan Pre-Master Secret.\nCertificateRequest # CertificateRequest dikirim oleh server yang memberi tahu client bahwa ia menginginkan sertifikat. Server dapat Meminta atau Mengharuskan sertifikat.\nServerHelloDone # ServerHelloDone memberi tahu client bahwa server selesai dengan handshake.\nCertificateVerify # CertificateVerify adalah bagaimana pengirim membuktikan bahwa ia memiliki kunci pribadi yang dikirim dalam pesan Certificate.\nChangeCipherSpec # ChangeCipherSpec memberi tahu penerima bahwa segala sesuatu yang dikirim setelah pesan ini akan dienkripsi.\nFinished # Finished dienkripsi dan berisi hash dari semua pesan. Ini untuk menegaskan bahwa handshake tidak dirusak.\nPembuatan Kunci # Setelah Handshake selesai, Anda dapat mulai mengirim data terenkripsi. Cipher dipilih oleh server dan ada di ServerHello. Bagaimana kuncinya dipilih?\nPertama kita menghasilkan Pre-Master Secret. Untuk mendapatkan nilai ini, Diffie–Hellman digunakan pada kunci yang dipertukarkan oleh ServerKeyExchange dan ClientKeyExchange. Detailnya berbeda tergantung pada Cipher yang dipilih.\nSelanjutnya Master Secret dihasilkan. Setiap versi DTLS memiliki Pseudorandom function yang ditentukan. Untuk DTLS 1.2 fungsi tersebut mengambil Pre-Master Secret dan nilai acak di ClientHello dan ServerHello. Output dari menjalankan Pseudorandom Function adalah Master Secret. Master Secret adalah nilai yang digunakan untuk Cipher.\nBertukar ApplicationData # Kuda beban DTLS adalah ApplicationData. Sekarang kita memiliki cipher yang diinisialisasi, kita dapat mulai mengenkripsi dan mengirimkan nilai.\nPesan ApplicationData menggunakan header DTLS seperti yang dijelaskan sebelumnya. Payload diisi dengan ciphertext. Anda sekarang memiliki Sesi DTLS yang berfungsi dan dapat berkomunikasi dengan aman.\nDTLS memiliki banyak fitur menarik lainnya seperti renegosiasi. Mereka tidak digunakan oleh WebRTC, jadi tidak akan dibahas di sini.\nSRTP # SRTP adalah protokol yang dirancang khusus untuk mengenkripsi paket RTP. Untuk memulai sesi SRTP Anda menentukan kunci dan cipher Anda. Tidak seperti DTLS ia tidak memiliki mekanisme handshake. Semua konfigurasi dan kunci dihasilkan selama handshake DTLS.\nDTLS menyediakan API khusus untuk mengekspor kunci yang akan digunakan oleh proses lain. Ini didefinisikan dalam RFC 5705.\nPembuatan Sesi # SRTP mendefinisikan Key Derivation Function yang digunakan pada input. Ketika membuat Sesi SRTP, input dijalankan melalui ini untuk menghasilkan kunci kita untuk SRTP Cipher kita. Setelah ini Anda dapat melanjutkan untuk memproses media.\nBertukar Media # Setiap paket RTP memiliki SequenceNumber 16 bit. SequenceNumber ini digunakan untuk menjaga paket tetap teratur, seperti Primary Key. Selama panggilan ini akan berputar. SRTP melacaknya dan menyebutnya rollover counter.\nKetika mengenkripsi paket, SRTP menggunakan rollover counter dan sequence number sebagai nonce. Ini untuk memastikan bahwa bahkan jika Anda mengirim data yang sama dua kali, ciphertext akan berbeda. Ini penting untuk mencegah penyerang mengidentifikasi pola atau mencoba serangan replay.\n"},{"id":4,"href":"/id/docs/05-real-time-networking/","title":"Real-time Networking","section":"Docs","content":" Real-time Networking # Mengapa jaringan begitu penting dalam komunikasi Real-time? # Jaringan adalah faktor pembatas dalam komunikasi Real-time. Dalam dunia yang ideal kita akan memiliki bandwidth tak terbatas dan paket akan tiba secara instan. Namun ini tidak terjadi. Jaringan terbatas, dan kondisinya dapat berubah kapan saja. Mengukur dan mengamati kondisi jaringan juga merupakan masalah yang sulit. Anda bisa mendapatkan perilaku yang berbeda tergantung pada perangkat keras, perangkat lunak dan konfigurasinya.\nKomunikasi real-time juga menghadirkan masalah yang tidak ada di sebagian besar domain lain. Untuk developer web, tidak fatal jika situs web Anda lebih lambat di beberapa jaringan. Selama semua data tiba, pengguna senang. Dengan WebRTC, jika data Anda terlambat, itu tidak berguna. Tidak ada yang peduli tentang apa yang dikatakan dalam panggilan konferensi 5 detik yang lalu. Jadi ketika mengembangkan sistem komunikasi realtime, Anda harus membuat trade-off. Apa batas waktu saya, dan berapa banyak data yang dapat saya kirim?\nBab ini mencakup konsep yang berlaku untuk komunikasi data dan media. Pada bab selanjutnya kita akan melampaui teorinya dan membahas bagaimana subsistem media dan data WebRTC menyelesaikan masalah ini.\nApa atribut jaringan yang membuatnya sulit? # Kode yang efektif bekerja di semua jaringan adalah rumit. Anda memiliki banyak faktor berbeda, dan mereka semua dapat saling mempengaruhi secara halus. Ini adalah masalah paling umum yang akan dihadapi developer.\nBandwidth # Bandwidth adalah laju maksimum data yang dapat ditransfer melintasi jalur tertentu. Penting untuk diingat ini juga bukan angka statis. Bandwidth akan berubah sepanjang rute seiring lebih banyak (atau lebih sedikit) orang menggunakannya.\nTransmission Time dan Round Trip Time # Transmission Time adalah berapa lama waktu yang dibutuhkan paket untuk tiba di tujuannya. Seperti Bandwidth ini tidak konstan. Transmission Time dapat berfluktuasi kapan saja.\ntransmission_time = receive_time - send_time\nUntuk menghitung transmission time, Anda memerlukan jam pada pengirim dan penerima yang disinkronkan dengan presisi milidetik. Bahkan penyimpangan kecil akan menghasilkan pengukuran transmission time yang tidak dapat diandalkan. Karena WebRTC beroperasi di lingkungan yang sangat heterogen, hampir mustahil untuk mengandalkan sinkronisasi waktu sempurna antara host.\nPengukuran round-trip time adalah solusi untuk sinkronisasi jam yang tidak sempurna.\nAlih-alih beroperasi pada jam terdistribusi, peer WebRTC mengirim paket khusus dengan timestamp-nya sendiri sendertime1. Peer yang bekerja sama menerima paket dan memantulkan timestamp kembali ke pengirim. Setelah pengirim asli mendapat waktu yang dipantulkan, ia mengurangi timestamp sendertime1 dari waktu saat ini sendertime2. Delta waktu ini disebut \u0026ldquo;round-trip propagation delay\u0026rdquo; atau lebih umum round-trip time.\nrtt = sendertime2 - sendertime1\nSetengah dari round trip time dianggap sebagai perkiraan yang cukup baik dari transmission time. Solusi ini tidak tanpa kekurangan. Ini membuat asumsi bahwa dibutuhkan waktu yang sama untuk mengirim dan menerima paket. Namun pada jaringan seluler, operasi pengiriman dan penerimaan mungkin tidak simetris waktu. Anda mungkin telah memperhatikan bahwa kecepatan unggah pada ponsel Anda hampir selalu lebih rendah daripada kecepatan unduh.\ntransmission_time = rtt/2\nTeknisnya pengukuran round-trip time dijelaskan lebih detail dalam bab RTCP Sender dan Receiver Reports.\nJitter # Jitter adalah fakta bahwa Transmission Time dapat bervariasi untuk setiap paket. Paket Anda dapat ditunda, tetapi kemudian tiba dalam ledakan.\nPacket Loss # Packet Loss adalah ketika pesan hilang dalam transmisi. Kehilangan bisa stabil, atau bisa datang dalam lonjakan. Ini bisa karena jenis jaringan seperti satelit atau Wi-Fi. Atau bisa diperkenalkan oleh perangkat lunak di sepanjang jalan.\nMaximum Transmission Unit # Maximum Transmission Unit adalah batas seberapa besar satu paket tunggal bisa. Jaringan tidak mengizinkan Anda mengirim satu pesan raksasa. Pada level protokol, pesan mungkin harus dipecah menjadi beberapa paket yang lebih kecil.\nMTU juga akan berbeda tergantung pada jalur jaringan apa yang Anda ambil. Anda dapat menggunakan protokol seperti Path MTU Discovery untuk mengetahui ukuran paket terbesar yang dapat Anda kirim.\nCongestion # Congestion adalah ketika batas jaringan telah tercapai. Ini biasanya karena Anda telah mencapai puncak bandwidth yang dapat ditangani rute saat ini. Atau bisa operator yang memaksakan seperti batas per jam yang dikonfigurasi ISP Anda.\nCongestion menampakkan dirinya dalam banyak cara berbeda. Tidak ada perilaku standar. Dalam kebanyakan kasus ketika congestion tercapai jaringan akan menjatuhkan paket berlebih. Dalam kasus lain jaringan akan buffer. Ini akan menyebabkan Transmission Time untuk paket Anda meningkat. Anda juga dapat melihat lebih banyak jitter saat jaringan Anda menjadi padat. Ini adalah area yang berubah dengan cepat dan algoritma baru untuk deteksi congestion masih ditulis.\nDinamis # Jaringan sangat dinamis dan kondisinya dapat berubah dengan cepat. Selama panggilan Anda dapat mengirim dan menerima ratusan ribu paket. Paket-paket itu akan melakukan perjalanan melalui beberapa hop. Hop tersebut akan dibagikan oleh jutaan pengguna lain. Bahkan di jaringan lokal Anda, Anda dapat memiliki film HD yang diunduh atau mungkin perangkat memutuskan untuk mengunduh pembaruan perangkat lunak.\nMemiliki panggilan yang baik tidak sesederhana mengukur jaringan Anda saat startup. Anda perlu terus mengevaluasi. Anda juga perlu menangani semua perilaku berbeda yang berasal dari banyak perangkat keras dan perangkat lunak jaringan.\nMenyelesaikan Packet Loss # Menangani packet loss adalah masalah pertama untuk diselesaikan. Ada beberapa cara untuk menyelesaikannya, masing-masing dengan manfaatnya sendiri. Ini tergantung pada apa yang Anda kirim dan seberapa toleran Anda terhadap latensi. Penting juga untuk dicatat bahwa tidak semua packet loss fatal. Kehilangan beberapa video mungkin bukan masalah, mata manusia mungkin bahkan tidak mampu menganggapnya. Kehilangan pesan teks pengguna adalah fatal.\nKatakanlah Anda mengirim 10 paket, dan paket 5 dan 6 hilang. Ini adalah cara Anda dapat menyelesaikannya.\nAcknowledgments # Acknowledgments adalah ketika penerima memberi tahu pengirim setiap paket yang telah mereka terima. Pengirim menyadari packet loss ketika ia mendapat acknowledgment untuk paket dua kali yang bukan final. Ketika pengirim mendapat ACK untuk paket 4 dua kali, ia tahu bahwa paket 5 belum terlihat.\nSelective Acknowledgments # Selective Acknowledgments adalah peningkatan dari Acknowledgments. Penerima dapat mengirim SACK yang mengakui beberapa paket dan memberi tahu pengirim tentang kesenjangan. Sekarang pengirim dapat mendapat SACK untuk paket 4 dan 7. Kemudian ia tahu ia perlu mengirim ulang paket 5 dan 6.\nNegative Acknowledgments # Negative Acknowledgments menyelesaikan masalah dengan cara sebaliknya. Alih-alih memberi tahu pengirim apa yang telah diterimanya, penerima memberi tahu pengirim apa yang telah hilang. Dalam kasus kami NACK akan dikirim untuk paket 5 dan 6. Pengirim hanya mengetahui paket yang ingin dikirim ulang oleh penerima.\nForward Error Correction # Forward Error Correction memperbaiki packet loss secara pre-emptif. Pengirim mengirim data redundan, yang berarti paket yang hilang tidak mempengaruhi stream akhir. Salah satu algoritma populer untuk ini adalah koreksi kesalahan Reed–Solomon.\nIni mengurangi latensi/kompleksitas pengiriman dan penanganan Acknowledgments. Forward Error Correction adalah pemborosan bandwidth jika jaringan tempat Anda berada memiliki nol kehilangan.\nMenyelesaikan Jitter # Jitter hadir di sebagian besar jaringan. Bahkan di dalam LAN Anda memiliki banyak perangkat yang mengirim data pada tingkat yang berfluktuasi. Anda dapat dengan mudah mengamati jitter dengan melakukan ping perangkat lain dengan perintah ping dan memperhatikan fluktuasi dalam latensi round-trip.\nUntuk menyelesaikan jitter, klien menggunakan JitterBuffer. JitterBuffer memastikan waktu pengiriman paket yang stabil. Kelemahannya adalah JitterBuffer menambahkan beberapa latensi ke paket yang tiba lebih awal. Sisi baiknya adalah paket yang terlambat tidak menyebabkan jitter. Bayangkan bahwa selama panggilan, Anda melihat waktu kedatangan paket berikut:\n* time=1.46 ms * time=1.93 ms * time=1.57 ms * time=1.55 ms * time=1.54 ms * time=1.72 ms * time=1.45 ms * time=1.73 ms * time=1.80 ms Dalam kasus ini, sekitar 1,8 ms akan menjadi pilihan yang baik. Paket yang tiba terlambat akan menggunakan jendela latensi kami. Paket yang tiba lebih awal akan ditunda sedikit dan dapat mengisi jendela yang habis oleh paket yang terlambat. Ini berarti kita tidak lagi memiliki gagap dan memberikan tingkat pengiriman yang lancar untuk klien.\nOperasi JitterBuffer # Setiap paket ditambahkan ke jitter buffer segera setelah diterima. Setelah ada cukup paket untuk merekonstruksi frame, paket yang membentuk frame dilepaskan dari buffer dan dikeluarkan untuk dekoding. Decoder, pada gilirannya, mendekode dan menggambar frame video di layar pengguna. Karena jitter buffer memiliki kapasitas terbatas, paket yang tetap di buffer terlalu lama akan dibuang.\nBaca lebih lanjut tentang bagaimana frame video dikonversi menjadi paket RTP, dan mengapa rekonstruksi diperlukan dalam bab komunikasi media.\njitterBufferDelay memberikan wawasan yang baik tentang kinerja jaringan Anda dan pengaruhnya pada kelancaran pemutaran. Ini adalah bagian dari WebRTC statistics API yang relevan dengan stream masuk penerima. Penundaan mendefinisikan jumlah waktu frame video menghabiskan di jitter buffer sebelum dikeluarkan untuk dekoding. Penundaan jitter buffer yang panjang berarti jaringan Anda sangat padat.\nMendeteksi Congestion # Sebelum kita dapat menyelesaikan congestion, kita perlu mendeteksinya. Untuk mendeteksinya kita menggunakan congestion controller. Ini adalah subjek yang rumit, dan masih berubah dengan cepat. Algoritma baru masih diterbitkan dan diuji. Pada level tinggi mereka semua beroperasi sama. Congestion controller memberikan estimasi bandwidth yang diberikan beberapa input. Ini beberapa input yang mungkin:\nPacket Loss - Paket dijatuhkan saat jaringan menjadi padat. Jitter - Saat peralatan jaringan menjadi lebih kelebihan beban, antrian paket akan menyebabkan waktu menjadi tidak menentu. Round Trip Time - Paket membutuhkan waktu lebih lama untuk tiba ketika padat. Tidak seperti jitter, Round Trip Time terus meningkat. Explicit Congestion Notification - Jaringan yang lebih baru dapat menandai paket sebagai berisiko dijatuhkan untuk mengurangi congestion. Nilai-nilai ini perlu diukur terus-menerus selama panggilan. Pemanfaatan jaringan dapat meningkat atau menurun, sehingga bandwidth yang tersedia dapat terus berubah.\nMenyelesaikan Congestion # Sekarang kita memiliki estimasi bandwidth kita perlu menyesuaikan apa yang kita kirim. Bagaimana kita menyesuaikan tergantung pada jenis data apa yang ingin kita kirim.\nMengirim Lebih Lambat # Membatasi kecepatan di mana Anda mengirim data adalah solusi pertama untuk mencegah congestion. Congestion Controller memberi Anda estimasi, dan itu adalah tanggung jawab pengirim untuk membatasi laju.\nIni adalah metode yang digunakan untuk sebagian besar komunikasi data. Dengan protokol seperti TCP ini semua dilakukan oleh sistem operasi dan sepenuhnya transparan bagi pengguna dan developer.\nMengirim Lebih Sedikit # Dalam beberapa kasus kita dapat mengirim lebih sedikit informasi untuk memenuhi batas kita. Kita juga memiliki tenggat waktu keras untuk kedatangan data kita, jadi kita tidak bisa mengirim lebih lambat. Ini adalah kendala yang dimiliki media Real-time.\nJika kita tidak memiliki cukup bandwidth yang tersedia, kita dapat menurunkan kualitas video yang kita kirim. Ini memerlukan feedback loop yang ketat antara video encoder dan congestion controller Anda.\n"},{"id":5,"href":"/id/docs/06-media-communication/","title":"Media Communication","section":"Docs","content":" Media Communication # Apa yang saya dapatkan dari komunikasi media WebRTC? # WebRTC memungkinkan Anda mengirim dan menerima jumlah stream audio dan video yang tidak terbatas. Anda dapat menambah dan menghapus stream ini kapan saja selama panggilan. Stream ini semuanya bisa independen, atau bisa digabungkan bersama! Anda dapat mengirim feed video desktop Anda, dan kemudian menyertakan audio dan video dari webcam Anda.\nProtokol WebRTC adalah codec agnostic. Transpor yang mendasarinya mendukung semuanya, bahkan hal-hal yang belum ada! Namun, Agent WebRTC yang berkomunikasi dengan Anda mungkin tidak memiliki alat yang diperlukan untuk menerimanya.\nWebRTC juga dirancang untuk menangani kondisi jaringan yang dinamis. Selama panggilan bandwidth Anda mungkin meningkat, atau menurun. Mungkin Anda tiba-tiba mengalami banyak packet loss. Protokol ini dirancang untuk menangani semua ini. WebRTC merespons kondisi jaringan dan mencoba memberi Anda pengalaman terbaik yang mungkin dengan sumber daya yang tersedia.\nBagaimana cara kerjanya? # WebRTC menggunakan dua protokol yang sudah ada sebelumnya RTP dan RTCP, keduanya didefinisikan dalam RFC 1889.\nRTP (Real-time Transport Protocol) adalah protokol yang membawa media. Ini dirancang untuk memungkinkan pengiriman video real-time. Ini tidak menetapkan aturan apa pun mengenai latensi atau keandalan, tetapi memberi Anda alat untuk mengimplementasikannya. RTP memberi Anda stream, sehingga Anda dapat menjalankan beberapa feed media melalui satu koneksi. Ini juga memberi Anda informasi timing dan pengurutan yang Anda butuhkan untuk memberi makan pipeline media.\nRTCP (RTP Control Protocol) adalah protokol yang mengomunikasikan metadata tentang panggilan. Formatnya sangat fleksibel dan memungkinkan Anda menambahkan metadata apa pun yang Anda inginkan. Ini digunakan untuk mengomunikasikan statistik tentang panggilan. Ini juga digunakan untuk menangani packet loss dan untuk mengimplementasikan congestion control. Ini memberi Anda komunikasi dua arah yang diperlukan untuk merespons kondisi jaringan yang berubah.\nLatensi vs Kualitas # Media real-time adalah tentang membuat trade-off antara latensi dan kualitas. Semakin banyak latensi yang bersedia Anda toleransi, semakin tinggi kualitas video yang dapat Anda harapkan.\nKeterbatasan Dunia Nyata # Batasan ini semua disebabkan oleh keterbatasan dunia nyata. Ini semua adalah karakteristik jaringan Anda yang perlu Anda atasi.\nVideo itu Kompleks # Mengangkut video tidaklah mudah. Untuk menyimpan 30 menit video 720 8-bit yang tidak dikompresi, Anda memerlukan sekitar 110 GB. Dengan angka-angka itu, panggilan konferensi 4 orang tidak akan terjadi. Kita memerlukan cara untuk membuatnya lebih kecil, dan jawabannya adalah kompresi video. Itu tidak datang tanpa kekurangan.\nVideo 101 # Kami tidak akan membahas kompresi video secara mendalam, tetapi cukup untuk memahami mengapa RTP dirancang seperti itu. Kompresi video mengenkode video ke dalam format baru yang memerlukan lebih sedikit bit untuk merepresentasikan video yang sama.\nKompresi Lossy dan Lossless # Anda dapat mengenkode video menjadi lossless (tidak ada informasi yang hilang) atau lossy (informasi mungkin hilang). Karena pengkodean lossless memerlukan lebih banyak data yang dikirim ke peer, membuat stream latensi lebih tinggi dan lebih banyak paket yang dijatuhkan, RTP biasanya menggunakan kompresi lossy meskipun kualitas videonya tidak akan sebaik itu.\nKompresi Intra dan Inter frame # Kompresi video hadir dalam dua jenis. Yang pertama adalah intra-frame. Kompresi intra-frame mengurangi bit yang digunakan untuk mendeskripsikan satu frame video. Teknik yang sama digunakan untuk mengompresi gambar diam, seperti metode kompresi JPEG.\nJenis kedua adalah kompresi inter-frame. Karena video terdiri dari banyak gambar, kita mencari cara untuk tidak mengirim informasi yang sama dua kali.\nJenis Inter-frame # Anda kemudian memiliki tiga jenis frame:\nI-Frame - Gambar lengkap, dapat didekode tanpa apa pun. P-Frame - Gambar parsial, hanya berisi perubahan dari gambar sebelumnya. B-Frame - Gambar parsial, adalah modifikasi dari gambar sebelumnya dan masa depan. Berikut adalah visualisasi dari tiga jenis frame.\nVideo itu rapuh # Kompresi video sangat stateful, membuatnya sulit untuk ditransfer melalui internet. Apa yang terjadi jika Anda kehilangan bagian dari I-Frame? Bagaimana P-Frame tahu apa yang harus dimodifikasi? Seiring kompresi video menjadi lebih kompleks, ini menjadi masalah yang lebih besar. Untungnya RTP dan RTCP memiliki solusinya.\nRTP # Format Paket # Setiap paket RTP memiliki struktur berikut:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Synchronization Source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | Contributing Source (CSRC) identifiers | | .... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Version (V) # Version selalu 2\nPadding (P) # Padding adalah bool yang mengontrol apakah payload memiliki padding.\nByte terakhir dari payload berisi hitungan berapa banyak byte padding yang ditambahkan.\nExtension (X) # Jika disetel, header RTP akan memiliki ekstensi. Ini dijelaskan lebih detail di bawah ini.\nCSRC count (CC) # Jumlah pengidentifikasi CSRC yang mengikuti setelah SSRC, dan sebelum payload.\nMarker (M) # Marker bit tidak memiliki arti yang telah ditetapkan, dan dapat digunakan sesuai keinginan pengguna.\nDalam beberapa kasus, ini disetel ketika pengguna sedang berbicara. Ini juga biasanya digunakan untuk menandai keyframe.\nPayload Type (PT) # Payload Type adalah pengidentifikasi unik untuk codec apa yang dibawa oleh paket ini.\nUntuk WebRTC, Payload Type adalah dinamis. VP8 dalam satu panggilan mungkin berbeda dari yang lain. Offerer dalam panggilan menentukan pemetaan Payload Types ke codec dalam Session Description.\nSequence Number # Sequence Number digunakan untuk mengurutkan paket dalam stream. Setiap kali paket dikirim, Sequence Number ditambah satu.\nRTP dirancang agar berguna melalui jaringan yang lossy. Ini memberi penerima cara untuk mendeteksi kapan paket telah hilang.\nTimestamp # Momen pengambilan sampel untuk paket ini. Ini bukan jam global, tetapi berapa banyak waktu yang telah berlalu dalam stream media. Beberapa paket RTP dapat memiliki timestamp yang sama jika mereka misalnya semua bagian dari frame video yang sama.\nSynchronization Source (SSRC) # SSRC adalah pengidentifikasi unik untuk stream ini. Ini memungkinkan Anda menjalankan beberapa stream media melalui satu stream RTP.\nContributing Source (CSRC) # Daftar yang mengomunikasikan SSRC mana yang berkontribusi pada paket ini.\nIni biasanya digunakan untuk indikator berbicara. Katakanlah server side Anda menggabungkan beberapa feed audio menjadi satu stream RTP. Anda kemudian dapat menggunakan bidang ini untuk mengatakan \u0026ldquo;Input stream A dan C sedang berbicara pada saat ini\u0026rdquo;.\nPayload # Data payload yang sebenarnya. Mungkin diakhiri dengan hitungan berapa banyak byte padding yang ditambahkan, jika flag padding disetel.\nExtensions # RTCP # Format Paket # Setiap paket RTCP memiliki struktur berikut:\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| RC | PT | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Version (V) # Version selalu 2.\nPadding (P) # Padding adalah bool yang mengontrol apakah payload memiliki padding.\nByte terakhir dari payload berisi hitungan berapa banyak byte padding yang ditambahkan.\nReception Report Count (RC) # Jumlah laporan dalam paket ini. Satu paket RTCP dapat berisi beberapa event.\nPacket Type (PT) # Pengidentifikasi Unik untuk jenis paket RTCP apa ini. Agent WebRTC tidak perlu mendukung semua jenis ini, dan dukungan antar Agent dapat berbeda. Ini adalah yang mungkin sering Anda lihat:\n192 - Full INTRA-frame Request (FIR) 193 - Negative ACKnowledgements (NACK) 200 - Sender Report 201 - Receiver Report 205 - Generic RTP Feedback 206 - Payload Specific Feedback Signifikansi jenis paket ini akan dijelaskan lebih detail di bawah ini.\nFull INTRA-frame Request (FIR) dan Picture Loss Indication (PLI) # Pesan FIR dan PLI melayani tujuan yang serupa. Pesan-pesan ini meminta key frame penuh dari pengirim. PLI digunakan ketika frame parsial diberikan ke decoder, tetapi tidak dapat mendekodenya. Ini bisa terjadi karena Anda memiliki banyak packet loss, atau mungkin decoder crash.\nMenurut RFC 5104, FIR tidak boleh digunakan ketika paket atau frame hilang. Itu adalah tugas PLI. FIR meminta key frame untuk alasan selain packet loss - misalnya ketika anggota baru memasuki konferensi video. Mereka memerlukan key frame penuh untuk mulai mendekode stream video, decoder akan membuang frame sampai key frame tiba.\nIni adalah ide yang baik bagi penerima untuk meminta key frame penuh segera setelah terhubung, ini meminimalkan penundaan antara koneksi, dan gambar yang muncul di layar pengguna.\nPaket PLI adalah bagian dari pesan Payload Specific Feedback.\nDalam praktiknya, perangkat lunak yang dapat menangani paket PLI dan FIR akan bertindak dengan cara yang sama dalam kedua kasus. Ini akan mengirim sinyal ke encoder untuk menghasilkan key frame penuh yang baru.\nNegative Acknowledgment # NACK meminta pengirim mengirim ulang satu paket RTP. Ini biasanya disebabkan oleh paket RTP yang hilang, tetapi juga bisa terjadi karena terlambat.\nNACK jauh lebih efisien bandwidth daripada meminta seluruh frame dikirim lagi. Karena RTP memecah paket menjadi potongan yang sangat kecil, Anda benar-benar hanya meminta satu bagian kecil yang hilang. Penerima membuat pesan RTCP dengan SSRC dan Sequence Number. Jika pengirim tidak memiliki paket RTP ini tersedia untuk dikirim ulang, ia hanya mengabaikan pesan tersebut.\nSender dan Receiver Reports # Laporan ini digunakan untuk mengirim statistik antar agent. Ini mengomunikasikan jumlah paket yang benar-benar diterima dan jitter.\nLaporan dapat digunakan untuk diagnostik dan congestion control.\nBagaimana RTP/RTCP menyelesaikan masalah bersama-sama # RTP dan RTCP kemudian bekerja sama untuk menyelesaikan semua masalah yang disebabkan oleh jaringan. Teknik-teknik ini masih terus berubah!\nForward Error Correction # Juga dikenal sebagai FEC. Metode lain untuk menangani packet loss. FEC adalah ketika Anda mengirim data yang sama beberapa kali, tanpa diminta. Ini dilakukan pada level RTP, atau bahkan lebih rendah dengan codec.\nJika packet loss untuk panggilan stabil maka FEC adalah solusi latensi yang jauh lebih rendah daripada NACK. Round trip time untuk meminta, dan kemudian mengirim ulang paket yang hilang bisa signifikan untuk NACK.\nAdaptive Bitrate dan Bandwidth Estimation # Seperti yang dibahas dalam bab Real-time networking, jaringan tidak dapat diprediksi dan tidak dapat diandalkan. Ketersediaan bandwidth dapat berubah beberapa kali sepanjang sesi. Tidak jarang melihat bandwidth yang tersedia berubah secara dramatis (beberapa kali lipat) dalam satu detik.\nIde utamanya adalah menyesuaikan bitrate pengkodean berdasarkan bandwidth jaringan yang tersedia yang diprediksi, saat ini, dan masa depan. Ini memastikan bahwa sinyal video dan audio dengan kualitas terbaik yang mungkin ditransmisikan, dan koneksi tidak terputus karena kemacetan jaringan. Heuristik yang memodelkan perilaku jaringan dan mencoba memprediksinya dikenal sebagai Bandwidth estimation.\nAda banyak nuansa untuk ini, jadi mari kita jelajahi lebih detail.\nMengidentifikasi dan Mengomunikasikan Status Jaringan # RTP/RTCP berjalan di atas semua jenis jaringan yang berbeda, dan sebagai hasilnya, adalah umum untuk beberapa komunikasi dijatuhkan dalam perjalanan dari pengirim ke penerima. Dibangun di atas UDP, tidak ada mekanisme bawaan untuk retransmisi paket, apalagi menangani congestion control.\nUntuk memberikan pengalaman terbaik kepada pengguna, WebRTC harus memperkirakan kualitas tentang jalur jaringan, dan beradaptasi dengan bagaimana kualitas tersebut berubah dari waktu ke waktu. Sifat kunci untuk dipantau meliputi: bandwidth yang tersedia (di setiap arah, karena mungkin tidak simetris), round trip time, dan jitter (fluktuasi dalam round trip time). Ini perlu memperhitungkan packet loss, dan mengomunikasikan perubahan dalam properti ini seiring kondisi jaringan berkembang.\nAda dua tujuan utama untuk protokol ini:\nMemperkirakan bandwidth yang tersedia (di setiap arah) yang didukung oleh jaringan. Mengomunikasikan karakteristik jaringan antara pengirim dan penerima. RTP/RTCP memiliki tiga pendekatan berbeda untuk mengatasi masalah ini. Semuanya memiliki pro dan kontra, dan umumnya setiap generasi telah meningkat dari pendahulunya. Implementasi mana yang Anda gunakan akan bergantung terutama pada stack perangkat lunak yang tersedia untuk klien Anda dan library yang tersedia untuk membangun aplikasi Anda.\nReceiver Reports / Sender Reports # Implementasi pertama adalah pasangan Receiver Reports dan komplemennya, Sender Reports. Ini pesan RTCP didefinisikan dalam RFC 3550, dan bertanggung jawab untuk mengomunikasikan status jaringan antar endpoint. Receiver Reports berfokus pada mengomunikasikan kualitas tentang jaringan (termasuk packet loss, round-trip time, dan jitter), dan berpasangan dengan algoritma lain yang kemudian bertanggung jawab untuk memperkirakan bandwidth yang tersedia berdasarkan laporan ini.\nSender dan Receiver report (SR dan RR) bersama-sama melukiskan gambaran kualitas jaringan. Mereka dikirim sesuai jadwal untuk setiap SSRC, dan mereka adalah input yang digunakan saat memperkirakan bandwidth yang tersedia. Perkiraan tersebut dibuat oleh pengirim setelah menerima data RR, yang berisi bidang-bidang berikut:\nFraction Lost - Berapa persentase paket yang hilang sejak Receiver Report terakhir. Cumulative Number of Packets Lost - Berapa banyak paket yang hilang selama seluruh panggilan. Extended Highest Sequence Number Received - Apa Sequence Number terakhir yang diterima, dan berapa kali telah berputar. Interarrival Jitter - Jitter bergulir untuk seluruh panggilan. Last Sender Report Timestamp - Waktu terakhir yang diketahui pada pengirim, digunakan untuk perhitungan round-trip time. SR dan RR bekerja bersama untuk menghitung round-trip time.\nPengirim menyertakan waktu lokalnya, sendertime1 dalam SR. Ketika penerima mendapat paket SR, ia mengirim kembali RR. Di antara hal-hal lain, RR menyertakan sendertime1 yang baru saja diterima dari pengirim. Akan ada penundaan antara menerima SR dan mengirim RR. Karena itu, RR juga menyertakan waktu \u0026ldquo;delay since last sender report\u0026rdquo; - DLSR. DLSR digunakan untuk menyesuaikan perkiraan round-trip time nanti dalam proses. Setelah pengirim menerima RR, ia mengurangi sendertime1 dan DLSR dari waktu saat ini sendertime2. Delta waktu ini disebut round-trip propagation delay atau round-trip time.\nrtt = sendertime2 - sendertime1 - DLSR\nRound-trip time dalam bahasa Inggris sederhana:\nSaya mengirim Anda pesan dengan pembacaan jam saya saat ini, katakanlah jam 4:20 sore, 42 detik dan 420 milidetik. Anda mengirim saya timestamp yang sama ini kembali. Anda juga menyertakan waktu yang berlalu dari membaca pesan saya hingga mengirim pesan kembali, katakanlah 5 milidetik. Setelah saya menerima waktu kembali, saya melihat jam lagi. Sekarang jam saya mengatakan jam 4:20 sore, 42 detik 690 milidetik. Itu berarti dibutuhkan 265 milidetik (690 - 420 - 5) untuk mencapai Anda dan kembali ke saya. Oleh karena itu, round-trip time adalah 265 milidetik. TMMBR, TMMBN, REMB dan TWCC, dipasangkan dengan GCC # Google Congestion Control (GCC) # Algoritma Google Congestion Control (GCC) (dijelaskan dalam draft-ietf-rmcat-gcc-02) mengatasi tantangan estimasi bandwidth. Ini berpasangan dengan berbagai protokol lain untuk memfasilitasi persyaratan komunikasi terkait. Akibatnya, ini sangat cocok untuk berjalan baik di sisi penerima (ketika dijalankan dengan TMMBR/TMMBN atau REMB) atau di sisi pengirim (ketika dijalankan dengan TWCC).\nUntuk mencapai perkiraan untuk bandwidth yang tersedia, GCC berfokus pada packet loss dan fluktuasi dalam waktu kedatangan frame sebagai dua metrik utamanya. Ini menjalankan metrik ini melalui dua controller yang terhubung: controller berbasis kehilangan dan controller berbasis penundaan.\nKomponen pertama GCC, loss-based controller, sederhana:\nJika packet loss di atas 10%, perkiraan bandwidth dikurangi. Jika packet loss antara 2-10%, perkiraan bandwidth tetap sama. Jika packet loss di bawah 2%, perkiraan bandwidth ditingkatkan. Pengukuran packet loss dilakukan dengan sering. Tergantung pada protokol komunikasi berpasangan, packet loss dapat dikomunikasikan secara eksplisit (seperti dengan TWCC) atau disimpulkan (seperti dengan TMMBR/TMMBN dan REMB). Persentase ini dievaluasi melalui jendela waktu sekitar satu detik.\nDelay-based controller bekerja sama dengan loss-based controller, dan melihat variasi dalam waktu kedatangan paket. Delay-based controller ini bertujuan untuk mengidentifikasi kapan tautan jaringan menjadi semakin padat, dan dapat mengurangi perkiraan bandwidth bahkan sebelum packet loss terjadi. Teorinya adalah bahwa antarmuka jaringan yang paling sibuk di sepanjang jalur akan terus mengantri paket sampai antarmuka kehabisan kapasitas di dalam buffer-nya. Jika antarmuka itu terus menerima lebih banyak lalu lintas daripada yang dapat dikirimnya, ia akan dipaksa untuk menjatuhkan semua paket yang tidak dapat masuk ke dalam ruang buffer-nya. Jenis packet loss ini sangat mengganggu untuk komunikasi latensi rendah/real-time, tetapi juga dapat menurunkan throughput untuk semua komunikasi melalui tautan itu dan idealnya harus dihindari. Dengan demikian, GCC mencoba mencari tahu apakah tautan jaringan menumbuhkan kedalaman antrian yang semakin besar dan lebih besar sebelum packet loss benar-benar terjadi. Ini akan mengurangi penggunaan bandwidth jika mengamati peningkatan penundaan antrian dari waktu ke waktu.\nUntuk mencapai ini, GCC mencoba menyimpulkan peningkatan kedalaman antrian dengan mengukur peningkatan halus dalam round trip time. Ini mencatat \u0026ldquo;inter-arrival time\u0026rdquo; frame, t(i) - t(i-1): perbedaan waktu kedatangan dari dua kelompok paket (umumnya, frame video berturut-turut). Kelompok paket ini sering berangkat pada interval waktu yang teratur (misalnya setiap 1/24 detik untuk video 24 fps). Sebagai hasilnya, mengukur inter-arrival time kemudian sesederhana merekam perbedaan waktu antara awal dari kelompok paket pertama (yaitu frame) dan frame pertama dari yang berikutnya.\nDalam diagram di bawah ini, peningkatan penundaan inter-packet median adalah +20 milidetik, indikator yang jelas dari kemacetan jaringan.\nJika inter-arrival time meningkat dari waktu ke waktu, itu dianggap bukti peningkatan kedalaman antrian pada antarmuka jaringan yang menghubungkan dan dianggap kemacetan jaringan. (Catatan: GCC cukup pintar untuk mengontrol pengukuran ini untuk fluktuasi dalam ukuran byte frame.) GCC memperbaiki pengukuran latensinya menggunakan filter Kalman dan mengambil banyak pengukuran round-trip time jaringan (dan variasinya) sebelum menandai kemacetan. Orang dapat menganggap filter Kalman GCC sebagai pengganti regresi linier: membantu membuat prediksi yang akurat bahkan ketika jitter menambahkan kebisingan ke dalam pengukuran timing. Setelah menandai kemacetan, GCC akan mengurangi bitrate yang tersedia. Atau, dalam kondisi jaringan yang stabil, ia dapat perlahan-lahan meningkatkan perkiraan bandwidth-nya untuk menguji nilai beban yang lebih tinggi.\nTMMBR, TMMBN, dan REMB # Untuk TMMBR/TMMBN dan REMB, sisi penerima pertama-tama memperkirakan bandwidth masuk yang tersedia (menggunakan protokol seperti GCC), dan kemudian mengomunikasikan perkiraan bandwidth ini ke pengirim remote. Mereka tidak perlu bertukar detail tentang packet loss atau kualitas lain tentang kemacetan jaringan karena beroperasi di sisi penerima memungkinkan mereka mengukur inter-arrival time dan packet loss secara langsung. Sebaliknya, TMMBR, TMMBN, dan REMB hanya bertukar perkiraan bandwidth itu sendiri:\nTemporary Maximum Media Stream Bit Rate Request - Mantissa/eksponen dari bitrate yang diminta untuk satu SSRC. Temporary Maximum Media Stream Bit Rate Notification - Pesan untuk memberi tahu bahwa TMMBR telah diterima. Receiver Estimated Maximum Bitrate - Mantissa/eksponen dari bitrate yang diminta untuk seluruh sesi. TMMBR dan TMMBN datang pertama dan didefinisikan dalam RFC 5104. REMB datang kemudian, ada draft yang diajukan dalam draft-alvestrand-rmcat-remb, tetapi tidak pernah distandarisasi.\nContoh sesi yang menggunakan REMB mungkin berperilaku seperti berikut:\nMetode ini bekerja dengan baik di atas kertas. Pengirim menerima estimasi dari penerima, mengatur bitrate encoder ke nilai yang diterima. Tada! Kami telah menyesuaikan dengan kondisi jaringan.\nNamun dalam praktiknya, pendekatan REMB memiliki beberapa kekurangan.\nKetidakefisienan encoder adalah yang pertama. Ketika Anda menetapkan bitrate untuk encoder, itu tidak selalu menghasilkan bitrate yang tepat yang Anda minta. Pengkodean dapat menghasilkan lebih banyak atau lebih sedikit bit, tergantung pada pengaturan encoder dan frame yang dikode.\nMisalnya, menggunakan encoder x264 dengan tune=zerolatency dapat secara signifikan menyimpang dari target bitrate yang ditentukan. Berikut adalah skenario yang mungkin:\nKatakanlah kita mulai dengan mengatur bitrate ke 1000 kbps. Encoder hanya menghasilkan 700 kbps, karena tidak ada cukup fitur frekuensi tinggi untuk dikode. (AKA - \u0026ldquo;menatap dinding\u0026rdquo;.) Mari kita juga bayangkan bahwa penerima mendapat video 700 kbps dengan nol packet loss. Kemudian ia menerapkan aturan REMB 1 untuk meningkatkan bitrate masuk sebesar 8%. Penerima mengirim paket REMB dengan saran 756 kbps (700 kbps * 1.08) ke pengirim. Pengirim mengatur bitrate encoder ke 756 kbps. Encoder menghasilkan bitrate yang lebih rendah lagi. Proses ini terus berulang, menurunkan bitrate ke minimum absolut. Anda dapat melihat bagaimana ini akan menyebabkan penyetelan parameter encoder yang berat, dan mengejutkan pengguna dengan video yang tidak dapat ditonton bahkan pada koneksi yang bagus.\nTransport Wide Congestion Control # Transport Wide Congestion Control adalah perkembangan terbaru dalam komunikasi status jaringan RTCP. Ini didefinisikan dalam draft-holmer-rmcat-transport-wide-cc-extensions-01, tetapi juga tidak pernah distandarisasi.\nTWCC menggunakan prinsip yang cukup sederhana:\nDengan REMB, penerima menginstruksikan sisi pengirim dalam bitrate download yang tersedia. Ini menggunakan pengukuran yang tepat tentang packet loss yang disimpulkan dan data hanya yang dimilikinya tentang waktu kedatangan inter-packet.\nTWCC hampir merupakan pendekatan hibrida antara SR/RR dan generasi protokol REMB. Ini membawa perkiraan bandwidth kembali ke sisi pengirim (mirip dengan SR/RR), tetapi teknik estimasi bandwidth-nya lebih mirip dengan generasi REMB.\nDengan TWCC, penerima memberi tahu pengirim waktu kedatangan setiap paket. Ini adalah informasi yang cukup untuk pengirim mengukur variasi penundaan kedatangan inter-packet, serta mengidentifikasi paket mana yang dijatuhkan atau tiba terlambat untuk berkontribusi pada feed audio/video. Dengan data ini yang dipertukarkan dengan sering, pengirim dapat dengan cepat menyesuaikan dengan kondisi jaringan yang berubah dan bervariasi output bandwidth-nya menggunakan algoritma seperti GCC.\nPengirim melacak paket yang dikirim, nomor urutnya, ukuran dan timestamp. Ketika pengirim menerima pesan RTCP dari penerima, ia membandingkan penundaan inter-packet pengiriman dengan penundaan penerimaan. Jika penundaan penerimaan meningkat, ini menandakan kemacetan jaringan, dan pengirim harus mengambil tindakan korektif.\nDengan memberikan pengirim data mentah, TWCC menyediakan pandangan yang sangat baik ke dalam kondisi jaringan real time:\nPerilaku packet loss hampir instan, hingga paket individual yang hilang Bitrate pengiriman yang akurat Bitrate penerimaan yang akurat Pengukuran jitter Perbedaan antara penundaan paket pengiriman dan penerimaan Deskripsi tentang bagaimana jaringan mentolerir pengiriman bandwidth yang bursty atau stabil Salah satu kontribusi paling signifikan dari TWCC adalah fleksibilitas yang diberikannya kepada developer WebRTC. Dengan mengkonsolidasikan algoritma congestion control ke sisi pengirim, ini memungkinkan kode klien sederhana yang dapat digunakan secara luas dan memerlukan peningkatan minimal dari waktu ke waktu. Algoritma congestion control yang kompleks kemudian dapat diiterasi lebih cepat pada perangkat keras yang mereka kontrol langsung (seperti Selective Forwarding Unit, dibahas di bagian 8). Dalam kasus peramban dan perangkat seluler, ini berarti klien tersebut dapat mengambil manfaat dari peningkatan algoritma tanpa harus menunggu standardisasi atau pembaruan peramban (yang dapat memakan waktu cukup lama untuk tersedia secara luas).\nAlternatif Bandwidth Estimation # Implementasi yang paling banyak diterapkan adalah \u0026ldquo;A Google Congestion Control Algorithm for Real-Time Communication\u0026rdquo; yang didefinisikan dalam draft-alvestrand-rmcat-congestion.\nAda beberapa alternatif untuk GCC, misalnya NADA: A Unified Congestion Control Scheme for Real-Time Media dan SCReAM - Self-Clocked Rate Adaptation for Multimedia.\n"},{"id":6,"href":"/id/docs/07-data-communication/","title":"Data Communication","section":"Docs","content":" Data Communication # Apa yang saya dapatkan dari komunikasi data WebRTC? # WebRTC menyediakan data channel untuk komunikasi data. Antara dua peer Anda dapat membuka 65.534 data channel. Data channel berbasis datagram, dan masing-masing memiliki pengaturan daya tahan sendiri. Secara default, setiap data channel memiliki pengiriman berurutan yang dijamin.\nJika Anda mendekati WebRTC dari latar belakang media, data channel mungkin tampak boros. Mengapa saya memerlukan seluruh subsistem ini ketika saya bisa menggunakan HTTP atau WebSocket?\nKekuatan sebenarnya dengan data channel adalah Anda dapat mengonfigurasinya untuk berperilaku seperti UDP dengan pengiriman tidak berurutan/lossy. Ini diperlukan untuk situasi latensi rendah dan kinerja tinggi. Anda dapat mengukur backpressure dan memastikan Anda hanya mengirim sebanyak yang didukung jaringan Anda.\nBagaimana cara kerjanya? # WebRTC menggunakan Stream Control Transmission Protocol (SCTP), didefinisikan dalam RFC 4960. SCTP adalah protokol lapisan transpor yang dimaksudkan sebagai alternatif untuk TCP atau UDP. Untuk WebRTC kami menggunakannya sebagai protokol lapisan aplikasi yang berjalan di atas koneksi DTLS kami.\nSCTP memberi Anda stream dan setiap stream dapat dikonfigurasi secara independen. Data channel WebRTC hanyalah abstraksi tipis di sekitarnya. Pengaturan sekitar daya tahan dan pengurutan hanya diteruskan langsung ke Agent SCTP.\nData channel memiliki beberapa fitur yang tidak dapat diekspresikan oleh SCTP, seperti label channel. Untuk mengatasi itu WebRTC menggunakan Data Channel Establishment Protocol (DCEP) yang didefinisikan dalam RFC 8832. DCEP mendefinisikan pesan untuk mengomunikasikan label channel dan protokol.\nDCEP # DCEP hanya memiliki dua pesan DATA_CHANNEL_OPEN dan DATA_CHANNEL_ACK. Untuk setiap data channel yang dibuka, remote harus merespons dengan ack.\nDATA_CHANNEL_OPEN # Pesan ini dikirim oleh Agent WebRTC yang ingin membuka channel.\nFormat Paket # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | Channel Type | Priority | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reliability Parameter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Label Length | Protocol Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Label / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Protocol / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Message Type # Message Type adalah nilai statis 0x03.\nChannel Type # Channel Type mengontrol atribut daya tahan/pengurutan dari channel. Ini mungkin memiliki nilai berikut:\nDATA_CHANNEL_RELIABLE (0x00) - Tidak ada pesan yang hilang dan akan tiba secara berurutan DATA_CHANNEL_RELIABLE_UNORDERED (0x80) - Tidak ada pesan yang hilang, tetapi mereka mungkin tiba tidak berurutan. DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT (0x01) - Pesan mungkin hilang setelah mencoba jumlah yang diminta, tetapi mereka akan tiba secara berurutan. DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED (0x81) - Pesan mungkin hilang setelah mencoba jumlah yang diminta dan mungkin tiba tidak berurutan. DATA_CHANNEL_PARTIAL_RELIABLE_TIMED (0x02) - Pesan mungkin hilang jika mereka tidak tiba dalam jumlah waktu yang diminta, tetapi mereka akan tiba secara berurutan. DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED (0x82) - Pesan mungkin hilang jika mereka tidak tiba dalam jumlah waktu yang diminta dan mungkin tiba tidak berurutan. Priority # Prioritas dari data channel. Data channel yang memiliki prioritas lebih tinggi akan dijadwalkan terlebih dahulu. Pesan pengguna prioritas rendah yang besar tidak akan menunda pengiriman pesan pengguna prioritas lebih tinggi.\nReliability Parameter # Jika tipe data channel adalah DATA_CHANNEL_PARTIAL_RELIABLE, akhiran mengonfigurasi perilaku:\nREXMIT - Mendefinisikan berapa kali pengirim akan mengirim ulang pesan sebelum menyerah. TIMED - Mendefinisikan berapa lama waktu (dalam ms) pengirim akan mengirim ulang pesan sebelum menyerah. Label # String yang dikode UTF-8 yang berisi nama data channel. String ini mungkin kosong.\nProtocol # Jika ini adalah string kosong, protokol tidak ditentukan. Jika itu adalah string yang tidak kosong, itu harus menentukan protokol yang terdaftar dalam \u0026ldquo;WebSocket Subprotocol Name Registry\u0026rdquo;, didefinisikan dalam RFC 6455.\nDATA_CHANNEL_ACK # Pesan ini dikirim oleh Agent WebRTC untuk mengakui bahwa data channel ini telah dibuka.\nFormat Paket # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | +-+-+-+-+-+-+-+-+ Stream Control Transmission Protocol # SCTP adalah kekuatan sebenarnya di balik data channel WebRTC. Ini menyediakan semua fitur data channel ini:\nMultiplexing Pengiriman andal menggunakan mekanisme retransmisi seperti TCP Opsi keandalan parsial Congestion Avoidance Flow Control Untuk memahami SCTP kita akan menjelajahinya dalam tiga bagian. Tujuannya adalah Anda akan tahu cukup untuk men-debug dan mempelajari detail mendalam SCTP sendiri setelah bab ini.\nKonsep # SCTP adalah protokol yang kaya fitur. Bagian ini hanya akan membahas bagian-bagian SCTP yang digunakan oleh WebRTC. Fitur dalam SCTP yang tidak digunakan oleh WebRTC termasuk multi-homing dan path selection.\nDengan lebih dari dua puluh tahun pengembangan SCTP bisa sulit untuk sepenuhnya dipahami.\nAssociation # Association adalah istilah yang digunakan untuk Sesi SCTP. Ini adalah state yang dibagikan antara dua Agent SCTP saat mereka berkomunikasi.\nStreams # Stream adalah satu urutan data pengguna dua arah. Ketika Anda membuat data channel, Anda sebenarnya hanya membuat stream SCTP. Setiap Association SCTP berisi daftar stream. Setiap stream dapat dikonfigurasi dengan jenis keandalan yang berbeda.\nWebRTC hanya memungkinkan Anda mengonfigurasi saat pembuatan stream, tetapi SCTP sebenarnya memungkinkan mengubah konfigurasi kapan saja.\nBerbasis Datagram # SCTP membingkai data sebagai datagram dan bukan sebagai byte stream. Mengirim dan menerima data terasa seperti menggunakan UDP daripada TCP. Anda tidak perlu menambahkan kode tambahan untuk mentransfer beberapa file melalui satu stream.\nPesan SCTP tidak memiliki batas ukuran seperti UDP. Satu pesan SCTP bisa berukuran beberapa gigabyte.\nChunks # Protokol SCTP terdiri dari chunk. Ada banyak jenis chunk yang berbeda. Chunk ini digunakan untuk semua komunikasi. Data pengguna, inisialisasi koneksi, congestion control, dan lainnya semuanya dilakukan melalui chunk.\nSetiap paket SCTP berisi daftar chunk. Jadi dalam satu paket UDP Anda dapat memiliki beberapa chunk yang membawa pesan dari stream yang berbeda.\nTransmission Sequence Number # Transmission Sequence Number (TSN) adalah pengidentifikasi unik global untuk chunk DATA. Chunk DATA adalah yang membawa semua pesan yang ingin dikirim pengguna. TSN penting karena membantu penerima menentukan apakah paket hilang atau tidak berurutan.\nJika penerima menyadari TSN yang hilang, ia tidak memberikan data kepada pengguna sampai dipenuhi.\nStream Identifier # Setiap stream memiliki pengidentifikasi unik. Ketika Anda membuat data channel dengan ID eksplisit, itu sebenarnya hanya diteruskan langsung ke SCTP sebagai stream identifier. Jika Anda tidak memberikan ID, stream identifier dipilih untuk Anda.\nPayload Protocol Identifier # Setiap chunk DATA juga memiliki Payload Protocol Identifier (PPID). Ini digunakan untuk mengidentifikasi secara unik jenis data apa yang sedang dipertukarkan. SCTP memiliki banyak PPID, tetapi WebRTC hanya menggunakan lima berikut:\nWebRTC DCEP (50) - Pesan DCEP. WebRTC String (51) - Pesan string DataChannel. WebRTC Binary (53) - Pesan biner DataChannel. WebRTC String Empty (56) - Pesan string DataChannel dengan panjang 0. WebRTC Binary Empty (57) - Pesan biner DataChannel dengan panjang 0. Protokol # Berikut adalah beberapa chunk yang digunakan oleh protokol SCTP. Ini bukan demonstrasi lengkap. Ini memberikan cukup struktur agar state machine masuk akal.\nSetiap Chunk dimulai dengan bidang type. Sebelum daftar chunk, Anda juga akan memiliki header.\nDATA Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 0 | Reserved|U|B|E| Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | TSN | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Stream Identifier | Stream Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload Protocol Identifier | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / User Data / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk DATA adalah bagaimana semua data pengguna dipertukarkan. Ketika Anda mengirim apa pun melalui data channel, ini adalah cara pertukaran.\nBit U disetel jika ini adalah paket tidak berurutan. Kita dapat mengabaikan Stream Sequence Number.\nB dan E adalah bit awal dan akhir. Jika Anda ingin mengirim pesan yang terlalu besar untuk satu chunk DATA, ia perlu difragmentasi menjadi beberapa chunk DATA yang dikirim dalam paket terpisah. Dengan bit B dan E dan Sequence Number SCTP dapat mengekspresikan ini.\nB=1, E=0 - Bagian pertama dari pesan pengguna yang terfragmentasi. B=0, E=0 - Bagian tengah dari pesan pengguna yang terfragmentasi. B=0, E=1 - Bagian terakhir dari pesan pengguna yang terfragmentasi. B=1, E=1 - Pesan yang tidak terfragmentasi. TSN adalah Transmission Sequence Number. Ini adalah pengidentifikasi unik global untuk chunk DATA ini. Setelah 4.294.967.295 chunk ini akan kembali ke 0. TSN ditambah untuk setiap chunk dalam pesan pengguna yang terfragmentasi sehingga penerima tahu cara mengurutkan chunk yang diterima untuk merekonstruksi pesan asli.\nStream Identifier adalah pengidentifikasi unik untuk stream tempat data ini berada.\nStream Sequence Number adalah angka 16-bit yang ditambah setiap pesan pengguna dan disertakan dalam header chunk pesan DATA. Setelah 65535 pesan ini akan kembali ke 0. Angka ini digunakan untuk memutuskan urutan pengiriman pesan ke penerima jika U disetel ke 0. Mirip dengan TSN, kecuali Stream Sequence Number hanya ditambah untuk setiap pesan secara keseluruhan dan bukan setiap chunk DATA individual.\nPayload Protocol Identifier adalah jenis data yang mengalir melalui stream ini. Untuk WebRTC, itu akan menjadi DCEP, String atau Binary.\nUser Data adalah apa yang Anda kirim. Semua data yang Anda kirim melalui data channel WebRTC ditransmisikan melalui chunk DATA.\nINIT Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 1 | Chunk Flags | Chunk Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Initiate Tag | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Advertised Receiver Window Credit (a_rwnd) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Number of Outbound Streams | Number of Inbound Streams | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Initial TSN | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Optional/Variable-Length Parameters / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk INIT memulai proses pembuatan association.\nInitiate Tag digunakan untuk pembuatan cookie. Cookie digunakan untuk perlindungan Man-In-The-Middle dan Denial of Service. Mereka dijelaskan lebih detail di bagian state machine.\nAdvertised Receiver Window Credit digunakan untuk Congestion Control SCTP. Ini mengomunikasikan seberapa besar buffer yang dialokasikan penerima untuk association ini.\nNumber of Outbound/Inbound Streams memberi tahu remote berapa banyak stream yang didukung agent ini.\nInitial TSN adalah uint32 acak untuk memulai TSN lokal.\nOptional Parameters memungkinkan SCTP memperkenalkan fitur baru ke protokol.\nSACK Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 3 |Chunk Flags | Chunk Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Cumulative TSN Ack | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Advertised Receiver Window Credit (a_rwnd) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Number of Gap Ack Blocks = N | Number of Duplicate TSNs = X | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Gap Ack Block #1 Start | Gap Ack Block #1 End | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / \\ ... \\ / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Gap Ack Block #N Start | Gap Ack Block #N End | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Duplicate TSN 1 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / \\ ... \\ / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Duplicate TSN X | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk SACK (Selective Acknowledgment) adalah bagaimana penerima memberi tahu pengirim bahwa ia telah mendapatkan paket. Sampai pengirim mendapat SACK untuk TSN ia akan mengirim ulang chunk DATA yang dimaksud. SACK melakukan lebih dari sekedar memperbarui TSN.\nCumulative TSN ACK TSN tertinggi yang telah diterima.\nAdvertised Receiver Window Credit ukuran buffer penerima. Penerima mungkin mengubah ini selama sesi jika lebih banyak memori menjadi tersedia.\nAck Blocks TSN yang telah diterima setelah Cumulative TSN ACK. Ini digunakan jika ada kesenjangan dalam paket yang dikirim. Katakanlah chunk DATA dengan TSN 100, 102, 103 dan 104 dikirim. Cumulative TSN ACK akan menjadi 100, tetapi Ack Blocks dapat digunakan untuk memberi tahu pengirim bahwa ia tidak perlu mengirim ulang 102, 103 atau 104.\nDuplicate TSN menginformasikan pengirim bahwa ia telah menerima chunk DATA berikut lebih dari sekali.\nHEARTBEAT Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 4 | Chunk Flags | Heartbeat Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / Heartbeat Information TLV (Variable-Length) / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk HEARTBEAT digunakan untuk menegaskan remote masih merespons. Berguna jika Anda tidak mengirim chunk DATA apa pun dan perlu menjaga mapping NAT tetap terbuka.\nABORT Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 6 |Reserved |T| Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / \\ Zero or more Error Causes \\ / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk ABORT menutup association secara tiba-tiba. Digunakan ketika satu sisi memasuki state kesalahan. Mengakhiri koneksi dengan anggun menggunakan chunk SHUTDOWN.\nSHUTDOWN Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 7 | Chunk Flags | Length = 8 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Cumulative TSN Ack | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk SHUTDOWN memulai penutupan anggun dari association SCTP. Setiap agent menginformasikan remote tentang TSN terakhir yang dikirimnya. Ini memastikan bahwa tidak ada paket yang hilang. WebRTC tidak melakukan penutupan anggun dari association SCTP. Anda perlu merobohkan setiap data channel sendiri untuk menanganinya dengan anggun.\nCumulative TSN ACK adalah TSN terakhir yang dikirim. Setiap sisi tahu untuk tidak mengakhiri sampai mereka menerima chunk DATA dengan TSN ini.\nERROR Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 9 | Chunk Flags | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ \\ / One or more Error Causes / \\ \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk ERROR digunakan untuk memberi tahu Agent SCTP remote bahwa kesalahan non-fatal telah terjadi.\nFORWARD TSN Chunk # 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type = 192 | Flags = 0x00 | Length = Variable | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | New Cumulative TSN | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Stream-1 | Stream Sequence-1 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ / / \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Stream-N | Stream Sequence-N | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Chunk FORWARD TSN memindahkan TSN global ke depan. SCTP melakukan ini, sehingga Anda dapat melewati beberapa paket yang tidak Anda pedulikan lagi. Katakanlah Anda mengirim 10 11 12 13 14 15 dan paket-paket ini hanya valid jika mereka semua tiba. Data ini juga sensitif terhadap real-time, jadi jika tiba terlambat itu tidak berguna.\nJika Anda kehilangan 12 dan 13 tidak ada alasan untuk mengirim 14 dan 15! SCTP menggunakan chunk FORWARD TSN untuk mencapai itu. Ini memberi tahu penerima bahwa 14 dan 15 tidak akan dikirim lagi.\nNew Cumulative TSN ini adalah TSN baru dari koneksi. Setiap paket sebelum TSN ini tidak akan dipertahankan.\nStream dan Stream Sequence digunakan untuk melompat Stream Sequence Number nomor ke depan. Rujuk kembali ke DATA Chunk untuk signifikansi bidang ini.\nState Machine # Ini adalah beberapa bagian menarik dari state machine SCTP. WebRTC tidak menggunakan semua fitur state machine SCTP, jadi kami telah mengecualikan bagian-bagian itu. Kami juga telah menyederhanakan beberapa komponen untuk membuatnya dapat dipahami sendiri.\nConnection Establishment Flow # Chunk INIT dan INIT ACK digunakan untuk bertukar kemampuan dan konfigurasi dari setiap peer. SCTP menggunakan cookie selama handshake untuk memvalidasi peer yang berkomunikasi dengannya. Ini untuk memastikan bahwa handshake tidak dicegat dan untuk mencegah serangan DoS.\nChunk INIT ACK berisi cookie. Cookie kemudian dikembalikan ke pembuatnya menggunakan COOKIE ECHO. Jika verifikasi cookie berhasil, COOKIE ACK dikirim dan chunk DATA siap untuk dipertukarkan.\nConnection Teardown Flow # SCTP menggunakan chunk SHUTDOWN. Ketika agent menerima chunk SHUTDOWN ia akan menunggu sampai ia menerima Cumulative TSN ACK yang diminta. Ini memungkinkan pengguna untuk memastikan bahwa semua data dikirim bahkan jika koneksi lossy.\nKeep-Alive Mechanism # SCTP menggunakan Chunk HEARTBEAT REQUEST dan HEARTBEAT ACK untuk menjaga koneksi tetap hidup. Ini dikirim pada interval yang dapat dikonfigurasi. SCTP juga melakukan exponential backoff jika paket belum tiba.\nChunk HEARTBEAT juga berisi nilai waktu. Ini memungkinkan dua association menghitung waktu perjalanan antara dua agent.\n"},{"id":7,"href":"/id/docs/08-applied-webrtc/","title":"Applied WebRTC","section":"Docs","content":" Applied WebRTC # Sekarang setelah Anda mengetahui bagaimana WebRTC bekerja, saatnya untuk membangun dengannya! Bab ini mengeksplorasi apa yang orang bangun dengan WebRTC, dan bagaimana mereka membangunnya. Anda akan mempelajari semua hal menarik yang terjadi dengan WebRTC. Kekuatan WebRTC datang dengan biaya. Membangun layanan WebRTC tingkat produksi adalah menantang. Bab ini akan mencoba menjelaskan tantangan tersebut sebelum Anda menghadapinya.\nBerdasarkan Kasus Penggunaan # Banyak yang berpikir WebRTC hanyalah teknologi untuk konferensi di peramban web. Namun itu jauh lebih dari itu! WebRTC digunakan dalam berbagai aplikasi. Kasus penggunaan baru muncul sepanjang waktu. Dalam bab ini kami akan mencantumkan beberapa yang umum dan bagaimana WebRTC merevolusi mereka.\nConferencing # Conferencing adalah kasus penggunaan asli untuk WebRTC. Protokol ini berisi beberapa fitur yang diperlukan yang tidak ditawarkan protokol lain di peramban. Anda bisa membangun sistem konferensi dengan WebSocket dan mungkin bekerja dalam kondisi optimal. Jika Anda ingin sesuatu yang dapat digunakan dalam kondisi jaringan dunia nyata, WebRTC adalah pilihan terbaik.\nWebRTC menyediakan congestion control dan adaptive bitrate untuk media. Seiring kondisi jaringan berubah, pengguna masih akan mendapatkan pengalaman terbaik yang mungkin. Developer juga tidak perlu menulis kode tambahan untuk mengukur kondisi ini.\nPeserta dapat mengirim dan menerima beberapa stream. Mereka juga dapat menambah dan menghapus stream tersebut kapan saja selama panggilan. Codec juga dinegosiasikan. Semua fungsi ini disediakan oleh peramban, tidak ada kode khusus yang perlu ditulis oleh developer.\nConferencing juga mendapat manfaat dari data channel. Pengguna dapat mengirim metadata atau berbagi dokumen. Anda dapat membuat beberapa stream dan mengonfigurasinya jika Anda membutuhkan performa lebih daripada keandalan.\nBroadcasting # Banyak proyek baru mulai muncul di ruang siaran yang menggunakan WebRTC. Protokol ini menawarkan banyak hal baik untuk penerbit dan konsumen media.\nWebRTC yang berada di peramban memudahkan pengguna untuk menerbitkan video. Ini menghilangkan keharusan bagi pengguna untuk mengunduh klien baru. Platform apa pun yang memiliki peramban web dapat menerbitkan video. Penerbit kemudian dapat mengirim beberapa track dan memodifikasi atau menghapusnya kapan saja. Ini adalah peningkatan besar dibanding protokol lama yang hanya mengizinkan satu audio atau satu track video per koneksi.\nWebRTC memberi developer kontrol yang lebih besar atas trade-off latensi versus kualitas. Jika lebih penting bahwa latensi tidak pernah melebihi ambang batas tertentu, dan Anda bersedia mentolerir beberapa artefak dekoding. Anda dapat mengonfigurasi penonton untuk memutar media segera setelah tiba. Dengan protokol lain yang berjalan melalui TCP, itu tidak semudah itu. Di peramban Anda dapat meminta data dan itu saja.\nRemote Access # Remote Access adalah ketika Anda mengakses komputer lain dari jarak jauh melalui WebRTC. Anda bisa memiliki kendali penuh atas host remote, atau mungkin hanya satu aplikasi. Ini bagus untuk menjalankan tugas yang mahal secara komputasi ketika perangkat keras lokal tidak dapat melakukannya. Seperti menjalankan video game baru, atau perangkat lunak CAD. WebRTC mampu merevolusi ruang ini dalam tiga cara.\nWebRTC dapat digunakan untuk mengakses host dari jarak jauh yang tidak dapat di-route secara global. Dengan NAT Traversal Anda dapat mengakses komputer yang hanya tersedia melalui STUN. Ini bagus untuk keamanan dan privasi. Pengguna Anda tidak perlu merutekan video melalui ingest, atau \u0026ldquo;jump box\u0026rdquo;. NAT Traversal juga membuat penerapan lebih mudah. Anda tidak perlu khawatir tentang port forwarding atau mengatur IP statis sebelumnya.\nData channel juga sangat kuat dalam skenario ini. Mereka dapat dikonfigurasi sehingga hanya data terbaru yang diterima. Dengan TCP Anda menjalankan risiko mengalami Head-of-line blocking. Klik mouse atau penekanan tombol lama bisa tiba terlambat, dan memblokir yang berikutnya agar tidak diterima. Data channel WebRTC dirancang untuk menangani ini dan dapat dikonfigurasi untuk tidak mengirim ulang paket yang hilang. Anda juga dapat mengukur backpressure dan memastikan bahwa Anda tidak mengirim lebih banyak data daripada yang didukung jaringan Anda.\nWebRTC yang tersedia di peramban telah menjadi peningkatan kualitas hidup yang besar. Anda tidak perlu mengunduh klien propriet untuk memulai sesi. Semakin banyak klien yang dilengkapi dengan WebRTC, Smart TV sekarang mendapatkan peramban web lengkap.\nBerbagi File dan Penghindaran Sensor # Berbagi File dan Penghindaran Sensor adalah masalah yang sangat berbeda. Namun, WebRTC menyelesaikan masalah yang sama untuk keduanya. Ini membuat keduanya mudah tersedia dan lebih sulit untuk diblokir.\nMasalah pertama yang diselesaikan WebRTC adalah mendapatkan klien. Jika Anda ingin bergabung dengan jaringan berbagi file, Anda perlu mengunduh klien. Bahkan jika jaringan terdistribusi, Anda masih perlu mendapatkan klien terlebih dahulu. Dalam jaringan yang dibatasi, unduhan sering diblokir. Bahkan jika Anda dapat mengunduhnya, pengguna mungkin tidak dapat menginstal dan menjalankan klien. WebRTC tersedia di setiap peramban web yang membuatnya mudah tersedia.\nMasalah kedua yang diselesaikan WebRTC adalah traffic Anda yang diblokir. Jika Anda menggunakan protokol yang hanya untuk berbagi file atau penghindaran sensor lebih mudah untuk memblokirnya. Karena WebRTC adalah protokol tujuan umum, memblokirnya akan berdampak pada semua orang. Memblokir WebRTC mungkin mencegah pengguna jaringan lain dari bergabung dengan panggilan konferensi.\nInternet of Things # Internet of Things (IoT) mencakup beberapa kasus penggunaan yang berbeda. Bagi banyak orang ini berarti kamera keamanan yang terhubung ke jaringan. Menggunakan WebRTC Anda dapat melakukan streaming video ke peer WebRTC lain seperti ponsel Anda atau peramban. Kasus penggunaan lainnya adalah memiliki perangkat yang terhubung dan bertukar data sensor. Anda dapat memiliki dua perangkat di LAN Anda bertukar pembacaan iklim, kebisingan, atau cahaya.\nWebRTC memiliki keuntungan privasi besar di sini dibandingkan protokol stream video lama. Karena WebRTC mendukung konektivitas P2P, kamera dapat mengirim video langsung ke peramban Anda. Tidak ada alasan untuk video Anda dikirim ke server pihak ketiga. Bahkan ketika video dienkripsi, penyerang dapat membuat asumsi dari metadata panggilan.\nInteroperabilitas adalah keuntungan lain untuk ruang IoT. WebRTC tersedia dalam banyak bahasa berbeda; C#, C++, C, Go, Java, Python, Rust dan TypeScript. Ini berarti Anda dapat menggunakan bahasa yang paling cocok untuk Anda. Anda juga tidak perlu beralih ke protokol atau format proprietary untuk dapat menghubungkan klien Anda.\nMedia Protocol Bridging # Anda memiliki perangkat keras dan perangkat lunak yang ada yang menghasilkan video, tetapi Anda belum dapat mengupgradenya. Mengharapkan pengguna untuk mengunduh klien proprietary untuk menonton video itu membuat frustrasi. Jawabannya adalah menjalankan bridge WebRTC. Bridge menerjemahkan antara dua protokol sehingga pengguna dapat menggunakan peramban dengan pengaturan lama Anda.\nBanyak format yang di-bridge oleh developer menggunakan protokol yang sama dengan WebRTC. SIP umumnya diekspos melalui WebRTC dan memungkinkan pengguna untuk melakukan panggilan telepon dari peramban mereka. RTSP digunakan di banyak kamera keamanan lama. Keduanya menggunakan protokol dasar yang sama (RTP dan SDP) sehingga murah secara komputasi untuk dijalankan. Bridge hanya diperlukan untuk menambahkan atau menghapus hal-hal yang spesifik untuk WebRTC.\nData Protocol Bridging # Peramban web hanya dapat berbicara dengan set protokol yang terbatas. Anda dapat menggunakan HTTP, WebSocket, WebRTC dan QUIC. Jika Anda ingin terhubung ke hal lain, Anda perlu menggunakan protocol bridge. Protocol bridge adalah server yang mengonversi traffic asing menjadi sesuatu yang dapat diakses peramban. Contoh populer adalah menggunakan SSH dari peramban Anda untuk mengakses server. Data channel WebRTC memiliki dua keuntungan dibanding kompetisi.\nData channel WebRTC memungkinkan pengiriman tidak andal dan tidak terurut. Dalam kasus di mana latensi rendah kritis ini diperlukan. Anda tidak ingin data baru diblokir oleh data lama, ini dikenal sebagai head-of-line blocking. Bayangkan Anda bermain game First-person shooter multipemain. Apakah Anda benar-benar peduli di mana pemain berada dua detik yang lalu? Jika data itu tidak tiba tepat waktu, tidak masuk akal untuk terus mencoba mengirimnya. Pengiriman tidak andal dan tidak terurut memungkinkan Anda menggunakan data segera setelah tiba.\nData channel juga menyediakan feedback pressure. Ini memberi tahu Anda jika Anda mengirim data lebih cepat daripada yang dapat didukung koneksi Anda. Anda kemudian memiliki dua pilihan ketika ini terjadi. Data channel dapat dikonfigurasi untuk buffer dan mengirimkan data terlambat, atau Anda dapat menjatuhkan data yang belum tiba dalam real-time.\nTeleoperation # Teleoperation adalah tindakan mengendalikan perangkat dari jarak jauh melalui data channel WebRTC, dan mengirim video kembali melalui RTP. Developer mengemudikan mobil dari jarak jauh melalui WebRTC hari ini! Ini digunakan untuk mengendalikan robot di lokasi konstruksi dan mengirim paket. Menggunakan WebRTC untuk masalah ini masuk akal karena dua alasan.\nKeberadaan WebRTC di mana-mana memudahkan untuk memberikan kontrol kepada pengguna. Yang dibutuhkan pengguna hanyalah peramban web dan perangkat input. Peramban bahkan mendukung pengambilan input dari joystick dan gamepad. WebRTC sepenuhnya menghilangkan kebutuhan untuk menginstal klien tambahan di perangkat pengguna.\nCDN Terdistribusi # CDN terdistribusi adalah subset dari berbagi file. File yang didistribusikan dikonfigurasi oleh operator CDN sebagai gantinya. Ketika pengguna bergabung dengan jaringan CDN mereka dapat mengunduh dan berbagi file yang diizinkan. Pengguna mendapat semua manfaat yang sama seperti berbagi file.\nCDN ini bekerja dengan baik ketika Anda berada di kantor dengan konektivitas eksternal yang buruk, tetapi konektivitas LAN yang bagus. Anda dapat memiliki satu pengguna mengunduh video, dan kemudian membagikannya dengan orang lain. Karena tidak semua orang mencoba mengambil file yang sama melalui jaringan eksternal, transfer akan selesai lebih cepat.\nTopologi WebRTC # WebRTC adalah protokol untuk menghubungkan dua agent, jadi bagaimana developer menghubungkan ratusan orang sekaligus? Ada beberapa cara berbeda yang dapat Anda lakukan, dan semuanya memiliki pro dan kontra. Solusi ini secara luas terbagi dalam dua kategori; Peer-to-Peer atau Client/Server. Fleksibilitas WebRTC memungkinkan kita untuk membuat keduanya.\nOne-To-One # One-to-One adalah tipe koneksi pertama yang akan Anda gunakan dengan WebRTC. Anda menghubungkan dua klien WebRTC secara langsung dan mereka dapat mengirim media dan data dua arah. Koneksi terlihat seperti ini.\nFull Mesh # Full mesh adalah jawabannya jika Anda ingin membangun panggilan konferensi atau game multipemain. Dalam topologi ini setiap pengguna membuat koneksi dengan setiap pengguna lain secara langsung. Ini memungkinkan Anda membangun aplikasi Anda, tetapi datang dengan beberapa kekurangan.\nDalam topologi Full Mesh setiap pengguna terhubung langsung. Itu berarti Anda harus mengenkode dan mengunggah video secara independen untuk setiap anggota panggilan. Kondisi jaringan antara setiap koneksi akan berbeda, jadi Anda tidak dapat menggunakan kembali video yang sama. Penanganan kesalahan juga sulit dalam penerapan ini. Anda perlu mempertimbangkan dengan hati-hati apakah Anda telah kehilangan konektivitas lengkap, atau hanya konektivitas dengan satu peer remote.\nKarena masalah ini, Full Mesh paling baik digunakan untuk grup kecil. Untuk apa pun yang lebih besar, topologi client/server adalah yang terbaik.\nHybrid Mesh # Hybrid Mesh adalah alternatif untuk Full Mesh yang dapat meringankan beberapa masalah Full Mesh. Dalam Hybrid Mesh koneksi tidak dibuat antara setiap pengguna. Sebaliknya, media direlai melalui peer di jaringan. Ini berarti bahwa pencipta media tidak perlu menggunakan sebanyak bandwidth untuk mendistribusikan media.\nIni memiliki beberapa kekurangan. Dalam pengaturan ini, pencipta asli media tidak tahu kepada siapa videonya dikirim, atau apakah tiba dengan sukses. Anda juga akan memiliki peningkatan latensi dengan setiap hop di jaringan Hybrid Mesh Anda.\nSelective Forwarding Unit # SFU (Selective Forwarding Unit) juga menyelesaikan masalah Full Mesh, tetapi dengan cara yang sama sekali berbeda. SFU mengimplementasikan topologi client/server, bukannya P2P. Setiap peer WebRTC terhubung ke SFU dan mengunggah medianya. SFU kemudian meneruskan media ini ke setiap klien yang terhubung.\nDengan SFU setiap klien WebRTC hanya perlu mengenkode dan mengunggah video mereka sekali. Beban mendistribusikannya ke semua penonton ada pada SFU. Konektivitas dengan SFU juga jauh lebih mudah daripada P2P. Anda dapat menjalankan SFU pada alamat yang dapat di-route secara global, membuatnya jauh lebih mudah bagi klien untuk terhubung. Anda tidak perlu khawatir tentang NAT Mapping. Anda masih perlu memastikan SFU Anda tersedia melalui TCP (baik melalui ICE-TCP atau TURN).\nMembangun SFU sederhana dapat dilakukan dalam satu akhir pekan. Membangun SFU yang baik yang dapat menangani semua jenis klien tidak pernah berakhir. Menyetel Congestion Control, Error Correction dan Kinerja adalah tugas yang tidak pernah berakhir.\nMCU # MCU (Multi-point Conferencing Unit) adalah topologi client/server seperti SFU, tetapi menyusun stream output. Alih-alih mendistribusikan media keluar yang tidak dimodifikasi, ia mengenkodekannya kembali sebagai satu feed.\n"},{"id":8,"href":"/id/docs/09-debugging/","title":"Debugging","section":"Docs","content":" Debugging # Debugging WebRTC bisa menjadi tugas yang menakutkan. Ada banyak bagian yang bergerak, dan semuanya bisa rusak secara independen. Jika Anda tidak hati-hati, Anda dapat kehilangan berminggu-minggu waktu melihat hal yang salah. Ketika Anda akhirnya menemukan bagian yang rusak, Anda perlu belajar sedikit untuk memahami mengapa.\nBab ini akan membawa Anda ke pola pikir untuk men-debug WebRTC. Ini akan menunjukkan kepada Anda cara memecah masalah. Setelah kami mengetahui masalahnya, kami akan memberikan tur singkat dari alat debugging yang populer.\nIsolasi Masalah # Saat men-debug, Anda perlu mengisolasi dari mana masalah berasal. Mulai dari awal\u0026hellip;\nKegagalan Signaling # Kegagalan Jaringan # Uji server STUN Anda menggunakan netcat:\nSiapkan paket permintaan pengikatan 20-byte:\necho -ne \u0026#34;\\x00\\x01\\x00\\x00\\x21\\x12\\xA4\\x42TESTTESTTEST\u0026#34; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 Interpretasi:\n00 01 adalah tipe pesan. 00 00 adalah panjang bagian data. 21 12 a4 42 adalah magic cookie. dan 54 45 53 54 54 45 53 54 54 45 53 54 (Dekode ke ASCII: TESTTESTTEST) adalah transaction ID 12-byte. Kirim permintaan dan tunggu respons 32 byte:\nstunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne \u0026#34;\\x00\\x01\\x00\\x00\\x21\\x12\\xA4\\x42TESTTESTTEST\u0026#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C 00000000 01 01 00 0c 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 00 20 00 08 00 01 6f 32 7f 36 de 89 |TEST. ....o2.6..| 00000020 Interpretasi:\n01 01 adalah tipe pesan 00 0c adalah panjang bagian data yang didekode menjadi 12 dalam desimal 21 12 a4 42 adalah magic cookie dan 54 45 53 54 54 45 53 54 54 45 53 54 (Dekode ke ASCII: TESTTESTTEST) adalah transaction ID 12-byte. 00 20 00 08 00 01 6f 32 7f 36 de 89 adalah data 12-byte, interpretasi: 00 20 adalah tipenya: XOR-MAPPED-ADDRESS 00 08 adalah panjang bagian nilai yang didekode menjadi 8 dalam desimal 00 01 6f 32 7f 36 de 89 adalah nilai data, interpretasi: 00 01 adalah tipe alamat (IPv4) 6f 32 adalah port yang di-XOR-mapped 7f 36 de 89 adalah alamat IP yang di-XOR-mapped Mendekode bagian XOR-mapped merepotkan, tetapi kita dapat mengelabui server stun untuk melakukan dummy XOR-mapping, dengan memberikan dummy magic cookie (tidak valid) yang disetel ke 00 00 00 00:\nstunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne \u0026#34;\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00TESTTESTTEST\u0026#34; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C 00000000 01 01 00 0c 00 00 00 00 54 45 53 54 54 45 53 54 |........TESTTEST| 00000010 54 45 53 54 00 01 00 08 00 01 4e 20 5e 24 7a cb |TEST......N ^$z.| 00000020 XOR-ing terhadap dummy magic cookie adalah idempoten, jadi port dan alamat akan jelas dalam respons. Ini tidak akan bekerja dalam semua situasi, karena beberapa router memanipulasi paket yang lewat, curang pada alamat IP. Jika kita melihat nilai data yang dikembalikan (delapan byte terakhir):\n00 01 4e 20 5e 24 7a cb adalah nilai data, interpretasi: 00 01 adalah tipe alamat (IPv4) 4e 20 adalah port yang di-mapped, yang didekode menjadi 20000 dalam desimal 5e 24 7a cb adalah alamat IP, yang didekode menjadi 94.36.122.203 dalam notasi dotted-decimal. Kegagalan Keamanan # Kegagalan Media # Kegagalan Data # Alat perdagangan # netcat (nc) # netcat adalah utilitas jaringan command-line untuk membaca dari dan menulis ke koneksi jaringan menggunakan TCP atau UDP. Ini biasanya tersedia sebagai perintah nc.\ntcpdump # tcpdump adalah penganalisis paket jaringan data command-line.\nPerintah umum:\nTangkap paket UDP ke dan dari port 19302, cetak hexdump dari konten paket:\nsudo tcpdump 'udp port 19302' -xx\nSama, tetapi simpan paket dalam file PCAP (packet capture) untuk inspeksi nanti:\nsudo tcpdump 'udp port 19302' -w stun.pcap\nFile PCAP dapat dibuka dengan aplikasi Wireshark: wireshark stun.pcap\nWireshark # Wireshark adalah penganalisis protokol jaringan yang banyak digunakan.\nAlat peramban WebRTC # Peramban dilengkapi dengan alat bawaan yang dapat Anda gunakan untuk memeriksa koneksi yang Anda buat. Chrome memiliki chrome://webrtc-internals dan chrome://webrtc-logs. Firefox memiliki about:webrtc.\nLatensi # Bagaimana Anda tahu Anda memiliki latensi tinggi? Anda mungkin telah memperhatikan bahwa video Anda tertinggal, tetapi apakah Anda tahu persis berapa banyak tertinggal? Untuk dapat mengurangi latensi ini, Anda harus mulai dengan mengukurnya terlebih dahulu.\nLatensi sejati seharusnya diukur end-to-end. Itu berarti tidak hanya latensi jalur jaringan antara pengirim dan penerima, tetapi latensi gabungan dari pengambilan kamera, pengkodean frame, transmisi, penerimaan, dekoding dan tampilan, serta kemungkinan antrian antara salah satu langkah ini.\nLatensi end-to-end bukan jumlah sederhana dari latensi setiap komponen.\nMeskipun Anda secara teoritis dapat mengukur latensi komponen dari pipeline transmisi video langsung secara terpisah dan kemudian menambahkannya bersama-sama, dalam praktiknya, setidaknya beberapa komponen akan tidak dapat diakses untuk instrumentasi, atau menghasilkan hasil yang sangat berbeda ketika diukur di luar pipeline. Kedalaman antrian variabel antara tahap pipeline, topologi jaringan dan perubahan eksposur kamera hanyalah beberapa contoh komponen yang mempengaruhi latensi end-to-end.\nLatensi intrinsik dari setiap komponen dalam sistem live-streaming Anda dapat berubah dan mempengaruhi komponen downstream. Bahkan konten video yang ditangkap mempengaruhi latensi. Misalnya, lebih banyak bit diperlukan untuk fitur frekuensi tinggi seperti cabang pohon, dibandingkan dengan langit biru yang jelas dengan frekuensi rendah. Kamera dengan eksposur otomatis yang diaktifkan mungkin memakan waktu jauh lebih lama daripada 33 milidetik yang diharapkan untuk menangkap frame, bahkan jika ketika tingkat pengambilan disetel ke 30 frame per detik. Transmisi melalui jaringan, terutama seluler, juga sangat dinamis karena permintaan yang berubah. Lebih banyak pengguna memperkenalkan lebih banyak obrolan di udara. Lokasi fisik Anda (zona sinyal rendah yang terkenal) dan beberapa faktor lain meningkatkan packet loss dan latensi. Apa yang terjadi ketika Anda mengirim paket ke antarmuka jaringan, katakanlah adaptor WiFi atau modem LTE untuk pengiriman? Jika tidak dapat segera dikirim, ia akan diantrekan pada antarmuka, semakin besar antrian semakin banyak latensi yang diperkenalkan antarmuka jaringan tersebut.\nPengukuran latensi end-to-end manual # Ketika kita berbicara tentang latensi end-to-end, yang kami maksud adalah waktu antara event terjadi dan diamati, artinya frame video muncul di layar.\nEndToEndLatency = T(observe) - T(happen) Pendekatan naif adalah merekam waktu ketika event terjadi dan menguranginya dari waktu pengamatan. Namun, karena presisi turun ke milidetik sinkronisasi waktu menjadi masalah. Mencoba menyinkronkan jam di seluruh sistem terdistribusi sebagian besar sia-sia, bahkan kesalahan kecil dalam sinkronisasi waktu menghasilkan pengukuran latensi yang tidak dapat diandalkan.\nSolusi sederhana untuk masalah sinkronisasi jam adalah menggunakan jam yang sama. Tempatkan pengirim dan penerima dalam kerangka referensi yang sama.\nBayangkan Anda memiliki jam milidetik yang berdetak atau sumber event lainnya sebenarnya. Anda ingin mengukur latensi dalam sistem yang melakukan live stream jam ke layar remote dengan mengarahkan kamera padanya. Cara yang jelas untuk mengukur waktu antara timer milidetik berdetak (Thappen) dan frame video jam muncul di layar (Tobserve) adalah sebagai berikut:\nArahkan kamera Anda ke jam milidetik. Kirim frame video ke penerima yang berada di lokasi fisik yang sama. Ambil gambar (gunakan ponsel Anda) dari timer milidetik dan video yang diterima di layar. Kurangi dua waktu. Itu adalah pengukuran latensi end-to-end yang paling benar untuk diri Anda sendiri. Ini memperhitungkan semua latensi komponen (kamera, encoder, jaringan, decoder) dan tidak bergantung pada sinkronisasi jam apa pun.\n. Dalam foto di atas latensi end-to-end yang diukur adalah 101 milidetik. Event yang terjadi sekarang adalah 10:16:02.862, tetapi pengamat sistem live-streaming melihat 10:16:02.761.\nPengukuran latensi end-to-end otomatis # Pada saat penulisan (Mei 2021) standar WebRTC untuk penundaan end-to-end sedang aktif dibahas. Firefox mengimplementasikan satu set API untuk membiarkan pengguna membuat pengukuran latensi otomatis di atas API WebRTC standar. Namun dalam paragraf ini, kami membahas cara yang paling kompatibel untuk mengukur latensi secara otomatis.\nRoundtrip time dalam singkatnya: Saya mengirim Anda waktu saya tR1, ketika saya menerima kembali tR1 saya pada waktu tR2, saya tahu round trip time adalah tR2 - tR1.\nDiberikan saluran komunikasi antara pengirim dan penerima (misalnya DataChannel), penerima dapat memodelkan jam monotonic pengirim dengan mengikuti langkah-langkah di bawah ini:\nPada waktu tR1, penerima mengirim pesan dengan timestamp jam monotonic lokalnya. Ketika diterima di pengirim dengan waktu lokal tS1, pengirim merespons dengan salinan tR1 serta tS1 pengirim dan waktu track video pengirim tSV1. Pada waktu tR2 di sisi penerima, round trip time dihitung dengan mengurangi waktu pengiriman dan penerimaan pesan: RTT = tR2 - tR1. Round trip time RTT bersama dengan timestamp lokal pengirim tS1 cukup untuk membuat estimasi jam monotonic pengirim. Waktu saat ini pada pengirim pada waktu tR2 akan sama dengan tS1 ditambah setengah dari round trip time. Timestamp jam lokal pengirim tS1 dipasangkan dengan timestamp track video tSV1 bersama dengan round trip time RTT karena itu cukup untuk menyinkronkan waktu track video penerima ke track video pengirim. Sekarang kita tahu berapa banyak waktu telah berlalu sejak waktu frame video pengirim yang dikenal terakhir tSV1, kita dapat memperkirakan latensi dengan mengurangi waktu frame video yang ditampilkan saat ini (actual_video_time) dari waktu yang diharapkan:\nexpected_video_time = tSV1 + time_since(tSV1) latency = expected_video_time - actual_video_time Kelemahan metode ini adalah tidak termasuk latensi intrinsik kamera. Sebagian besar sistem video menganggap timestamp pengambilan frame adalah waktu ketika frame dari kamera dikirim ke memori utama, yang akan beberapa saat setelah event yang direkam benar-benar terjadi.\nContoh estimasi latensi # Implementasi sampel membuka data channel latency pada penerima dan secara berkala mengirim timestamp timer monotonic penerima ke pengirim. Pengirim merespons kembali dengan pesan JSON dan penerima menghitung latensi berdasarkan pesan.\n{ \u0026#34;received_time\u0026#34;: 64714, // Timestamp dikirim oleh penerima, pengirim memantulkan timestamp. \u0026#34;delay_since_received\u0026#34;: 46, // Waktu yang berlalu sejak `received_time` terakhir diterima di pengirim. \u0026#34;local_clock\u0026#34;: 1597366470336, // Waktu jam monotonic pengirim saat ini. \u0026#34;track_times_msec\u0026#34;: { \u0026#34;myvideo_track1\u0026#34;: [ 13100, // Timestamp RTP frame video (dalam milidetik). 1597366470289 // Timestamp jam monotonic frame video. ] } } Buka data channel pada penerima:\ndataChannel = peerConnection.createDataChannel(\u0026#39;latency\u0026#39;); Kirim waktu penerima tR1 secara berkala. Contoh ini menggunakan 2 detik tanpa alasan tertentu:\nsetInterval(() =\u0026gt; { let tR1 = Math.trunc(performance.now()); dataChannel.send(\u0026#34;\u0026#34; + tR1); }, 2000); Tangani pesan masuk dari penerima di pengirim:\n// Assuming event.data is a string like \u0026#34;1234567\u0026#34;. tR1 = event.data now = Math.trunc(performance.now()); tSV1 = 42000; // Current frame RTP timestamp converted to millisecond timescale. tS1 = 1597366470289; // Current frame monotonic clock timestamp. msg = { \u0026#34;received_time\u0026#34;: tR1, \u0026#34;delay_since_received\u0026#34;: 0, \u0026#34;local_clock\u0026#34;: now, \u0026#34;track_times_msec\u0026#34;: { \u0026#34;myvideo_track1\u0026#34;: [tSV1, tS1] } } dataChannel.send(JSON.stringify(msg)); Tangani pesan masuk dari pengirim dan cetak latensi yang diestimasi ke console:\nlet tR2 = performance.now(); let fromSender = JSON.parse(event.data); let tR1 = fromSender[\u0026#39;received_time\u0026#39;]; let delay = fromSender[\u0026#39;delay_since_received\u0026#39;]; // How much time that has passed between the sender receiving and sending the response. let senderTimeFromResponse = fromSender[\u0026#39;local_clock\u0026#39;]; let rtt = tR2 - delay - tR1; let networkLatency = rtt / 2; let senderTime = (senderTimeFromResponse + delay + networkLatency); VIDEO.requestVideoFrameCallback((now, framemeta) =\u0026gt; { // Estimate current time of the sender. let delaySinceVideoCallbackRequested = now - tR2; senderTime += delaySinceVideoCallbackRequested; let [tSV1, tS1] = Object.entries(fromSender[\u0026#39;track_times_msec\u0026#39;])[0][1] let timeSinceLastKnownFrame = senderTime - tS1; let expectedVideoTimeMsec = tSV1 + timeSinceLastKnownFrame; let actualVideoTimeMsec = Math.trunc(framemeta.rtpTimestamp / 90); // Convert RTP timebase (90000) to millisecond timebase. let latency = expectedVideoTimeMsec - actualVideoTimeMsec; console.log(\u0026#39;latency\u0026#39;, latency, \u0026#39;msec\u0026#39;); }); Waktu video aktual di peramban # \u0026lt;video\u0026gt;.requestVideoFrameCallback() memungkinkan penulis web untuk diberi tahu ketika frame telah disajikan untuk komposisi.\nSampai sangat baru-baru ini (Mei 2020), hampir tidak mungkin untuk mendapatkan timestamp dari frame video yang ditampilkan saat ini di peramban dengan andal. Metode solusi berdasarkan video.currentTime ada, tetapi tidak terlalu tepat. Baik pengembang peramban Chrome dan Mozilla mendukung pengenalan standar W3C baru, HTMLVideoElement.requestVideoFrameCallback(), yang menambahkan callback API untuk mengakses waktu frame video saat ini. Meskipun penambahan terdengar sepele, ini telah memungkinkan beberapa aplikasi media lanjutan di web yang memerlukan sinkronisasi audio dan video. Khusus untuk WebRTC, callback akan menyertakan bidang rtpTimestamp, timestamp RTP yang terkait dengan frame video saat ini. Ini harus ada untuk aplikasi WebRTC, tetapi tidak ada selain itu.\nTips Debugging Latensi # Karena debugging kemungkinan akan mempengaruhi latensi yang diukur, aturan umum adalah menyederhanakan pengaturan Anda ke yang terkecil yang mungkin yang masih dapat mereproduksi masalah. Semakin banyak komponen yang dapat Anda hapus, semakin mudah untuk mencari tahu komponen mana yang menyebabkan masalah latensi.\nLatensi kamera # Tergantung pada pengaturan kamera latensi kamera mungkin bervariasi. Periksa pengaturan eksposur otomatis, fokus otomatis dan keseimbangan putih otomatis. Semua fitur \u0026ldquo;auto\u0026rdquo; dari kamera web memerlukan waktu ekstra untuk menganalisis gambar yang ditangkap sebelum membuatnya tersedia untuk stack WebRTC.\nJika Anda di Linux, Anda dapat menggunakan alat command line v4l2-ctl untuk mengontrol pengaturan kamera:\n# Disable autofocus: v4l2-ctl -d /dev/video0 -c focus_auto=0 # Set focus to infinity: v4l2-ctl -d /dev/video0 -c focus_absolute=0 Anda juga dapat menggunakan alat UI grafis guvcview untuk dengan cepat memeriksa dan men-tweak pengaturan kamera.\nLatensi encoder # Sebagian besar encoder modern akan buffer beberapa frame sebelum mengeluarkan yang dikode. Prioritas pertama mereka adalah keseimbangan antara kualitas gambar yang dihasilkan dan bitrate. Pengkodean multipass adalah contoh ekstrem dari pengabaian latensi output encoder. Selama pass pertama encoder mencerna seluruh video dan hanya setelah itu mulai mengeluarkan frame.\nNamun, dengan penyetelan yang tepat orang telah mencapai latensi sub-frame. Pastikan encoder Anda tidak menggunakan reference frame yang berlebihan atau bergantung pada B-frame. Pengaturan penyetelan latensi setiap codec berbeda, tetapi untuk x264 kami merekomendasikan menggunakan tune=zerolatency dan profile=baseline untuk latensi output frame terendah.\nLatensi jaringan # Latensi jaringan adalah salah satu yang dapat Anda lakukan paling sedikit, selain meningkatkan ke koneksi jaringan yang lebih baik. Latensi jaringan sangat mirip dengan cuaca - Anda tidak dapat menghentikan hujan, tetapi Anda dapat memeriksa prakiraan dan membawa payung. WebRTC mengukur kondisi jaringan dengan presisi milidetik. Metrik penting adalah:\nRound-trip time. Packet loss dan retransmisi paket. Round-Trip Time\nStack WebRTC memiliki mekanisme pengukuran round trip time (RTT) jaringan bawaan mechanism. Perkiraan latensi yang cukup baik adalah setengah dari RTT. Ini mengasumsikan bahwa dibutuhkan waktu yang sama untuk mengirim dan menerima paket, yang tidak selalu terjadi. RTT menetapkan batas bawah pada latensi end-to-end. Frame video Anda tidak dapat mencapai penerima lebih cepat dari RTT/2, tidak peduli seberapa dioptimalkan pipeline kamera ke encoder Anda.\nMekanisme RTT bawaan didasarkan pada paket RTCP khusus yang disebut sender/receiver reports. Pengirim mengirim pembacaan waktunya ke penerima, penerima pada gilirannya memantulkan timestamp yang sama ke pengirim. Dengan demikian pengirim tahu berapa banyak waktu yang dibutuhkan paket untuk melakukan perjalanan ke penerima dan kembali. Lihat bab Sender/Receiver Reports untuk lebih detail tentang pengukuran RTT.\nPacket loss dan retransmisi paket\nBaik RTP dan RTCP adalah protokol berdasarkan UDP, yang tidak memiliki jaminan pengurutan, pengiriman yang berhasil, atau non-duplikasi. Semua hal di atas dapat dan memang terjadi dalam aplikasi WebRTC dunia nyata. Implementasi decoder yang tidak canggih mengharapkan semua paket dari frame dikirim agar decoder berhasil merakit gambar. Dalam kehadiran packet loss artefak dekoding mungkin muncul jika paket dari P-frame hilang. Jika paket I-frame hilang maka semua frame dependen akan mendapatkan artefak berat atau tidak akan didekode sama sekali. Kemungkinan besar ini akan membuat video \u0026ldquo;membeku\u0026rdquo; untuk sesaat.\nUntuk menghindari (yah, setidaknya untuk mencoba menghindari) pembekuan video atau artefak dekoding, WebRTC menggunakan pesan pengakuan negatif (NACK). Ketika penerima tidak mendapatkan paket RTP yang diharapkan, ia mengembalikan pesan NACK untuk memberi tahu pengirim untuk mengirim paket yang hilang lagi. Penerima menunggu untuk retransmisi paket. Retransmisi seperti itu menyebabkan peningkatan latensi. Jumlah paket NACK yang dikirim dan diterima dicatat dalam bidang statistik bawaan WebRTC outbound stream nackCount dan inbound stream nackCount.\nAnda dapat melihat grafik bagus dari nackCount inbound dan outbound di halaman webrtc internals. Jika Anda melihat nackCount meningkat, itu berarti jaringan mengalami packet loss tinggi, dan stack WebRTC melakukan yang terbaik untuk membuat pengalaman video/audio yang mulus meskipun itu.\nKetika packet loss sangat tinggi sehingga decoder tidak dapat menghasilkan gambar, atau gambar dependen berikutnya seperti dalam kasus I-frame yang hilang sepenuhnya, semua P-frame masa depan tidak akan didekode. Penerima akan mencoba mengurangi itu dengan mengirim pesan Picture Loss Indication khusus (PLI). Setelah pengirim menerima PLI, ia akan menghasilkan I-frame baru untuk membantu decoder penerima. I-frame biasanya lebih besar dalam ukuran daripada P-frame. Ini meningkatkan jumlah paket yang perlu ditransmisikan. Seperti dengan pesan NACK, penerima perlu menunggu I-frame baru, memperkenalkan latensi tambahan.\nPerhatikan pliCount di halaman webrtc internals. Jika meningkat, tweak encoder Anda untuk menghasilkan lebih sedikit paket atau aktifkan mode yang lebih tahan kesalahan.\nLatensi sisi penerima # Latensi akan dipengaruhi oleh paket yang tiba tidak berurutan. Jika paket setengah bawah gambar datang sebelum atas Anda harus menunggu atas sebelum dekoding. Ini dijelaskan dalam bab Solving Jitter dengan sangat detail.\nAnda juga dapat merujuk ke metrik bawaan jitterBufferDelay untuk melihat berapa lama frame ditahan di buffer penerimaan, menunggu semua paketnya sampai dilepaskan ke decoder.\n"},{"id":9,"href":"/id/docs/10-history-of-webrtc/","title":"History","section":"Docs","content":" History # Ketika mempelajari WebRTC, developer sering merasa frustrasi dengan kompleksitasnya. Mereka melihat fitur WebRTC yang tidak relevan dengan proyek mereka saat ini dan berharap WebRTC lebih sederhana. Masalahnya adalah bahwa setiap orang memiliki set kasus penggunaan yang berbeda. Komunikasi real-time memiliki sejarah yang kaya dengan banyak orang yang berbeda membangun banyak hal yang berbeda.\nBab ini berisi wawancara dengan penulis protokol yang membentuk WebRTC. Ini memberikan wawasan tentang desain yang dibuat saat membangun setiap protokol, dan diakhiri dengan wawancara tentang WebRTC itu sendiri. Jika Anda memahami niat dan desain dari perangkat lunak, Anda dapat membangun sistem yang lebih efektif dengannya.\nRTP # RTP dan RTCP adalah protokol yang menangani semua transpor media untuk WebRTC. Ini didefinisikan dalam RFC 1889 pada Januari 1996. Kami sangat beruntung memiliki salah satu penulis Ron Frederick berbicara tentang itu sendiri. Ron baru-baru ini mengunggah Network Video tool ke GitHub, sebuah proyek yang menginformasikan RTP.\nDengan kata-katanya sendiri # Pada Oktober 1992, saya mulai bereksperimen dengan kartu frame grabber Sun VideoPix, dengan ide menulis alat konferensi video jaringan berdasarkan multicast IP. Ini dimodelkan setelah \u0026ldquo;vat\u0026rdquo; \u0026ndash; alat konferensi audio yang dikembangkan di LBL, karena menggunakan protokol sesi lightweight yang serupa untuk pengguna bergabung ke konferensi, di mana Anda cukup mengirim data ke grup multicast tertentu dan menonton grup itu untuk lalu lintas apa pun dari anggota grup lainnya.\nAgar program benar-benar berhasil, ia perlu mengompresi data video sebelum menempatkannya di jaringan. Tujuan saya adalah membuat stream data yang terlihat dapat diterima yang akan masuk dalam sekitar 128 kbps, atau bandwidth yang tersedia pada jalur ISDN rumah standar. Saya juga berharap menghasilkan sesuatu yang masih dapat ditonton yang masuk dalam setengah bandwidth ini. Ini berarti saya memerlukan faktor kompresi sekitar 20 untuk ukuran gambar dan frame rate tertentu yang saya kerjakan. Saya dapat mencapai kompresi ini dan mengajukan paten untuk teknik yang saya gunakan, kemudian diberikan sebagai paten US5485212A: Kompresi video perangkat lunak untuk konferensi telepon.\nPada awal November 1992, saya merilis alat konferensi video \u0026ldquo;nv\u0026rdquo; (dalam bentuk biner) ke komunitas Internet. Setelah beberapa pengujian awal, itu digunakan untuk videocast bagian dari Internet Engineering Task Force November ke seluruh dunia. Sekitar 200 subnet di 15 negara mampu menerima siaran ini, dan sekitar 50-100 orang menerima video menggunakan \u0026ldquo;nv\u0026rdquo; di beberapa titik dalam minggu itu.\nSelama beberapa bulan berikutnya, tiga workshop lain dan beberapa pertemuan yang lebih kecil menggunakan \u0026ldquo;nv\u0026rdquo; untuk menyiarkan ke Internet secara luas, termasuk Australian NetWorkshop, workshop MCNC Packet Audio and Video, dan workshop MultiG tentang realitas virtual terdistribusi di Swedia.\nRilis source code dari \u0026ldquo;nv\u0026rdquo; mengikuti pada Februari 1993, dan pada Maret saya merilis versi alat di mana saya memperkenalkan skema kompresi berbasis wavelet yang baru. Pada Mei 1993, saya menambahkan dukungan untuk video berwarna.\nProtokol jaringan yang digunakan untuk \u0026ldquo;nv\u0026rdquo; dan alat konferensi Internet lainnya menjadi dasar dari Realtime Transport Protocol (RTP), distandarisasi melalui Internet Engineering Task Force (IETF), pertama kali diterbitkan dalam RFC 1889-1890 dan kemudian direvisi dalam RFC 3550-3551 bersama dengan berbagai RFC lain yang mencakup profil untuk membawa format audio dan video tertentu.\nSelama beberapa tahun berikutnya, pekerjaan berlanjut pada \u0026ldquo;nv\u0026rdquo;, mem-port alat ke sejumlah platform perangkat keras dan perangkat pengambilan video tambahan. Ini terus digunakan sebagai salah satu alat utama untuk menyiarkan konferensi di Internet pada saat itu, termasuk dipilih oleh NASA untuk menyiarkan liputan langsung misi shuttle secara online.\nPada 1994, saya menambahkan dukungan dalam \u0026ldquo;nv\u0026rdquo; untuk mendukung algoritma kompresi video yang dikembangkan oleh orang lain, termasuk beberapa skema kompresi perangkat keras seperti format CellB yang didukung oleh kartu pengambilan video SunVideo. Ini juga memungkinkan \u0026ldquo;nv\u0026rdquo; untuk mengirim video dalam format CUSeeMe, untuk mengirim video ke pengguna yang menjalankan CUSeeMe pada Mac dan PC.\nVersi yang dirilis secara publik terakhir dari \u0026ldquo;nv\u0026rdquo; adalah versi 3.3beta, dirilis pada Juli 1994. Saya sedang mengerjakan rilis \u0026ldquo;4.0alpha\u0026rdquo; yang dimaksudkan untuk memigrasikan \u0026ldquo;nv\u0026rdquo; ke versi 2 dari protokol RTP, tetapi pekerjaan ini tidak pernah selesai karena saya pindah ke proyek lain. Salinan kode 4.0 alpha disertakan dalam arsip Network Video tool untuk kelengkapan, tetapi tidak lengkap dan ada masalah yang diketahui dengannya, terutama dalam dukungan RTPv2 yang tidak lengkap.\nFramework yang disediakan dalam \u0026ldquo;nv\u0026rdquo; kemudian menjadi dasar konferensi video dalam proyek \u0026ldquo;Jupiter multi-media MOO\u0026rdquo; di Xerox PARC, yang akhirnya menjadi dasar untuk perusahaan spin-off \u0026ldquo;PlaceWare\u0026rdquo;, kemudian diakuisisi oleh Microsoft. Ini juga digunakan sebagai dasar untuk sejumlah proyek konferensi video perangkat keras yang memungkinkan pengiriman video berkualitas siaran NTSC penuh melalui Ethernet dan jaringan ATM bandwidth tinggi. Saya juga kemudian menggunakan beberapa kode ini sebagai dasar untuk \u0026ldquo;Mediastore\u0026rdquo;, yang adalah layanan perekaman dan pemutaran video berbasis jaringan.\nApakah Anda ingat motivasi/ide orang lain di draft? # Kami semua adalah peneliti yang bekerja pada multicast IP, dan membantu membuat Internet multicast backbone (alias MBONE). MBONE diciptakan oleh Steve Deering (yang pertama kali mengembangkan multicast IP), Van Jacobson, dan Steve Casner. Steve Deering dan saya memiliki penasihat yang sama di Stanford, dan Steve akhirnya pergi bekerja di Xerox PARC ketika ia meninggalkan Stanford, saya menghabiskan musim panas di Xerox PARC sebagai intern yang bekerja pada proyek terkait multicast IP dan terus bekerja untuk mereka paruh waktu saat di Stanford dan kemudian penuh waktu. Van Jacobson dan Steve Casner adalah dua dari empat penulis pada RFC RTP awal, bersama dengan Henning Schulzrinne dan saya sendiri. Kami semua memiliki alat MBONE yang kami kerjakan yang memungkinkan berbagai bentuk kolaborasi online, dan mencoba untuk menghasilkan protokol dasar umum yang dapat digunakan semua alat ini adalah yang mengarah pada RTP.\nMulticast sangat menarik. WebRTC sepenuhnya unicast, bisakah Anda menjelaskan tentang itu? # Sebelum sampai ke Stanford dan belajar tentang multicast IP, saya memiliki sejarah panjang bekerja pada cara menggunakan komputer sebagai cara bagi orang untuk berkomunikasi satu sama lain. Ini dimulai pada awal 80-an untuk saya di mana saya menjalankan sistem bulletin board dial-up di mana orang dapat masuk dan meninggalkan pesan untuk satu sama lain, baik pribadi (semacam setara dengan e-mail) dan publik (grup diskusi). Sekitar waktu yang sama, saya juga belajar tentang penyedia layanan online CompuServe. Salah satu fitur keren pada CompuServe adalah sesuatu yang disebut \u0026ldquo;CB Simulator\u0026rdquo; di mana orang dapat berbicara satu sama lain secara real-time. Itu semua berbasis teks, tetapi memiliki gagasan tentang \u0026ldquo;saluran\u0026rdquo; seperti radio CB nyata, dan beberapa orang dapat melihat apa yang diketik orang lain, selama mereka berada di saluran yang sama. Saya membangun versi CB saya sendiri yang berjalan pada sistem timesharing yang saya miliki akses ke yang memungkinkan pengguna pada sistem itu mengirim pesan satu sama lain secara real-time, dan selama beberapa tahun berikutnya saya bekerja dengan teman-teman untuk mengembangkan versi yang lebih canggih dari alat komunikasi real-time pada beberapa sistem komputer dan jaringan yang berbeda. Bahkan, salah satu dari sistem itu masih beroperasi, dan saya menggunakannya untuk berbicara setiap hari kepada orang-orang yang saya kuliah bersama 30+ tahun yang lalu!\nSemua alat itu berbasis teks, karena komputer pada saat itu umumnya tidak memiliki kemampuan audio/video apa pun, tetapi ketika saya sampai ke Stanford dan belajar tentang multicast IP, saya tertarik dengan gagasan menggunakan multicast untuk mendapatkan sesuatu yang lebih seperti \u0026ldquo;radio\u0026rdquo; nyata di mana Anda dapat mengirim sinyal keluar ke jaringan yang tidak ditujukan kepada siapa pun khususnya, tetapi semua orang yang menyetel ke \u0026ldquo;saluran\u0026rdquo; itu dapat menerimanya. Kebetulan, komputer tempat saya mem-port kode multicast IP adalah generasi pertama SPARC-station dari Sun, dan itu sebenarnya memiliki perangkat keras audio berkualitas telepon bawaan! Anda dapat mendigitalkan suara dari mikrofon dan memutarnya kembali melalui speaker bawaan (atau melalui output headphone). Jadi, pikiran pertama saya adalah untuk mencari tahu bagaimana mengirim audio itu keluar ke jaringan secara real-time menggunakan multicast IP, dan melihat apakah saya dapat membangun setara \u0026ldquo;radio CB\u0026rdquo; dengan audio aktual alih-alih teks.\nAda beberapa hal rumit yang harus diselesaikan, seperti fakta bahwa komputer hanya dapat memutar satu stream audio pada satu waktu, jadi jika beberapa orang berbicara Anda perlu secara matematis \u0026ldquo;mencampur\u0026rdquo; beberapa stream audio menjadi satu sebelum Anda dapat memutarnya, tetapi itu semua dapat dilakukan dalam perangkat lunak setelah Anda memahami bagaimana pengambilan sampel audio bekerja. Aplikasi audio itu membawa saya untuk bekerja pada MBONE dan akhirnya berpindah dari audio ke video dengan \u0026ldquo;nv\u0026rdquo;.\nApakah ada yang tertinggal dari protokol yang Anda harap Anda tambahkan? Apakah ada dalam protokol yang Anda sesali? # Saya tidak akan mengatakan saya menyesalinya, tetapi salah satu keluhan besar yang akhirnya dimiliki orang tentang RTP adalah kompleksitas mengimplementasikan RTCP, protokol kontrol yang berjalan paralel dengan lalu lintas data RTP utama. Saya pikir kompleksitas itu adalah bagian besar mengapa RTP tidak lebih banyak diadopsi, terutama dalam kasus unicast di mana tidak ada banyak kebutuhan untuk beberapa fitur RTCP. Karena bandwidth jaringan menjadi kurang langka dan kemacetan bukan masalah besar, banyak orang hanya akhirnya streaming audio \u0026amp; video melalui TCP biasa (dan kemudian HTTP), dan secara umum itu bekerja \u0026ldquo;cukup baik\u0026rdquo; sehingga tidak layak berurusan dengan RTP.\nSayangnya, menggunakan TCP atau HTTP berarti bahwa aplikasi audio dan video multi-pihak harus mengirim data yang sama melalui jaringan beberapa kali, ke setiap peer yang perlu menerimanya, membuatnya jauh kurang efisien dari perspektif bandwidth. Saya kadang-kadang berharap kami telah mendorong lebih keras untuk mendapatkan multicast IP yang diadopsi di luar hanya komunitas penelitian. Saya pikir kami bisa melihat transisi dari televisi kabel dan siaran ke audio dan video berbasis Internet jauh lebih cepat jika kami melakukannya.\nHal-hal apa yang Anda bayangkan dibangun dengan RTP? Apakah Anda memiliki proyek/ide RTP keren yang hilang dalam waktu? # Salah satu hal yang menyenangkan yang saya bangun adalah versi dari permainan klasik \u0026ldquo;Spacewar\u0026rdquo; yang menggunakan multicast IP. Tanpa memiliki jenis server pusat apa pun, beberapa klien dapat masing-masing menjalankan binary spacewar dan mulai menyiarkan lokasi kapal mereka, kecepatan, arah yang dihadapi, dan informasi serupa untuk \u0026ldquo;peluru\u0026rdquo; apa pun yang telah mereka tembakkan, dan semua instance lain akan mengambil informasi itu dan merendernya secara lokal, memungkinkan pengguna untuk semua melihat kapal dan peluru satu sama lain, dengan kapal \u0026ldquo;meledak\u0026rdquo; jika mereka menabrak satu sama lain atau peluru mengenai mereka. Saya bahkan membuat \u0026ldquo;puing-puing\u0026rdquo; dari ledakan objek hidup yang dapat mengeluarkan kapal lain, kadang-kadang mengarah ke reaksi berantai yang menyenangkan!\nDalam semangat permainan asli, saya merendernya menggunakan grafik vektor yang disimulasikan, jadi Anda dapat melakukan hal-hal seperti memperbesar tampilan Anda masuk \u0026amp; keluar dan semuanya akan naik/turun skala. Kapal-kapal itu sendiri adalah sekelompok segmen garis dalam bentuk vektor yang saya minta beberapa rekan saya di PARC bantu saya desain, jadi kapal setiap orang memiliki tampilan unik padanya.\nPada dasarnya, apa pun yang dapat mengambil manfaat dari stream data real-time yang tidak memerlukan pengiriman in-order yang sempurna dapat mengambil manfaat dari RTP. Jadi, selain audio \u0026amp; video kami dapat membangun hal-hal seperti shared whiteboard. Bahkan transfer file dapat mengambil manfaat dari RTP, terutama dalam hubungannya dengan multicast IP.\nBayangkan sesuatu seperti BitTorrent tetapi di mana Anda tidak memerlukan semua data yang berjalan point-to-point antara peer. Seeder asli dapat mengirim stream multicast ke semua leeche sekaligus, dan kehilangan paket apa pun di sepanjang jalan dapat dengan cepat dibersihkan oleh retransmisi dari peer apa pun yang berhasil menerima data. Anda bahkan dapat membatasi permintaan retransmisi Anda sehingga beberapa peer di dekatnya mengirimkan salinan data, dan itu juga dapat di-multicast ke orang lain di wilayah itu, karena kehilangan paket di tengah jaringan akan cenderung berarti sekelompok klien downstream dari titik itu semua melewatkan data yang sama.\nMengapa Anda harus membuat kompresi video Anda sendiri. Tidak ada yang tersedia pada saat itu? # Pada saat saya mulai membangun \u0026ldquo;nv\u0026rdquo;, satu-satunya sistem yang saya tahu yang melakukan konferensi video adalah perangkat keras khusus yang sangat mahal. Misalnya, Steve Casner memiliki akses ke sistem dari BBN yang disebut \u0026ldquo;DVC\u0026rdquo; (dan kemudian dikomersialisasikan sebagai \u0026ldquo;PictureWindow\u0026rdquo;). Kompresi memerlukan perangkat keras khusus, tetapi dekompresi dapat dilakukan dalam perangkat lunak. Apa yang membuat \u0026ldquo;nv\u0026rdquo; agak unik adalah bahwa baik kompresi dan dekompresi dilakukan dalam perangkat lunak, dengan satu-satunya persyaratan perangkat keras adalah sesuatu untuk mendigitalkan sinyal video analog yang masuk.\nBanyak konsep dasar tentang cara mengompresi video ada pada saat itu, dengan hal-hal seperti standar MPEG-1 muncul tepat pada waktu yang sama dengan \u0026ldquo;nv\u0026rdquo;, tetapi pengkodean real-time dengan MPEG-1 jelas TIDAK mungkin pada saat itu. Perubahan yang saya buat adalah semua tentang mengambil konsep dasar itu dan memperkirakan mereka dengan algoritma yang jauh lebih murah, di mana saya menghindari hal-hal seperti transformasi kosinus dan floating point, dan bahkan menghindari perkalian integer karena itu sangat lambat pada SPARC-station. Saya mencoba melakukan semua yang saya bisa dengan hanya penambahan/pengurangan dan masking dan shifting bit, dan itu mendapatkan kembali cukup kecepatan untuk masih terasa agak seperti video.\nDalam satu atau dua tahun setelah rilis \u0026ldquo;nv\u0026rdquo;, ada banyak alat audio dan video yang berbeda untuk dipilih, tidak hanya di MBONE tetapi di tempat lain seperti alat CU-SeeMe yang dibangun di Mac. Jadi, itu jelas merupakan ide yang waktunya telah tiba. Saya sebenarnya akhirnya membuat \u0026ldquo;nv\u0026rdquo; interoperasi dengan banyak alat ini, dan dalam beberapa kasus alat lain mengambil codec \u0026ldquo;nv\u0026rdquo; saya, jadi mereka dapat berinteroperasi ketika menggunakan skema kompresi saya.\nWebRTC # WebRTC memerlukan upaya standardisasi yang mengerdilkan semua upaya lain yang dijelaskan dalam bab ini. Ini memerlukan kerja sama di dua badan standar yang berbeda (IETF dan W3C) dan ratusan individu di banyak perusahaan dan negara. Untuk memberi kami pandangan ke dalam motivasi dan upaya monumental yang diperlukan untuk membuat WebRTC terjadi kami memiliki Serge Lachapelle.\nSerge adalah product manager di Google, saat ini melayani sebagai product manager untuk Google Workspace. Ini adalah ringkasan saya dari wawancara.\nApa yang membawa Anda untuk bekerja pada WebRTC? # Saya telah bersemangat tentang membangun perangkat lunak komunikasi sejak saya di perguruan tinggi. Pada tahun 90-an teknologi seperti nv mulai muncul, tetapi sulit digunakan. Saya membuat proyek yang memungkinkan Anda untuk bergabung dengan panggilan video langsung dari peramban Anda. Saya juga mem-port-nya ke Windows.\nSaya membawa pengalaman ini ke Marratech, sebuah perusahaan yang saya ikut dirikan. Kami membuat perangkat lunak untuk konferensi video grup. Secara teknologi lanskap sangat berbeda. Ujung tombak dalam video didasarkan pada jaringan multicast. Pengguna dapat bergantung pada jaringan untuk mengirimkan paket video ke semua orang dalam panggilan. Ini berarti bahwa kami memiliki server yang sangat sederhana. Ini memiliki kelemahan besar meskipun, jaringan harus dirancang untuk mengakomodasi itu. Industri bergerak menjauh dari multicast ke packet shuffler, lebih umum dikenal sebagai SFU.\nMarratech diakuisisi oleh Google pada 2007. Saya kemudian akan bekerja pada proyek yang akan menginformasikan WebRTC.\nProyek Google pertama # Proyek pertama yang dikerjakan oleh tim WebRTC masa depan adalah chat suara dan video Gmail. Mendapatkan audio dan video ke dalam peramban bukanlah tugas yang mudah. Ini memerlukan komponen khusus yang harus kami lisensikan dari perusahaan yang berbeda. Audio dilisensikan dari GIPs, video dilisensikan untuk Vidyo dan jaringan adalah libjingle. Keajaibannya kemudian membuat semuanya bekerja bersama.\nSetiap subsistem memiliki API yang sangat berbeda, dan mengasumsikan Anda memecahkan masalah yang berbeda. Untuk membuat semuanya bekerja bersama Anda memerlukan pengetahuan kerja tentang jaringan, kriptografi, media dan banyak lagi. Justin Uberti adalah orang yang mengambil pekerjaan ini. Dia membawa komponen-komponen ini bersama untuk membuat produk yang dapat digunakan.\nRendering real-time di peramban juga sangat sulit. Kami harus menggunakan NPAPI (Netscape Plugin API) dan melakukan banyak hal cerdas untuk membuatnya bekerja. Pelajaran yang kami pelajari dari proyek ini sangat mempengaruhi WebRTC.\nChrome # Pada saat yang sama proyek Chrome dimulai di dalam Google. Ada begitu banyak kegembiraan, dan proyek ini memiliki tujuan besar. Ada pembicaraan tentang WebGL, Offline, kemampuan Database, input latensi rendah untuk permainan hanya untuk beberapa nama.\nBergerak menjauh dari NPAPI menjadi fokus besar. Ini adalah API yang kuat, tetapi datang dengan konsekuensi keamanan yang besar. Chrome menggunakan desain sandbox untuk menjaga pengguna tetap aman. Operasi yang berpotensi tidak aman dijalankan dalam proses yang berbeda. Bahkan jika sesuatu yang salah terjadi, penyerang masih tidak memiliki akses ke data pengguna.\nWebRTC lahir # Bagi saya WebRTC lahir dengan beberapa motivasi. Digabungkan mereka melahirkan upaya.\nSeharusnya tidak sesulit ini untuk membangun pengalaman RTC. Begitu banyak upaya terbuang mengimplementasikan ulang hal yang sama oleh developer yang berbeda. Kami harus menyelesaikan masalah integrasi yang membuat frustrasi ini sekali, dan fokus pada hal-hal lain.\nKomunikasi manusia harus tidak terhalangi dan harus terbuka. Bagaimana oke untuk teks dan HTML menjadi terbuka, tetapi suara saya dan gambar saya secara real-time tidak?\nKeamanan adalah prioritas. Menggunakan NPAPI bukan yang terbaik untuk pengguna. Ini juga adalah kesempatan untuk membuat protokol yang aman secara default.\nUntuk membuat WebRTC terjadi Google mengakuisisi dan Open Source komponen yang telah kami gunakan sebelumnya. On2 diakuisisi untuk teknologi videonya dan Global IP Solutions untuk teknologi RTC-nya. Saya bertanggung jawab atas upaya mengakuisisi GIPS. Kami bekerja menggabungkan ini dan membuatnya mudah digunakan di dalam dan di luar peramban.\nStandardisasi # Standardisasi WebRTC adalah sesuatu yang benar-benar kami ingin lakukan, tetapi bukan sesuatu yang pernah saya lakukan sebelumnya maupun siapa pun di tim langsung kami. Untuk ini kami benar-benar beruntung memiliki Harald Alvestrand di Google. Dia telah melakukan pekerjaan ekstensif di IETF sudah dan memulai proses standardisasi WebRTC.\nPada musim panas 2010 makan siang informal dijadwalkan di Maastricht. Developer dari banyak perusahaan datang bersama untuk mendiskusikan apa yang seharusnya WebRTC. Makan siang memiliki engineer dari Google, Cisco, Ericsson, Skype, Mozilla, Linden Labs dan lainnya. Anda dapat menemukan kehadiran penuh dan slide presenter di rtc-web.alvestrand.com.\nSkype juga memberikan beberapa panduan hebat karena pekerjaan yang mereka lakukan dengan Opus di IETF.\nBerdiri di bahu raksasa # Ketika bekerja di IETF Anda memperluas pekerjaan yang telah datang sebelum Anda. Dengan WebRTC kami beruntung bahwa begitu banyak hal ada. Kami tidak harus mengambil setiap masalah karena mereka sudah terpecahkan. Jika Anda tidak suka teknologi yang sudah ada sebelumnya, itu bisa membuat frustrasi. Harus ada alasan yang cukup besar untuk mengabaikan pekerjaan yang ada, jadi membuat sendiri bukan pilihan.\nKami juga secara sadar tidak mencoba untuk standarisasi ulang hal-hal seperti signaling. Ini sudah diselesaikan dengan SIP dan upaya non-IETF lainnya, dan terasa seperti bisa berakhir sangat politik. Pada akhirnya itu hanya tidak terasa seperti ada banyak nilai untuk ditambahkan ke ruang.\nSaya tidak tetap terlibat dalam standardisasi seperti Justin dan Harald, tetapi saya menikmati waktu saya melakukannya. Saya lebih bersemangat tentang kembali membangun hal-hal untuk pengguna.\nMasa depan # WebRTC berada di tempat yang bagus hari ini. Ada banyak perubahan berulang terjadi, tetapi tidak ada yang khususnya yang telah saya kerjakan.\nSaya paling bersemangat tentang apa yang dapat dilakukan cloud computing untuk komunikasi. Menggunakan algoritma canggih kami dapat menghapus kebisingan latar belakang dari panggilan dan membuat komunikasi mungkin di mana tidak mungkin sebelumnya. Kami juga melihat WebRTC memperluas jauh melampaui komunikasi… Siapa yang tahu bahwa itu akan menggerakkan gaming berbasis cloud 9 tahun kemudian? Semua ini tidak akan mungkin tanpa fondasi WebRTC.\n"},{"id":10,"href":"/id/docs/11-faq/","title":"FAQ","section":"Docs","content":" FAQ # Mengapa WebRTC menggunakan UDP? NAT Traversal memerlukan UDP. Tanpa NAT Traversal membangun koneksi P2P tidak akan mungkin. UDP tidak menyediakan \u0026ldquo;pengiriman terjamin\u0026rdquo; seperti TCP, jadi WebRTC menyediakannya di level pengguna.\nLihat Connecting untuk info lebih lanjut.\nBerapa banyak DataChannel yang bisa saya miliki? 65534 channel karena stream identifier memiliki 16 bit. Anda dapat menutup dan membuka yang baru kapan saja. Apakah WebRTC memberlakukan batas bandwidth? Baik DataChannel maupun RTP menggunakan congestion control. Ini berarti bahwa WebRTC secara aktif mengukur bandwidth Anda dan mencoba menggunakan jumlah yang optimal. Ini adalah keseimbangan antara mengirim sebanyak mungkin, tanpa membebani koneksi. Bisakah saya mengirim data biner? Ya, Anda dapat mengirim data teks dan biner melalui DataChannel. Latensi apa yang bisa saya harapkan dengan WebRTC? Untuk media yang tidak disetel, Anda dapat mengharapkan di bawah 500 milidetik. Jika Anda bersedia menyetel atau mengorbankan kualitas untuk latensi, developer telah mendapatkan latensi di bawah 100 ms.\nDataChannel mendukung opsi \u0026ldquo;Partial-reliability\u0026rdquo; yang dapat mengurangi latensi yang disebabkan oleh retransmisi data melalui koneksi yang hilang. Jika dikonfigurasi dengan benar, telah ditunjukkan untuk mengalahkan koneksi TCP TLS.\nMengapa saya menginginkan pengiriman tidak terurut untuk DataChannel? Ketika informasi yang lebih baru membuat yang lama menjadi usang seperti informasi posisi sebuah objek, atau setiap pesan independen dari yang lain dan perlu menghindari penundaan head-of-line blocking. Bisakah saya mengirim audio atau video melalui DataChannel? Ya, Anda dapat mengirim data apa pun melalui DataChannel. Dalam kasus peramban, itu akan menjadi tanggung jawab Anda untuk mendekode data dan meneruskannya ke pemutar media untuk rendering, sementara semua itu dilakukan secara otomatis jika Anda menggunakan media channel. "},{"id":11,"href":"/id/docs/12-glossary/","title":"Glossary","section":"Docs","content":" Glossary # ACK: Acknowledgment (Pengakuan) AVP: Audio and Video profile (Profil audio dan video) B-Frame: Bi-directional Predicted Frame (Frame yang Diprediksi Dua Arah). Gambar parsial, merupakan modifikasi dari gambar sebelumnya dan masa depan. DCEP: Data Channel Establishment Protocol (Protokol Pembentukan Data Channel) didefinisikan dalam RFC 8832 DeMux: Demultiplexer DLSR: Delay since last sender report (Penundaan sejak laporan pengirim terakhir) DTLS: Datagram Transport Layer Security (Keamanan Lapisan Transpor Datagram) didefinisikan dalam RFC 6347 E2E: End-to-End (Ujung ke Ujung) FEC: Forward Error Correction (Koreksi Kesalahan Forward) FIR: Full INTRA-frame Request (Permintaan Frame INTRA Penuh) G.711: Codec audio narrowband GCC: Google Congestion Control (Kontrol Kemacetan Google) didefinisikan dalam draft-ietf-rmcat-gcc-02 H.264: Pengkodean video lanjutan untuk layanan audiovisual generik H.265: Spesifikasi kesesuaian untuk pengkodean video efisiensi tinggi ITU-T H.265 HEVC: High Efficiency Video Coding (Pengkodean Video Efisiensi Tinggi) HTTP: Hypertext Transfer Protocol (Protokol Transfer Hiperteks) HTTPS: HTTP Over TLS, didefinisikan dalam RFC 2818 I-Frame: Intra-coded Frame (Frame Intra-coded). Gambar lengkap, dapat didekode tanpa apa pun. ICE: Interactive Connectivity Establishment (Pembentukan Konektivitas Interaktif) didefinisikan dalam RFC 8445 INIT: Initiate (Memulai) IoT: Internet of Things (Internet untuk Segala) IPv4: Internet Protocol, Version 4 (Protokol Internet, Versi 4) IPv6: Internet Protocol, Version 6 (Protokol Internet, Versi 6) ITU-T: International Telecommunication Union Telecommunication Standardization Sector (Sektor Standardisasi Telekomunikasi Union Telekomunikasi Internasional) JSEP: JavaScript Session Establishment Protocol (Protokol Pembentukan Sesi JavaScript) didefinisikan dalam RFC 8829 MCU: Multi-point Conferencing Unit (Unit Konferensi Multi-titik) mDNS: Multicast DNS didefinisikan dalam RFC 6762 MITM: Man-In-The-Middle (Orang di Tengah) MTU: Maximum Transmission Unit (Unit Transmisi Maksimum), ukuran paket MUX: Multiplexing NACK: Negative Acknowledgment (Pengakuan Negatif) NADA: network-assisted dynamic adaptation (adaptasi dinamis yang dibantu jaringan) didefinisikan dalam draft-zhu-rmcat-nada-04 NAT: Network Address Translation (Terjemahan Alamat Jaringan) didefinisikan dalam RFC 4787 Opus: Codec audio yang sepenuhnya terbuka, bebas royalti, sangat serbaguna P-Frame: Predicted Frame (Frame yang Diprediksi). Gambar parsial, hanya berisi perubahan dari gambar sebelumnya. P2P: Peer-to-Peer PLI: Picture Loss Indication (Indikasi Kehilangan Gambar) PPID: Payload Protocol Identifier (Pengidentifikasi Protokol Payload) REMB: Receiver Estimated Maximum Bitrate (Bitrate Maksimum Estimasi Penerima) RFC: Request for Comments (Permintaan untuk Komentar) RMCAT: RTP Media Congestion Avoidance Techniques (Teknik Penghindaran Kemacetan Media RTP) RR: Receiver Report (Laporan Penerima) RTCP: RTP Control Protocol (Protokol Kontrol RTP) didefinisikan dalam RFC 3550 RTP: Real-time transport protocol (protokol transpor real-time) didefinisikan dalam RFC 3550 RTT: Round-Trip Time (Waktu Perjalanan Pulang-Pergi) SACK: Selective Acknowledgment (Pengakuan Selektif) SCReAM: Self-Clocked Rate Adaptation for Multimedia (Adaptasi Laju Self-Clocked untuk Multimedia) didefinisikan dalam draft-johansson-rmcat-scream-cc-05 SCTP: Stream Control Transmission Protocol (Protokol Transmisi Kontrol Stream) didefinisikan dalam RFC 4960 SDP: Session Description Protocol (Protokol Deskripsi Sesi) didefinisikan dalam RFC 8866 SFU: Selective Forwarding Unit (Unit Forwarding Selektif) SR: Sender Report (Laporan Pengirim) SRTP: Secure Real-time Transport Protocol (Protokol Transpor Real-time Aman) didefinisikan dalam RFC 3711 SSRC: Synchronization Source (Sumber Sinkronisasi) STUN: Session Traversal Utilities for NAT (Utilitas Traversal Sesi untuk NAT) didefinisikan dalam RFC 8489 TCP: Transmission Control Protocol (Protokol Kontrol Transmisi) TLS: The Transport Layer Security (Keamanan Lapisan Transpor) didefinisikan dalam RFC 8446 TMMBN: Temporary Maximum Media Stream Bit Rate Notification (Notifikasi Laju Bit Stream Media Maksimum Sementara) TMMBR: Temporary Maximum Media Stream Bit Rate Request (Permintaan Laju Bit Stream Media Maksimum Sementara) TSN: Transmission Sequence Number (Nomor Urutan Transmisi) TURN: Traversal Using Relays around NAT (Traversal Menggunakan Relay di sekitar NAT) didefinisikan dalam RFC 8656 TWCC: Transport Wide Congestion Control (Kontrol Kemacetan Luas Transpor) UDP: User Datagram Protocol (Protokol Datagram Pengguna) VP8, VP9: Teknologi kompresi video yang sangat efisien (codec video) yang dikembangkan oleh WebM Project. Siapa pun dapat menggunakan codec ini tanpa royalti. WebM: Format file media terbuka yang dirancang untuk web. WebRTC: Web Real-Time Communications (Komunikasi Real-Time Web). W3C WebRTC 1.0: Real-Time Communication Between Browsers "},{"id":12,"href":"/id/docs/13-reference/","title":"Reference","section":"Docs","content":" Reference # WebRTC(W3C) # WebRTC 1.0: Real-Time Communication Between Browsers [26 January 2021] (Status: Recommendation) Web Real-Time Communications Working Group - Publications WebRTC(RFC) # RFC8825: Overview: Real-Time Protocols for Browser-Based Applications H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8826: Security Considerations for WebRTC E. Rescorla [January 2021] (Status: PROPOSED STANDARD) RFC8836: Congestion Control Requirements for Interactive Real-Time Media R. Jesup, Z. Sarker [January 2021] (Status: INFORMATIONAL) RFC8854: WebRTC Forward Error Correction Requirements J. Uberti [January 2021] (Status: PROPOSED STANDARD) DTLS # RFC6347: Datagram Transport Layer Security Version 1.2 E. Rescorla, N. Modadugu [January 2012] (Obsoletes RFC4347) (Obsoleted-By RFC9147) (Updated-By RFC7507, RFC7905, RFC8996, RFC9146) (Status: PROPOSED STANDARD) RFC9147: The Datagram Transport Layer Security (DTLS) Protocol Version 1.3 E. Rescorla, H. Tschofenig, N. Modadugu [April 2022] (Obsoletes RFC6347) (Status: PROPOSED STANDARD) (See also: OpenSSL DTLS 1.3 status) DataChannel # RFC8831: WebRTC Data Channels R. Jesup, S. Loreto, M. Tüxen [January 2021] (Status: PROPOSED STANDARD) RFC8832: WebRTC Data Channel Establishment Protocol R. Jesup, S. Loreto, M. Tüxen [January 2021] (Status: PROPOSED STANDARD) RFC8864: Negotiation Data Channels Using the Session Description Protocol (SDP) K. Drage, M. Makaraju, R. Ejzak, J. Marcon, R. Even [January 2021] (Status: PROPOSED STANDARD) MediaTransport # RFC8834: Media Transport and Use of RTP in WebRTC C. Perkins, M. Westerlund, J. Ott [January 2021] (Status: PROPOSED STANDARD) RFC8837: Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS P. Jones, S. Dhesikan, C. Jennings, D. Druta [January 2021] (Status: PROPOSED STANDARD) SCTP # RFC3758: Stream Control Transmission Protocol (SCTP) Partial Reliability Extension R. Stewart, M. Ramalho, Q. Xie, M. Tuexen, P. Conrad [May 2004] (Status: PROPOSED STANDARD) RFC5061: Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration R. Stewart, Q. Xie, M. Tuexen, S. Maruyama, M. Kozuka [September 2007] (Status: PROPOSED STANDARD) RFC5827: Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP) M. Allman, K. Avrachenkov, U. Ayesta, J. Blanton, P. Hurtig [May 2010] (Status: EXPERIMENTAL) RFC6083: Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP) M. Tuexen, R. Seggelmann, E. Rescorla [January 2011] (Updated-By RFC8996) (Status: PROPOSED STANDARD) RFC6525: Stream Control Transmission Protocol (SCTP) Stream Reconfiguration R. Stewart, M. Tuexen, P. Lei [February 2012] (Status: PROPOSED STANDARD) RFC6951: UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication M. Tuexen, R. Stewart [May 2013] (Updated-By RFC8899) (Status: PROPOSED STANDARD) RFC7765: TCP and Stream Control Transmission Protocol (SCTP) RTO Restart P. Hurtig, A. Brunstrom, A. Petlund, M. Welzl [February 2016] (Status: EXPERIMENTAL) RFC8260: Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol R. Stewart, M. Tuexen, S. Loreto, R. Seggelmann [November 2017] (Status: PROPOSED STANDARD) RFC8261: Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets M. Tuexen, R. Stewart, R. Jesup, S. Loreto [November 2017] (Updated-By RFC8899, RFC8996) (Status: PROPOSED STANDARD) RFC8841: Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport C. Holmberg, R. Shpount, S. Loreto, G. Camarillo [January 2021] (Status: PROPOSED STANDARD) RFC8899: Packetization Layer Path MTU Discovery for Datagram Transports G. Fairhurst, T. Jones, M. Tüxen, I. Rüngeler, T. Völker [September 2020] (Updates RFC4821, RFC4960, RFC6951, RFC8085, RFC8261) (Status: PROPOSED STANDARD) RFC9260: Stream Control Transmission Protocol R. Stewart, M. Tüxen, K. Nielsen [June 2022] (Obsoletes RFC4460, RFC4960, RFC6096, RFC7053, RFC8540) (Status: PROPOSED STANDARD) SDP # RFC8829: JavaScript Session Establishment Protocol (JSEP) J. Uberti, C. Jennings, E. Rescorla [January 2021] (Status: PROPOSED STANDARD) RFC8830: WebRTC MediaStream Identification in the Session Description Protocol H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8839: Session Description Protocol (SDP) Offer/Answer Procedures for Interactive Connectivity Establishment (ICE) M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [January 2021] (Obsoletes RFC5245, RFC6336) (Status: PROPOSED STANDARD) RFC8841: Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport C. Holmberg, R. Shpount, S. Loreto, G. Camarillo [January 2021] (Status: PROPOSED STANDARD) RFC8843: Negotiating Media Multiplexing Using the Session Description Protocol (SDP) C. Holmberg, H. Alvestrand, C. Jennings [January 2021] (Obsoleted-By RFC9143) (Updates RFC3264, RFC5888, RFC7941) (Status: PROPOSED STANDARD) RFC8844: Unknown Key-Share Attacks on Uses of TLS with the Session Description Protocol (SDP) M. Thomson, E. Rescorla [January 2021] (Updates RFC8122) (Status: PROPOSED STANDARD) RFC8851: RTP Payload Format Restrictions A.B. Roach [January 2021] (Updates RFC4855) (Status: PROPOSED STANDARD) RFC8852: RTP Stream Identifier Source Description (SDES) A.B. Roach, S. Nandakumar, P. Thatcher [January 2021] (Status: PROPOSED STANDARD) RFC8853: Using Simulcast in Session Description Protocol (SDP) and RTP Sessions B. Burman, M. Westerlund, S. Nandakumar, M. Zanaty [January 2021] (Status: PROPOSED STANDARD) RFC8866: SDP: Session Description Protocol A. Begen, P. Kyzivat, C. Perkins, M. Handley [January 2021] (Obsoletes RFC4566) (Status: PROPOSED STANDARD) RTP # RFC3550: RTP: A Transport Protocol for Real-Time Applications H. Schulzrinne, S. Casner, R. Frederick, V. Jacobson [July 2003] (Obsoletes RFC1889) (Updated-By RFC5506, RFC5761, RFC6051, RFC6222, RFC7022, RFC7160, RFC7164, RFC8083, RFC8108, RFC8860) (Also STD0064) (Status: INTERNET STANDARD) RFC3611: RTP Control Protocol Extended Reports (RTCP XR) T. Friedman, R. Caceres, A. Clark [November 2003] (Status: PROPOSED STANDARD) RFC3711: The Secure Real-time Transport Protocol (SRTP) M. Baugher, D. McGrew, M. Naslund, E. Carrara, K. Norrman [March 2004] (Updated-By RFC5506, RFC6904) (Status: PROPOSED STANDARD) RFC4585: Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF) J. Ott, S. Wenger, N. Sato, C. Burmeister, J. Rey [July 2006] (Updated-By RFC5506, RFC8108) (Status: PROPOSED STANDARD) RFC5104: Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF) S. Wenger, U. Chandra, M. Westerlund, B. Burman [February 2008] (Updated-By RFC7728, RFC8082) (Status: PROPOSED STANDARD) RFC5764: Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP) D. McGrew, E. Rescorla [May 2010] (Updated-By RFC7983) (Status: PROPOSED STANDARD) RFC6904: Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP) J. Lennox [April 2013] (Updates RFC3711) (Status: PROPOSED STANDARD) RFC7741: RTP Payload Format for VP8 Video P. Westin, H. Lundin, M. Glover, J. Uberti, F. Galligan [March 2016] (Status: PROPOSED STANDARD) RFC8285: A General Mechanism for RTP Header Extensions D. Singer, H. Desineni, R. Even [October 2017] (Obsoletes RFC5285) (Status: PROPOSED STANDARD) RFC8852: RTP Stream Identifier Source Description (SDES) A.B. Roach, S. Nandakumar, P. Thatcher [January 2021] (Status: PROPOSED STANDARD) RFC8858: Indicating Exclusive Support of RTP and RTP Control Protocol (RTCP) Multiplexing Using the Session Description Protocol (SDP) C. Holmberg [January 2021] (Updates RFC5761) (Status: PROPOSED STANDARD) RFC8860: Sending Multiple Types of Media in a Single RTP Session M. Westerlund, C. Perkins, J. Lennox [January 2021] (Updates RFC3550, RFC3551) (Status: PROPOSED STANDARD) RFC8867: Test Cases for Evaluating Congestion Control for Interactive Real-Time Media Z. Sarker, V. Singh, X. Zhu, M. Ramalho [January 2021] (Status: INFORMATIONAL) RFC8868: Evaluating Congestion Control for Interactive Real-Time Media V. Singh, J. Ott, S. Holmer [January 2021] (Status: INFORMATIONAL) RFC8869: Evaluation Test Cases for Interactive Real-Time Media over Wireless Networks Z. Sarker, X. Zhu, J. Fu [January 2021] (Status: INFORMATIONAL) RFC8872: Guidelines for Using the Multiplexing Features of RTP to Support Multiple Media Streams M. Westerlund, B. Burman, C. Perkins, H. Alvestrand, R. Even [January 2021] (Status: INFORMATIONAL) RFC8888: RTP Control Protocol (RTCP) Feedback for Congestion Control Z. Sarker, C. Perkins, V. Singh, M. Ramalho [January 2021] (Status: PROPOSED STANDARD) ICE, TURN dan STUN # RFC5780: NAT Behavior Discovery Using Session Traversal Utilities for NAT (STUN) D. MacDonald, B. Lowekamp [May 2010] (Updated-By RFC8553) (Status: EXPERIMENTAL) RFC8445: Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal A. Keranen, C. Holmberg, J. Rosenberg [July 2018] (Obsoletes RFC5245) (Updated-By RFC8863) (Status: PROPOSED STANDARD) RFC8489: Session Traversal Utilities for NAT (STUN) M. Petit-Huguenin, G. Salgueiro, J. Rosenberg, D. Wing, R. Mahy, P. Matthews [February 2020] (Obsoletes RFC5389) (Status: PROPOSED STANDARD) RFC8656: Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN) T. Reddy, A. Johnston, P. Matthews, J. Rosenberg [February 2020] (Obsoletes RFC5766, RFC6156) (Status: PROPOSED STANDARD) RFC8835: Transports for WebRTC H. Alvestrand [January 2021] (Status: PROPOSED STANDARD) RFC8838: Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol E. Ivov, J. Uberti, P. Saint-Andre [January 2021] (Updated-By RFC8863) (Status: PROPOSED STANDARD) RFC8839: Session Description Protocol (SDP) Offer/Answer Procedures for Interactive Connectivity Establishment (ICE) M. Petit-Huguenin, S. Nandakumar, C. Holmberg, A. Keränen, R. Shpount [January 2021] (Obsoletes RFC5245, RFC6336) (Status: PROPOSED STANDARD) RFC8863: Interactive Connectivity Establishment Patiently Awaiting Connectivity (ICE PAC) C. Holmberg, J. Uberti [January 2021] (Updates RFC8445, RFC8838) (Status: PROPOSED STANDARD) "}]